var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a2, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { c as createReduxEnhancer, a as createStore, b as combineReducers, d as compose$1, m as makeStyles, u as useSelector, r as react$1, j as jsxDevRuntime, s as startTransaction, g as getCurrentHub, e as spanstatus, f as createTheme, T as Tooltip$1, h as default_1$3, M as Menu$1, F as Fade, i as MenuItem$1, L as ListItemIcon, k as Typography, l as dayjs, n as relativeTime, U as URI, o as MUIIcon, p as red, R as React, q as connect, B as Button$2, D as Divider, t as Badge, I as IconButton, v as createSvgIcon, w as interopRequireDefault, x as require$$2, C as CircularProgress, S as Spring, y as animated, _ as _unsupportedIterableToArray$3, z as _defineProperty$3, A as _objectSpread2$3, E as _objectWithoutPropertiesLoose$3, G as _setPrototypeOf, H as _assertThisInitialized, J as _createClass, K as warning$1, N as jsx, O as Fragment$1, P as reactDom, Q as _extends, V as jsxs, W as green, X as orange, Y as styled, Z as Tabs, $ as Tab, a0 as NumberFormat$1, a1 as TextField, a2 as InputAdornment, a3 as Autocomplete, a4 as FormControlLabel, a5 as Checkbox, a6 as TextareaAutosize, a7 as useSpring, a8 as circularProgressClasses, a9 as Transition, aa as easings, ab as StyledEngineProvider, ac as ThemeProvider$1, ad as CssBaseline, ae as Snackbar, af as Alert, ag as init, ah as BrowserTracing, ai as ReactDOM, aj as Provider$1 } from "./vendor.058cba58.js";
const p$1 = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node4 of mutation.addedNodes) {
        if (node4.tagName === "LINK" && node4.rel === "modulepreload")
          processPreload(node4);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
};
p$1();
const defaultState = {};
defaultState.character = {
  serverId: 1,
  cid: 1e3,
  firstname: "Default",
  lastname: "State",
  phone: "0412345678",
  job: "judge",
  server_id: 1,
  hasVPN: true
};
defaultState.hud = {
  compass: {
    visible: true,
    heading: 60,
    street: "Not a street",
    zone: "Not a zone"
  },
  values: {
    health: {
      enabled: true,
      value: 75
    },
    armor: {
      enabled: true,
      value: 100
    },
    hunger: {
      enabled: true,
      value: 100
    },
    thirst: {
      enabled: true,
      value: 100
    },
    air: {
      enabled: true,
      value: 100
    }
  },
  voice: {
    normal: true,
    onRadio: false
  }
};
defaultState.contextmenu = [
  {
    id: "1",
    title: "Context Menu Item 1",
    icon: "cog",
    callbackURL: "test-url"
  },
  {
    id: "2",
    title: "Context Menu Item 2",
    icon: "cog",
    callbackURL: "test-url"
  },
  {
    id: "3",
    title: "Context Menu Item 3",
    description: "This is a description",
    callbackURL: "test-url",
    disabled: true
  },
  {
    id: "4",
    title: "Context Menu Item 4",
    icon: "cog",
    callbackURL: "test-url",
    submenu: [
      {
        id: "4.1",
        title: "Context Menu Item 4.1",
        icon: "cog",
        callbackURL: "test-url"
      }
    ]
  }
];
defaultState.financials = {
  isAtm: false,
  bank: "fleeca",
  cash: 343578
};
const isDevel = () => {
  return false;
};
const store$p = {
  key: "main",
  initialState: {
    currentApp: "",
    error: null,
    mounted: true
  },
  auxiliaryState: {
    character: {},
    game: {
      location: "world",
      time: "12:00",
      weather: "EXTRASUNNY"
    }
  }
};
var __glob_6_0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$p
});
const store$o = {
  key: "cli",
  initialState: {
    visible: isDevel()
  }
};
var __glob_6_1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$o
});
const store$n = {
  key: "contextmenu",
  initialState: {
    visible: true,
    entries: [],
    allEntries: [],
    parentEntry: null
  }
};
var __glob_6_2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$n
});
const store$m = {
  key: "debuglogs",
  initialState: {
    visible: isDevel(),
    logs: []
  }
};
var __glob_6_3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$m
});
const store$l = {
  key: "financials",
  initialState: {
    visible: false,
    openPane: false,
    cash: 0,
    bank: "",
    isAtm: false,
    canLoadMore: false,
    accounts: [],
    selected: null,
    transactions: [],
    backdrop: false,
    modalComponent: null
  }
};
var __glob_6_4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$l
});
const store$k = {
  key: "hud",
  initialState: {
    visible: true,
    compass: {
      visible: false,
      heading: 0,
      street: "",
      zone: ""
    },
    values: {
      health: {
        enabled: true,
        value: 0
      },
      armor: {
        enabled: true,
        value: 0
      },
      hunger: {
        enabled: false,
        value: 0
      },
      thirst: {
        enabled: false,
        value: 0
      },
      air: {
        enabled: false,
        value: 0
      }
    },
    voice: {
      normal: false,
      onRadio: false
    },
    iconIdx: 0
  }
};
var __glob_6_5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$k
});
const store$j = {
  key: "input",
  initialState: {
    visible: false,
    inputs: [],
    callbackURL: ""
  }
};
var __glob_6_6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$j
});
const store$i = {
  key: "interaction",
  initialState: {
    visible: false,
    show: false,
    text: "",
    type: "info"
  }
};
var __glob_6_7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$i
});
const store$h = {
  key: "notifications",
  initialState: {
    visible: true,
    notifications: []
  }
};
var __glob_6_8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$h
});
const store$g = {
  key: "phone",
  initialState: {
    visible: false,
    animating: false,
    isSilent: false,
    inCamera: false,
    callActive: false,
    hasNotifications: false,
    activeApp: "home-screen",
    callMeta: {},
    background: {}
  },
  auxiliaryState: {
    "phone.form": {
      visible: false,
      element: null,
      checkmark: false
    },
    "phone.notifications": {
      list: []
    }
  }
};
var __glob_6_9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$g
});
const store$f = {
  key: "phone.apps.contacts",
  initialState: {
    contacts: []
  }
};
var __glob_6_10 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$f
});
const store$e = {
  key: "phone.apps.crypto",
  initialState: {
    list: [],
    shouldRenew: false
  }
};
var __glob_6_11 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$e
});
const store$d = {
  key: "phone.apps.example",
  initialState: {}
};
var __glob_6_12 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$d
});
const store$c = {
  key: "phone.apps.gallery",
  initialState: {
    list: []
  }
};
var __glob_6_13 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$c
});
const store$b = {
  key: "phone.apps.home-screen",
  initialState: {}
};
var __glob_6_14 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$b
});
const store$a = {
  key: "phone.apps.info",
  initialState: {
    entries: []
  }
};
var __glob_6_15 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$a
});
const store$9 = {
  key: "phone.apps.justice",
  initialState: {
    list: {}
  }
};
var __glob_6_16 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$9
});
const store$8 = {
  key: "phone.apps.mail",
  initialState: {
    mails: []
  }
};
var __glob_6_17 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$8
});
const store$7 = {
  key: "phone.apps.messages",
  initialState: {
    messages: {},
    currentNumber: null
  }
};
var __glob_6_18 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$7
});
const store$6 = {
  key: "phone.apps.notes",
  initialState: {
    list: [],
    current: null
  }
};
var __glob_6_19 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$6
});
const store$5 = {
  key: "phone.apps.payconiq",
  initialState: {
    list: [],
    dirty: false
  }
};
var __glob_6_20 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$5
});
const store$4 = {
  key: "phone.apps.phone",
  initialState: {
    calls: []
  }
};
var __glob_6_21 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$4
});
const store$3 = {
  key: "phone.apps.example",
  initialState: {}
};
var __glob_6_22 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$3
});
const store$2 = {
  key: "phone.apps.twitter",
  initialState: {
    tweets: [],
    requestAmount: 0
  }
};
var __glob_6_23 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$2
});
const store$1 = {
  key: "phone.apps.yellowpages",
  initialState: {
    list: [],
    current: null
  }
};
var __glob_6_24 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store$1
});
const events$b = {
  main: {
    restart: () => {
      store.dispatch({
        type,
        cb: () => GetInitialState()
      });
    }
  }
};
const auxStates = [];
const addAuxState = (stateName) => {
  auxStates.push(stateName);
};
const handleIncomingEvent = (e2) => {
  if (!e2.data.app || !e2.data.data) {
    return;
  }
  if (auxStates.includes(e2.data.app)) {
    store.dispatch({
      type,
      cb: (state) => __spreadProps(__spreadValues({}, state), {
        [e2.data.app]: __spreadValues(__spreadValues({}, state[e2.data.app]), e2.data.data)
      })
    });
    return;
  }
  if (events$b[e2.data.app] && events$b[e2.data.app][e2.data.data.event]) {
    events$b[e2.data.app][e2.data.data.event](e2.data.data);
    return;
  }
};
const type = "dg-ui-action";
const compose = (storeObj, { mapStateToProps: extraMap = (_o) => ({}), mapDispatchToProps: extraDispatch = {} } = {}) => {
  const mapStateToProps2 = (state) => {
    return __spreadValues(__spreadValues({}, state[storeObj.key]), extraMap(state));
  };
  const updateState2 = (data) => {
    if (typeof data === "function") {
      return { cb: data, type };
    }
    const cb = (state) => __spreadProps(__spreadValues({}, state), {
      [storeObj.key]: __spreadValues(__spreadValues({}, state[storeObj.key]), data)
    });
    return { cb, type };
  };
  const mapDispatchToProps2 = __spreadProps(__spreadValues({}, extraDispatch), {
    updateState: updateState2
  });
  return {
    mapStateToProps: mapStateToProps2,
    mapDispatchToProps: mapDispatchToProps2
  };
};
let store = null;
let initialState = {};
const GetInitialState = () => initialState;
const reducer$1 = (state = initialState, action2) => {
  switch (action2.type) {
    case type:
      return action2.cb(state)[action2.key];
    default:
      return state[action2.key];
  }
};
const setReducers = () => {
  const initred = {};
  const importAll = (r2) => {
    Object.keys(r2).forEach((key) => {
      const result2 = r2[key].default;
      initred[result2.key] = (state, action2) => reducer$1(__spreadProps(__spreadValues({}, initialState), {
        [result2.key]: __spreadValues(__spreadValues({}, initialState[result2.key]), state)
      }), __spreadProps(__spreadValues({}, action2), { key: result2.key }));
      if (!result2.auxiliaryState)
        return;
      Object.keys(result2.auxiliaryState).forEach((auxKey) => {
        addAuxState(auxKey);
        initred[auxKey] = (state, action2) => reducer$1(__spreadProps(__spreadValues({}, initialState), {
          [auxKey]: __spreadValues(__spreadValues({}, initialState[auxKey]), state)
        }), __spreadProps(__spreadValues({}, action2), { key: auxKey }));
      });
    });
  };
  importAll({ "../main/store.ts": __glob_6_0, "../main/cli/store.ts": __glob_6_1, "../main/contextmenu/store.ts": __glob_6_2, "../main/debuglogs/store.ts": __glob_6_3, "../main/financials/store.ts": __glob_6_4, "../main/hud/store.ts": __glob_6_5, "../main/input/store.ts": __glob_6_6, "../main/interaction/store.ts": __glob_6_7, "../main/notifications/store.ts": __glob_6_8, "../main/phone/store.ts": __glob_6_9, "../main/phone/apps/contacts-app/store.ts": __glob_6_10, "../main/phone/apps/crypto-app/store.ts": __glob_6_11, "../main/phone/apps/example-app/store.ts": __glob_6_12, "../main/phone/apps/gallery-app/store.ts": __glob_6_13, "../main/phone/apps/home-screen/store.ts": __glob_6_14, "../main/phone/apps/info-app/store.ts": __glob_6_15, "../main/phone/apps/justice-app/store.ts": __glob_6_16, "../main/phone/apps/mail-app/store.ts": __glob_6_17, "../main/phone/apps/message-app/store.ts": __glob_6_18, "../main/phone/apps/notes-app/store.ts": __glob_6_19, "../main/phone/apps/payconiq-app/store.ts": __glob_6_20, "../main/phone/apps/phone-app/store.ts": __glob_6_21, "../main/phone/apps/pinger-app/store.ts": __glob_6_22, "../main/phone/apps/twitter-app/store.ts": __glob_6_23, "../main/phone/apps/yp-app/store.ts": __glob_6_24 });
  return initred;
};
const setInitialState = () => {
  const importAll = (r2) => {
    Object.keys(r2).forEach((key) => {
      var _a;
      const result2 = r2[key].default;
      initialState = __spreadProps(__spreadValues(__spreadValues({}, initialState), (_a = result2.auxiliaryState) != null ? _a : {}), {
        [result2.key]: result2.initialState
      });
    });
  };
  importAll({ "../main/store.ts": __glob_6_0, "../main/cli/store.ts": __glob_6_1, "../main/contextmenu/store.ts": __glob_6_2, "../main/debuglogs/store.ts": __glob_6_3, "../main/financials/store.ts": __glob_6_4, "../main/hud/store.ts": __glob_6_5, "../main/input/store.ts": __glob_6_6, "../main/interaction/store.ts": __glob_6_7, "../main/notifications/store.ts": __glob_6_8, "../main/phone/store.ts": __glob_6_9, "../main/phone/apps/contacts-app/store.ts": __glob_6_10, "../main/phone/apps/crypto-app/store.ts": __glob_6_11, "../main/phone/apps/example-app/store.ts": __glob_6_12, "../main/phone/apps/gallery-app/store.ts": __glob_6_13, "../main/phone/apps/home-screen/store.ts": __glob_6_14, "../main/phone/apps/info-app/store.ts": __glob_6_15, "../main/phone/apps/justice-app/store.ts": __glob_6_16, "../main/phone/apps/mail-app/store.ts": __glob_6_17, "../main/phone/apps/message-app/store.ts": __glob_6_18, "../main/phone/apps/notes-app/store.ts": __glob_6_19, "../main/phone/apps/payconiq-app/store.ts": __glob_6_20, "../main/phone/apps/phone-app/store.ts": __glob_6_21, "../main/phone/apps/pinger-app/store.ts": __glob_6_22, "../main/phone/apps/twitter-app/store.ts": __glob_6_23, "../main/phone/apps/yp-app/store.ts": __glob_6_24 });
  return initialState;
};
const sentryReduxEnhancer = createReduxEnhancer({});
const composeEnhancers = compose$1;
store = createStore(combineReducers(__spreadValues({}, setReducers())), setInitialState(), composeEnhancers(sentryReduxEnhancer));
let logId = 1;
const getState$2 = () => store.getState().debuglogs;
const action = (data) => {
  if (data.logs) {
    data.logs = data.logs.slice(0, 20);
  }
  store.dispatch({
    type,
    cb: (state) => __spreadProps(__spreadValues({}, state), {
      debuglogs: __spreadValues(__spreadValues({}, state.debuglogs), data)
    })
  });
};
const addLog = (info) => {
  const logs = [...getState$2().logs];
  const log = __spreadProps(__spreadValues({}, info), {
    id: logId++
  });
  logs.unshift(log);
  action({ logs });
  return log.id;
};
const finishLog = (id, info) => {
  const logs = [...getState$2().logs];
  const logIdx = logs.findIndex((l2) => l2.id === id);
  if (logIdx !== -1) {
    const log = logs[logIdx];
    log.response = info.response;
    log.isOk = info.isOk;
    logs[logIdx] = log;
    action({ logs });
  }
};
const doRequest = async (action2, body = {}) => {
  const rawResult = await fetch(`https://${GetParentResourceName()}/${action2}`, {
    method: "post",
    headers: {
      "Content-Type": "application/json; charset=UTF-8"
    },
    body: JSON.stringify(body)
  });
  try {
    const result2 = await rawResult.json();
    return result2;
  } catch (err2) {
    return { data: {}, meta: { ok: false, message: `Failed to do request for: ${action2} - ${err2.message}` } };
  }
};
const nuiAction = async (action2, body = {}, devData2 = {}) => {
  var _a, _b, _c;
  body = __spreadProps(__spreadValues({}, body), { _character: store.getState().character });
  const actionId = addLog({
    name: action2,
    body
  });
  const request = await doRequest(action2, body);
  if (!((_a = request == null ? void 0 : request.meta) == null ? void 0 : _a.ok)) {
    throw new Error(request.meta.message);
  }
  finishLog(actionId, {
    response: request != null ? request : {},
    isOk: (_c = (_b = request == null ? void 0 : request.meta) == null ? void 0 : _b.ok) != null ? _c : false
  });
  return request.data;
};
const mockEvent = (app, data, extraData = {}) => {
  window.dispatchEvent(new MessageEvent("message", {
    data: __spreadValues({
      app,
      data
    }, extraData)
  }));
};
const devData = {};
devData.contacts = [
  {
    id: 1,
    label: "John Doe",
    phone: "0467227521"
  },
  {
    id: 2,
    label: "Jane Doe",
    phone: "0467227522"
  },
  {
    id: 3,
    label: "Jack Doe",
    phone: "0467227523"
  },
  {
    id: 4,
    label: "Jill Doe",
    phone: "0467227524"
  },
  {
    id: 5,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 6,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 7,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 8,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 9,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 10,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 11,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 12,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 13,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 14,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 15,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 16,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 17,
    label: "Jenny Doe",
    phone: "0467227525"
  },
  {
    id: 18,
    label: "Jenny Doe",
    phone: "0467227525"
  }
];
devData.messages = {
  "0467227521": [
    {
      id: 1,
      isread: true,
      isreceiver: true,
      message: "message 1",
      date: 1638488727
    },
    {
      id: 2,
      isread: true,
      isreceiver: false,
      message: "message 2 look a this dog https://cdn.pixabay.com/photo/2019/10/10/11/36/dog-4539374_960_720.jpg",
      date: 1638488900
    },
    {
      id: 3,
      isread: false,
      isreceiver: true,
      message: "message 3",
      date: 1638489e3
    },
    {
      id: 4,
      isread: false,
      isreceiver: false,
      message: "message 4",
      date: 1638489100
    },
    {
      id: 5,
      isread: false,
      isreceiver: true,
      message: "message 5",
      date: 1638489200
    },
    {
      id: 6,
      isread: false,
      isreceiver: false,
      message: "message 6",
      date: 1638489300
    },
    {
      id: 7,
      isread: false,
      isreceiver: true,
      message: "message 7",
      date: 1638489400
    },
    {
      id: 8,
      isread: false,
      isreceiver: false,
      message: "message 8",
      date: 1638489500
    },
    {
      id: 9,
      isread: false,
      isreceiver: true,
      message: "message 9",
      date: 1638489600
    },
    {
      id: 10,
      isread: false,
      isreceiver: false,
      message: "message 10",
      date: 1638489700
    },
    {
      id: 11,
      isread: false,
      isreceiver: true,
      message: "message 11",
      date: 1638489800
    },
    {
      id: 12,
      isread: false,
      isreceiver: false,
      message: "message 12",
      date: 1638489900
    },
    {
      id: 13,
      isread: false,
      isreceiver: true,
      message: "message 13",
      date: 163849e4
    },
    {
      id: 14,
      isread: false,
      isreceiver: false,
      message: "message 14",
      date: 1638490100
    },
    {
      id: 15,
      isread: false,
      isreceiver: true,
      message: "message 15",
      date: 1638490300
    },
    {
      id: 16,
      isread: false,
      isreceiver: false,
      message: "message 16",
      date: 1638490400
    },
    {
      id: 17,
      isread: false,
      isreceiver: true,
      message: "message 17",
      date: 1638490500
    }
  ]
};
devData.YPListings = [
  {
    id: 1,
    phone: "0467227521",
    name: "John Doe",
    text: "My first ad https://inspyrus.com/wp-content/uploads/2016/08/cloud-image-1.jpg"
  },
  {
    id: 2,
    phone: "0467227522",
    name: "Jane Doe",
    text: "My Second super long ad with a nice emoji look --> \u{1F697} toet toet"
  }
];
devData.tweets = [
  {
    id: 1,
    sender_name: "@John_Doe",
    tweet: "This is a tweet  https://i.redd.it/osiouuinz7881.jpg",
    date: 1638488727e3,
    like_count: 2,
    retweet_count: 1,
    liked: false,
    retweeted: true
  },
  {
    id: 2,
    sender_name: "@Jane_Doe",
    tweet: "This is a tweet",
    date: 1638488727e3,
    like_count: 11,
    retweet_count: 0,
    liked: true,
    retweeted: false
  }
];
devData.notes = [
  {
    id: 1,
    title: "My first note",
    date: 1638488727,
    note: "<p>My test note</p>"
  },
  {
    id: 2,
    title: "Contract",
    date: 1638489e3,
    note: "<p>This is a contract with alot of restrictions and useless text nobody understands</p>"
  }
];
devData.crypto = [
  {
    crypto_name: "Manera",
    icon: "mdi-alpha-m-circle-outline",
    value: 200,
    wallet: {
      cid: "MNK81964",
      amount: 345,
      cname: "Manera"
    }
  }
];
devData.bankTrans = [
  {
    accepted_by: "Jane Doe",
    triggered_by: "Default State",
    date: 1638489e3,
    comment: "Druggies",
    change: 100,
    transaction_id: "ABC YOU DONT SEE ME"
  },
  {
    accepted_by: "Default State",
    triggered_by: "Jane Deo",
    date: 1638489e3,
    comment: "SUBPOENA ME",
    change: 17834,
    transaction_id: "ABC YOU DONT SEE ME2"
  }
];
devData.images = [
  {
    id: 1,
    src: "https://i.imgur.com/p2AF1tL.jpg"
  },
  {
    id: 2,
    src: "https://i.imgur.com/TJvF3KT.jpg"
  },
  {
    id: 3,
    src: "https://i.imgur.com/1W5Io9e.jpg"
  },
  {
    id: 4,
    src: "https://i.imgur.com/bswBJPK.jpg"
  },
  {
    id: 5,
    src: "https://i.imgur.com/ISeGfCO.jpg"
  },
  {
    id: 6,
    src: "https://i.imgur.com/u2N5k3z.jpg"
  },
  {
    id: 7,
    src: "https://i.imgur.com/Rho7WGc.jpg"
  },
  {
    id: 8,
    src: "https://i.imgur.com/UAAoJ51.jpg"
  },
  {
    id: 9,
    src: "https://i.imgur.com/HsUDGTh.jpg"
  },
  {
    id: 10,
    src: "https://i.imgur.com/WVC05JR.jpg"
  }
];
devData.justice = {
  judge: [
    {
      name: "John doe",
      phone: "0467227521",
      available: true
    },
    {
      name: "David Achter",
      phone: "0487809321",
      available: true
    }
  ],
  lawyer: [
    {
      name: "Jane doe",
      phone: "0467227522",
      available: false
    }
  ]
};
devData.financialsAccounts = [
  {
    account_id: "BE01234566",
    name: "Standard",
    balance: -1020.01,
    type: "standard",
    permissions: {
      deposit: true,
      withdraw: true,
      transfer: true,
      transactions: true
    }
  },
  {
    account_id: "BE01234567",
    name: "Me Savings",
    balance: 14786739e-1,
    type: "savings",
    permissions: {
      deposit: true,
      withdraw: false,
      transfer: false,
      transactions: true
    }
  },
  {
    account_id: "BE01234568",
    name: "Bank of America",
    balance: 67980.12,
    type: "business",
    permissions: {
      deposit: true,
      withdraw: true,
      transfer: true,
      transactions: false
    }
  }
];
devData.financialsTransactions = [
  {
    transaction_id: "e418e011-54fc-49a6-968a-8e9197c2cb1b",
    origin_account_id: "BE01234567",
    origin_account_name: "Me Savings",
    target_account_id: "BE01234568",
    target_account_name: "Bank of America",
    change: 100,
    comment: "Transfer to Bank of America",
    triggered_by: "David Voor",
    accepted_by: "David Achter",
    date: 1641766054368,
    type: "transfer"
  }
];
var _jsxFileName$1P = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/appwrapper.tsx";
const useStyles = makeStyles({
  wrapper: (props) => __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    position: "absolute",
    visibility: "visible",
    pointerEvents: "none",
    overflow: "scroll",
    opacity: 1,
    display: "block"
  }, props.full && {
    width: "100vw",
    height: "100vh"
  }), (props.center || props.column) && {
    display: "flex",
    alignItems: "center"
  }), props.center && {
    justifyContent: "center",
    width: "100vw"
  }), props.column && {
    flexDirection: "column",
    justifyContent: "flex-start"
  }), props.unSelectable && {
    userSelect: "none",
    WebkitUserSelect: "none"
  }), {
    "& > *": {
      pointerEvents: "all"
    }
  })
});
const registeredApps = {};
const setCurrentApp = (app) => {
  store.dispatch({
    type,
    cb: (state) => __spreadProps(__spreadValues({}, state), {
      main: __spreadProps(__spreadValues({}, state.main), {
        currentApp: app
      })
    })
  });
};
function AppWrapper(props) {
  const mainState = useSelector((state) => state.main);
  const styles2 = useStyles(props);
  const appRef = react$1.exports.useRef(null);
  const appInfo = getApp(props.appName);
  const appState = useSelector((state) => state[props.appName]);
  const [visible, setVisible] = react$1.exports.useState(false);
  const [active, setActive] = react$1.exports.useState(false);
  const eventHandler = async (e2) => {
    if (e2.data.app === props.appName) {
      const transaction = startTransaction({
        name: `incomingAppEvent`,
        tags: {
          app: props.appName
        }
      });
      getCurrentHub().configureScope((scope) => {
        scope.setSpan(transaction);
      });
      const span = transaction.startChild({
        op: "AppWrapper.eventHandler",
        description: `Incoming event for ${props.appName} handled by AppWrapper`,
        data: {
          eventData: e2.data
        }
      });
      try {
        addLog({
          name: `AppWrapper:${props.appName}`,
          body: {},
          response: e2.data,
          isOk: true
        });
        if (e2.data.show) {
          props.onShow(e2.data.data);
          if ((appInfo == null ? void 0 : appInfo.type) === "interactive" && e2.data.shouldFocus) {
            nuiAction("__appwrapper:setfocus");
          }
          return;
        } else if (e2.data.show === false) {
          if (visible) {
            if (active) {
              setCurrentApp("");
            }
            props.onHide();
          }
          return;
        }
        if (props.onEvent) {
          props.onEvent(e2.data.data);
        }
        span.setStatus(spanstatus.SpanStatus.Ok);
      } catch (e22) {
        span.setStatus(spanstatus.SpanStatus.UnknownError);
        throw e22;
      } finally {
        span.finish();
        transaction.finish();
      }
    }
  };
  const handlePress = (e2) => {
    var _a;
    switch (e2.key) {
      case "Escape":
        if (visible) {
          const shouldEvent = props.onEscape ? (_a = props.onEscape()) != null ? _a : true : null;
          if (shouldEvent === true) {
            nuiAction("dg-ui:applicationClosed", {
              app: props.appName,
              fromEscape: true
            });
          }
        }
        break;
    }
  };
  const handleError = (e2) => {
    if (props.onError) {
      props.onError(e2);
    } else {
      nuiAction("reload");
    }
  };
  const handleActiveApp = () => {
    setActive(true);
    setCurrentApp(props.appName);
  };
  react$1.exports.useEffect(() => {
    window.addEventListener("message", eventHandler);
    window.addEventListener("keydown", handlePress);
    window.addEventListener("error", handleError);
    if (appRef && appRef.current) {
      appRef.current.addEventListener("click", handleActiveApp);
    }
    return () => {
      window.removeEventListener("message", eventHandler);
      window.removeEventListener("keydown", handlePress);
      window.removeEventListener("error", handleError);
      if (appRef && appRef.current) {
        appRef.current.removeEventListener("click", handleActiveApp);
      }
    };
  }, [visible]);
  react$1.exports.useEffect(() => {
    registeredApps[props.appName] = {
      onHide: () => {
        if (active) {
          setCurrentApp("");
        }
        setVisible(false);
        props.onHide();
      },
      onShow: props.onShow
    };
    return () => {
      delete registeredApps[props.appName];
    };
  }, []);
  react$1.exports.useEffect(() => {
    if (appState.visible === visible)
      return;
    setActive(appState.visible);
    setVisible(appState.visible);
    if (appState.visible) {
      setCurrentApp(props.appName);
    }
  }, [appState]);
  react$1.exports.useEffect(() => {
    const isActiveApp = mainState.currentApp === props.appName;
    if (isActiveApp === active)
      return;
    setActive(isActiveApp);
  }, [mainState]);
  react$1.exports.useEffect(() => {
    if (!appInfo) {
      throw new Error(`No config found for ${props.appName}`);
    }
  }, [appInfo]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: `${styles2.wrapper}${visible ? "" : " hidden"}`,
    style: __spreadValues({
      zIndex: active ? 10 : 1
    }, props.style || {}),
    "data-appwrapper": props.appName,
    ref: appRef,
    children: props.children
  }, void 0, false, {
    fileName: _jsxFileName$1P,
    lineNumber: 226,
    columnNumber: 5
  }, this);
}
const closeApplication = (app) => {
  if (!registeredApps[app]) {
    return;
  }
  registeredApps[app].onHide();
  nuiAction("dg-ui:applicationClosed", {
    app,
    fromEscape: false
  });
};
var baseBackground = "./assets/background.4f90d3bd.png";
const vhToPixel = (vh) => {
  return vh * window.innerHeight / 100;
};
const useVhToPixel = (vh) => {
  const [calcPx, setCalcPx] = react$1.exports.useState(vhToPixel(vh));
  const handleResize = () => {
    setCalcPx(vhToPixel(vh));
  };
  window.addEventListener("resize", handleResize);
  return calcPx;
};
const theme = createTheme({
  palette: {
    mode: "dark",
    primary: {
      main: "#8d96ec"
    },
    secondary: {
      main: "#E6B341"
    },
    background: {
      default: "transparent",
      paper: "transparent"
    }
  },
  typography: {
    body2: {
      fontSize: "0.75rem"
    }
  },
  components: {
    MuiTooltip: {
      styleOverrides: {
        tooltip: {
          fontSize: "0.7rem"
        }
      }
    }
  }
});
const baseStyle = {
  primary: {
    darker: "#232832",
    dark: "#3d4482",
    normal: "#767fcf",
    light: "#abb3ff",
    lighter: "#bbbed7"
  },
  primaryDarker: {
    darker: "#1b1e23",
    dark: "#404654",
    normal: "#646f84",
    light: "#8796b3",
    lighter: "#abbee2"
  },
  secondary: {
    darker: "#664F1D",
    dark: "#A6802E",
    normal: "#E6B341",
    light: "#FFCD61",
    lighter: "#EACB88"
  },
  tertiary: {
    darker: "#692635",
    dark: "#B5415C",
    normal: "#E85476",
    light: "#FF7595",
    lighter: "#EC9CAE"
  },
  gray: {
    darker: "#020006",
    dark: "#424046",
    normal: "#828086",
    light: "#c8c6ca",
    lighter: "#fefaff"
  }
};
const styles$o = makeStyles({
  wrapper: {
    width: "100%",
    height: "100%",
    color: "white",
    display: "flex",
    flexDirection: "column",
    overflow: "hidden",
    padding: "0 1vh",
    position: "relative",
    "& > div:first-child": {
      width: "100%",
      display: "flex",
      flexDirection: "column"
    }
  },
  actionWrapper: {
    color: "white",
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    alignSelf: "flex-end",
    position: "fixed"
  },
  innerActionWrapper: {
    width: "100%",
    display: "flex",
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center"
  },
  action: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "2vh",
    marginLeft: ".5vh",
    cursor: "pointer"
  },
  backAction: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "1vh"
  },
  inputsWrapper: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center"
  },
  innerInputWrapper: {
    width: "100%",
    display: "flex",
    flexDirection: "column"
  },
  container: {
    height: "100%",
    overflow: "auto",
    overflowX: "hidden",
    position: "relative"
  }
});
var _jsxFileName$1O = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/os/appcontainer/appcontainer.tsx";
const AppContainer = (props) => {
  var _a, _b, _c, _d;
  const classes = styles$o();
  const wrapperTop = useVhToPixel(1);
  const activeApp = useSelector((state) => state.phone.activeApp);
  const [anchorEl, setAnchorEl] = react$1.exports.useState(null);
  const [topPadding, setTopPadding] = react$1.exports.useState(0);
  const [searchValue, setSearchValue] = react$1.exports.useState("");
  const rootWrapperRef = react$1.exports.useRef(null);
  const actionWrapperRef = react$1.exports.useRef(null);
  const inputWrapperRef = react$1.exports.useRef(null);
  const open = Boolean(anchorEl);
  const handleAuxClick = (e2) => {
    setAnchorEl(e2.currentTarget);
  };
  const handleClose = () => {
    setAnchorEl(null);
  };
  const handleSearchChange = (val) => {
    if (!props.search)
      return;
    setSearchValue(val);
    if (!val) {
      props.search.onChange(props.search.list);
      return;
    }
    const list = props.search.list.filter((item) => {
      var _a2, _b2;
      for (const field of (_b2 = (_a2 = props.search) == null ? void 0 : _a2.filter) != null ? _b2 : []) {
        const v2 = typeof field === "function" ? field(item) : item[field];
        if (v2 && v2.toString().toLowerCase().indexOf(val.toLowerCase()) !== -1) {
          return true;
        }
      }
      return false;
    });
    props.search.onChange(list);
  };
  react$1.exports.useEffect(() => {
    let padding = 0;
    if (actionWrapperRef.current) {
      padding = actionWrapperRef.current.getBoundingClientRect().height;
    }
    if (inputWrapperRef.current) {
      const inputPadding = inputWrapperRef.current.getBoundingClientRect().height;
      padding = padding < inputPadding ? inputPadding : padding;
    }
    if (padding > 0) {
      padding += wrapperTop;
    }
    setTopPadding(padding);
  }, [actionWrapperRef]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: [classes.wrapper, (_a = props.className) != null ? _a : ""].join(" "),
    style: props.style,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      style: {
        height: topPadding,
        backgroundColor: typeof ((_b = getPhoneApp(activeApp)) == null ? void 0 : _b.background) === "string" ? (_c = getPhoneApp(activeApp)) == null ? void 0 : _c.background : baseStyle.primaryDarker.darker
      },
      ref: rootWrapperRef,
      children: [(props.primaryActions || props.auxActions || props.onClickBack && !(props.search || props.input)) && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.actionWrapper,
        ref: actionWrapperRef,
        style: {
          width: rootWrapperRef.current ? rootWrapperRef.current.getBoundingClientRect().width : "initial"
        },
        children: [props.onClickBack && !(props.search || props.input) && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tooltip$1, {
          title: "Terug",
          children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: classes.backAction,
            onClick: props.onClickBack,
            children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(default_1$3, {}, void 0, false, {
              fileName: _jsxFileName$1O,
              lineNumber: 94,
              columnNumber: 19
            }, globalThis)
          }, void 0, false, {
            fileName: _jsxFileName$1O,
            lineNumber: 93,
            columnNumber: 17
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$1O,
          lineNumber: 92,
          columnNumber: 15
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: classes.innerActionWrapper,
          children: [props.primaryActions && props.primaryActions.map((action2, index3) => {
            var _a2;
            return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tooltip$1, {
              title: action2.title,
              placement: "bottom",
              children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
                className: classes.action,
                onClick: () => action2.onClick(action2.data),
                children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
                  className: `${(_a2 = action2.iconLib) != null ? _a2 : "fas"} fa-${action2.icon}`
                }, void 0, false, {
                  fileName: _jsxFileName$1O,
                  lineNumber: 103,
                  columnNumber: 23
                }, globalThis)
              }, void 0, false, {
                fileName: _jsxFileName$1O,
                lineNumber: 102,
                columnNumber: 21
              }, globalThis)
            }, index3, false, {
              fileName: _jsxFileName$1O,
              lineNumber: 101,
              columnNumber: 19
            }, globalThis);
          }), props.auxActions && props.auxActions.length > 0 && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(jsxDevRuntime.exports.Fragment, {
            children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
              className: classes.action,
              onClick: handleAuxClick,
              children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
                className: "fas fa-ellipsis-v"
              }, void 0, false, {
                fileName: _jsxFileName$1O,
                lineNumber: 110,
                columnNumber: 21
              }, globalThis)
            }, void 0, false, {
              fileName: _jsxFileName$1O,
              lineNumber: 109,
              columnNumber: 19
            }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Menu$1, {
              anchorEl,
              anchorOrigin: {
                horizontal: "right",
                vertical: "top"
              },
              transformOrigin: {
                horizontal: "right",
                vertical: "top"
              },
              keepMounted: true,
              onClose: handleClose,
              TransitionComponent: Fade,
              open,
              children: props.auxActions.map((action2, index3) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(MenuItem$1, {
                onClick: () => {
                  action2.onClick(action2.data);
                  handleClose();
                },
                children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ListItemIcon, {
                  style: {
                    minWidth: 32
                  },
                  children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
                    className: `fas fa-${action2.icon}`
                  }, void 0, false, {
                    fileName: _jsxFileName$1O,
                    lineNumber: 130,
                    columnNumber: 27
                  }, globalThis)
                }, void 0, false, {
                  fileName: _jsxFileName$1O,
                  lineNumber: 129,
                  columnNumber: 25
                }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
                  variant: "body2",
                  children: action2.title
                }, void 0, false, {
                  fileName: _jsxFileName$1O,
                  lineNumber: 132,
                  columnNumber: 25
                }, globalThis)]
              }, index3, true, {
                fileName: _jsxFileName$1O,
                lineNumber: 122,
                columnNumber: 23
              }, globalThis))
            }, void 0, false, {
              fileName: _jsxFileName$1O,
              lineNumber: 112,
              columnNumber: 19
            }, globalThis)]
          }, void 0, true)]
        }, void 0, true, {
          fileName: _jsxFileName$1O,
          lineNumber: 98,
          columnNumber: 13
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$1O,
        lineNumber: 84,
        columnNumber: 11
      }, globalThis), (props.onClickBack || props.search || props.input) && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.inputsWrapper,
        ref: inputWrapperRef,
        children: [props.onClickBack && (props.search || props.input) && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tooltip$1, {
          title: "Terug",
          children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: "back-btn",
            children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(default_1$3, {
              onClick: props.onClickBack
            }, void 0, false, {
              fileName: _jsxFileName$1O,
              lineNumber: 146,
              columnNumber: 19
            }, globalThis)
          }, void 0, false, {
            fileName: _jsxFileName$1O,
            lineNumber: 145,
            columnNumber: 17
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$1O,
          lineNumber: 144,
          columnNumber: 15
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: classes.innerInputWrapper,
          children: [props.input && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadValues({}, props.input), void 0, false, {
            fileName: _jsxFileName$1O,
            lineNumber: 151,
            columnNumber: 31
          }, globalThis), props.search && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Search, {
            value: searchValue,
            onChange: handleSearchChange
          }, void 0, false, {
            fileName: _jsxFileName$1O,
            lineNumber: 152,
            columnNumber: 32
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$1O,
          lineNumber: 150,
          columnNumber: 13
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$1O,
        lineNumber: 142,
        columnNumber: 11
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$1O,
      lineNumber: 73,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: [classes.container, (_d = props.containerClassName) != null ? _d : ""].join(" "),
      style: props.containerStyle,
      children: props.emptyList ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "emptylist",
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: "fas fa-frown"
        }, void 0, false, {
          fileName: _jsxFileName$1O,
          lineNumber: 160,
          columnNumber: 13
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("p", {
          children: "Niks te tonen"
        }, void 0, false, {
          fileName: _jsxFileName$1O,
          lineNumber: 161,
          columnNumber: 13
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$1O,
        lineNumber: 159,
        columnNumber: 11
      }, globalThis) : props.children
    }, void 0, false, {
      fileName: _jsxFileName$1O,
      lineNumber: 157,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$1O,
    lineNumber: 72,
    columnNumber: 5
  }, globalThis);
};
const emptyFn = () => {
};
const copyToClipboard = (msg) => {
  const clipElem = document.createElement("input");
  clipElem.value = msg;
  document.body.appendChild(clipElem);
  clipElem.select();
  document.execCommand("copy");
  document.body.removeChild(clipElem);
};
const isUriImage = (uri) => {
  uri = uri.split("?")[0];
  const parts = uri.split(".");
  const extension2 = parts[parts.length - 1];
  const imageTypes = ["jpg", "jpeg", "tiff", "png", "gif", "bmp"];
  return imageTypes.indexOf(extension2) !== -1;
};
const checkImageValidity = (url) => {
  if (!isUriImage(url)) {
    return Promise.resolve(false);
  }
  const image = new Image();
  return new Promise((resolve7) => {
    image.onload = () => resolve7(true);
    image.onerror = () => resolve7(false);
    image.src = url;
  });
};
const extractLinks = (text3) => {
  const links = [];
  URI.withinString(text3, (url) => {
    if (isUriImage(url)) {
      links.push(url);
      text3 = text3.replace(url, "");
    }
    return text3;
  });
  return {
    text: text3.trim(),
    links
  };
};
const IllegalTags = [
  "script",
  "style",
  "iframe",
  "frame",
  "frameset",
  "object",
  "embed",
  "link",
  "embed",
  "meta",
  "head",
  "title"
];
const sanitizeText = (text3) => {
  IllegalTags.forEach((t2) => {
    text3 = text3.replace(new RegExp(`<${t2}\b[^<]*(?:(?!</${t2}>)<[^<]*)*</${t2}>`, "gi"), "");
  });
  return text3.trim();
};
const getFirstLine = (text3) => {
  const lines = text3.split(/\n|<br>/);
  return lines[0];
};
function uuidv4() {
  let uuid = "";
  for (let ii = 0; ii < 32; ii += 1) {
    switch (ii) {
      case 8:
      case 20:
        uuid += "-";
        uuid += (Math.random() * 16 | 0).toString(16);
        break;
      case 12:
        uuid += "-";
        uuid += "4";
        break;
      case 16:
        uuid += "-";
        uuid += (Math.random() * 4 | 8).toString(16);
        break;
      default:
        uuid += (Math.random() * 16 | 0).toString(16);
    }
  }
  return uuid;
}
const formatRelativeTime = (time) => {
  dayjs.extend(relativeTime).locale("nl-be");
  return dayjs(time).fromNow();
};
const formatTime = (time) => {
  const sec = Math.floor(time % 60);
  const min3 = Math.floor(time / 60);
  return `${min3 < 10 ? "0" + min3 : min3}:${sec < 10 ? "0" + sec : sec}`;
};
const hexToRGB = (hex, alpha = 1) => {
  const r2 = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r2}, ${g}, ${b}, ${alpha})`;
};
const styles$n = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column",
    marginBottom: "1vh",
    color: baseStyle.gray.lighter,
    backgroundColor: baseStyle.primaryDarker.dark,
    borderBottom: `.2vh solid ${baseStyle.gray.light}`,
    borderRadius: "0.3vh",
    boxShadow: "0px 3px 5px 0px black",
    padding: "0.9vh",
    position: "relative",
    "&.imgonly": {
      padding: "0.4vh",
      "& .paper-image": {
        marginRight: "0!important",
        fontSize: "0em!important",
        width: "100%!important"
      }
    },
    "&:not(.extended):hover": {
      backgroundColor: baseStyle.primary.dark
    }
  },
  actionList: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-evenly",
    alignItems: "center",
    padding: "0 0.5vh",
    position: "absolute",
    width: "100%",
    height: "100%",
    top: "0",
    left: "0",
    backgroundColor: "rgba(0,0,0,0.75)"
  },
  actionEntry: {
    cursor: "pointer",
    color: baseStyle.gray.lighter,
    margin: ".3vh .5vw 0",
    fontSize: "1.2em"
  },
  details: {
    display: "flex",
    flexDirection: "column"
  },
  innerDetails: {
    display: "flex",
    flexDirection: "row",
    "& > .paper-image": {
      marginRight: "0.9vh",
      alignSelf: "center",
      fontSize: "2.25rem",
      "& img": {
        height: "100%",
        width: "100%",
        objectFit: "contain"
      }
    }
  },
  textWrapper: {
    display: "flex",
    flexDirection: "column",
    justifyContent: "space-between",
    alignItems: "flex-start",
    width: "100%",
    "& > .paper-title, & > .paper-description": {
      width: "100%",
      display: "-webkit-box",
      overflow: "hidden",
      "-webkit-line-clamp": "1",
      "-webkit-box-orient": "vertical"
    },
    "& > .paper-title": {
      marginBottom: "0.5vh",
      fontSize: "1em"
    },
    "& > .paper-description": {
      fontSize: ".9em"
    }
  },
  extDescription: {
    marginBottom: ".5vh",
    fontSize: ".9em"
  }
});
var _jsxFileName$1N = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/icon.tsx";
const Icon$2 = (props) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  if (props.lib == "img") {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      style: {
        width: props.size
      },
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("img", {
        src: props.name,
        alt: "Icon img",
        style: {
          width: "100%"
        }
      }, void 0, false, {
        fileName: _jsxFileName$1N,
        lineNumber: 17,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$1N,
      lineNumber: 16,
      columnNumber: 7
    }, globalThis);
  }
  if (props.lib == "svg") {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(MUIIcon, {
      sx: {
        textAlign: "center",
        height: props.size
      },
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("img", {
        src: props.name,
        alt: "svgIcon",
        style: {
          height: "100%"
        }
      }, void 0, false, {
        fileName: _jsxFileName$1N,
        lineNumber: 29,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$1N,
      lineNumber: 23,
      columnNumber: 7
    }, globalThis);
  }
  if (props.lib == "mdi" || props.name.startsWith("mdi-")) {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(MUIIcon, {
      baseClassName: "mdi",
      className: props.name.startsWith("mdi-") ? props.name : `mdi-${props.name}`,
      sx: __spreadProps(__spreadValues({}, (_a = props == null ? void 0 : props.style) != null ? _a : {}), {
        color: (_b = props.color) != null ? _b : "inherit",
        fontSize: (_c = props.size) != null ? _c : "1.5rem"
      })
    }, void 0, false, {
      fileName: _jsxFileName$1N,
      lineNumber: 41,
      columnNumber: 7
    }, globalThis);
  }
  if (props.lib && ["mi", "material-icons"].includes(props.lib) || props.name.startsWith("mi-")) {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(MUIIcon, {
      sx: __spreadProps(__spreadValues({}, (_d = props == null ? void 0 : props.style) != null ? _d : {}), {
        color: (_e = props.color) != null ? _e : "inherit",
        fontSize: (_f = props.size) != null ? _f : "1.5rem"
      }),
      children: props.name.startsWith("mi-") ? props.name.replace(/^mi-/, "") : props.name
    }, void 0, false, {
      fileName: _jsxFileName$1N,
      lineNumber: 54,
      columnNumber: 7
    }, globalThis);
  }
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(MUIIcon, {
    baseClassName: (_g = props == null ? void 0 : props.lib) != null ? _g : "fas",
    className: `fa-${props.name}`,
    sx: __spreadProps(__spreadValues({}, (_h = props == null ? void 0 : props.style) != null ? _h : {}), {
      color: (_i = props.color) != null ? _i : "inherit",
      fontSize: (_j = props.size) != null ? _j : "1.5rem"
    })
  }, void 0, false, {
    fileName: _jsxFileName$1N,
    lineNumber: 66,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1M = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/paper.tsx";
const Paper = (props) => {
  const [showActions, setShowActions] = react$1.exports.useState(false);
  const [imgOnly, setImgOnly] = react$1.exports.useState(false);
  const [showExtDescription, setShowExtDescription] = react$1.exports.useState(false);
  const rootRef = react$1.exports.useRef(null);
  const classes = styles$n();
  react$1.exports.useEffect(() => {
    setImgOnly(!props.title && !props.description);
  }, []);
  const handleClick2 = (e2) => {
    if (props.onClick) {
      props.onClick(e2);
    }
    setShowExtDescription(!showExtDescription);
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: [classes.root, imgOnly ? "imgonly" : "", showExtDescription ? "extended" : ""].join(" "),
    ref: rootRef,
    onMouseEnter: () => setShowActions(true),
    onMouseLeave: () => setShowActions(false),
    onClick: handleClick2,
    style: {
      cursor: props.onClick ? "pointer" : "default",
      borderBottomColor: props.notification ? red[700] : "inherit"
    },
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.details,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.innerDetails,
        children: [props.image && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: "paper-image",
          children: typeof props.image === "string" ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Icon$2, {
            name: props.image,
            size: "2.25rem"
          }, void 0, false, {
            fileName: _jsxFileName$1M,
            lineNumber: 44,
            columnNumber: 50
          }, globalThis) : props.image
        }, void 0, false, {
          fileName: _jsxFileName$1M,
          lineNumber: 43,
          columnNumber: 13
        }, globalThis), (props.title || props.description) && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: classes.textWrapper,
          children: [props.title && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: "paper-title",
            children: props.title
          }, void 0, false, {
            fileName: _jsxFileName$1M,
            lineNumber: 49,
            columnNumber: 31
          }, globalThis), props.description && (!props.replaceDescription || !showExtDescription) && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: "paper-description",
            children: typeof props.description === "string" ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
              children: props.description
            }, void 0, false, {
              fileName: _jsxFileName$1M,
              lineNumber: 52,
              columnNumber: 60
            }, globalThis) : props.description
          }, void 0, false, {
            fileName: _jsxFileName$1M,
            lineNumber: 51,
            columnNumber: 17
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$1M,
          lineNumber: 48,
          columnNumber: 13
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$1M,
        lineNumber: 41,
        columnNumber: 9
      }, globalThis), props.extDescription && showExtDescription && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.extDescription,
        children: typeof props.extDescription === "string" ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
          children: props.extDescription
        }, void 0, false, {
          fileName: _jsxFileName$1M,
          lineNumber: 60,
          columnNumber: 57
        }, globalThis) : props.extDescription
      }, void 0, false, {
        fileName: _jsxFileName$1M,
        lineNumber: 59,
        columnNumber: 11
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$1M,
      lineNumber: 40,
      columnNumber: 7
    }, globalThis), showActions && (props == null ? void 0 : props.actions) && props.actions.length > 0 && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.actionList,
      children: props.actions.map((a2, i2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tooltip$1, {
        arrow: true,
        title: a2.title,
        placement: "bottom",
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: classes.actionEntry,
          onClick: a2.onClick ? () => a2.onClick(a2.data) : emptyFn,
          children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Icon$2, {
            name: a2.icon
          }, void 0, false, {
            fileName: _jsxFileName$1M,
            lineNumber: 69,
            columnNumber: 17
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$1M,
          lineNumber: 68,
          columnNumber: 15
        }, globalThis)
      }, i2, false, {
        fileName: _jsxFileName$1M,
        lineNumber: 67,
        columnNumber: 13
      }, globalThis))
    }, void 0, false, {
      fileName: _jsxFileName$1M,
      lineNumber: 65,
      columnNumber: 9
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$1M,
    lineNumber: 29,
    columnNumber: 5
  }, globalThis);
};
const addMessage = (phoneNr, pMessages, place, reset) => {
  const { messages: messages2 } = getState3("phone.apps.messages");
  if (reset) {
    messages2[phoneNr] = pMessages;
  } else {
    switch (place) {
      case "append": {
        messages2[phoneNr] = [...messages2[phoneNr] || [], ...pMessages];
        break;
      }
      case "prepend": {
        messages2[phoneNr] = [...pMessages, ...messages2[phoneNr] || []];
        break;
      }
    }
  }
  genericAction("phone.apps.messages", { messages: messages2 });
};
const openConversation = async (phoneNr) => {
  var _a;
  const appState = getState3("phone.apps.messages");
  appState.currentNumber = phoneNr;
  const messages2 = (_a = await nuiAction("phone/messages/get", {
    target: phoneNr,
    offset: 0
  }, devData.messages)) != null ? _a : { [phoneNr]: [] };
  appState.messages[phoneNr] = messages2[phoneNr] || [];
  genericAction("phone.apps.messages", appState);
  changeApp("messages");
  nuiAction("phone/messages/set-read", { target: phoneNr });
};
const getState$1 = () => store.getState()["phone.apps.contacts"];
const getContact = (phone) => {
  const appState = getState$1();
  return appState.contacts.find((contact) => contact.phone === phone);
};
const fetchContacts = async () => {
  const appState = getState$1();
  appState.contacts = await nuiAction("phone/contacts/getContacts", {}, devData.contacts);
  genericAction("phone.apps.contacts", appState);
  return appState.contacts;
};
const addCallEntry = (name, number10, date2, incoming2) => {
  const calls = getState3("phone.apps.phone").calls;
  calls.push({
    name,
    number: number10,
    date: date2,
    incoming: incoming2
  });
  genericAction("phone.apps.phone", { calls });
};
const phoneCallNotiId = `__internal_phone_call_noti__`;
let incoming = false;
const startPhoneCall = (nr, isAnon = false) => {
  var _a, _b;
  nuiAction("phone/startCall", {
    phone: nr,
    isAnon
  });
  genericAction("phone", {
    callMeta: {
      number: nr,
      isAnon
    }
  });
  addNotification({
    id: phoneCallNotiId,
    title: (_b = (_a = getContact(nr)) == null ? void 0 : _a.label) != null ? _b : nr,
    description: "Calling...",
    icon: "phone",
    sticky: true,
    onDecline: () => {
      nuiAction("phone/dispatchEndCall");
    }
  });
};
const endPhoneCall = () => {
  var _a, _b;
  updateNotification(phoneCallNotiId, {
    description: "Call ended"
  });
  nuiAction("phone/endcall");
  removeNotification(phoneCallNotiId);
  const callMeta = getState3().callMeta;
  const contact = getContact(callMeta.number);
  if (!callMeta.isAnon) {
    addCallEntry((_a = contact == null ? void 0 : contact.label) != null ? _a : callMeta.number, (_b = contact == null ? void 0 : contact.phone) != null ? _b : "", Date.now(), incoming);
  }
  genericAction("phone", {
    callMeta: {}
  });
  incoming = false;
};
const setIncomingCall = (data) => {
  var _a;
  incoming = true;
  const contact = getContact(data.label);
  genericAction("phone", {
    callMeta: {
      number: data.label,
      isAnon: data.isAnon
    }
  });
  addNotification({
    id: phoneCallNotiId,
    title: (_a = contact == null ? void 0 : contact.label) != null ? _a : data.label,
    description: "Incoming call...",
    icon: "phone",
    keepOnAction: true,
    sticky: true,
    onAccept: () => {
      nuiAction("phone/acceptCall");
    },
    onDecline: () => {
      nuiAction("phone/declineCall");
    }
  });
};
const setActiveCall = () => {
  updateNotification(phoneCallNotiId, {
    description: "in call...",
    timer: 0,
    onAccept: void 0
  });
};
const styles$m = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column"
  }
});
var _jsxFileName$1L = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/contacts-app/components/modals.tsx";
var ModalHeader = /* @__PURE__ */ ((ModalHeader2) => {
  ModalHeader2["new"] = "Nieuw contact";
  ModalHeader2["edit"] = "Contact bewerken";
  return ModalHeader2;
})(ModalHeader || {});
var ModalAction = /* @__PURE__ */ ((ModalAction2) => {
  ModalAction2["new"] = "add";
  ModalAction2["edit"] = "update";
  return ModalAction2;
})(ModalAction || {});
const ContactModal = (props) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
  header: ModalHeader[props.type],
  elements: [{
    name: "label",
    defaultValue: props.contact.label,
    render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props2), {
      label: "Label",
      icon: "tag"
    }), void 0, false, {
      fileName: _jsxFileName$1L,
      lineNumber: 26,
      columnNumber: 26
    }, globalThis)
  }, {
    name: "phone",
    defaultValue: props.contact.phone,
    render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props2), {
      label: "TelefoonNr",
      icon: "mobile"
    }), void 0, false, {
      fileName: _jsxFileName$1L,
      lineNumber: 31,
      columnNumber: 26
    }, globalThis)
  }],
  onAccept: async (contact) => {
    await nuiAction(`phone/contacts/${ModalAction[props.type]}`, contact);
    showCheckmarkModal(() => fetchContacts());
  }
}, void 0, false, {
  fileName: _jsxFileName$1L,
  lineNumber: 20,
  columnNumber: 3
}, globalThis);
var _jsxFileName$1K = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/contacts-app/components/contacts.tsx";
const Contacts = (props) => {
  const classes = styles$m();
  const actions2 = [{
    title: "Bewerk",
    icon: "pencil",
    onClick: (c2) => {
      showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ContactModal, {
        contact: c2,
        type: "edit"
      }, void 0, false, {
        fileName: _jsxFileName$1K,
        lineNumber: 23,
        columnNumber: 23
      }, globalThis));
    }
  }, {
    title: "Verwijder",
    icon: "trash-alt",
    onClick: (c2) => {
      showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ConfirmationModal, {
        header: "Weet je zeker dat je dit contact wilt verwijderen?",
        onAccept: async () => {
          await nuiAction("phone/contacts/delete", {
            id: c2.id
          });
          showCheckmarkModal(() => fetchContacts());
        }
      }, void 0, false, {
        fileName: _jsxFileName$1K,
        lineNumber: 31,
        columnNumber: 11
      }, globalThis));
    }
  }, {
    title: "Bel",
    icon: "phone",
    onClick: (c2) => {
      startPhoneCall(c2.phone);
    }
  }, {
    title: "SMS",
    icon: "comment-alt",
    onClick: (c2) => {
      openConversation(c2.phone);
    }
  }, {
    title: "Kopieer",
    icon: "clipboard",
    onClick: (c2) => {
      copyToClipboard(c2.phone);
    }
  }];
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.root,
    children: props.contacts.map((c2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Paper, {
      title: c2.label,
      description: c2.phone,
      image: "user-circle",
      actions: actions2.map((a2) => __spreadProps(__spreadValues({}, a2), {
        data: c2
      }))
    }, c2.id, false, {
      fileName: _jsxFileName$1K,
      lineNumber: 69,
      columnNumber: 9
    }, globalThis))
  }, void 0, false, {
    fileName: _jsxFileName$1K,
    lineNumber: 67,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1J = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/contacts-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$n,
  mapDispatchToProps: mapDispatchToProps$n
} = compose(store$f, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$n extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      contacts: props.contacts
    };
  }
  componentDidUpdate(prevProps) {
    if (prevProps.contacts !== this.props.contacts) {
      this.setState({
        contacts: this.props.contacts
      });
    }
  }
  componentDidMount() {
    fetchContacts();
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      primaryActions: [{
        title: "Nieuw",
        icon: "plus",
        onClick: () => {
          showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ContactModal, {
            contact: {},
            type: "new"
          }, void 0, false, {
            fileName: _jsxFileName$1J,
            lineNumber: 43,
            columnNumber: 29
          }, this));
        }
      }],
      search: {
        list: this.props.contacts,
        filter: ["label", "phone"],
        onChange: (value) => {
          this.setState({
            contacts: value
          });
        }
      },
      emptyList: this.props.contacts.length === 0,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Contacts, {
        contacts: this.state.contacts
      }, void 0, false, {
        fileName: _jsxFileName$1J,
        lineNumber: 58,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1J,
      lineNumber: 37,
      columnNumber: 7
    }, this);
  }
}
var Container$n = connect(mapStateToProps$n, mapDispatchToProps$n)(Component$n);
var _jsxFileName$1I = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/contacts-app/events.tsx";
const events$a = {};
events$a.openNewContactModal = (data) => {
  showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ContactModal, {
    contact: data,
    type: "new"
  }, void 0, false, {
    fileName: _jsxFileName$1I,
    lineNumber: 10,
    columnNumber: 17
  }, globalThis));
};
var _jsxFileName$1H = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/contacts-app/_config.tsx";
const config$n = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "contacts",
  label: "Contacten",
  icon: {
    name: "address-book",
    color: "white",
    background: "#f5771d"
  },
  position: 2,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$n, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$1H,
    lineNumber: 20,
    columnNumber: 16
  }, globalThis),
  init: () => {
    fetchContacts();
  },
  events: events$a
});
var __glob_1_0$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$n
});
var Icon$1 = "./assets/crypto.7f9f1ae3.svg";
var _jsxFileName$1G = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/button.tsx";
const Button$1 = {};
Button$1.Primary = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$2, __spreadProps(__spreadValues({
    variant: "contained",
    size: "small"
  }, props), {
    color: "primary",
    children: props.children
  }), void 0, false, {
    fileName: _jsxFileName$1G,
    lineNumber: 8,
    columnNumber: 5
  }, globalThis);
};
Button$1.Secondary = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$2, __spreadProps(__spreadValues({
    variant: "contained",
    size: "small"
  }, props), {
    color: "secondary",
    children: props.children
  }), void 0, false, {
    fileName: _jsxFileName$1G,
    lineNumber: 16,
    columnNumber: 5
  }, globalThis);
};
const styles$l = makeStyles({
  list: {
    display: "flex",
    flexDirection: "column"
  },
  entry: {
    display: "flex",
    alignItems: "center",
    borderBottom: `.1vh solid #e0e0e0`,
    "& .icon": {
      width: "1.5rem",
      height: "1.75rem",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    "& .text": {
      marginLeft: ".5rem",
      fontSize: "1rem"
    }
  }
});
var _jsxFileName$1F = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/list.tsx";
const List$2 = (props) => {
  const classes = styles$l();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.list,
    children: props.items.map((e2) => {
      var _a;
      return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.entry,
        children: [e2.icon && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: "icon",
          children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Icon$2, {
            name: e2.icon,
            size: (_a = e2.size) != null ? _a : "1rem"
          }, void 0, false, {
            fileName: _jsxFileName$1F,
            lineNumber: 15,
            columnNumber: 15
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$1F,
          lineNumber: 14,
          columnNumber: 13
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: "text",
          children: e2.label
        }, void 0, false, {
          fileName: _jsxFileName$1F,
          lineNumber: 18,
          columnNumber: 11
        }, globalThis)]
      }, e2.label + e2.icon, true, {
        fileName: _jsxFileName$1F,
        lineNumber: 12,
        columnNumber: 9
      }, globalThis);
    })
  }, void 0, false, {
    fileName: _jsxFileName$1F,
    lineNumber: 10,
    columnNumber: 5
  }, globalThis);
};
const styles$k = makeStyles({
  list: {
    display: "flex",
    flexDirection: "column"
  }
});
var _jsxFileName$1E = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/crypto-app/components/modals.tsx";
const setDirty = () => {
  genericAction("phone.apps.crypto", {
    shouldRenew: true
  });
};
const ExchangeModal = ({
  coin
}) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
  elements: [{
    name: "target",
    render: (props) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Contact, __spreadProps(__spreadValues({}, props), {
      icon: "mobile"
    }), void 0, false, {
      fileName: _jsxFileName$1E,
      lineNumber: 19,
      columnNumber: 26
    }, globalThis)
  }, {
    name: "amount",
    render: (props) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Number, __spreadProps(__spreadValues({}, props), {
      min: 0,
      max: coin.wallet.amount,
      label: "Amount",
      icon: "coins"
    }), void 0, false, {
      fileName: _jsxFileName$1E,
      lineNumber: 23,
      columnNumber: 26
    }, globalThis)
  }],
  onAccept: async (vals) => {
    vals.amount = parseInt(vals.amount);
    if (vals.amount <= 0 || vals.amount > coin.wallet.amount || isNaN(vals.amount))
      return;
    await nuiAction("phone/crypto/transfer", __spreadProps(__spreadValues({}, vals), {
      coin: coin.crypto_name
    }));
    showCheckmarkModal(setDirty);
  }
}, void 0, false, {
  fileName: _jsxFileName$1E,
  lineNumber: 15,
  columnNumber: 3
}, globalThis);
const PurchaseModal = ({
  coin
}) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
  elements: [{
    name: "amount",
    render: (props) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Number, __spreadProps(__spreadValues({}, props), {
      min: 0,
      label: "Amount",
      icon: "coins"
    }), void 0, false, {
      fileName: _jsxFileName$1E,
      lineNumber: 40,
      columnNumber: 26
    }, globalThis)
  }],
  onAccept: async (vals) => {
    vals.amount = parseInt(vals.amount);
    if (vals.amount <= 0 || isNaN(vals.amount))
      return;
    await nuiAction("phone/crypto/purchase", __spreadProps(__spreadValues({}, vals), {
      coin: coin.crypto_name
    }));
    showCheckmarkModal(setDirty);
  }
}, void 0, false, {
  fileName: _jsxFileName$1E,
  lineNumber: 36,
  columnNumber: 3
}, globalThis);
var _jsxFileName$1D = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/crypto-app/components/crypto.tsx";
const Crypto = (props) => {
  const classes = styles$k();
  const getCoinInfo = (coin) => [{
    icon: "tag",
    label: coin.crypto_name
  }, {
    icon: "money-check-alt",
    label: String(coin.wallet.amount)
  }, {
    icon: "mi-assessment",
    label: `\u20AC${coin.value}`,
    size: "1.3rem"
  }];
  const showPurchaseModal = (e2, coin) => {
    e2.stopPropagation();
    showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(PurchaseModal, {
      coin
    }, void 0, false, {
      fileName: _jsxFileName$1D,
      lineNumber: 30,
      columnNumber: 19
    }, globalThis));
  };
  const showExchangeModal = (e2, coin) => {
    e2.stopPropagation();
    showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ExchangeModal, {
      coin
    }, void 0, false, {
      fileName: _jsxFileName$1D,
      lineNumber: 34,
      columnNumber: 19
    }, globalThis));
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.list,
    children: props.list.map((c2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Paper, {
      title: c2.crypto_name,
      description: c2.wallet.amount,
      image: c2.icon,
      extDescription: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(jsxDevRuntime.exports.Fragment, {
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(List$2, {
          items: getCoinInfo(c2)
        }, void 0, false, {
          fileName: _jsxFileName$1D,
          lineNumber: 46,
          columnNumber: 15
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: "btnWrapper",
          children: [c2.value !== 0 && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Primary, {
            size: "small",
            onClick: (e2) => showPurchaseModal(e2, c2),
            children: "PURCHASE"
          }, void 0, false, {
            fileName: _jsxFileName$1D,
            lineNumber: 49,
            columnNumber: 19
          }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Secondary, {
            size: "small",
            onClick: (e2) => showExchangeModal(e2, c2),
            children: "EXCHANGE"
          }, void 0, false, {
            fileName: _jsxFileName$1D,
            lineNumber: 53,
            columnNumber: 17
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$1D,
          lineNumber: 47,
          columnNumber: 15
        }, globalThis)]
      }, void 0, true)
    }, c2.crypto_name, false, {
      fileName: _jsxFileName$1D,
      lineNumber: 39,
      columnNumber: 9
    }, globalThis))
  }, void 0, false, {
    fileName: _jsxFileName$1D,
    lineNumber: 37,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1C = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/crypto-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$m,
  mapDispatchToProps: mapDispatchToProps$m
} = compose(store$e, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$m extends React.Component {
  async loadCoins() {
    this.props.updateState({
      list: []
    });
    const coins = await nuiAction("phone/crypto/get", {}, devData.crypto);
    this.props.updateState({
      list: coins
    });
  }
  componentDidMount() {
    this.loadCoins();
  }
  componentDidUpdate() {
    if (this.props.shouldRenew) {
      this.loadCoins();
      this.props.updateState({
        shouldRenew: false
      });
    }
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      emptyList: this.props.list.length === 0,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Crypto, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$1C,
        lineNumber: 43,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1C,
      lineNumber: 42,
      columnNumber: 7
    }, this);
  }
}
var Container$m = connect(mapStateToProps$m, mapDispatchToProps$m)(Component$m);
var _jsxFileName$1B = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/crypto-app/_config.tsx";
const config$m = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "crypto",
  label: "Crypto",
  icon: {
    name: Icon$1,
    lib: "svg",
    color: "white",
    background: "#282828",
    size: "2.5rem"
  },
  position: 10,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$m, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$1B,
    lineNumber: 21,
    columnNumber: 16
  }, globalThis)
});
var __glob_1_1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$m
});
var _jsxFileName$1A = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/example-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$l,
  mapDispatchToProps: mapDispatchToProps$l
} = compose(store$d, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$l extends React.Component {
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
        children: "Example app"
      }, void 0, false, {
        fileName: _jsxFileName$1A,
        lineNumber: 17,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1A,
      lineNumber: 16,
      columnNumber: 7
    }, this);
  }
}
var Container$l = connect(mapStateToProps$l, mapDispatchToProps$l)(Component$l);
const events$9 = {};
var _jsxFileName$1z = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/example-app/_config.tsx";
const config$l = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "example",
  label: "Voorbeeld",
  icon: {
    name: "house",
    color: "white",
    background: "black"
  },
  position: 1,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$l, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$1z,
    lineNumber: 19,
    columnNumber: 16
  }, globalThis),
  events: events$9,
  hidden: () => true
});
var __glob_1_2$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$l
});
var _jsxFileName$1y = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/gallery-app/components/gallery.tsx";
const Gallery = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
    children: props.list.map((i2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Paper, {
      image: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Icon$2, {
        name: i2.link,
        lib: "img"
      }, void 0, false, {
        fileName: _jsxFileName$1y,
        lineNumber: 18,
        columnNumber: 18
      }, globalThis),
      actions: [{
        icon: "trash",
        title: "Delete",
        onClick: () => {
          nuiAction("phone/gallery/delete", {
            id: i2.id
          });
          props.fetchImages();
        }
      }, {
        icon: "clipboard",
        title: "Copy",
        onClick: () => {
          copyToClipboard(i2.link);
        }
      }]
    }, i2.id, false, {
      fileName: _jsxFileName$1y,
      lineNumber: 17,
      columnNumber: 9
    }, globalThis))
  }, void 0, false, {
    fileName: _jsxFileName$1y,
    lineNumber: 15,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1x = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/gallery-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$k,
  mapDispatchToProps: mapDispatchToProps$k
} = compose(store$c, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$k extends React.Component {
  constructor() {
    super(...arguments);
    this.fetchImages = async () => {
      const imgs = await nuiAction("phone/gallery/get", {}, devData.images);
      this.props.updateState({
        list: imgs
      });
    };
  }
  componentDidMount() {
    this.fetchImages();
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Gallery, __spreadProps(__spreadValues({}, this.props), {
        fetchImages: this.fetchImages
      }), void 0, false, {
        fileName: _jsxFileName$1x,
        lineNumber: 31,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1x,
      lineNumber: 30,
      columnNumber: 7
    }, this);
  }
}
var Container$k = connect(mapStateToProps$k, mapDispatchToProps$k)(Component$k);
var _jsxFileName$1w = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/gallery-app/_config.tsx";
const config$k = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "gallery",
  label: "Gallerij",
  icon: {
    name: "images",
    color: "white",
    background: "#155312"
  },
  position: 12,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$k, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$1w,
    lineNumber: 18,
    columnNumber: 16
  }, globalThis)
});
var __glob_1_3$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$k
});
const styles$j = makeStyles({
  root: {
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-around",
    "& > *": {
      flex: "1 0 22%"
    }
  },
  app: {
    minWidth: "5.3vh",
    maxWidth: "5.3vh",
    minHeight: "5.3vh",
    maxHeight: "5.3vh",
    marginBottom: ".75vh",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    borderRadius: "1vh",
    boxShadow: "3px 3px 4px 0vh rgba(0, 0, 0, 0.2)"
  }
});
var _jsxFileName$1v = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/home-screen/components/homescreen.tsx";
const AppIcon = (props) => {
  var _a, _b, _c, _d, _e;
  const classes = styles$j();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tooltip$1, {
    placement: "top",
    arrow: true,
    title: props.label,
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.app,
      onClick: () => changeApp(props.name),
      style: {
        color: (_b = (_a = props.icon) == null ? void 0 : _a.color) != null ? _b : "white",
        background: `linear-gradient(transparent, ${(_c = props.icon.backgroundGradient) != null ? _c : "rgba(0, 0, 0, 0)"})`,
        backgroundColor: (_d = props.icon.background) != null ? _d : "#000"
      },
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Icon$2, {
        lib: props.icon.lib,
        name: props.icon.name,
        size: (_e = props.icon.size) != null ? _e : "1.5rem"
      }, void 0, false, {
        fileName: _jsxFileName$1v,
        lineNumber: 29,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$1v,
      lineNumber: 20,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$1v,
    lineNumber: 15,
    columnNumber: 5
  }, globalThis);
};
const EmptyIcon = () => {
  const classes = styles$j();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.app,
    style: {
      background: "none",
      boxShadow: "none"
    }
  }, void 0, false, {
    fileName: _jsxFileName$1v,
    lineNumber: 36,
    columnNumber: 10
  }, globalThis);
};
const HomeScreen = () => {
  const [apps, setApps] = react$1.exports.useState([]);
  const classes = styles$j();
  react$1.exports.useMemo(() => {
    const _apps = getPhoneApps().filter((c2) => !!c2.icon && (c2.hidden ? !c2.hidden() : true));
    const missingAmount = 4 - _apps.length % 4;
    missingAmount === 4 ? setApps(_apps) : setApps(_apps.concat(new Array(missingAmount).fill({
      empty: true
    })));
  }, []);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.root,
      children: apps.map((a2, i2) => a2.empty ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(EmptyIcon, {}, i2, false, {
        fileName: _jsxFileName$1v,
        lineNumber: 50,
        columnNumber: 40
      }, globalThis) : /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppIcon, __spreadValues({}, a2), a2.name, false, {
        fileName: _jsxFileName$1v,
        lineNumber: 50,
        columnNumber: 64
      }, globalThis))
    }, void 0, false, {
      fileName: _jsxFileName$1v,
      lineNumber: 49,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$1v,
    lineNumber: 48,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1u = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/home-screen/component.tsx";
const {
  mapStateToProps: mapStateToProps$j,
  mapDispatchToProps: mapDispatchToProps$j
} = compose(store$b, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$j extends React.Component {
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(HomeScreen, {}, void 0, false, {
      fileName: _jsxFileName$1u,
      lineNumber: 14,
      columnNumber: 12
    }, this);
  }
}
var Container$j = connect(mapStateToProps$j, mapDispatchToProps$j)(Component$j);
const events$8 = {};
events$8.addNotification = (noti) => {
  addNotification(noti);
};
events$8.removeNotification = (id) => {
  removeNotification(id);
};
events$8.updateNotification = (data) => {
  updateNotification(data.id, data.notification);
};
events$8.acceptNotification = () => {
  const notis = getState3("phone.notifications");
  const acceptableNoti = notis.list.find((n2) => n2.onAccept);
  if (!acceptableNoti)
    return;
  acceptNotification(acceptableNoti.id);
};
events$8.declineNotification = () => {
  const notis = getState3("phone.notifications");
  const acceptableNoti = notis.list.find((n2) => n2.onDecline);
  if (!acceptableNoti)
    return;
  acceptNotification(acceptableNoti.id);
};
var _jsxFileName$1t = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/home-screen/_config.tsx";
const config$j = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "home-screen",
  label: "Home Screen",
  background: "transparent",
  icon: {
    name: "home"
  },
  hidden: () => true,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$j, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$1t,
    lineNumber: 16,
    columnNumber: 16
  }, globalThis),
  events: events$8
});
var __glob_1_4$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$j
});
const styles$i = makeStyles({
  wrapper: {
    display: "flex",
    flexDirection: "column",
    marginTop: "5vh"
  },
  entry: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    marginBottom: ".5vh",
    "& > .info-icon": {
      textAlign: "center",
      minWidth: "5.3vh",
      marginRight: ".2vh",
      fontSize: "2.5rem"
    },
    "& > p": {
      fontSize: "1.2rem",
      fontWeight: "bold"
    }
  }
});
var _jsxFileName$1s = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/info-app/components/infoapp.tsx";
const InfoApp = (props) => {
  const classes = styles$i();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.wrapper,
    children: props.entries.map((e2) => {
      var _a, _b, _c;
      return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.entry,
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: "info-icon",
          children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
            className: `fas fa-${(_a = e2.icon) != null ? _a : "info"}`,
            style: {
              color: (_b = e2.color) != null ? _b : "white"
            }
          }, void 0, false, {
            fileName: _jsxFileName$1s,
            lineNumber: 13,
            columnNumber: 13
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$1s,
          lineNumber: 12,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
          variant: "body2",
          children: [(_c = e2.prefix) != null ? _c : "", e2.value]
        }, void 0, true, {
          fileName: _jsxFileName$1s,
          lineNumber: 15,
          columnNumber: 11
        }, globalThis)]
      }, e2.name, true, {
        fileName: _jsxFileName$1s,
        lineNumber: 11,
        columnNumber: 9
      }, globalThis);
    })
  }, void 0, false, {
    fileName: _jsxFileName$1s,
    lineNumber: 9,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1r = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/info-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$i,
  mapDispatchToProps: mapDispatchToProps$i
} = compose(store$a, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$i extends React.Component {
  async refreshValues() {
    const info = await nuiAction("phone/info/fetchInfo");
    const newEntries = getState3("phone.apps.info").entries.map((entry) => {
      if (info[entry.name]) {
        entry.value = info[entry.name];
      }
      return entry;
    });
    genericAction("phone.apps.info", {
      entries: newEntries
    });
  }
  componentDidMount() {
    this.refreshValues();
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      primaryActions: [{
        title: "Refresh",
        onClick: () => this.refreshValues(),
        icon: "sync-alt"
      }],
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(InfoApp, {
        entries: this.props.entries
      }, void 0, false, {
        fileName: _jsxFileName$1r,
        lineNumber: 45,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1r,
      lineNumber: 36,
      columnNumber: 7
    }, this);
  }
}
var Container$i = connect(mapStateToProps$i, mapDispatchToProps$i)(Component$i);
const events$7 = {};
events$7.registerInfoEntry = (data) => {
  const infoState = getState3("phone.apps.info");
  genericAction("phone.apps.info", {
    entries: [...infoState.entries, data.entry]
  });
};
var _jsxFileName$1q = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/info-app/_config.tsx";
const config$i = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "info",
  label: "Info",
  icon: {
    name: "info-circle",
    color: "white",
    background: "#67a4bd"
  },
  position: 1,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$i, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$1q,
    lineNumber: 19,
    columnNumber: 16
  }, globalThis),
  events: events$7
});
var __glob_1_5$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$i
});
var WeatherIcons = /* @__PURE__ */ ((WeatherIcons2) => {
  WeatherIcons2["EXTRASUNNY"] = "sun";
  WeatherIcons2["CLEAR"] = "sun";
  WeatherIcons2["CLEARING"] = "sun";
  WeatherIcons2["OVERCAST"] = "sun-cloud";
  WeatherIcons2["SMOG"] = "sun-cloud";
  WeatherIcons2["FOGGY"] = "fog";
  WeatherIcons2["CLOUDS"] = "cloud";
  WeatherIcons2["RAIN"] = "cloud-rain";
  WeatherIcons2["THUNDER"] = "thunderstorm";
  WeatherIcons2["SNOW"] = "snowflake";
  WeatherIcons2["BLIZZARD"] = "snowflakes";
  WeatherIcons2["SNOWLIGHT"] = "cloud-hail";
  WeatherIcons2["XMAS"] = "snowflakes";
  WeatherIcons2["HALLOWEEN"] = "cloud-hail-mixed";
  return WeatherIcons2;
})(WeatherIcons || {});
var JusticeNames = /* @__PURE__ */ ((JusticeNames2) => {
  JusticeNames2["judge"] = "Advocaten";
  JusticeNames2["lawyer"] = "Rechters";
  return JusticeNames2;
})(JusticeNames || {});
const styles$h = makeStyles({
  root: {
    display: "flex"
  },
  header: {
    fontSize: "1.2rem",
    fontWeight: 600
  },
  body: {
    display: "flex",
    flexDirection: "column"
  },
  entry: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    width: "100%",
    "& > .phone": {
      justifySelf: "end"
    }
  }
});
var _jsxFileName$1p = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/justice-app/components/justice.tsx";
const Justice = (props) => {
  const classes = styles$h();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    children: Object.keys(props.list).map((k) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.header,
        children: JusticeNames[k]
      }, void 0, false, {
        fileName: _jsxFileName$1p,
        lineNumber: 16,
        columnNumber: 11
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Divider, {}, void 0, false, {
        fileName: _jsxFileName$1p,
        lineNumber: 17,
        columnNumber: 11
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.body,
        children: props.list[k].map((e2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: classes.entry,
          children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Badge, {
              color: e2.available ? "success" : "error",
              sx: {
                marginRight: "1.5vh",
                marginLeft: "1.25vh"
              },
              badgeContent: " ",
              anchorOrigin: {
                vertical: "top",
                horizontal: "left"
              }
            }, void 0, false, {
              fileName: _jsxFileName$1p,
              lineNumber: 22,
              columnNumber: 19
            }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
              children: e2.name
            }, void 0, false, {
              fileName: _jsxFileName$1p,
              lineNumber: 31,
              columnNumber: 19
            }, globalThis)]
          }, void 0, true, {
            fileName: _jsxFileName$1p,
            lineNumber: 21,
            columnNumber: 17
          }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: "phone",
            children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tooltip$1, {
              title: "bel",
              placement: "left",
              onClick: () => startPhoneCall(e2.phone),
              children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(IconButton, {
                children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Icon$2, {
                  name: "phone",
                  size: ".9rem"
                }, void 0, false, {
                  fileName: _jsxFileName$1p,
                  lineNumber: 35,
                  columnNumber: 34
                }, globalThis)
              }, void 0, false, {
                fileName: _jsxFileName$1p,
                lineNumber: 35,
                columnNumber: 21
              }, globalThis)
            }, void 0, false, {
              fileName: _jsxFileName$1p,
              lineNumber: 34,
              columnNumber: 19
            }, globalThis)
          }, void 0, false, {
            fileName: _jsxFileName$1p,
            lineNumber: 33,
            columnNumber: 17
          }, globalThis)]
        }, e2.phone, true, {
          fileName: _jsxFileName$1p,
          lineNumber: 20,
          columnNumber: 15
        }, globalThis))
      }, void 0, false, {
        fileName: _jsxFileName$1p,
        lineNumber: 18,
        columnNumber: 11
      }, globalThis)]
    }, `phone-justice-${k}`, true, {
      fileName: _jsxFileName$1p,
      lineNumber: 15,
      columnNumber: 9
    }, globalThis))
  }, void 0, false, {
    fileName: _jsxFileName$1p,
    lineNumber: 13,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1o = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/justice-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$h,
  mapDispatchToProps: mapDispatchToProps$h
} = compose(store$9, {
  mapStateToProps: (s2) => ({
    character: s2.character
  }),
  mapDispatchToProps: {}
});
const whitelistedJobs = ["judge", "lawyer"];
class Component$h extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      available: false
    };
  }
  async fetchList() {
    const list = await nuiAction("phone/justice/get", {}, devData.justice);
    this.props.updateState({
      list
    });
    this.getAvailability();
  }
  getAvailability() {
    var _a, _b;
    let isAvail = false;
    if (Object.keys(this.props.list).includes(this.props.character.job)) {
      isAvail = (_b = (_a = this.props.list[this.props.character.job].find((p2) => p2.phone === this.props.character.phone)) == null ? void 0 : _a.available) != null ? _b : false;
    }
    this.setState({
      available: isAvail
    });
  }
  componentDidMount() {
    this.fetchList();
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      primaryActions: whitelistedJobs.includes(this.props.character.job) ? this.state.available === true ? [{
        title: "Zet onbeschikbaar",
        icon: "handshake-slash",
        onClick: async () => {
          await nuiAction("phone/justice/setAvailable", {
            available: false
          });
          await this.fetchList();
        }
      }] : [{
        title: "Zet beschikbaar",
        icon: "handshake",
        onClick: async () => {
          await nuiAction("phone/justice/setAvailable", {
            available: true
          });
          await this.fetchList();
        }
      }] : [],
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Justice, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$1o,
        lineNumber: 84,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1o,
      lineNumber: 53,
      columnNumber: 7
    }, this);
  }
}
var Container$h = connect(mapStateToProps$h, mapDispatchToProps$h)(Component$h);
var _jsxFileName$1n = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/justice-app/_config.tsx";
const config$h = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "justice",
  label: "Justitie",
  icon: {
    name: "balance-scale-right",
    lib: "far fa-",
    color: "#dc2222",
    background: "#282828",
    size: "1.4rem"
  },
  position: 13,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$h, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$1n,
    lineNumber: 20,
    columnNumber: 16
  }, globalThis)
});
var __glob_1_6$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$h
});
const styles$g = makeStyles({
  list: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center"
  },
  entry: {
    width: "100%",
    backgroundColor: baseStyle.primary.darker,
    borderBottom: `.2vh solid ${baseStyle.gray.light}`,
    borderRadius: ".5vh",
    boxShadow: "0px 3px 5px 0px black"
  },
  textWrapper: {
    fontSize: ".9rem",
    margin: "1vh .9vh",
    display: "flex",
    flexDirection: "column",
    borderBottom: `.1vh solid ${baseStyle.gray.light}`,
    "& > *": {
      marginBottom: "1vh"
    }
  },
  body: {
    fontSize: ".8rem",
    "&.small": {
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis"
    }
  },
  date: {
    textAlign: "center",
    fontSize: ".8rem",
    marginBottom: "1vh"
  }
});
var _jsxFileName$1m = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/mail-app/components/mail.tsx";
const MailEntry = ({
  mail
}) => {
  const [isExtended, setIsExtended] = react$1.exports.useState(false);
  const classes = styles$g();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.entry,
    onClick: () => setIsExtended(!isExtended),
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.textWrapper,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        children: ["Van: ", mail.sender]
      }, void 0, true, {
        fileName: _jsxFileName$1m,
        lineNumber: 15,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        children: ["Onderwerp: ", mail.subject]
      }, void 0, true, {
        fileName: _jsxFileName$1m,
        lineNumber: 16,
        columnNumber: 9
      }, globalThis), isExtended ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.body,
        dangerouslySetInnerHTML: {
          __html: sanitizeText(mail.message)
        }
      }, void 0, false, {
        fileName: _jsxFileName$1m,
        lineNumber: 18,
        columnNumber: 11
      }, globalThis) : /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: [classes.body, "small"].join(" "),
        children: getFirstLine(mail.message)
      }, void 0, false, {
        fileName: _jsxFileName$1m,
        lineNumber: 20,
        columnNumber: 11
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$1m,
      lineNumber: 14,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.date,
      children: formatRelativeTime(mail.date)
    }, void 0, false, {
      fileName: _jsxFileName$1m,
      lineNumber: 23,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$1m,
    lineNumber: 13,
    columnNumber: 5
  }, globalThis);
};
const Mail = (props) => {
  const classes = styles$g();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.list,
      children: props.mails.map((mail) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(MailEntry, {
        mail
      }, mail.id, false, {
        fileName: _jsxFileName$1m,
        lineNumber: 34,
        columnNumber: 11
      }, globalThis))
    }, void 0, false, {
      fileName: _jsxFileName$1m,
      lineNumber: 32,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$1m,
    lineNumber: 31,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1l = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/mail-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$g,
  mapDispatchToProps: mapDispatchToProps$g
} = compose(store$8, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$g extends React.Component {
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      emptyList: this.props.mails.length === 0,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Mail, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$1l,
        lineNumber: 18,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1l,
      lineNumber: 17,
      columnNumber: 7
    }, this);
  }
}
var Container$g = connect(mapStateToProps$g, mapDispatchToProps$g)(Component$g);
const events$6 = {};
let mailId = 0;
events$6.newMail = (mail) => {
  var _a;
  const mailState = getState3("phone.apps.mail");
  mail.id = `mail-${mailId++}`;
  mail.date = Date.now();
  mailState.mails.push(mail);
  genericAction("phone.apps.mail", mailState);
  addNotification({
    id: `mail_${mail.id}`,
    icon: "mail",
    title: `Email`,
    description: (_a = mail.subject) != null ? _a : "New email",
    app: "mail"
  });
};
var _jsxFileName$1k = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/mail-app/_config.tsx";
const config$g = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "mail",
  label: "Mails",
  icon: {
    name: "mail-bulk",
    color: "white",
    background: "#59b3a9",
    backgroundGradient: "#82DED5"
  },
  position: 6,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$g, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$1k,
    lineNumber: 20,
    columnNumber: 16
  }, globalThis),
  events: events$6
});
var __glob_1_7$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$g
});
var Send = {};
var _interopRequireDefault$2 = interopRequireDefault.exports;
Object.defineProperty(Send, "__esModule", {
  value: true
});
var default_1$2 = Send.default = void 0;
var _createSvgIcon$2 = _interopRequireDefault$2(createSvgIcon);
var _jsxRuntime$2 = require$$2;
var _default$3 = (0, _createSvgIcon$2.default)(/* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
  d: "M2.01 21 23 12 2.01 3 2 10l15 2-15 2z"
}), "Send");
default_1$2 = Send.default = _default$3;
const styles$f = makeStyles({
  wrapper: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    "& > span": {
      width: "100%"
    }
  },
  imageList: {
    display: "flex",
    flexDirection: "column",
    width: "100%"
  }
});
const styles$e = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column"
  },
  hideSpan: {
    textDecoration: "underline",
    cursor: "pointer",
    textAlign: "left"
  },
  wrapper: {
    border: "1px solid",
    height: "18vh",
    "& > div": {
      height: "100%",
      width: "100%",
      display: "flex",
      justifyContent: "center"
    },
    "& img": {
      height: "100%",
      width: "100%",
      objectFit: "contain"
    }
  },
  spinner: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    color: "black"
  },
  hidden: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    height: "inherit",
    cursor: "pointer",
    "& > i": {
      fontSize: "2rem",
      marginBottom: "1vh"
    }
  }
});
var _jsxFileName$1j = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/imagecontainer.tsx";
const Imagecontainer = (props) => {
  const [isClicked, setIsClicked] = react$1.exports.useState(false);
  const classes = styles$e();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.root,
    children: [isClicked && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
      className: classes.hideSpan,
      onClick: () => setIsClicked(false),
      children: "Click here to hide the image"
    }, void 0, false, {
      fileName: _jsxFileName$1j,
      lineNumber: 16,
      columnNumber: 9
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.wrapper,
      children: props.loading ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.spinner,
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(CircularProgress, {
          color: "inherit"
        }, void 0, false, {
          fileName: _jsxFileName$1j,
          lineNumber: 23,
          columnNumber: 13
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$1j,
        lineNumber: 22,
        columnNumber: 11
      }, globalThis) : isClicked ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        onClick: () => copyToClipboard(props.url),
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("img", {
          src: props.url,
          alt: "image"
        }, void 0, false, {
          fileName: _jsxFileName$1j,
          lineNumber: 27,
          columnNumber: 13
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$1j,
        lineNumber: 26,
        columnNumber: 11
      }, globalThis) : /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.hidden,
        onClick: () => setIsClicked(true),
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: "fas fa-eye-slash"
        }, void 0, false, {
          fileName: _jsxFileName$1j,
          lineNumber: 31,
          columnNumber: 13
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("p", {
          children: "Click to view this image"
        }, void 0, false, {
          fileName: _jsxFileName$1j,
          lineNumber: 32,
          columnNumber: 13
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$1j,
        lineNumber: 30,
        columnNumber: 11
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$1j,
      lineNumber: 20,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$1j,
    lineNumber: 14,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1i = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/textwrapper.tsx";
const Textwrapper = (props) => {
  const classes = styles$f();
  const [images, setImages] = react$1.exports.useState([]);
  const strippedText = react$1.exports.useMemo(() => {
    let {
      text: text3,
      links
    } = extractLinks(props.children);
    new Promise((res) => {
      let _images = [];
      links.forEach(async (l2) => {
        _images.push({
          isLoading: true,
          src: l2
        });
      });
      setImages(_images);
      links.forEach(async (l2) => {
        const valid4 = await checkImageValidity(l2);
        if (valid4) {
          const idx = _images.findIndex((p2) => p2.src === l2);
          if (idx < 0) {
            return;
          }
          _images[idx].isLoading = false;
          setImages(_images);
          return;
        }
        _images = _images.filter((p2) => p2.src !== l2);
        const txtIdx = String(props.children).indexOf(l2);
        if (txtIdx > -1) {
          text3 = text3.slice(0, txtIdx) + l2 + text3.slice(txtIdx);
        }
        setImages(_images);
      });
      res();
    });
    return text3;
  }, [props.children]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.wrapper,
    style: images.length > 0 ? {
      minWidth: "21vh"
    } : {},
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
      children: strippedText
    }, void 0, false, {
      fileName: _jsxFileName$1i,
      lineNumber: 58,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.imageList,
      children: images.map((img, idx) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Imagecontainer, {
        url: img.src,
        loading: img.isLoading
      }, idx, false, {
        fileName: _jsxFileName$1i,
        lineNumber: 61,
        columnNumber: 11
      }, globalThis))
    }, void 0, false, {
      fileName: _jsxFileName$1i,
      lineNumber: 59,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$1i,
    lineNumber: 57,
    columnNumber: 5
  }, globalThis);
};
const styles$d = makeStyles({
  wrapper: {
    height: "100%",
    width: "100%"
  },
  list: {
    display: "flex",
    flexDirection: "column",
    height: "100%",
    width: "100%"
  },
  conversationWrapper: {
    display: "flex",
    flexDirection: "column",
    height: "100%",
    width: "100%",
    "& button": {
      alignSelf: "center"
    }
  },
  messageWrapper: {
    display: "flex",
    flexDirection: "column",
    overflowY: "auto",
    flex: "1"
  },
  message: {
    display: "flex",
    flexDirection: "column",
    maxWidth: "75%",
    margin: ".5vh 0",
    fontSize: ".9rem",
    "& > .text": {
      width: "fit-content",
      padding: "1vh .9vh",
      borderRadius: "2vh"
    },
    "& > .time": {
      color: baseStyle.gray.light,
      marginTop: ".1vh",
      marginLeft: ".9vh"
    }
  },
  receiver: {
    alignSelf: "flex-start",
    "& > .text": {
      color: "white",
      backgroundColor: baseStyle.gray.normal,
      alignSelf: "flex-start"
    },
    "& > .time": {
      textAlign: "start"
    }
  },
  sender: {
    alignSelf: "flex-end",
    "& > .text": {
      color: "black",
      backgroundColor: "#6aaee0",
      alignSelf: "flex-end"
    },
    "& > .time": {
      alignSelf: "flex-end"
    }
  },
  inputWrapper: {
    width: "100%",
    display: "flex",
    flexDirection: "row"
  }
});
var _jsxFileName$1h = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/message-app/components/conversation.tsx";
const Conversation = (props) => {
  const [messages2, setMessages] = react$1.exports.useState([]);
  const [canLoadMore, setCanLoadMore] = react$1.exports.useState(true);
  const [message, setMessage] = react$1.exports.useState("");
  const classes = styles$d();
  const messageListRef = react$1.exports.useRef(null);
  const showList = () => {
    props.updateState({
      currentNumber: null
    });
  };
  const loadMore = async () => {
    if (!props.currentNumber)
      return;
    const newMes = await nuiAction("phone/messages/get", {
      target: props.currentNumber,
      offset: messages2.length
    });
    if (typeof newMes !== "object" || Array.isArray(newMes) || newMes[props.currentNumber].length === 0) {
      console.log("could not load more messages");
      setCanLoadMore(false);
      return;
    }
    addMessage(props.currentNumber, newMes[props.currentNumber], "prepend");
  };
  const sendMessage = () => {
    nuiAction("phone/messages/send", {
      msg: message,
      target: props.currentNumber,
      date: Date.now()
    });
    setMessage("");
  };
  react$1.exports.useEffect(() => {
    setTimeout(() => {
      if (!messageListRef.current)
        return;
      messageListRef.current.scrollTop = messageListRef.current.scrollHeight;
    }, 10);
  }, [props.messages]);
  react$1.exports.useEffect(() => {
    if (!props.currentNumber) {
      setMessages([]);
      setCanLoadMore(true);
      return;
    }
    if (!props.messages[props.currentNumber]) {
      setCanLoadMore(false);
      return;
    }
    if (props.messages[props.currentNumber] === messages2) {
      return;
    }
    if (props.messages[props.currentNumber].length - messages2.length === 1) {
      setTimeout(() => {
        if (!messageListRef.current)
          return;
        messageListRef.current.scrollTop = messageListRef.current.scrollHeight;
      }, 10);
    }
    setMessages(props.messages[props.currentNumber]);
  }, [props.messages, props.currentNumber]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
    onClickBack: showList,
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Spring, {
      from: {
        translateX: "100%",
        height: "100%"
      },
      to: {
        translateX: "0%",
        height: "100%"
      },
      children: (styles2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(animated.div, {
        style: styles2,
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: classes.conversationWrapper,
          children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: classes.messageWrapper,
            ref: messageListRef,
            children: [canLoadMore && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Primary, {
              onClick: loadMore,
              children: "Laad meer"
            }, void 0, false, {
              fileName: _jsxFileName$1h,
              lineNumber: 97,
              columnNumber: 33
            }, globalThis), messages2.map((mes) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
              className: [classes.message, mes.isreceiver ? classes.receiver : classes.sender].join(" "),
              children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
                className: "text",
                children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Textwrapper, {
                  children: mes.message
                }, void 0, false, {
                  fileName: _jsxFileName$1h,
                  lineNumber: 104,
                  columnNumber: 23
                }, globalThis)
              }, void 0, false, {
                fileName: _jsxFileName$1h,
                lineNumber: 103,
                columnNumber: 21
              }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
                className: "time",
                children: formatRelativeTime(mes.date)
              }, void 0, false, {
                fileName: _jsxFileName$1h,
                lineNumber: 106,
                columnNumber: 21
              }, globalThis)]
            }, mes.id, true, {
              fileName: _jsxFileName$1h,
              lineNumber: 99,
              columnNumber: 19
            }, globalThis))]
          }, void 0, true, {
            fileName: _jsxFileName$1h,
            lineNumber: 96,
            columnNumber: 15
          }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: classes.inputWrapper,
            children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, {
              onChange: (val) => setMessage(val),
              value: message,
              label: "Bericht",
              fullWidth: true
            }, void 0, false, {
              fileName: _jsxFileName$1h,
              lineNumber: 111,
              columnNumber: 17
            }, globalThis), message.trim() !== "" && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(IconButton, {
              onClick: sendMessage,
              color: "primary",
              children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(default_1$2, {}, void 0, false, {
                fileName: _jsxFileName$1h,
                lineNumber: 114,
                columnNumber: 21
              }, globalThis)
            }, void 0, false, {
              fileName: _jsxFileName$1h,
              lineNumber: 113,
              columnNumber: 19
            }, globalThis)]
          }, void 0, true, {
            fileName: _jsxFileName$1h,
            lineNumber: 110,
            columnNumber: 15
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$1h,
          lineNumber: 95,
          columnNumber: 13
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$1h,
        lineNumber: 94,
        columnNumber: 11
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$1h,
      lineNumber: 83,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$1h,
    lineNumber: 82,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1g = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/message-app/components/modals.tsx";
const NewConversationModal = () => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
  header: "Nieuw gesprek",
  elements: [{
    name: "number",
    render: (props) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.PhoneNumber, __spreadProps(__spreadValues({}, props), {
      label: "TelefoonNr",
      icon: "mobile"
    }), void 0, false, {
      fileName: _jsxFileName$1g,
      lineNumber: 14,
      columnNumber: 26
    }, globalThis)
  }],
  onAccept: ({
    number: number10
  }) => {
    hideFormModal();
    openConversation(number10);
  }
}, void 0, false, {
  fileName: _jsxFileName$1g,
  lineNumber: 9,
  columnNumber: 3
}, globalThis);
var _jsxFileName$1f = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/message-app/components/list.tsx";
const List$1 = (props) => {
  const classes = styles$d();
  const [list, setList] = react$1.exports.useState([]);
  const [filteredList, setFilteredList] = react$1.exports.useState([]);
  const fetchMessages = async () => {
    const messages2 = await nuiAction("phone/messages/get", {}, devData.messages);
    Object.entries(messages2).sort(([_2, c1V], [__, c2V]) => {
      var _a, _b, _c, _d;
      return ((_b = (_a = c1V.at(-1)) == null ? void 0 : _a.date) != null ? _b : 0) - ((_d = (_c = c2V.at(-1)) == null ? void 0 : _c.date) != null ? _d : 0);
    }).forEach((KeyValuePair) => {
      messages2[KeyValuePair[0]] = KeyValuePair[1];
    });
    props.updateState({
      messages: messages2
    });
  };
  react$1.exports.useEffect(() => {
    fetchMessages();
  }, []);
  react$1.exports.useEffect(() => {
    const newList = [];
    Object.entries(props.list).forEach(([nr, value]) => {
      var _a;
      const contact = getContact(nr);
      newList.push({
        nr,
        label: (_a = contact == null ? void 0 : contact.label) != null ? _a : nr,
        messages: value,
        hasUnread: (value != null ? value : []).some((m2) => !m2.isread)
      });
    });
    setList(newList);
    setFilteredList(newList);
  }, [props.list]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
    primaryActions: [{
      title: "Nieuw bericht",
      onClick: () => {
        showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NewConversationModal, {}, void 0, false, {
          fileName: _jsxFileName$1f,
          lineNumber: 71,
          columnNumber: 27
        }, globalThis));
      },
      icon: "comment"
    }],
    search: {
      list,
      filter: ["nr", "label"],
      onChange: (value) => {
        setFilteredList(value);
      }
    },
    emptyList: Object.keys(props.list).length === 0,
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.list,
      children: filteredList.map((e2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Paper, {
        title: e2.label,
        description: e2.messages[e2.messages.length - 1].message,
        image: "comments",
        onClick: () => openConversation(e2.nr),
        notification: e2.hasUnread
      }, e2.nr, false, {
        fileName: _jsxFileName$1f,
        lineNumber: 87,
        columnNumber: 11
      }, globalThis))
    }, void 0, false, {
      fileName: _jsxFileName$1f,
      lineNumber: 85,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$1f,
    lineNumber: 66,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$1e = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/message-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$f,
  mapDispatchToProps: mapDispatchToProps$f
} = compose(store$7, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$f extends React.Component {
  componentWillUnmount() {
    this.props.updateState({
      currentNumber: null
    });
  }
  render() {
    var _a;
    return this.props.currentNumber === null ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(List$1, {
      list: (_a = this.props.messages) != null ? _a : [],
      updateState: this.props.updateState
    }, void 0, false, {
      fileName: _jsxFileName$1e,
      lineNumber: 22,
      columnNumber: 7
    }, this) : /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Conversation, __spreadValues({}, this.props), void 0, false, {
      fileName: _jsxFileName$1e,
      lineNumber: 24,
      columnNumber: 7
    }, this);
  }
}
var Container$f = connect(mapStateToProps$f, mapDispatchToProps$f)(Component$f);
let msgId = 1;
const events$5 = {};
events$5.addNew = (data) => {
  var _a, _b, _c;
  addMessage(data.otherPhone, [data.message], "append");
  if (data.message.isreceiver) {
    addNotification({
      id: `msg-${msgId++}`,
      title: (_c = (_b = getContact((_a = data.otherPhone) != null ? _a : "")) == null ? void 0 : _b.label) != null ? _c : data.otherPhone,
      description: data.message.message,
      icon: "messages",
      app: "messages"
    });
  }
};
var _jsxFileName$1d = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/message-app/_config.tsx";
const config$f = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "messages",
  label: "Berichten",
  icon: {
    name: "comments-alt",
    color: "white",
    background: "#2eafdb"
  },
  position: 3,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$f, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$1d,
    lineNumber: 19,
    columnNumber: 16
  }, globalThis),
  events: events$5
});
var __glob_1_8$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$f
});
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err2) {
    _d = true;
    _e = err2;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray$3(arr, i2) || _nonIterableRest();
}
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (!it) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray$3(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return {
        s: F2,
        n: function n2() {
          if (i2 >= o2.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o2[i2++]
          };
        },
        e: function e2(_e) {
          throw _e;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err2;
  return {
    s: function s2() {
      it = it.call(o2);
    },
    n: function n2() {
      var step2 = it.next();
      normalCompletion = step2.done;
      return step2;
    },
    e: function e2(_e2) {
      didErr = true;
      err2 = _e2;
    },
    f: function f2() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err2;
      }
    }
  };
}
var SELECTED_NODE_CLASS_NAME = "ProseMirror-selectednode";
var LEAF_NODE_REPLACING_CHARACTER = "\uFFFC";
var NULL_CHARACTER = "\0";
var STATE_OVERRIDE = "__state_override__";
var BaseExtensionTag = {
  LastNodeCompatible: "lastNodeCompatible",
  FormattingMark: "formattingMark",
  FormattingNode: "formattingNode",
  NodeCursor: "nodeCursor",
  FontStyle: "fontStyle",
  Link: "link",
  Color: "color",
  Alignment: "alignment",
  Indentation: "indentation",
  Behavior: "behavior",
  Code: "code",
  InlineNode: "inline",
  ListContainerNode: "listContainer",
  ListItemNode: "listItemNode",
  Block: "block",
  BlockNode: "block",
  TextBlock: "textBlock",
  ExcludeInputRules: "excludeFromInputRules",
  PreventExits: "preventsExits",
  Media: "media"
};
var ExtensionTag = BaseExtensionTag;
var __INTERNAL_REMIRROR_IDENTIFIER_KEY__ = Symbol.for("__remirror__");
var RemirrorIdentifier;
(function(RemirrorIdentifier2) {
  RemirrorIdentifier2["PlainExtension"] = "RemirrorPlainExtension";
  RemirrorIdentifier2["NodeExtension"] = "RemirrorNodeExtension";
  RemirrorIdentifier2["MarkExtension"] = "RemirrorMarkExtension";
  RemirrorIdentifier2["PlainExtensionConstructor"] = "RemirrorPlainExtensionConstructor";
  RemirrorIdentifier2["NodeExtensionConstructor"] = "RemirrorNodeExtensionConstructor";
  RemirrorIdentifier2["MarkExtensionConstructor"] = "RemirrorMarkExtensionConstructor";
  RemirrorIdentifier2["Manager"] = "RemirrorManager";
  RemirrorIdentifier2["Preset"] = "RemirrorPreset";
  RemirrorIdentifier2["PresetConstructor"] = "RemirrorPresetConstructor";
})(RemirrorIdentifier || (RemirrorIdentifier = {}));
var ExtensionPriority;
(function(ExtensionPriority2) {
  ExtensionPriority2[ExtensionPriority2["Critical"] = 1e6] = "Critical";
  ExtensionPriority2[ExtensionPriority2["Highest"] = 1e5] = "Highest";
  ExtensionPriority2[ExtensionPriority2["High"] = 1e4] = "High";
  ExtensionPriority2[ExtensionPriority2["Medium"] = 1e3] = "Medium";
  ExtensionPriority2[ExtensionPriority2["Default"] = 100] = "Default";
  ExtensionPriority2[ExtensionPriority2["Low"] = 10] = "Low";
  ExtensionPriority2[ExtensionPriority2["Lowest"] = 0] = "Lowest";
})(ExtensionPriority || (ExtensionPriority = {}));
var ManagerPhase;
(function(ManagerPhase2) {
  ManagerPhase2[ManagerPhase2["None"] = 0] = "None";
  ManagerPhase2[ManagerPhase2["Create"] = 1] = "Create";
  ManagerPhase2[ManagerPhase2["EditorView"] = 2] = "EditorView";
  ManagerPhase2[ManagerPhase2["Runtime"] = 3] = "Runtime";
  ManagerPhase2[ManagerPhase2["Destroy"] = 4] = "Destroy";
})(ManagerPhase || (ManagerPhase = {}));
var NamedShortcut;
(function(NamedShortcut2) {
  NamedShortcut2["Undo"] = "_|undo|_";
  NamedShortcut2["Redo"] = "_|redo|_";
  NamedShortcut2["Bold"] = "_|bold|_";
  NamedShortcut2["Italic"] = "_|italic|_";
  NamedShortcut2["Underline"] = "_|underline|_";
  NamedShortcut2["Strike"] = "_|strike|_";
  NamedShortcut2["Code"] = "_|code|_";
  NamedShortcut2["Paragraph"] = "_|paragraph|_";
  NamedShortcut2["H1"] = "_|h1|_";
  NamedShortcut2["H2"] = "_|h2|_";
  NamedShortcut2["H3"] = "_|h3|_";
  NamedShortcut2["H4"] = "_|h4|_";
  NamedShortcut2["H5"] = "_|h5|_";
  NamedShortcut2["H6"] = "_|h6|_";
  NamedShortcut2["TaskList"] = "_|task|_";
  NamedShortcut2["BulletList"] = "_|bullet|_";
  NamedShortcut2["OrderedList"] = "_|number|_";
  NamedShortcut2["Quote"] = "_|quote|_";
  NamedShortcut2["Divider"] = "_|divider|_";
  NamedShortcut2["Codeblock"] = "_|codeblock|_";
  NamedShortcut2["ClearFormatting"] = "_|clear|_";
  NamedShortcut2["Superscript"] = "_|sup|_";
  NamedShortcut2["Subscript"] = "_|sub|_";
  NamedShortcut2["LeftAlignment"] = "_|left-align|_";
  NamedShortcut2["CenterAlignment"] = "_|center-align|_";
  NamedShortcut2["RightAlignment"] = "_|right-align|_";
  NamedShortcut2["JustifyAlignment"] = "_|justify-align|_";
  NamedShortcut2["InsertLink"] = "_|link|_";
  NamedShortcut2["Find"] = "_|find|_";
  NamedShortcut2["FindBackwards"] = "_|find-backwards|_";
  NamedShortcut2["FindReplace"] = "_|find-replace|_";
  NamedShortcut2["AddFootnote"] = "_|footnote|_";
  NamedShortcut2["AddComment"] = "_|comment|_";
  NamedShortcut2["ContextMenu"] = "_|context-menu|_";
  NamedShortcut2["IncreaseFontSize"] = "_|inc-font-size|_";
  NamedShortcut2["DecreaseFontSize"] = "_|dec-font-size|_";
  NamedShortcut2["IncreaseIndent"] = "_|indent|_";
  NamedShortcut2["DecreaseIndent"] = "_|dedent|_";
  NamedShortcut2["Shortcuts"] = "_|shortcuts|_";
  NamedShortcut2["Copy"] = "_|copy|_";
  NamedShortcut2["Cut"] = "_|cut|_";
  NamedShortcut2["Paste"] = "_|paste|_";
  NamedShortcut2["PastePlain"] = "_|paste-plain|_";
  NamedShortcut2["SelectAll"] = "_|select-all|_";
  NamedShortcut2["Format"] = "_|format|_";
})(NamedShortcut || (NamedShortcut = {}));
var ErrorConstant;
(function(ErrorConstant2) {
  ErrorConstant2["PROD"] = "RMR0000";
  ErrorConstant2["UNKNOWN"] = "RMR0001";
  ErrorConstant2["INVALID_COMMAND_ARGUMENTS"] = "RMR0002";
  ErrorConstant2["CUSTOM"] = "RMR0003";
  ErrorConstant2["CORE_HELPERS"] = "RMR0004";
  ErrorConstant2["MUTATION"] = "RMR0005";
  ErrorConstant2["INTERNAL"] = "RMR0006";
  ErrorConstant2["MISSING_REQUIRED_EXTENSION"] = "RMR0007";
  ErrorConstant2["MANAGER_PHASE_ERROR"] = "RMR0008";
  ErrorConstant2["INVALID_GET_EXTENSION"] = "RMR0010";
  ErrorConstant2["INVALID_MANAGER_ARGUMENTS"] = "RMR0011";
  ErrorConstant2["SCHEMA"] = "RMR0012";
  ErrorConstant2["HELPERS_CALLED_IN_OUTER_SCOPE"] = "RMR0013";
  ErrorConstant2["INVALID_MANAGER_EXTENSION"] = "RMR0014";
  ErrorConstant2["DUPLICATE_COMMAND_NAMES"] = "RMR0016";
  ErrorConstant2["DUPLICATE_HELPER_NAMES"] = "RMR0017";
  ErrorConstant2["NON_CHAINABLE_COMMAND"] = "RMR0018";
  ErrorConstant2["INVALID_EXTENSION"] = "RMR0019";
  ErrorConstant2["INVALID_CONTENT"] = "RMR0021";
  ErrorConstant2["INVALID_NAME"] = "RMR0050";
  ErrorConstant2["EXTENSION"] = "RMR0100";
  ErrorConstant2["EXTENSION_SPEC"] = "RMR0101";
  ErrorConstant2["EXTENSION_EXTRA_ATTRIBUTES"] = "RMR0102";
  ErrorConstant2["INVALID_SET_EXTENSION_OPTIONS"] = "RMR0103";
  ErrorConstant2["REACT_PROVIDER_CONTEXT"] = "RMR0200";
  ErrorConstant2["REACT_GET_ROOT_PROPS"] = "RMR0201";
  ErrorConstant2["REACT_EDITOR_VIEW"] = "RMR0202";
  ErrorConstant2["REACT_CONTROLLED"] = "RMR0203";
  ErrorConstant2["REACT_NODE_VIEW"] = "RMR0204";
  ErrorConstant2["REACT_GET_CONTEXT"] = "RMR0205";
  ErrorConstant2["REACT_COMPONENTS"] = "RMR0206";
  ErrorConstant2["REACT_HOOKS"] = "RMR0207";
  ErrorConstant2["I18N_CONTEXT"] = "RMR0300";
})(ErrorConstant || (ErrorConstant = {}));
var makeError = { exports: {} };
(function(module, exports) {
  var construct = typeof Reflect !== "undefined" ? Reflect.construct : void 0;
  var defineProperty = Object.defineProperty;
  var captureStackTrace = Error.captureStackTrace;
  if (captureStackTrace === void 0) {
    captureStackTrace = function captureStackTrace2(error) {
      var container = new Error();
      defineProperty(error, "stack", {
        configurable: true,
        get: function getStack() {
          var stack = container.stack;
          defineProperty(this, "stack", {
            configurable: true,
            value: stack,
            writable: true
          });
          return stack;
        },
        set: function setStack(stack) {
          defineProperty(error, "stack", {
            configurable: true,
            value: stack,
            writable: true
          });
        }
      });
    };
  }
  function BaseError(message) {
    if (message !== void 0) {
      defineProperty(this, "message", {
        configurable: true,
        value: message,
        writable: true
      });
    }
    var cname = this.constructor.name;
    if (cname !== void 0 && cname !== this.name) {
      defineProperty(this, "name", {
        configurable: true,
        value: cname,
        writable: true
      });
    }
    captureStackTrace(this, this.constructor);
  }
  BaseError.prototype = Object.create(Error.prototype, {
    constructor: {
      configurable: true,
      value: BaseError,
      writable: true
    }
  });
  var setFunctionName = function() {
    function setFunctionName2(fn2, name) {
      return defineProperty(fn2, "name", {
        configurable: true,
        value: name
      });
    }
    try {
      var f2 = function() {
      };
      setFunctionName2(f2, "foo");
      if (f2.name === "foo") {
        return setFunctionName2;
      }
    } catch (_2) {
    }
  }();
  function makeError2(constructor, super_) {
    if (super_ == null || super_ === Error) {
      super_ = BaseError;
    } else if (typeof super_ !== "function") {
      throw new TypeError("super_ should be a function");
    }
    var name;
    if (typeof constructor === "string") {
      name = constructor;
      constructor = construct !== void 0 ? function() {
        return construct(super_, arguments, this.constructor);
      } : function() {
        super_.apply(this, arguments);
      };
      if (setFunctionName !== void 0) {
        setFunctionName(constructor, name);
        name = void 0;
      }
    } else if (typeof constructor !== "function") {
      throw new TypeError("constructor should be either a string or a function");
    }
    constructor.super_ = constructor["super"] = super_;
    var properties = {
      constructor: {
        configurable: true,
        value: constructor,
        writable: true
      }
    };
    if (name !== void 0) {
      properties.name = {
        configurable: true,
        value: name,
        writable: true
      };
    }
    constructor.prototype = Object.create(super_.prototype, properties);
    return constructor;
  }
  exports = module.exports = makeError2;
  exports.BaseError = BaseError;
})(makeError, makeError.exports);
const cx$1 = function cx() {
  const result2 = Array.prototype.slice.call(arguments).filter(Boolean).join(" ");
  return result2;
};
var cx$1$1 = cx$1;
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function getMergeFunction(key, options) {
  if (!options.customMerge) {
    return deepmerge;
  }
  var customMerge = options.customMerge(key);
  return typeof customMerge === "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    return target.propertyIsEnumerable(symbol);
  }) : [];
}
function getKeys(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object2, property) {
  try {
    return property in object2;
  } catch (_2) {
    return false;
  }
}
function propertyIsUnsafe(target, key) {
  return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
}
function mergeObject(target, source, options) {
  var destination = {};
  if (options.isMergeableObject(target)) {
    getKeys(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }
  getKeys(source).forEach(function(key) {
    if (propertyIsUnsafe(target, key)) {
      return;
    }
    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    }
  });
  return destination;
}
function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}
deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error("first argument should be an array");
  }
  return array.reduce(function(prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};
var deepmerge_1 = deepmerge;
var cjs = deepmerge_1;
var fastDeepEqual = function equal(a2, b) {
  if (a2 === b)
    return true;
  if (a2 && b && typeof a2 == "object" && typeof b == "object") {
    if (a2.constructor !== b.constructor)
      return false;
    var length, i2, keys2;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal(a2[i2], b[i2]))
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b.source && a2.flags === b.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b.toString();
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys2[i2];
      if (!equal(a2[key], b[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b !== b;
};
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject = function isObject(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isObject$4 = isobject;
function isObjectObject(o2) {
  return isObject$4(o2) === true && Object.prototype.toString.call(o2) === "[object Object]";
}
var isPlainObject$3 = function isPlainObject(o2) {
  var ctor, prot;
  if (isObjectObject(o2) === false)
    return false;
  ctor = o2.constructor;
  if (typeof ctor !== "function")
    return false;
  prot = ctor.prototype;
  if (isObjectObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
};
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isPlainObject$2 = isPlainObject$3;
var isExtendable = function isExtendable2(val) {
  return isPlainObject$2(val) || typeof val === "function" || Array.isArray(val);
};
/*!
 * object.omit <https://github.com/jonschlinkert/object.omit>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isObject$3 = isExtendable;
var object_omit = function omit(obj, props, fn2) {
  if (!isObject$3(obj))
    return {};
  if (typeof props === "function") {
    fn2 = props;
    props = [];
  }
  if (typeof props === "string") {
    props = [props];
  }
  var isFunction3 = typeof fn2 === "function";
  var keys2 = Object.keys(obj);
  var res = {};
  for (var i2 = 0; i2 < keys2.length; i2++) {
    var key = keys2[i2];
    var val = obj[key];
    if (!props || props.indexOf(key) === -1 && (!isFunction3 || fn2(val, key, obj))) {
      res[key] = val;
    }
  }
  return res;
};
var omit2 = object_omit;
/*!
 * object.pick <https://github.com/jonschlinkert/object.pick>
 *
 * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */
var isObject$2 = isobject;
var object_pick = function pick(obj, keys2) {
  if (!isObject$2(obj) && typeof obj !== "function") {
    return {};
  }
  var res = {};
  if (typeof keys2 === "string") {
    if (keys2 in obj) {
      res[keys2] = obj[keys2];
    }
    return res;
  }
  var len = keys2.length;
  var idx = -1;
  while (++idx < len) {
    var key = keys2[idx];
    if (key in obj) {
      res[key] = obj[key];
    }
  }
  return res;
};
function splitOnSpecialChars(string) {
  return string.match(/^[a-zà-öø-ÿ]+|[A-ZÀ-ÖØ-ß][a-zà-öø-ÿ]+|[a-zà-öø-ÿ]+|[0-9]+|[A-ZÀ-ÖØ-ß]+(?![a-zà-öø-ÿ])/g);
}
function getParts(string, noSpecialChars2) {
  if (noSpecialChars2 === void 0) {
    noSpecialChars2 = false;
  }
  var target = string.trim().normalize("NFC");
  var parts = target.includes(" ") ? target.split(" ").filter(Boolean) : splitOnSpecialChars(target);
  return noSpecialChars2 ? parts.map(function(part) {
    return part.normalize("NFD").replace(/[^a-zA-ZØßø0-9]/g, "");
  }) : parts;
}
function capitaliseWord(string) {
  return string[0].toUpperCase() + string.slice(1).toLowerCase();
}
var noSpecialChars = true;
function pascalCase(string) {
  return getParts(string, noSpecialChars).reduce(function(result2, match) {
    return result2 + capitaliseWord(match);
  }, "");
}
function kebabCase(string) {
  return getParts(string, noSpecialChars).join("-").toLowerCase();
}
function throttle(delay, noTrailing, callback, debounceMode) {
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel() {
    clearExistingTimeout();
    cancelled = true;
  }
  if (typeof noTrailing !== "boolean") {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = void 0;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      exec();
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce$1(delay, atBegin, callback) {
  return callback === void 0 ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
}
function Cast(value) {
  return value;
}
function assertGet(value, key, message) {
  var prop = value[key];
  assert(!isUndefined(prop), message);
  return prop;
}
function assert(testValue, message) {
  if (!testValue) {
    throw new AssertionError(message);
  }
}
class AssertionError extends makeError.exports.BaseError {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "name", "AssertionError");
  }
}
function entries(value) {
  return Object.entries(value);
}
function keys$1(value) {
  return Object.keys(value);
}
function values(value) {
  return Object.values(value);
}
function includes(array, item, fromIndex) {
  return array.includes(item, fromIndex);
}
function object(value) {
  return Object.assign(/* @__PURE__ */ Object.create(null), value);
}
var TypeName;
(function(TypeName2) {
  TypeName2["Object"] = "Object";
  TypeName2["RegExp"] = "RegExp";
  TypeName2["Date"] = "Date";
  TypeName2["Promise"] = "Promise";
  TypeName2["Error"] = "Error";
  TypeName2["Map"] = "Map";
  TypeName2["Set"] = "Set";
})(TypeName || (TypeName = {}));
function toString(value) {
  return Object.prototype.toString.call(value);
}
function getObjectType(value) {
  var objectName = toString(value).slice(8, -1);
  return objectName;
}
function isOfType(type2, predicate) {
  return (value) => {
    if (typeof value !== type2) {
      return false;
    }
    return predicate ? predicate(value) : true;
  };
}
function isObjectOfType(type2) {
  return (value) => getObjectType(value) === type2;
}
var isUndefined = isOfType("undefined");
var isString$1 = isOfType("string");
var isNumber = isOfType("number", (value) => {
  return !Number.isNaN(value);
});
var isFunction$1 = isOfType("function");
function isNull(value) {
  return value === null;
}
function isBoolean(value) {
  return value === true || value === false;
}
function isPlainObject$1(value) {
  if (getObjectType(value) !== TypeName.Object) {
    return false;
  }
  var prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.getPrototypeOf({});
}
function isPrimitive(value) {
  return value == null || /^[bns]/.test(typeof value);
}
function isNullOrUndefined(value) {
  return isNull(value) || isUndefined(value);
}
function isObject$1(value) {
  return !isNullOrUndefined(value) && (isFunction$1(value) || isOfType("object")(value));
}
var isRegExp = isObjectOfType(TypeName.RegExp);
isObjectOfType(TypeName.Date);
isObjectOfType(TypeName.Error);
function isMap(value) {
  return isObjectOfType(TypeName.Map)(value);
}
function isSet(value) {
  return isObjectOfType(TypeName.Set)(value);
}
function isEmptyObject(value) {
  return isObject$1(value) && !isMap(value) && !isSet(value) && Object.keys(value).length === 0;
}
var isArray = Array.isArray;
function isEmptyArray(value) {
  return isArray(value) && value.length === 0;
}
function isNonEmptyArray(value) {
  return isArray(value) && value.length > 0;
}
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function findMatches(text3, regexp) {
  var runWhile = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (match2) => !!match2;
  regexp.lastIndex = 0;
  var results = [];
  var flags = regexp.flags;
  var match;
  if (!flags.includes("g")) {
    regexp = new RegExp(regexp.source, "g".concat(flags));
  }
  do {
    match = regexp.exec(text3);
    if (match) {
      results.push(match);
    }
  } while (runWhile(match));
  regexp.lastIndex = 0;
  return results;
}
function n$1() {
  var time = Date.now();
  var last = n$1.last || time;
  return n$1.last = time > last ? time : last + 1;
}
n$1.last = 0;
function uniqueId() {
  var prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return "".concat(prefix).concat(n$1().toString(36));
}
function omitUndefined(object2) {
  return omit2(object2, (value) => !isUndefined(value));
}
function clone(value) {
  if (!isPlainObject$1(value)) {
    throw new Error("An invalid value was passed into this clone utility. Expected a plain object");
  }
  return _objectSpread2$3({}, value);
}
var isEqual = fastDeepEqual;
function uniqueArray(array) {
  var fromStart = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var array_ = fromStart ? [...array].reverse() : array;
  var set2 = new Set(array_);
  return fromStart ? [...set2].reverse() : [...set2];
}
function noop$1() {
  return;
}
function deepMerge() {
  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    objects[_key2] = arguments[_key2];
  }
  return cjs.all(objects, {
    isMergeableObject: isPlainObject$1
  });
}
function clamp$1(_ref) {
  var min3 = _ref.min, max3 = _ref.max, value = _ref.value;
  if (value < min3) {
    return min3;
  }
  return value > max3 ? max3 : value;
}
function sort(array, compareFn) {
  return [...array].map((value, index3) => ({
    value,
    index: index3
  })).sort((a2, z2) => compareFn(a2.value, z2.value) || a2.index - z2.index).map((_ref2) => {
    var value = _ref2.value;
    return value;
  });
}
function get(root, path, defaultValue) {
  try {
    if (isString$1(path) && path in root) {
      return root[path];
    }
    if (isArray(path)) {
      path = "['".concat(path.join("']['"), "']");
    }
    var obj = root;
    path.replace(/\[\s*(["'])(.*?)\1\s*]|^\s*(\w+)\s*(?=\.|\[|$)|\.\s*(\w*)\s*(?=\.|\[|$)|\[\s*(-?\d+)\s*]/g, (_2, __, quotedProp, firstLevel, namedProp, index3) => {
      obj = obj[quotedProp || firstLevel || namedProp || index3];
      return "";
    });
    return obj === void 0 ? defaultValue : obj;
  } catch (_unused) {
    return defaultValue;
  }
}
function unset(path, target) {
  var clonedObject = clone(target);
  var value = clonedObject;
  var _iterator2 = _createForOfIteratorHelper(path.entries()), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var _step2$value = _slicedToArray(_step2.value, 2), index3 = _step2$value[0], key = _step2$value[1];
      var shouldDelete = index3 >= path.length - 1;
      var _item2 = value[key];
      if (shouldDelete) {
        if (isArray(value)) {
          var indexKey = Number.parseInt(key.toString(), 10);
          if (isNumber(indexKey)) {
            value.splice(indexKey, 1);
          }
        } else {
          Reflect.deleteProperty(value, key);
        }
        return clonedObject;
      }
      if (isPrimitive(_item2)) {
        return clonedObject;
      }
      _item2 = isArray(_item2) ? [..._item2] : _objectSpread2$3({}, _item2);
      value[key] = _item2;
      value = _item2;
    }
  } catch (err2) {
    _iterator2.e(err2);
  } finally {
    _iterator2.f();
  }
  return clonedObject;
}
function makeFunctionForUniqueBy(value) {
  return (item) => {
    return get(item, value);
  };
}
function uniqueBy$1(array, getValue) {
  var fromStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var unique = [];
  var found2 = /* @__PURE__ */ new Set();
  var getter = isFunction$1(getValue) ? getValue : makeFunctionForUniqueBy(getValue);
  var list = fromStart ? [...array].reverse() : array;
  var _iterator3 = _createForOfIteratorHelper(list), _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var _item3 = _step3.value;
      var _value = getter(_item3);
      if (!found2.has(_value)) {
        found2.add(_value);
        unique.push(_item3);
      }
    }
  } catch (err2) {
    _iterator3.e(err2);
  } finally {
    _iterator3.f();
  }
  return fromStart ? unique.reverse() : unique;
}
function range(start4, end3) {
  var startValue = isArray(start4) ? start4[0] : start4;
  if (!isNumber(end3)) {
    return Array.from({
      length: Math.abs(startValue)
    }, (_2, index3) => (startValue < 0 ? -1 : 1) * index3);
  }
  if (startValue <= end3) {
    return Array.from({
      length: end3 + 1 - startValue
    }, (_2, index3) => index3 + startValue);
  }
  return Array.from({
    length: startValue + 1 - end3
  }, (_2, index3) => -1 * index3 + startValue);
}
function within$1(value) {
  for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    rest[_key3 - 1] = arguments[_key3];
  }
  var numbers = rest.filter(isNumber);
  return value >= Math.min(...numbers) && value <= Math.max(...numbers);
}
function hasOwnProperty$1(object_, key) {
  return Object.prototype.hasOwnProperty.call(object_, key);
}
function getLazyArray(value) {
  if (isFunction$1(value)) {
    return value();
  }
  return value;
}
function cx2() {
  return uniqueArray(cx$1$1(...arguments).split(" ")).join(" ");
}
var ERROR_INFORMATION_URL = "https://remirror.io/docs/errors";
var errorMessageMap = {
  [ErrorConstant.UNKNOWN]: "An error occurred but we're not quite sure why. \u{1F9D0}",
  [ErrorConstant.INVALID_COMMAND_ARGUMENTS]: "The arguments passed to the command method were invalid.",
  [ErrorConstant.CUSTOM]: "This is a custom error, possibly thrown by an external library.",
  [ErrorConstant.CORE_HELPERS]: "An error occurred in a function called from the `@remirror/core-helpers` library.",
  [ErrorConstant.MUTATION]: "Mutation of immutable value detected.",
  [ErrorConstant.INTERNAL]: "This is an error which should not occur and is internal to the remirror codebase.",
  [ErrorConstant.MISSING_REQUIRED_EXTENSION]: "Your editor is missing a required extension.",
  [ErrorConstant.MANAGER_PHASE_ERROR]: "This occurs when accessing a method or property before it is available.",
  [ErrorConstant.INVALID_GET_EXTENSION]: "The user requested an invalid extension from the getExtensions method. Please check the `createExtensions` return method is returning an extension with the defined constructor.",
  [ErrorConstant.INVALID_MANAGER_ARGUMENTS]: "Invalid value(s) passed into `Manager` constructor. Only `Presets` and `Extensions` are supported.",
  [ErrorConstant.SCHEMA]: "There is a problem with the schema or you are trying to access a node / mark that doesn't exists.",
  [ErrorConstant.HELPERS_CALLED_IN_OUTER_SCOPE]: "The `helpers` method which is passed into the ``create*` method should only be called within returned method since it relies on an active view (not present in the outer scope).",
  [ErrorConstant.INVALID_MANAGER_EXTENSION]: "You requested an invalid extension from the manager.",
  [ErrorConstant.DUPLICATE_COMMAND_NAMES]: "Command method names must be unique within the editor.",
  [ErrorConstant.DUPLICATE_HELPER_NAMES]: "Helper method names must be unique within the editor.",
  [ErrorConstant.NON_CHAINABLE_COMMAND]: "Attempted to chain a non chainable command.",
  [ErrorConstant.INVALID_EXTENSION]: "The provided extension is invalid.",
  [ErrorConstant.INVALID_CONTENT]: "The content provided to the editor is not supported.",
  [ErrorConstant.INVALID_NAME]: "An invalid name was used for the extension.",
  [ErrorConstant.EXTENSION]: "An error occurred within an extension. More details should be made available.",
  [ErrorConstant.EXTENSION_SPEC]: "The spec was defined without calling the `defaults`, `parse` or `dom` methods.",
  [ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES]: "Extra attributes must either be a string or an object.",
  [ErrorConstant.INVALID_SET_EXTENSION_OPTIONS]: "A call to `extension.setOptions` was made with invalid keys.",
  [ErrorConstant.REACT_PROVIDER_CONTEXT]: "`useRemirrorContext` was called outside of the `remirror` context. It can only be used within an active remirror context created by the `<Remirror />`.",
  [ErrorConstant.REACT_GET_ROOT_PROPS]: "`getRootProps` has been attached to the DOM more than once. It should only be attached to the dom once per editor.",
  [ErrorConstant.REACT_EDITOR_VIEW]: "A problem occurred adding the editor view to the dom.",
  [ErrorConstant.REACT_CONTROLLED]: "There is a problem with your controlled editor setup.",
  [ErrorConstant.REACT_NODE_VIEW]: "Something went wrong with your custom ReactNodeView Component.",
  [ErrorConstant.REACT_GET_CONTEXT]: "You attempted to call `getContext` provided by the `useRemirror` prop during the first render of the editor. This is not possible and should only be after the editor first mounts.",
  [ErrorConstant.REACT_COMPONENTS]: "An error occurred within a remirror component.",
  [ErrorConstant.REACT_HOOKS]: "An error occurred within a remirror hook.",
  [ErrorConstant.I18N_CONTEXT]: "You called `useI18n()` outside of an `I18nProvider` context."
};
function isErrorConstant(code) {
  return isString$1(code) && includes(values(ErrorConstant), code);
}
function createErrorMessage(code, extraMessage) {
  var message = errorMessageMap[code];
  var prefix = message ? "".concat(message, "\n\n") : "";
  var customMessage = extraMessage ? "".concat(extraMessage, "\n\n") : "";
  return "".concat(prefix).concat(customMessage, "For more information visit ").concat(ERROR_INFORMATION_URL, "#").concat(code.toLowerCase());
}
class RemirrorError extends makeError.exports.BaseError {
  static create() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return new RemirrorError(options);
  }
  constructor() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, code = _ref.code, message = _ref.message, _ref$disableLogging = _ref.disableLogging, disableLogging = _ref$disableLogging === void 0 ? false : _ref$disableLogging;
    var errorCode;
    if (isErrorConstant(code)) {
      errorCode = code;
      super(createErrorMessage(errorCode, message));
    } else {
      errorCode = ErrorConstant.CUSTOM;
      super(createErrorMessage(errorCode, message));
    }
    this.errorCode = errorCode;
    this.url = "".concat(ERROR_INFORMATION_URL, "#").concat(errorCode.toLowerCase());
    if (!disableLogging) {
      console.error(this.message);
    }
  }
}
function invariant(condition, options) {
  if (condition) {
    return;
  }
  throw RemirrorError.create(options);
}
function freeze(target) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  !(isObject$1(target) || isArray(target)) ? invariant(false, {
    message: "`freeze` only supports objects and arrays.",
    code: ErrorConstant.CORE_HELPERS
  }) : void 0;
  return new Proxy(target, {
    get: (target2, prop, receiver) => {
      !(prop in target2 || !options.requireKeys) ? invariant(false, {
        message: "The prop: '".concat(prop.toString(), "' you are trying to access does not yet exist on the target.")
      }) : void 0;
      return Reflect.get(target2, prop, receiver);
    },
    set: (_2, prop) => {
      invariant(false, {
        message: "It seems you're trying to set the value of the property (".concat(String(prop), ") on a frozen object. For your protection this object does not allow direct mutation."),
        code: ErrorConstant.MUTATION
      });
    }
  });
}
function OrderedMap(content2) {
  this.content = content2;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      if (this.content[i2] === key)
        return i2;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self.find(key), content2 = self.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap(content2);
  },
  forEach: function(f2) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      f2(this.content[i2], this.content[i2 + 1]);
  },
  prepend: function(map16) {
    map16 = OrderedMap.from(map16);
    if (!map16.size)
      return this;
    return new OrderedMap(map16.content.concat(this.subtract(map16).content));
  },
  append: function(map16) {
    map16 = OrderedMap.from(map16);
    if (!map16.size)
      return this;
    return new OrderedMap(this.subtract(map16).content.concat(map16.content));
  },
  subtract: function(map16) {
    var result2 = this;
    map16 = OrderedMap.from(map16);
    for (var i2 = 0; i2 < map16.content.length; i2 += 2)
      result2 = result2.remove(map16.content[i2]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap(content2);
};
var orderedmap = OrderedMap;
function findDiffStart(a2, b, pos) {
  for (var i2 = 0; ; i2++) {
    if (i2 == a2.childCount || i2 == b.childCount) {
      return a2.childCount == b.childCount ? null : pos;
    }
    var childA = a2.child(i2), childB = b.child(i2);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a2, b, posA, posB) {
  for (var iA = a2.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a2.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment = function Fragment2(content2, size) {
  this.content = content2;
  this.size = size || 0;
  if (size == null) {
    for (var i2 = 0; i2 < content2.length; i2++) {
      this.size += content2[i2].nodeSize;
    }
  }
};
var prototypeAccessors$5 = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
Fragment.prototype.nodesBetween = function nodesBetween(from4, to, f2, nodeStart, parent) {
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i2 = 0, pos = 0; pos < to; i2++) {
    var child3 = this.content[i2], end3 = pos + child3.nodeSize;
    if (end3 > from4 && f2(child3, nodeStart + pos, parent, i2) !== false && child3.content.size) {
      var start4 = pos + 1;
      child3.nodesBetween(Math.max(0, from4 - start4), Math.min(child3.content.size, to - start4), f2, nodeStart + start4);
    }
    pos = end3;
  }
};
Fragment.prototype.descendants = function descendants(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment.prototype.textBetween = function textBetween(from4, to, blockSeparator, leafText) {
  var text3 = "", separated = true;
  this.nodesBetween(from4, to, function(node4, pos) {
    if (node4.isText) {
      text3 += node4.text.slice(Math.max(from4, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node4.isLeaf && leafText) {
      text3 += typeof leafText === "function" ? leafText(node4) : leafText;
      separated = !blockSeparator;
    } else if (!separated && node4.isBlock) {
      text3 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text3;
};
Fragment.prototype.append = function append(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i2 = 0;
  if (last.isText && last.sameMarkup(first)) {
    content2[content2.length - 1] = last.withText(last.text + first.text);
    i2 = 1;
  }
  for (; i2 < other.content.length; i2++) {
    content2.push(other.content[i2]);
  }
  return new Fragment(content2, this.size + other.size);
};
Fragment.prototype.cut = function cut(from4, to) {
  if (to == null) {
    to = this.size;
  }
  if (from4 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from4) {
    for (var i2 = 0, pos = 0; pos < to; i2++) {
      var child3 = this.content[i2], end3 = pos + child3.nodeSize;
      if (end3 > from4) {
        if (pos < from4 || end3 > to) {
          if (child3.isText) {
            child3 = child3.cut(Math.max(0, from4 - pos), Math.min(child3.text.length, to - pos));
          } else {
            child3 = child3.cut(Math.max(0, from4 - pos - 1), Math.min(child3.content.size, to - pos - 1));
          }
        }
        result2.push(child3);
        size += child3.nodeSize;
      }
      pos = end3;
    }
  }
  return new Fragment(result2, size);
};
Fragment.prototype.cutByIndex = function cutByIndex(from4, to) {
  if (from4 == to) {
    return Fragment.empty;
  }
  if (from4 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment(this.content.slice(from4, to));
};
Fragment.prototype.replaceChild = function replaceChild(index3, node4) {
  var current = this.content[index3];
  if (current == node4) {
    return this;
  }
  var copy5 = this.content.slice();
  var size = this.size + node4.nodeSize - current.nodeSize;
  copy5[index3] = node4;
  return new Fragment(copy5, size);
};
Fragment.prototype.addToStart = function addToStart(node4) {
  return new Fragment([node4].concat(this.content), this.size + node4.nodeSize);
};
Fragment.prototype.addToEnd = function addToEnd(node4) {
  return new Fragment(this.content.concat(node4), this.size + node4.nodeSize);
};
Fragment.prototype.eq = function eq(other) {
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.content.length; i2++) {
    if (!this.content[i2].eq(other.content[i2])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$5.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$5.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$5.childCount.get = function() {
  return this.content.length;
};
Fragment.prototype.child = function child(index3) {
  var found2 = this.content[index3];
  if (!found2) {
    throw new RangeError("Index " + index3 + " out of range for " + this);
  }
  return found2;
};
Fragment.prototype.maybeChild = function maybeChild(index3) {
  return this.content[index3];
};
Fragment.prototype.forEach = function forEach(f2) {
  for (var i2 = 0, p2 = 0; i2 < this.content.length; i2++) {
    var child3 = this.content[i2];
    f2(child3, p2, i2);
    p2 += child3.nodeSize;
  }
};
Fragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart(this, other, pos);
};
Fragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd(this, other, pos, otherPos);
};
Fragment.prototype.findIndex = function findIndex(pos, round2) {
  if (round2 === void 0)
    round2 = -1;
  if (pos == 0) {
    return retIndex(0, pos);
  }
  if (pos == this.size) {
    return retIndex(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i2 = 0, curPos = 0; ; i2++) {
    var cur = this.child(i2), end3 = curPos + cur.nodeSize;
    if (end3 >= pos) {
      if (end3 == pos || round2 > 0) {
        return retIndex(i2 + 1, end3);
      }
      return retIndex(i2, curPos);
    }
    curPos = end3;
  }
};
Fragment.prototype.toString = function toString2() {
  return "<" + this.toStringInner() + ">";
};
Fragment.prototype.toStringInner = function toStringInner() {
  return this.content.join(", ");
};
Fragment.prototype.toJSON = function toJSON() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment.fromJSON = function fromJSON(schema, value) {
  if (!value) {
    return Fragment.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment(value.map(schema.nodeFromJSON));
};
Fragment.fromArray = function fromArray(array) {
  if (!array.length) {
    return Fragment.empty;
  }
  var joined, size = 0;
  for (var i2 = 0; i2 < array.length; i2++) {
    var node4 = array[i2];
    size += node4.nodeSize;
    if (i2 && node4.isText && array[i2 - 1].sameMarkup(node4)) {
      if (!joined) {
        joined = array.slice(0, i2);
      }
      joined[joined.length - 1] = node4.withText(joined[joined.length - 1].text + node4.text);
    } else if (joined) {
      joined.push(node4);
    }
  }
  return new Fragment(joined || array, size);
};
Fragment.from = function from(nodes) {
  if (!nodes) {
    return Fragment.empty;
  }
  if (nodes instanceof Fragment) {
    return nodes;
  }
  if (Array.isArray(nodes)) {
    return this.fromArray(nodes);
  }
  if (nodes.attrs) {
    return new Fragment([nodes], nodes.nodeSize);
  }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
};
Object.defineProperties(Fragment.prototype, prototypeAccessors$5);
var found = { index: 0, offset: 0 };
function retIndex(index3, offset3) {
  found.index = index3;
  found.offset = offset3;
  return found;
}
Fragment.empty = new Fragment([], 0);
function compareDeep(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (!(a2 && typeof a2 == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array = Array.isArray(a2);
  if (Array.isArray(b) != array) {
    return false;
  }
  if (array) {
    if (a2.length != b.length) {
      return false;
    }
    for (var i2 = 0; i2 < a2.length; i2++) {
      if (!compareDeep(a2[i2], b[i2])) {
        return false;
      }
    }
  } else {
    for (var p2 in a2) {
      if (!(p2 in b) || !compareDeep(a2[p2], b[p2])) {
        return false;
      }
    }
    for (var p$12 in b) {
      if (!(p$12 in a2)) {
        return false;
      }
    }
  }
  return true;
}
var Mark = function Mark2(type2, attrs) {
  this.type = type2;
  this.attrs = attrs;
};
Mark.prototype.addToSet = function addToSet(set2) {
  var copy5, placed = false;
  for (var i2 = 0; i2 < set2.length; i2++) {
    var other = set2[i2];
    if (this.eq(other)) {
      return set2;
    }
    if (this.type.excludes(other.type)) {
      if (!copy5) {
        copy5 = set2.slice(0, i2);
      }
    } else if (other.type.excludes(this.type)) {
      return set2;
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy5) {
          copy5 = set2.slice(0, i2);
        }
        copy5.push(this);
        placed = true;
      }
      if (copy5) {
        copy5.push(other);
      }
    }
  }
  if (!copy5) {
    copy5 = set2.slice();
  }
  if (!placed) {
    copy5.push(this);
  }
  return copy5;
};
Mark.prototype.removeFromSet = function removeFromSet(set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (this.eq(set2[i2])) {
      return set2.slice(0, i2).concat(set2.slice(i2 + 1));
    }
  }
  return set2;
};
Mark.prototype.isInSet = function isInSet(set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (this.eq(set2[i2])) {
      return true;
    }
  }
  return false;
};
Mark.prototype.eq = function eq2(other) {
  return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
};
Mark.prototype.toJSON = function toJSON2() {
  var obj = { type: this.type.name };
  for (var _2 in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  return obj;
};
Mark.fromJSON = function fromJSON2(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type2 = schema.marks[json.type];
  if (!type2) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type2.create(json.attrs);
};
Mark.sameSet = function sameSet(a2, b) {
  if (a2 == b) {
    return true;
  }
  if (a2.length != b.length) {
    return false;
  }
  for (var i2 = 0; i2 < a2.length; i2++) {
    if (!a2[i2].eq(b[i2])) {
      return false;
    }
  }
  return true;
};
Mark.setFrom = function setFrom(marks2) {
  if (!marks2 || marks2.length == 0) {
    return Mark.none;
  }
  if (marks2 instanceof Mark) {
    return [marks2];
  }
  var copy5 = marks2.slice();
  copy5.sort(function(a2, b) {
    return a2.type.rank - b.type.rank;
  });
  return copy5;
};
Mark.none = [];
function ReplaceError(message) {
  var err2 = Error.call(this, message);
  err2.__proto__ = ReplaceError.prototype;
  return err2;
}
ReplaceError.prototype = Object.create(Error.prototype);
ReplaceError.prototype.constructor = ReplaceError;
ReplaceError.prototype.name = "ReplaceError";
var Slice = function Slice2(content2, openStart, openEnd) {
  this.content = content2;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$1$3 = { size: { configurable: true } };
prototypeAccessors$1$3.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice.prototype.insertAt = function insertAt(pos, fragment) {
  var content2 = insertInto(this.content, pos + this.openStart, fragment, null);
  return content2 && new Slice(content2, this.openStart, this.openEnd);
};
Slice.prototype.removeBetween = function removeBetween(from4, to) {
  return new Slice(removeRange(this.content, from4 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice.prototype.eq = function eq3(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice.prototype.toString = function toString3() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice.prototype.toJSON = function toJSON3() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice.fromJSON = function fromJSON3(schema, json) {
  if (!json) {
    return Slice.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
};
Slice.maxOpen = function maxOpen(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice(fragment, openStart, openEnd);
};
Object.defineProperties(Slice.prototype, prototypeAccessors$1$3);
function removeRange(content2, from4, to) {
  var ref2 = content2.findIndex(from4);
  var index3 = ref2.index;
  var offset3 = ref2.offset;
  var child3 = content2.maybeChild(index3);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset3 == from4 || child3.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from4).append(content2.cut(to));
  }
  if (index3 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index3, child3.copy(removeRange(child3.content, from4 - offset3 - 1, to - offset3 - 1)));
}
function insertInto(content2, dist, insert, parent) {
  var ref2 = content2.findIndex(dist);
  var index3 = ref2.index;
  var offset3 = ref2.offset;
  var child3 = content2.maybeChild(index3);
  if (offset3 == dist || child3.isText) {
    if (parent && !parent.canReplace(index3, index3, insert)) {
      return null;
    }
    return content2.cut(0, dist).append(insert).append(content2.cut(dist));
  }
  var inner = insertInto(child3.content, dist - offset3 - 1, insert);
  return inner && content2.replaceChild(index3, child3.copy(inner));
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function replace($from, $to, slice5) {
  if (slice5.openStart > $from.depth) {
    throw new ReplaceError("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice5.openStart != $to.depth - slice5.openEnd) {
    throw new ReplaceError("Inconsistent open depths");
  }
  return replaceOuter($from, $to, slice5, 0);
}
function replaceOuter($from, $to, slice5, depth) {
  var index3 = $from.index(depth), node4 = $from.node(depth);
  if (index3 == $to.index(depth) && depth < $from.depth - slice5.openStart) {
    var inner = replaceOuter($from, $to, slice5, depth + 1);
    return node4.copy(node4.content.replaceChild(index3, inner));
  } else if (!slice5.content.size) {
    return close(node4, replaceTwoWay($from, $to, depth));
  } else if (!slice5.openStart && !slice5.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close(parent, content2.cut(0, $from.parentOffset).append(slice5.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref2 = prepareSliceForReplace(slice5, $from);
    var start4 = ref2.start;
    var end3 = ref2.end;
    return close(node4, replaceThreeWay($from, start4, end3, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type)) {
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
}
function joinable$1($before, $after, depth) {
  var node4 = $before.node(depth);
  checkJoin(node4, $after.node(depth));
  return node4;
}
function addNode(child3, target) {
  var last = target.length - 1;
  if (last >= 0 && child3.isText && child3.sameMarkup(target[last])) {
    target[last] = child3.withText(target[last].text + child3.text);
  } else {
    target.push(child3);
  }
}
function addRange($start, $end, depth, target) {
  var node4 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node4.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i2 = startIndex; i2 < endIndex; i2++) {
    addNode(node4.child(i2), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode($end.nodeBefore, target);
  }
}
function close(node4, content2) {
  if (!node4.type.validContent(content2)) {
    throw new ReplaceError("Invalid content for node " + node4.type.name);
  }
  return node4.copy(content2);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  var content2 = [];
  addRange(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content2);
    }
    addRange($start, $end, depth, content2);
    if (openEnd) {
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content2);
    }
  }
  addRange($to, null, depth, content2);
  return new Fragment(content2);
}
function replaceTwoWay($from, $to, depth) {
  var content2 = [];
  addRange(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type2 = joinable$1($from, $to, depth + 1);
    addNode(close(type2, replaceTwoWay($from, $to, depth + 1)), content2);
  }
  addRange($to, null, depth, content2);
  return new Fragment(content2);
}
function prepareSliceForReplace(slice5, $along) {
  var extra = $along.depth - slice5.openStart, parent = $along.node(extra);
  var node4 = parent.copy(slice5.content);
  for (var i2 = extra - 1; i2 >= 0; i2--) {
    node4 = $along.node(i2).copy(Fragment.from(node4));
  }
  return {
    start: node4.resolveNoCache(slice5.openStart + extra),
    end: node4.resolveNoCache(node4.content.size - slice5.openEnd - extra)
  };
}
var ResolvedPos = function ResolvedPos2(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$2$1 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
ResolvedPos.prototype.resolveDepth = function resolveDepth(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$2$1.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$2$1.doc.get = function() {
  return this.node(0);
};
ResolvedPos.prototype.node = function node(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos.prototype.index = function index(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos.prototype.indexAfter = function indexAfter(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos.prototype.start = function start(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos.prototype.end = function end(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos.prototype.before = function before(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos.prototype.after = function after(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$2$1.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$2$1.nodeAfter.get = function() {
  var parent = this.parent, index3 = this.index(this.depth);
  if (index3 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child3 = parent.child(index3);
  return dOff ? parent.child(index3).cut(dOff) : child3;
};
prototypeAccessors$2$1.nodeBefore.get = function() {
  var index3 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index3).cut(0, dOff);
  }
  return index3 == 0 ? null : this.parent.child(index3 - 1);
};
ResolvedPos.prototype.posAtIndex = function posAtIndex(index3, depth) {
  depth = this.resolveDepth(depth);
  var node4 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i2 = 0; i2 < index3; i2++) {
    pos += node4.child(i2).nodeSize;
  }
  return pos;
};
ResolvedPos.prototype.marks = function marks() {
  var parent = this.parent, index3 = this.index();
  if (parent.content.size == 0) {
    return Mark.none;
  }
  if (this.textOffset) {
    return parent.child(index3).marks;
  }
  var main2 = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
  if (!main2) {
    var tmp = main2;
    main2 = other;
    other = tmp;
  }
  var marks2 = main2.marks;
  for (var i2 = 0; i2 < marks2.length; i2++) {
    if (marks2[i2].type.spec.inclusive === false && (!other || !marks2[i2].isInSet(other.marks))) {
      marks2 = marks2[i2--].removeFromSet(marks2);
    }
  }
  return marks2;
};
ResolvedPos.prototype.marksAcross = function marksAcross($end) {
  var after2 = this.parent.maybeChild(this.index());
  if (!after2 || !after2.isInline) {
    return null;
  }
  var marks2 = after2.marks, next = $end.parent.maybeChild($end.index());
  for (var i2 = 0; i2 < marks2.length; i2++) {
    if (marks2[i2].type.spec.inclusive === false && (!next || !marks2[i2].isInSet(next.marks))) {
      marks2 = marks2[i2--].removeFromSet(marks2);
    }
  }
  return marks2;
};
ResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {
  for (var depth = this.depth; depth > 0; depth--) {
    if (this.start(depth) <= pos && this.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos.prototype.blockRange = function blockRange(other, pred) {
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d2 = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d2 >= 0; d2--) {
    if (other.pos <= this.end(d2) && (!pred || pred(this.node(d2)))) {
      return new NodeRange(this, other, d2);
    }
  }
};
ResolvedPos.prototype.sameParent = function sameParent(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos.prototype.max = function max(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos.prototype.min = function min(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos.prototype.toString = function toString4() {
  var str = "";
  for (var i2 = 1; i2 <= this.depth; i2++) {
    str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos.resolve = function resolve(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start4 = 0, parentOffset = pos;
  for (var node4 = doc2; ; ) {
    var ref2 = node4.content.findIndex(parentOffset);
    var index3 = ref2.index;
    var offset3 = ref2.offset;
    var rem = parentOffset - offset3;
    path.push(node4, index3, start4 + offset3);
    if (!rem) {
      break;
    }
    node4 = node4.child(index3);
    if (node4.isText) {
      break;
    }
    parentOffset = rem - 1;
    start4 += offset3 + 1;
  }
  return new ResolvedPos(pos, path, parentOffset);
};
ResolvedPos.resolveCached = function resolveCached(doc2, pos) {
  for (var i2 = 0; i2 < resolveCache.length; i2++) {
    var cached = resolveCache[i2];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
  return result2;
};
Object.defineProperties(ResolvedPos.prototype, prototypeAccessors$2$1);
var resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
var NodeRange = function NodeRange2($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
prototypeAccessors$1$1$1.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$1.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$1.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$1.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$1.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange.prototype, prototypeAccessors$1$1$1);
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node$1 = function Node2(type2, attrs, content2, marks2) {
  this.type = type2;
  this.attrs = attrs;
  this.content = content2 || Fragment.empty;
  this.marks = marks2 || Mark.none;
};
var prototypeAccessors$3$1 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
prototypeAccessors$3$1.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$3$1.childCount.get = function() {
  return this.content.childCount;
};
Node$1.prototype.child = function child2(index3) {
  return this.content.child(index3);
};
Node$1.prototype.maybeChild = function maybeChild2(index3) {
  return this.content.maybeChild(index3);
};
Node$1.prototype.forEach = function forEach2(f2) {
  this.content.forEach(f2);
};
Node$1.prototype.nodesBetween = function nodesBetween2(from4, to, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from4, to, f2, startPos, this);
};
Node$1.prototype.descendants = function descendants2(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors$3$1.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$1.prototype.textBetween = function textBetween2(from4, to, blockSeparator, leafText) {
  return this.content.textBetween(from4, to, blockSeparator, leafText);
};
prototypeAccessors$3$1.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$3$1.lastChild.get = function() {
  return this.content.lastChild;
};
Node$1.prototype.eq = function eq4(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$1.prototype.sameMarkup = function sameMarkup(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$1.prototype.hasMarkup = function hasMarkup(type2, attrs, marks2) {
  return this.type == type2 && compareDeep(this.attrs, attrs || type2.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks2 || Mark.none);
};
Node$1.prototype.copy = function copy(content2) {
  if (content2 === void 0)
    content2 = null;
  if (content2 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content2, this.marks);
};
Node$1.prototype.mark = function mark(marks2) {
  return marks2 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks2);
};
Node$1.prototype.cut = function cut2(from4, to) {
  if (from4 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from4, to));
};
Node$1.prototype.slice = function slice(from4, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from4 == to) {
    return Slice.empty;
  }
  var $from = this.resolve(from4), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start4 = $from.start(depth), node4 = $from.node(depth);
  var content2 = node4.content.cut($from.pos - start4, $to.pos - start4);
  return new Slice(content2, $from.depth - depth, $to.depth - depth);
};
Node$1.prototype.replace = function replace$1(from4, to, slice5) {
  return replace(this.resolve(from4), this.resolve(to), slice5);
};
Node$1.prototype.nodeAt = function nodeAt(pos) {
  for (var node4 = this; ; ) {
    var ref2 = node4.content.findIndex(pos);
    var index3 = ref2.index;
    var offset3 = ref2.offset;
    node4 = node4.maybeChild(index3);
    if (!node4) {
      return null;
    }
    if (offset3 == pos || node4.isText) {
      return node4;
    }
    pos -= offset3 + 1;
  }
};
Node$1.prototype.childAfter = function childAfter(pos) {
  var ref2 = this.content.findIndex(pos);
  var index3 = ref2.index;
  var offset3 = ref2.offset;
  return { node: this.content.maybeChild(index3), index: index3, offset: offset3 };
};
Node$1.prototype.childBefore = function childBefore(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref2 = this.content.findIndex(pos);
  var index3 = ref2.index;
  var offset3 = ref2.offset;
  if (offset3 < pos) {
    return { node: this.content.child(index3), index: index3, offset: offset3 };
  }
  var node4 = this.content.child(index3 - 1);
  return { node: node4, index: index3 - 1, offset: offset3 - node4.nodeSize };
};
Node$1.prototype.resolve = function resolve2(pos) {
  return ResolvedPos.resolveCached(this, pos);
};
Node$1.prototype.resolveNoCache = function resolveNoCache(pos) {
  return ResolvedPos.resolve(this, pos);
};
Node$1.prototype.rangeHasMark = function rangeHasMark(from4, to, type2) {
  var found2 = false;
  if (to > from4) {
    this.nodesBetween(from4, to, function(node4) {
      if (type2.isInSet(node4.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$3$1.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$3$1.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$3$1.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$3$1.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$3$1.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$3$1.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$3$1.isAtom.get = function() {
  return this.type.isAtom;
};
Node$1.prototype.toString = function toString5() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks(this.marks, name);
};
Node$1.prototype.contentMatchAt = function contentMatchAt(index3) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index3);
  if (!match) {
    throw new Error("Called contentMatchAt on a node with invalid content");
  }
  return match;
};
Node$1.prototype.canReplace = function canReplace(from4, to, replacement, start4, end3) {
  if (replacement === void 0)
    replacement = Fragment.empty;
  if (start4 === void 0)
    start4 = 0;
  if (end3 === void 0)
    end3 = replacement.childCount;
  var one = this.contentMatchAt(from4).matchFragment(replacement, start4, end3);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i2 = start4; i2 < end3; i2++) {
    if (!this.type.allowsMarks(replacement.child(i2).marks)) {
      return false;
    }
  }
  return true;
};
Node$1.prototype.canReplaceWith = function canReplaceWith(from4, to, type2, marks2) {
  if (marks2 && !this.type.allowsMarks(marks2)) {
    return false;
  }
  var start4 = this.contentMatchAt(from4).matchType(type2);
  var end3 = start4 && start4.matchFragment(this.content, to);
  return end3 ? end3.validEnd : false;
};
Node$1.prototype.canAppend = function canAppend(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$1.prototype.check = function check() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  var copy5 = Mark.none;
  for (var i2 = 0; i2 < this.marks.length; i2++) {
    copy5 = this.marks[i2].addToSet(copy5);
  }
  if (!Mark.sameSet(copy5, this.marks)) {
    throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m2) {
      return m2.type.name;
    }));
  }
  this.content.forEach(function(node4) {
    return node4.check();
  });
};
Node$1.prototype.toJSON = function toJSON4() {
  var obj = { type: this.type.name };
  for (var _2 in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node$1.fromJSON = function fromJSON4(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks2 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks2 = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema.text(json.text, marks2);
  }
  var content2 = Fragment.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content2, marks2);
};
Object.defineProperties(Node$1.prototype, prototypeAccessors$3$1);
var TextNode = /* @__PURE__ */ function(Node3) {
  function TextNode2(type2, attrs, content2, marks2) {
    Node3.call(this, type2, attrs, null, marks2);
    if (!content2) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content2;
  }
  if (Node3)
    TextNode2.__proto__ = Node3;
  TextNode2.prototype = Object.create(Node3 && Node3.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: { configurable: true }, nodeSize: { configurable: true } };
  TextNode2.prototype.toString = function toString8() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween3(from4, to) {
    return this.text.slice(from4, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark3(marks2) {
    return marks2 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks2);
  };
  TextNode2.prototype.withText = function withText(text3) {
    if (text3 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text3, this.marks);
  };
  TextNode2.prototype.cut = function cut3(from4, to) {
    if (from4 === void 0)
      from4 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from4 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from4, to));
  };
  TextNode2.prototype.eq = function eq12(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON7() {
    var base2 = Node3.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$1);
function wrapMarks(marks2, str) {
  for (var i2 = marks2.length - 1; i2 >= 0; i2--) {
    str = marks2[i2].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch = function ContentMatch2(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$4$1 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
ContentMatch.parse = function parse(string, nodeTypes) {
  var stream = new TokenStream(string, nodeTypes);
  if (stream.next == null) {
    return ContentMatch.empty;
  }
  var expr = parseExpr(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match = dfa(nfa(expr));
  checkForDeadEnds(match, stream);
  return match;
};
ContentMatch.prototype.matchType = function matchType(type2) {
  for (var i2 = 0; i2 < this.next.length; i2 += 2) {
    if (this.next[i2] == type2) {
      return this.next[i2 + 1];
    }
  }
  return null;
};
ContentMatch.prototype.matchFragment = function matchFragment(frag, start4, end3) {
  if (start4 === void 0)
    start4 = 0;
  if (end3 === void 0)
    end3 = frag.childCount;
  var cur = this;
  for (var i2 = start4; cur && i2 < end3; i2++) {
    cur = cur.matchType(frag.child(i2).type);
  }
  return cur;
};
prototypeAccessors$4$1.inlineContent.get = function() {
  var first = this.next[0];
  return first ? first.isInline : false;
};
prototypeAccessors$4$1.defaultType.get = function() {
  for (var i2 = 0; i2 < this.next.length; i2 += 2) {
    var type2 = this.next[i2];
    if (!(type2.isText || type2.hasRequiredAttrs())) {
      return type2;
    }
  }
};
ContentMatch.prototype.compatible = function compatible(other) {
  for (var i2 = 0; i2 < this.next.length; i2 += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this.next[i2] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch.prototype.fillBefore = function fillBefore(after2, toEnd, startIndex) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex === void 0)
    startIndex = 0;
  var seen = [this];
  function search(match, types) {
    var finished = match.matchFragment(after2, startIndex);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i2 = 0; i2 < match.next.length; i2 += 2) {
      var type2 = match.next[i2], next = match.next[i2 + 1];
      if (!(type2.isText || type2.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found2 = search(next, types.concat(type2));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch.prototype.findWrapping = function findWrapping(target) {
  for (var i2 = 0; i2 < this.wrapCache.length; i2 += 2) {
    if (this.wrapCache[i2] == target) {
      return this.wrapCache[i2 + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch.prototype.computeWrapping = function computeWrapping(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i2 = 0; i2 < match.next.length; i2 += 2) {
      var type2 = match.next[i2];
      if (!type2.isLeaf && !type2.hasRequiredAttrs() && !(type2.name in seen) && (!current.type || match.next[i2 + 1].validEnd)) {
        active.push({ match: type2.contentMatch, type: type2, via: current });
        seen[type2.name] = true;
      }
    }
  }
};
prototypeAccessors$4$1.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch.prototype.edge = function edge(n2) {
  var i2 = n2 << 1;
  if (i2 >= this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i2], next: this.next[i2 + 1] };
};
ContentMatch.prototype.toString = function toString6() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i2 = 1; i2 < m2.next.length; i2 += 2) {
      if (seen.indexOf(m2.next[i2]) == -1) {
        scan(m2.next[i2]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i2) {
    var out = i2 + (m2.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m2.next.length; i$1 += 2) {
      out += (i$1 ? ", " : "") + m2.next[i$1].name + "->" + seen.indexOf(m2.next[i$1 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch.prototype, prototypeAccessors$4$1);
ContentMatch.empty = new ContentMatch(true);
var TokenStream = function TokenStream2(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.shift();
  }
};
var prototypeAccessors$1$2$1 = { next: { configurable: true } };
prototypeAccessors$1$2$1.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream.prototype.eat = function eat(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream.prototype.err = function err(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream.prototype, prototypeAccessors$1$2$1);
function parseExpr(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange(stream, expr) {
  var min3 = parseNum(stream), max3 = min3;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max3 = parseNum(stream);
    } else {
      max3 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min3, max: max3, expr };
}
function resolveName(stream, name) {
  var types = stream.nodeTypes, type2 = types[name];
  if (type2) {
    return [type2];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function(type2) {
      if (stream.inline == null) {
        stream.inline = type2.isInline;
      } else if (stream.inline != type2.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type2 };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  var nfa2 = [[]];
  connect2(compile4(expr, 0), node4());
  return nfa2;
  function node4() {
    return nfa2.push([]) - 1;
  }
  function edge2(from4, to, term) {
    var edge3 = { term, to };
    nfa2[from4].push(edge3);
    return edge3;
  }
  function connect2(edges, to) {
    edges.forEach(function(edge3) {
      return edge3.to = to;
    });
  }
  function compile4(expr2, from4) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile4(expr3, from4));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i2 = 0; ; i2++) {
        var next = compile4(expr2.exprs[i2], from4);
        if (i2 == expr2.exprs.length - 1) {
          return next;
        }
        connect2(next, from4 = node4());
      }
    } else if (expr2.type == "star") {
      var loop = node4();
      edge2(from4, loop);
      connect2(compile4(expr2.expr, loop), loop);
      return [edge2(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node4();
      connect2(compile4(expr2.expr, from4), loop$1);
      connect2(compile4(expr2.expr, loop$1), loop$1);
      return [edge2(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge2(from4)].concat(compile4(expr2.expr, from4));
    } else if (expr2.type == "range") {
      var cur = from4;
      for (var i$1 = 0; i$1 < expr2.min; i$1++) {
        var next$1 = node4();
        connect2(compile4(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect2(compile4(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node4();
          edge2(cur, next$2);
          connect2(compile4(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge2(cur)];
    } else if (expr2.type == "name") {
      return [edge2(from4, null, expr2.value)];
    }
  }
}
function cmp(a2, b) {
  return b - a2;
}
function nullFrom(nfa2, node4) {
  var result2 = [];
  scan(node4);
  return result2.sort(cmp);
  function scan(node5) {
    var edges = nfa2[node5];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node5);
    for (var i2 = 0; i2 < edges.length; i2++) {
      var ref2 = edges[i2];
      var term = ref2.term;
      var to = ref2.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node4) {
      nfa2[node4].forEach(function(ref2) {
        var term = ref2.term;
        var to = ref2.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set2 = known > -1 && out[known + 1];
        nullFrom(nfa2, to).forEach(function(node5) {
          if (!set2) {
            out.push(term, set2 = []);
          }
          if (set2.indexOf(node5) == -1) {
            set2.push(node5);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (var i2 = 0; i2 < out.length; i2 += 2) {
      var states$1 = out[i2 + 1].sort(cmp);
      state.next.push(out[i2], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (var i2 = 0, work = [match]; i2 < work.length; i2++) {
    var state = work[i2], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node4 = state.next[j], next = state.next[j + 1];
      nodes.push(node4.name);
      if (dead && !(node4.isText || node4.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next) == -1) {
        work.push(next);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
}
function defaultAttrs(attrs) {
  var defaults = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute(attrs[name]);
    }
  }
  return result2;
}
var NodeType$1 = function NodeType(name, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs(spec.attrs);
  this.defaultAttrs = defaultAttrs(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$5$1 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true }, whitespace: { configurable: true } };
prototypeAccessors$5$1.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$5$1.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$5$1.isLeaf.get = function() {
  return this.contentMatch == ContentMatch.empty;
};
prototypeAccessors$5$1.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
prototypeAccessors$5$1.whitespace.get = function() {
  return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
};
NodeType$1.prototype.hasRequiredAttrs = function hasRequiredAttrs() {
  for (var n2 in this.attrs) {
    if (this.attrs[n2].isRequired) {
      return true;
    }
  }
  return false;
};
NodeType$1.prototype.compatibleContent = function compatibleContent(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$1.prototype.computeAttrs = function computeAttrs$1(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs(this.attrs, attrs);
  }
};
NodeType$1.prototype.create = function create(attrs, content2, marks2) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content2), Mark.setFrom(marks2));
};
NodeType$1.prototype.createChecked = function createChecked(attrs, content2, marks2) {
  content2 = Fragment.from(content2);
  if (!this.validContent(content2)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$1(this, this.computeAttrs(attrs), content2, Mark.setFrom(marks2));
};
NodeType$1.prototype.createAndFill = function createAndFill(attrs, content2, marks2) {
  attrs = this.computeAttrs(attrs);
  content2 = Fragment.from(content2);
  if (content2.size) {
    var before2 = this.contentMatch.fillBefore(content2);
    if (!before2) {
      return null;
    }
    content2 = before2.append(content2);
  }
  var after2 = this.contentMatch.matchFragment(content2).fillBefore(Fragment.empty, true);
  if (!after2) {
    return null;
  }
  return new Node$1(this, attrs, content2.append(after2), Mark.setFrom(marks2));
};
NodeType$1.prototype.validContent = function validContent(content2) {
  var result2 = this.contentMatch.matchFragment(content2);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i2 = 0; i2 < content2.childCount; i2++) {
    if (!this.allowsMarks(content2.child(i2).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$1.prototype.allowsMarkType = function allowsMarkType(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$1.prototype.allowsMarks = function allowsMarks(marks2) {
  if (this.markSet == null) {
    return true;
  }
  for (var i2 = 0; i2 < marks2.length; i2++) {
    if (!this.allowsMarkType(marks2[i2].type)) {
      return false;
    }
  }
  return true;
};
NodeType$1.prototype.allowedMarks = function allowedMarks(marks2) {
  if (this.markSet == null) {
    return marks2;
  }
  var copy5;
  for (var i2 = 0; i2 < marks2.length; i2++) {
    if (!this.allowsMarkType(marks2[i2].type)) {
      if (!copy5) {
        copy5 = marks2.slice(0, i2);
      }
    } else if (copy5) {
      copy5.push(marks2[i2]);
    }
  }
  return !copy5 ? marks2 : copy5.length ? copy5 : Mark.empty;
};
NodeType$1.compile = function compile(nodes, schema) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes.forEach(function(name, spec) {
    return result2[name] = new NodeType$1(name, schema, spec);
  });
  var topType = schema.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _2 in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$1.prototype, prototypeAccessors$5$1);
var Attribute = function Attribute2(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$3$1 = { isRequired: { configurable: true } };
prototypeAccessors$1$3$1.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute.prototype, prototypeAccessors$1$3$1);
var MarkType = function MarkType2(name, rank, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.attrs = initAttrs(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs(this.attrs);
  this.instance = defaults && new Mark(this, defaults);
};
MarkType.prototype.create = function create2(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark(this, computeAttrs(this.attrs, attrs));
};
MarkType.compile = function compile2(marks2, schema) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks2.forEach(function(name, spec) {
    return result2[name] = new MarkType(name, rank++, schema, spec);
  });
  return result2;
};
MarkType.prototype.removeFromSet = function removeFromSet2(set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (set2[i2].type == this) {
      set2 = set2.slice(0, i2).concat(set2.slice(i2 + 1));
      i2--;
    }
  }
  return set2;
};
MarkType.prototype.isInSet = function isInSet2(set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (set2[i2].type == this) {
      return set2[i2];
    }
  }
};
MarkType.prototype.excludes = function excludes(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema = function Schema2(spec) {
  this.spec = {};
  for (var prop in spec) {
    this.spec[prop] = spec[prop];
  }
  this.spec.nodes = orderedmap.from(spec.nodes);
  this.spec.marks = orderedmap.from(spec.marks);
  this.nodes = NodeType$1.compile(this.spec.nodes, this);
  this.marks = MarkType.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this.nodes) {
    if (prop$1 in this.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type2 = this.nodes[prop$1], contentExpr = type2.spec.content || "", markExpr = type2.spec.marks;
    type2.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
    type2.inlineContent = type2.contentMatch.inlineContent;
    type2.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type2.inlineContent ? [] : null;
  }
  for (var prop$2 in this.marks) {
    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema.prototype.node = function node2(type2, attrs, content2, marks2) {
  if (typeof type2 == "string") {
    type2 = this.nodeType(type2);
  } else if (!(type2 instanceof NodeType$1)) {
    throw new RangeError("Invalid node type: " + type2);
  } else if (type2.schema != this) {
    throw new RangeError("Node type from different schema used (" + type2.name + ")");
  }
  return type2.createChecked(attrs, content2, marks2);
};
Schema.prototype.text = function text(text$12, marks2) {
  var type2 = this.nodes.text;
  return new TextNode(type2, type2.defaultAttrs, text$12, Mark.setFrom(marks2));
};
Schema.prototype.mark = function mark2(type2, attrs) {
  if (typeof type2 == "string") {
    type2 = this.marks[type2];
  }
  return type2.create(attrs);
};
Schema.prototype.nodeFromJSON = function nodeFromJSON(json) {
  return Node$1.fromJSON(this, json);
};
Schema.prototype.markFromJSON = function markFromJSON(json) {
  return Mark.fromJSON(this, json);
};
Schema.prototype.nodeType = function nodeType(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks(schema, marks2) {
  var found2 = [];
  for (var i2 = 0; i2 < marks2.length; i2++) {
    var name = marks2[i2], mark3 = schema.marks[name], ok2 = mark3;
    if (mark3) {
      found2.push(mark3);
    } else {
      for (var prop in schema.marks) {
        var mark$1 = schema.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok2 = mark$1);
        }
      }
    }
    if (!ok2) {
      throw new SyntaxError("Unknown mark type: '" + marks2[i2] + "'");
    }
  }
  return found2;
}
var DOMParser = function DOMParser2(schema, rules) {
  var this$1$1 = this;
  this.schema = schema;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
  this.normalizeLists = !this.tags.some(function(r2) {
    if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node) {
      return false;
    }
    var node4 = schema.nodes[r2.node];
    return node4.contentMatch.matchType(node4);
  });
};
DOMParser.prototype.parse = function parse2(dom, options) {
  if (options === void 0)
    options = {};
  var context2 = new ParseContext(this, options, false);
  context2.addAll(dom, null, options.from, options.to);
  return context2.finish();
};
DOMParser.prototype.parseSlice = function parseSlice(dom, options) {
  if (options === void 0)
    options = {};
  var context2 = new ParseContext(this, options, true);
  context2.addAll(dom, null, options.from, options.to);
  return Slice.maxOpen(context2.finish());
};
DOMParser.prototype.matchTag = function matchTag(dom, context2, after2) {
  for (var i2 = after2 ? this.tags.indexOf(after2) + 1 : 0; i2 < this.tags.length; i2++) {
    var rule = this.tags[i2];
    if (matches$1(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context2.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser.prototype.matchStyle = function matchStyle(prop, value, context2, after2) {
  for (var i2 = after2 ? this.styles.indexOf(after2) + 1 : 0; i2 < this.styles.length; i2++) {
    var rule = this.styles[i2];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context2.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser.schemaRules = function schemaRules(schema) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
    for (; i2 < result2.length; i2++) {
      var next = result2[i2], nextPriority = next.priority == null ? 50 : next.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i2, 0, rule);
  }
  var loop = function(name2) {
    var rules = schema.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy2(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy2(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema.nodes)
    loop$1();
  return result2;
};
DOMParser.fromSchema = function fromSchema(schema) {
  return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type2, preserveWhitespace, base2) {
  if (preserveWhitespace != null) {
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  }
  return type2 && type2.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = function NodeContext2(type2, attrs, marks2, pendingMarks, solid, match, options) {
  this.type = type2;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT ? null : type2.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks2;
  this.activeMarks = Mark.none;
  this.pendingMarks = pendingMarks;
  this.stashMarks = [];
};
NodeContext.prototype.findWrapping = function findWrapping2(node4) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment.from(node4));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start4 = this.type.contentMatch, wrap;
      if (wrap = start4.findWrapping(node4.type)) {
        this.match = start4;
        return wrap;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node4.type);
};
NodeContext.prototype.finish = function finish(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content2 = Fragment.from(this.content);
  if (!openEnd && this.match) {
    content2 = content2.append(this.match.fillBefore(Fragment.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
};
NodeContext.prototype.popFromStashMark = function popFromStashMark(mark3) {
  for (var i2 = this.stashMarks.length - 1; i2 >= 0; i2--) {
    if (mark3.eq(this.stashMarks[i2])) {
      return this.stashMarks.splice(i2, 1)[0];
    }
  }
};
NodeContext.prototype.applyPending = function applyPending(nextType) {
  for (var i2 = 0, pending = this.pendingMarks; i2 < pending.length; i2++) {
    var mark3 = pending[i2];
    if ((this.type ? this.type.allowsMarkType(mark3.type) : markMayApply(mark3.type, nextType)) && !mark3.isInSet(this.activeMarks)) {
      this.activeMarks = mark3.addToSet(this.activeMarks);
      this.pendingMarks = mark3.removeFromSet(this.pendingMarks);
    }
  }
};
NodeContext.prototype.inlineContext = function inlineContext(node4) {
  if (this.type) {
    return this.type.inlineContent;
  }
  if (this.content.length) {
    return this.content[0].isInline;
  }
  return node4.parentNode && !blockTags.hasOwnProperty(node4.parentNode.nodeName.toLowerCase());
};
var ParseContext = function ParseContext2(parser2, options, open) {
  this.parser = parser2;
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0);
  if (topNode) {
    topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
  } else if (open) {
    topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
  } else {
    topContext = new NodeContext(parser2.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6 = { top: { configurable: true }, currentPos: { configurable: true } };
prototypeAccessors$6.top.get = function() {
  return this.nodes[this.open];
};
ParseContext.prototype.addDOM = function addDOM(dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style = dom.getAttribute("style");
    var marks2 = style ? this.readStyles(parseStyles(style)) : null, top2 = this.top;
    if (marks2 != null) {
      for (var i2 = 0; i2 < marks2.length; i2++) {
        this.addPendingMark(marks2[i2]);
      }
    }
    this.addElement(dom);
    if (marks2 != null) {
      for (var i$1 = 0; i$1 < marks2.length; i$1++) {
        this.removePendingMark(marks2[i$1], top2);
      }
    }
  }
};
ParseContext.prototype.addTextNode = function addTextNode(dom) {
  var value = dom.nodeValue;
  var top2 = this.top;
  if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top2.options & OPT_PRESERVE_WS)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top2.content[top2.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext.prototype.addElement = function addElement(dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {
    normalizeList(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) {
      this.open = Math.max(0, this.open - 1);
    } else if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync2, top2 = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags.hasOwnProperty(name)) {
      sync2 = true;
      if (!top2.type) {
        this.needsBlock = true;
      }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return;
    }
    this.addAll(dom);
    if (sync2) {
      this.sync(top2);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};
ParseContext.prototype.leafFallback = function leafFallback(dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
    this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
};
ParseContext.prototype.ignoreFallback = function ignoreFallback(dom) {
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
    this.findPlace(this.parser.schema.text("-"));
  }
};
ParseContext.prototype.readStyles = function readStyles(styles2) {
  var marks2 = Mark.none;
  style:
    for (var i2 = 0; i2 < styles2.length; i2 += 2) {
      for (var after2 = null; ; ) {
        var rule = this.parser.matchStyle(styles2[i2], styles2[i2 + 1], this, after2);
        if (!rule) {
          continue style;
        }
        if (rule.ignore) {
          return null;
        }
        marks2 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks2);
        if (rule.consuming === false) {
          after2 = rule;
        } else {
          break;
        }
      }
    }
  return marks2;
};
ParseContext.prototype.addElementByRule = function addElementByRule(dom, rule, continueAfter) {
  var this$1$1 = this;
  var sync2, nodeType2, markType, mark3;
  if (rule.node) {
    nodeType2 = this.parser.schema.nodes[rule.node];
    if (!nodeType2.isLeaf) {
      sync2 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark3 = markType.create(rule.attrs);
    this.addPendingMark(mark3);
  }
  var startIn = this.top;
  if (nodeType2 && nodeType2.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node4) {
      return this$1$1.insertNode(node4);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync2);
  }
  if (sync2) {
    this.sync(startIn);
    this.open--;
  }
  if (mark3) {
    this.removePendingMark(mark3, startIn);
  }
};
ParseContext.prototype.addAll = function addAll(parent, sync2, startIndex, endIndex) {
  var index3 = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end3 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end3; dom = dom.nextSibling, ++index3) {
    this.findAtPoint(parent, index3);
    this.addDOM(dom);
    if (sync2 && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this.sync(sync2);
    }
  }
  this.findAtPoint(parent, index3);
};
ParseContext.prototype.findPlace = function findPlace(node4) {
  var route2, sync2;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx3 = this.nodes[depth];
    var found2 = cx3.findWrapping(node4);
    if (found2 && (!route2 || route2.length > found2.length)) {
      route2 = found2;
      sync2 = cx3;
      if (!found2.length) {
        break;
      }
    }
    if (cx3.solid) {
      break;
    }
  }
  if (!route2) {
    return false;
  }
  this.sync(sync2);
  for (var i2 = 0; i2 < route2.length; i2++) {
    this.enterInner(route2[i2], null, false);
  }
  return true;
};
ParseContext.prototype.insertNode = function insertNode(node4) {
  if (node4.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node4)) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(node4.type);
    if (top2.match) {
      top2.match = top2.match.matchType(node4.type);
    }
    var marks2 = top2.activeMarks;
    for (var i2 = 0; i2 < node4.marks.length; i2++) {
      if (!top2.type || top2.type.allowsMarkType(node4.marks[i2].type)) {
        marks2 = node4.marks[i2].addToSet(marks2);
      }
    }
    top2.content.push(node4.mark(marks2));
    return true;
  }
  return false;
};
ParseContext.prototype.enter = function enter(type2, attrs, preserveWS) {
  var ok2 = this.findPlace(type2.create(attrs));
  if (ok2) {
    this.enterInner(type2, attrs, true, preserveWS);
  }
  return ok2;
};
ParseContext.prototype.enterInner = function enterInner(type2, attrs, solid, preserveWS) {
  this.closeExtra();
  var top2 = this.top;
  top2.applyPending(type2);
  top2.match = top2.match && top2.match.matchType(type2, attrs);
  var options = wsOptionsFor(type2, preserveWS, top2.options);
  if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0) {
    options |= OPT_OPEN_LEFT;
  }
  this.nodes.push(new NodeContext(type2, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
  this.open++;
};
ParseContext.prototype.closeExtra = function closeExtra(openEnd) {
  var i2 = this.nodes.length - 1;
  if (i2 > this.open) {
    for (; i2 > this.open; i2--) {
      this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext.prototype.finish = function finish2() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext.prototype.sync = function sync(to) {
  for (var i2 = this.open; i2 >= 0; i2--) {
    if (this.nodes[i2] == to) {
      this.open = i2;
      return;
    }
  }
};
prototypeAccessors$6.currentPos.get = function() {
  this.closeExtra();
  var pos = 0;
  for (var i2 = this.open; i2 >= 0; i2--) {
    var content2 = this.nodes[i2].content;
    for (var j = content2.length - 1; j >= 0; j--) {
      pos += content2[j].nodeSize;
    }
    if (i2) {
      pos++;
    }
  }
  return pos;
};
ParseContext.prototype.findAtPoint = function findAtPoint(parent, offset3) {
  if (this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].node == parent && this.find[i2].offset == offset3) {
        this.find[i2].pos = this.currentPos;
      }
    }
  }
};
ParseContext.prototype.findInside = function findInside(parent) {
  if (this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
        this.find[i2].pos = this.currentPos;
      }
    }
  }
};
ParseContext.prototype.findAround = function findAround(parent, content2, before2) {
  if (parent != content2 && this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
        var pos = content2.compareDocumentPosition(this.find[i2].node);
        if (pos & (before2 ? 2 : 4)) {
          this.find[i2].pos = this.currentPos;
        }
      }
    }
  }
};
ParseContext.prototype.findInText = function findInText(textNode) {
  if (this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].node == textNode) {
        this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
      }
    }
  }
};
ParseContext.prototype.matchesContext = function matchesContext(context2) {
  var this$1$1 = this;
  if (context2.indexOf("|") > -1) {
    return context2.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context2.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function(i2, depth) {
    for (; i2 >= 0; i2--) {
      var part = parts[i2];
      if (part == "") {
        if (i2 == parts.length - 1 || i2 == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match(i2 - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next || next.name != part && next.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match(parts.length - 1, this.open);
};
ParseContext.prototype.textblockFromContext = function textblockFromContext() {
  var $context = this.options.context;
  if ($context) {
    for (var d2 = $context.depth; d2 >= 0; d2--) {
      var deflt = $context.node(d2).contentMatchAt($context.indexAfter(d2)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this.parser.schema.nodes) {
    var type2 = this.parser.schema.nodes[name];
    if (type2.isTextblock && type2.defaultAttrs) {
      return type2;
    }
  }
};
ParseContext.prototype.addPendingMark = function addPendingMark(mark3) {
  var found2 = findSameMarkInSet(mark3, this.top.pendingMarks);
  if (found2) {
    this.top.stashMarks.push(found2);
  }
  this.top.pendingMarks = mark3.addToSet(this.top.pendingMarks);
};
ParseContext.prototype.removePendingMark = function removePendingMark(mark3, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found2 = level.pendingMarks.lastIndexOf(mark3);
    if (found2 > -1) {
      level.pendingMarks = mark3.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark3.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark3);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
        level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
    }
    if (level == upto) {
      break;
    }
  }
};
Object.defineProperties(ParseContext.prototype, prototypeAccessors$6);
function normalizeList(dom) {
  for (var child3 = dom.firstChild, prevItem = null; child3; child3 = child3.nextSibling) {
    var name = child3.nodeType == 1 ? child3.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child3);
      child3 = prevItem;
    } else if (name == "li") {
      prevItem = child3;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$1(dom, selector2) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector2);
}
function parseStyles(style) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re.exec(style)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy2(obj) {
  var copy5 = {};
  for (var prop in obj) {
    copy5[prop] = obj[prop];
  }
  return copy5;
}
function markMayApply(markType, nodeType2) {
  var nodes = nodeType2.schema.nodes;
  var loop = function(name2) {
    var parent = nodes[name2];
    if (!parent.allowsMarkType(markType)) {
      return;
    }
    var seen = [], scan = function(match) {
      seen.push(match);
      for (var i2 = 0; i2 < match.edgeCount; i2++) {
        var ref2 = match.edge(i2);
        var type2 = ref2.type;
        var next = ref2.next;
        if (type2 == nodeType2) {
          return true;
        }
        if (seen.indexOf(next) < 0 && scan(next)) {
          return true;
        }
      }
    };
    if (scan(parent.contentMatch)) {
      return { v: true };
    }
  };
  for (var name in nodes) {
    var returned = loop(name);
    if (returned)
      return returned.v;
  }
}
function findSameMarkInSet(mark3, set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (mark3.eq(set2[i2])) {
      return set2[i2];
    }
  }
}
var DOMSerializer = function DOMSerializer2(nodes, marks2) {
  this.nodes = nodes || {};
  this.marks = marks2 || {};
};
DOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc(options).createDocumentFragment();
  }
  var top2 = target, active = null;
  fragment.forEach(function(node4) {
    if (active || node4.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node4.marks.length) {
        var next = node4.marks[rendered];
        if (!this$1$1.marks[next.type.name]) {
          rendered++;
          continue;
        }
        if (!next.eq(active[keep]) || next.type.spec.spanning === false) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top2 = active.pop();
        active.pop();
      }
      while (rendered < node4.marks.length) {
        var add2 = node4.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add2, node4.isInline, options);
        if (markDOM) {
          active.push(add2, top2);
          top2.appendChild(markDOM.dom);
          top2 = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top2.appendChild(this$1$1.serializeNodeInner(node4, options));
  });
  return target;
};
DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner(node4, options) {
  if (options === void 0)
    options = {};
  var ref2 = DOMSerializer.renderSpec(doc(options), this.nodes[node4.type.name](node4));
  var dom = ref2.dom;
  var contentDOM = ref2.contentDOM;
  if (contentDOM) {
    if (node4.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node4, contentDOM, options);
    } else {
      this.serializeFragment(node4.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer.prototype.serializeNode = function serializeNode(node4, options) {
  if (options === void 0)
    options = {};
  var dom = this.serializeNodeInner(node4, options);
  for (var i2 = node4.marks.length - 1; i2 >= 0; i2--) {
    var wrap = this.serializeMark(node4.marks[i2], node4.isInline, options);
    if (wrap) {
      (wrap.contentDOM || wrap.dom).appendChild(dom);
      dom = wrap.dom;
    }
  }
  return dom;
};
DOMSerializer.prototype.serializeMark = function serializeMark(mark3, inline2, options) {
  if (options === void 0)
    options = {};
  var toDOM = this.marks[mark3.type.name];
  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark3, inline2));
};
DOMSerializer.renderSpec = function renderSpec(doc2, structure, xmlNS) {
  if (xmlNS === void 0)
    xmlNS = null;
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  if (structure.dom && structure.dom.nodeType != null) {
    return structure;
  }
  var tagName = structure[0], space2 = tagName.indexOf(" ");
  if (space2 > 0) {
    xmlNS = tagName.slice(0, space2);
    tagName = tagName.slice(space2 + 1);
  }
  var contentDOM = null, dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  var attrs = structure[1], start4 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start4 = 2;
    for (var name in attrs) {
      if (attrs[name] != null) {
        var space$1 = name.indexOf(" ");
        if (space$1 > 0) {
          dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);
        } else {
          dom.setAttribute(name, attrs[name]);
        }
      }
    }
  }
  for (var i2 = start4; i2 < structure.length; i2++) {
    var child3 = structure[i2];
    if (child3 === 0) {
      if (i2 < structure.length - 1 || i2 > start4) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref2 = DOMSerializer.renderSpec(doc2, child3, xmlNS);
      var inner = ref2.dom;
      var innerContent = ref2.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer.fromSchema = function fromSchema2(schema) {
  return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
};
DOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {
  var result2 = gatherToDOM(schema.nodes);
  if (!result2.text) {
    result2.text = function(node4) {
      return node4.text;
    };
  }
  return result2;
};
DOMSerializer.marksFromSchema = function marksFromSchema(schema) {
  return gatherToDOM(schema.marks);
};
function gatherToDOM(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) {
      result2[name] = toDOM;
    }
  }
  return result2;
}
function doc(options) {
  return options.document || window.document;
}
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index3, offset3) {
  return index3 + offset3 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var MapResult = function MapResult2(pos, deleted, recover2) {
  if (deleted === void 0)
    deleted = false;
  if (recover2 === void 0)
    recover2 = null;
  this.pos = pos;
  this.deleted = deleted;
  this.recover = recover2;
};
var StepMap = function StepMap2(ranges, inverted) {
  if (inverted === void 0)
    inverted = false;
  if (!ranges.length && StepMap2.empty) {
    return StepMap2.empty;
  }
  this.ranges = ranges;
  this.inverted = inverted;
};
StepMap.prototype.recover = function recover(value) {
  var diff = 0, index3 = recoverIndex(value);
  if (!this.inverted) {
    for (var i2 = 0; i2 < index3; i2++) {
      diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
    }
  }
  return this.ranges[index3 * 3] + diff + recoverOffset(value);
};
StepMap.prototype.mapResult = function mapResult(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
StepMap.prototype.map = function map(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, true);
};
StepMap.prototype._map = function _map(pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i2 = 0; i2 < this.ranges.length; i2 += 3) {
    var start4 = this.ranges[i2] - (this.inverted ? diff : 0);
    if (start4 > pos) {
      break;
    }
    var oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end3 = start4 + oldSize;
    if (pos <= end3) {
      var side = !oldSize ? assoc : pos == start4 ? -1 : pos == end3 ? 1 : assoc;
      var result2 = start4 + diff + (side < 0 ? 0 : newSize);
      if (simple) {
        return result2;
      }
      var recover2 = pos == (assoc < 0 ? start4 : end3) ? null : makeRecover(i2 / 3, pos - start4);
      return new MapResult(result2, assoc < 0 ? pos != start4 : pos != end3, recover2);
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult(pos + diff);
};
StepMap.prototype.touches = function touches(pos, recover2) {
  var diff = 0, index3 = recoverIndex(recover2);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i2 = 0; i2 < this.ranges.length; i2 += 3) {
    var start4 = this.ranges[i2] - (this.inverted ? diff : 0);
    if (start4 > pos) {
      break;
    }
    var oldSize = this.ranges[i2 + oldIndex], end3 = start4 + oldSize;
    if (pos <= end3 && i2 == index3 * 3) {
      return true;
    }
    diff += this.ranges[i2 + newIndex] - oldSize;
  }
  return false;
};
StepMap.prototype.forEach = function forEach3(f2) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
    var start4 = this.ranges[i2], oldStart = start4 - (this.inverted ? diff : 0), newStart = start4 + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
    f2(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};
StepMap.prototype.invert = function invert() {
  return new StepMap(this.ranges, !this.inverted);
};
StepMap.prototype.toString = function toString7() {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
};
StepMap.offset = function offset(n2) {
  return n2 == 0 ? StepMap.empty : new StepMap(n2 < 0 ? [0, -n2, 0] : [0, 0, n2]);
};
StepMap.empty = new StepMap([]);
var Mapping = function Mapping2(maps, mirror, from4, to) {
  this.maps = maps || [];
  this.from = from4 || 0;
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};
Mapping.prototype.slice = function slice2(from4, to) {
  if (from4 === void 0)
    from4 = 0;
  if (to === void 0)
    to = this.maps.length;
  return new Mapping(this.maps, this.mirror, from4, to);
};
Mapping.prototype.copy = function copy3() {
  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
};
Mapping.prototype.appendMap = function appendMap(map16, mirrors) {
  this.to = this.maps.push(map16);
  if (mirrors != null) {
    this.setMirror(this.maps.length - 1, mirrors);
  }
};
Mapping.prototype.appendMapping = function appendMapping(mapping) {
  for (var i2 = 0, startSize = this.maps.length; i2 < mapping.maps.length; i2++) {
    var mirr = mapping.getMirror(i2);
    this.appendMap(mapping.maps[i2], mirr != null && mirr < i2 ? startSize + mirr : null);
  }
};
Mapping.prototype.getMirror = function getMirror(n2) {
  if (this.mirror) {
    for (var i2 = 0; i2 < this.mirror.length; i2++) {
      if (this.mirror[i2] == n2) {
        return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
      }
    }
  }
};
Mapping.prototype.setMirror = function setMirror(n2, m2) {
  if (!this.mirror) {
    this.mirror = [];
  }
  this.mirror.push(n2, m2);
};
Mapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {
  for (var i2 = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i2 >= 0; i2--) {
    var mirr = mapping.getMirror(i2);
    this.appendMap(mapping.maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : null);
  }
};
Mapping.prototype.invert = function invert2() {
  var inverse = new Mapping();
  inverse.appendMappingInverted(this);
  return inverse;
};
Mapping.prototype.map = function map2(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  if (this.mirror) {
    return this._map(pos, assoc, true);
  }
  for (var i2 = this.from; i2 < this.to; i2++) {
    pos = this.maps[i2].map(pos, assoc);
  }
  return pos;
};
Mapping.prototype.mapResult = function mapResult2(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
Mapping.prototype._map = function _map2(pos, assoc, simple) {
  var deleted = false;
  for (var i2 = this.from; i2 < this.to; i2++) {
    var map16 = this.maps[i2], result2 = map16.mapResult(pos, assoc);
    if (result2.recover != null) {
      var corr = this.getMirror(i2);
      if (corr != null && corr > i2 && corr < this.to) {
        i2 = corr;
        pos = this.maps[corr].recover(result2.recover);
        continue;
      }
    }
    if (result2.deleted) {
      deleted = true;
    }
    pos = result2.pos;
  }
  return simple ? pos : new MapResult(pos, deleted);
};
function TransformError(message) {
  var err2 = Error.call(this, message);
  err2.__proto__ = TransformError.prototype;
  return err2;
}
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = function Transform2(doc2) {
  this.doc = doc2;
  this.steps = [];
  this.docs = [];
  this.mapping = new Mapping();
};
var prototypeAccessors$4 = { before: { configurable: true }, docChanged: { configurable: true } };
prototypeAccessors$4.before.get = function() {
  return this.docs.length ? this.docs[0] : this.doc;
};
Transform.prototype.step = function step(object2) {
  var result2 = this.maybeStep(object2);
  if (result2.failed) {
    throw new TransformError(result2.failed);
  }
  return this;
};
Transform.prototype.maybeStep = function maybeStep(step2) {
  var result2 = step2.apply(this.doc);
  if (!result2.failed) {
    this.addStep(step2, result2.doc);
  }
  return result2;
};
prototypeAccessors$4.docChanged.get = function() {
  return this.steps.length > 0;
};
Transform.prototype.addStep = function addStep(step2, doc2) {
  this.docs.push(this.doc);
  this.steps.push(step2);
  this.mapping.appendMap(step2.getMap());
  this.doc = doc2;
};
Object.defineProperties(Transform.prototype, prototypeAccessors$4);
function mustOverride() {
  throw new Error("Override me");
}
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = function Step2() {
};
Step.prototype.apply = function apply(_doc) {
  return mustOverride();
};
Step.prototype.getMap = function getMap() {
  return StepMap.empty;
};
Step.prototype.invert = function invert3(_doc) {
  return mustOverride();
};
Step.prototype.map = function map3(_mapping) {
  return mustOverride();
};
Step.prototype.merge = function merge(_other) {
  return null;
};
Step.prototype.toJSON = function toJSON5() {
  return mustOverride();
};
Step.fromJSON = function fromJSON5(schema, json) {
  if (!json || !json.stepType) {
    throw new RangeError("Invalid input for Step.fromJSON");
  }
  var type2 = stepsByID[json.stepType];
  if (!type2) {
    throw new RangeError("No step type " + json.stepType + " defined");
  }
  return type2.fromJSON(schema, json);
};
Step.jsonID = function jsonID(id, stepClass) {
  if (id in stepsByID) {
    throw new RangeError("Duplicate use of step JSON ID " + id);
  }
  stepsByID[id] = stepClass;
  stepClass.prototype.jsonID = id;
  return stepClass;
};
var StepResult = function StepResult2(doc2, failed) {
  this.doc = doc2;
  this.failed = failed;
};
StepResult.ok = function ok(doc2) {
  return new StepResult(doc2, null);
};
StepResult.fail = function fail(message) {
  return new StepResult(null, message);
};
StepResult.fromReplace = function fromReplace(doc2, from4, to, slice5) {
  try {
    return StepResult.ok(doc2.replace(from4, to, slice5));
  } catch (e2) {
    if (e2 instanceof ReplaceError) {
      return StepResult.fail(e2.message);
    }
    throw e2;
  }
};
var ReplaceStep = /* @__PURE__ */ function(Step3) {
  function ReplaceStep2(from4, to, slice5, structure) {
    Step3.call(this);
    this.from = from4;
    this.to = to;
    this.slice = slice5;
    this.structure = !!structure;
  }
  if (Step3)
    ReplaceStep2.__proto__ = Step3;
  ReplaceStep2.prototype = Object.create(Step3 && Step3.prototype);
  ReplaceStep2.prototype.constructor = ReplaceStep2;
  ReplaceStep2.prototype.apply = function apply8(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to)) {
      return StepResult.fail("Structure replace would overwrite content");
    }
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  };
  ReplaceStep2.prototype.getMap = function getMap2() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  };
  ReplaceStep2.prototype.invert = function invert4(doc2) {
    return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  };
  ReplaceStep2.prototype.map = function map16(mapping) {
    var from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from4.deleted && to.deleted) {
      return null;
    }
    return new ReplaceStep2(from4.pos, Math.max(from4.pos, to.pos), this.slice);
  };
  ReplaceStep2.prototype.merge = function merge3(other) {
    if (!(other instanceof ReplaceStep2) || other.structure || this.structure) {
      return null;
    }
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice5 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice5, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep2(other.from, this.to, slice$1, this.structure);
    } else {
      return null;
    }
  };
  ReplaceStep2.prototype.toJSON = function toJSON7() {
    var json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceStep2.fromJSON = function fromJSON8(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    }
    return new ReplaceStep2(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  };
  return ReplaceStep2;
}(Step);
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = /* @__PURE__ */ function(Step3) {
  function ReplaceAroundStep2(from4, to, gapFrom, gapTo, slice5, insert, structure) {
    Step3.call(this);
    this.from = from4;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice5;
    this.insert = insert;
    this.structure = !!structure;
  }
  if (Step3)
    ReplaceAroundStep2.__proto__ = Step3;
  ReplaceAroundStep2.prototype = Object.create(Step3 && Step3.prototype);
  ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
  ReplaceAroundStep2.prototype.apply = function apply8(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to))) {
      return StepResult.fail("Structure gap-replace would overwrite content");
    }
    var gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd) {
      return StepResult.fail("Gap is not a flat range");
    }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) {
      return StepResult.fail("Content does not fit in gap");
    }
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  };
  ReplaceAroundStep2.prototype.getMap = function getMap2() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  };
  ReplaceAroundStep2.prototype.invert = function invert4(doc2) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  };
  ReplaceAroundStep2.prototype.map = function map16(mapping) {
    var from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from4.deleted && to.deleted || gapFrom < from4.pos || gapTo > to.pos) {
      return null;
    }
    return new ReplaceAroundStep2(from4.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  };
  ReplaceAroundStep2.prototype.toJSON = function toJSON7() {
    var json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceAroundStep2.fromJSON = function fromJSON8(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    }
    return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  };
  return ReplaceAroundStep2;
}(Step);
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from4, to) {
  var $from = doc2.resolve(from4), dist = to - from4, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) {
        return true;
      }
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function canCut(node4, start4, end3) {
  return (start4 == 0 || node4.canReplace(start4, node4.childCount)) && (end3 == node4.childCount || node4.canReplace(0, end3));
}
function liftTarget(range2) {
  var parent = range2.parent;
  var content2 = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
  for (var depth = range2.depth; ; --depth) {
    var node4 = range2.$from.node(depth);
    var index3 = range2.$from.index(depth), endIndex = range2.$to.indexAfter(depth);
    if (depth < range2.depth && node4.canReplace(index3, endIndex, content2)) {
      return depth;
    }
    if (depth == 0 || node4.type.spec.isolating || !canCut(node4, index3, endIndex)) {
      break;
    }
  }
}
Transform.prototype.lift = function(range2, target) {
  var $from = range2.$from;
  var $to = range2.$to;
  var depth = range2.depth;
  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start4 = gapStart, end3 = gapEnd;
  var before2 = Fragment.empty, openStart = 0;
  for (var d2 = depth, splitting = false; d2 > target; d2--) {
    if (splitting || $from.index(d2) > 0) {
      splitting = true;
      before2 = Fragment.from($from.node(d2).copy(before2));
      openStart++;
    } else {
      start4--;
    }
  }
  var after2 = Fragment.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
    if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after2 = Fragment.from($to.node(d$1).copy(after2));
      openEnd++;
    } else {
      end3++;
    }
  }
  return this.step(new ReplaceAroundStep(start4, end3, gapStart, gapEnd, new Slice(before2.append(after2), openStart, openEnd), before2.size - openStart, true));
};
function findWrapping3(range2, nodeType2, attrs, innerRange) {
  if (innerRange === void 0)
    innerRange = range2;
  var around = findWrappingOutside(range2, nodeType2);
  var inner = around && findWrappingInside(innerRange, nodeType2);
  if (!inner) {
    return null;
  }
  return around.map(withAttrs).concat({ type: nodeType2, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type2) {
  return { type: type2, attrs: null };
}
function findWrappingOutside(range2, type2) {
  var parent = range2.parent;
  var startIndex = range2.startIndex;
  var endIndex = range2.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type2);
  if (!around) {
    return null;
  }
  var outer = around.length ? around[0] : type2;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range2, type2) {
  var parent = range2.parent;
  var startIndex = range2.startIndex;
  var endIndex = range2.endIndex;
  var inner = parent.child(startIndex);
  var inside = type2.contentMatch.findWrapping(inner.type);
  if (!inside) {
    return null;
  }
  var lastType = inside.length ? inside[inside.length - 1] : type2;
  var innerMatch = lastType.contentMatch;
  for (var i2 = startIndex; innerMatch && i2 < endIndex; i2++) {
    innerMatch = innerMatch.matchType(parent.child(i2).type);
  }
  if (!innerMatch || !innerMatch.validEnd) {
    return null;
  }
  return inside;
}
Transform.prototype.wrap = function(range2, wrappers) {
  var content2 = Fragment.empty;
  for (var i2 = wrappers.length - 1; i2 >= 0; i2--) {
    if (content2.size) {
      var match = wrappers[i2].type.contentMatch.matchFragment(content2);
      if (!match || !match.validEnd) {
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
    }
    content2 = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content2));
  }
  var start4 = range2.start, end3 = range2.end;
  return this.step(new ReplaceAroundStep(start4, end3, start4, end3, new Slice(content2, 0, 0), wrappers.length, true));
};
Transform.prototype.setBlockType = function(from4, to, type2, attrs) {
  var this$1$1 = this;
  if (to === void 0)
    to = from4;
  if (!type2.isTextblock) {
    throw new RangeError("Type given to setBlockType should be a textblock");
  }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from4, to, function(node4, pos) {
    if (node4.isTextblock && !node4.hasMarkup(type2, attrs) && canChangeType(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type2)) {
      this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type2);
      var mapping = this$1$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node4.nodeSize, 1);
      this$1$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type2.create(attrs, null, node4.marks)), 0, 0), 1, true));
      return false;
    }
  });
  return this;
};
function canChangeType(doc2, pos, type2) {
  var $pos = doc2.resolve(pos), index3 = $pos.index();
  return $pos.parent.canReplaceWith(index3, index3 + 1, type2);
}
Transform.prototype.setNodeMarkup = function(pos, type2, attrs, marks2) {
  var node4 = this.doc.nodeAt(pos);
  if (!node4) {
    throw new RangeError("No node at given position");
  }
  if (!type2) {
    type2 = node4.type;
  }
  var newNode = type2.create(attrs, null, marks2 || node4.marks);
  if (node4.isLeaf) {
    return this.replaceWith(pos, pos + node4.nodeSize, newNode);
  }
  if (!type2.validContent(node4.content)) {
    throw new RangeError("Invalid content for node type " + type2.name);
  }
  return this.step(new ReplaceAroundStep(pos, pos + node4.nodeSize, pos + 1, pos + node4.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
};
function canSplit(doc2, pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {
    return false;
  }
  for (var d2 = $pos.depth - 1, i2 = depth - 2; d2 > base2; d2--, i2--) {
    var node4 = $pos.node(d2), index$1 = $pos.index(d2);
    if (node4.type.spec.isolating) {
      return false;
    }
    var rest = node4.content.cutByIndex(index$1, node4.childCount);
    var after2 = typesAfter && typesAfter[i2] || node4;
    if (after2 != node4) {
      rest = rest.replaceChild(0, after2.type.create(after2.attrs));
    }
    if (!node4.canReplace(index$1 + 1, node4.childCount) || !after2.type.validContent(rest)) {
      return false;
    }
  }
  var index3 = $pos.indexAfter(base2);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index3, index3, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
Transform.prototype.split = function(pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = this.doc.resolve(pos), before2 = Fragment.empty, after2 = Fragment.empty;
  for (var d2 = $pos.depth, e2 = $pos.depth - depth, i2 = depth - 1; d2 > e2; d2--, i2--) {
    before2 = Fragment.from($pos.node(d2).copy(before2));
    var typeAfter = typesAfter && typesAfter[i2];
    after2 = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after2) : $pos.node(d2).copy(after2));
  }
  return this.step(new ReplaceStep(pos, pos, new Slice(before2.append(after2), depth, depth), true));
};
function canJoin(doc2, pos) {
  var $pos = doc2.resolve(pos), index3 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index3, index3 + 1);
}
function joinable(a2, b) {
  return a2 && b && !a2.isLeaf && a2.canAppend(b);
}
Transform.prototype.join = function(pos, depth) {
  if (depth === void 0)
    depth = 1;
  var step2 = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  return this.step(step2);
};
function insertPoint(doc2, pos, nodeType2) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
    return pos;
  }
  if ($pos.parentOffset == 0) {
    for (var d2 = $pos.depth - 1; d2 >= 0; d2--) {
      var index3 = $pos.index(d2);
      if ($pos.node(d2).canReplaceWith(index3, index3, nodeType2)) {
        return $pos.before(d2 + 1);
      }
      if (index3 > 0) {
        return null;
      }
    }
  }
  if ($pos.parentOffset == $pos.parent.content.size) {
    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType2)) {
        return $pos.after(d$1 + 1);
      }
      if (index$1 < $pos.node(d$1).childCount) {
        return null;
      }
    }
  }
}
function dropPoint(doc2, pos, slice5) {
  var $pos = doc2.resolve(pos);
  if (!slice5.content.size) {
    return pos;
  }
  var content2 = slice5.content;
  for (var i2 = 0; i2 < slice5.openStart; i2++) {
    content2 = content2.firstChild.content;
  }
  for (var pass = 1; pass <= (slice5.openStart == 0 && slice5.size ? 2 : 1); pass++) {
    for (var d2 = $pos.depth; d2 >= 0; d2--) {
      var bias = d2 == $pos.depth ? 0 : $pos.pos <= ($pos.start(d2 + 1) + $pos.end(d2 + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d2) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d2), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content2);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content2.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits) {
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d2 + 1) : $pos.after(d2 + 1);
      }
    }
  }
  return null;
}
function mapFragment(fragment, f2, parent) {
  var mapped = [];
  for (var i2 = 0; i2 < fragment.childCount; i2++) {
    var child3 = fragment.child(i2);
    if (child3.content.size) {
      child3 = child3.copy(mapFragment(child3.content, f2, child3));
    }
    if (child3.isInline) {
      child3 = f2(child3, parent, i2);
    }
    mapped.push(child3);
  }
  return Fragment.fromArray(mapped);
}
var AddMarkStep = /* @__PURE__ */ function(Step3) {
  function AddMarkStep2(from4, to, mark3) {
    Step3.call(this);
    this.from = from4;
    this.to = to;
    this.mark = mark3;
  }
  if (Step3)
    AddMarkStep2.__proto__ = Step3;
  AddMarkStep2.prototype = Object.create(Step3 && Step3.prototype);
  AddMarkStep2.prototype.constructor = AddMarkStep2;
  AddMarkStep2.prototype.apply = function apply8(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice5 = new Slice(mapFragment(oldSlice.content, function(node4, parent2) {
      if (!node4.isAtom || !parent2.type.allowsMarkType(this$1$1.mark.type)) {
        return node4;
      }
      return node4.mark(this$1$1.mark.addToSet(node4.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice5);
  };
  AddMarkStep2.prototype.invert = function invert4() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  };
  AddMarkStep2.prototype.map = function map16(mapping) {
    var from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from4.deleted && to.deleted || from4.pos >= to.pos) {
      return null;
    }
    return new AddMarkStep2(from4.pos, to.pos, this.mark);
  };
  AddMarkStep2.prototype.merge = function merge3(other) {
    if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  AddMarkStep2.prototype.toJSON = function toJSON7() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  AddMarkStep2.fromJSON = function fromJSON8(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    }
    return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return AddMarkStep2;
}(Step);
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = /* @__PURE__ */ function(Step3) {
  function RemoveMarkStep2(from4, to, mark3) {
    Step3.call(this);
    this.from = from4;
    this.to = to;
    this.mark = mark3;
  }
  if (Step3)
    RemoveMarkStep2.__proto__ = Step3;
  RemoveMarkStep2.prototype = Object.create(Step3 && Step3.prototype);
  RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
  RemoveMarkStep2.prototype.apply = function apply8(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to);
    var slice5 = new Slice(mapFragment(oldSlice.content, function(node4) {
      return node4.mark(this$1$1.mark.removeFromSet(node4.marks));
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice5);
  };
  RemoveMarkStep2.prototype.invert = function invert4() {
    return new AddMarkStep(this.from, this.to, this.mark);
  };
  RemoveMarkStep2.prototype.map = function map16(mapping) {
    var from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from4.deleted && to.deleted || from4.pos >= to.pos) {
      return null;
    }
    return new RemoveMarkStep2(from4.pos, to.pos, this.mark);
  };
  RemoveMarkStep2.prototype.merge = function merge3(other) {
    if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  RemoveMarkStep2.prototype.toJSON = function toJSON7() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  RemoveMarkStep2.fromJSON = function fromJSON8(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    }
    return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return RemoveMarkStep2;
}(Step);
Step.jsonID("removeMark", RemoveMarkStep);
Transform.prototype.addMark = function(from4, to, mark3) {
  var this$1$1 = this;
  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from4, to, function(node4, pos, parent) {
    if (!node4.isInline) {
      return;
    }
    var marks2 = node4.marks;
    if (!mark3.isInSet(marks2) && parent.type.allowsMarkType(mark3.type)) {
      var start4 = Math.max(pos, from4), end3 = Math.min(pos + node4.nodeSize, to);
      var newSet = mark3.addToSet(marks2);
      for (var i2 = 0; i2 < marks2.length; i2++) {
        if (!marks2[i2].isInSet(newSet)) {
          if (removing && removing.to == start4 && removing.mark.eq(marks2[i2])) {
            removing.to = end3;
          } else {
            removed.push(removing = new RemoveMarkStep(start4, end3, marks2[i2]));
          }
        }
      }
      if (adding && adding.to == start4) {
        adding.to = end3;
      } else {
        added.push(adding = new AddMarkStep(start4, end3, mark3));
      }
    }
  });
  removed.forEach(function(s2) {
    return this$1$1.step(s2);
  });
  added.forEach(function(s2) {
    return this$1$1.step(s2);
  });
  return this;
};
Transform.prototype.removeMark = function(from4, to, mark3) {
  var this$1$1 = this;
  if (mark3 === void 0)
    mark3 = null;
  var matched = [], step2 = 0;
  this.doc.nodesBetween(from4, to, function(node4, pos) {
    if (!node4.isInline) {
      return;
    }
    step2++;
    var toRemove = null;
    if (mark3 instanceof MarkType) {
      var set2 = node4.marks, found2;
      while (found2 = mark3.isInSet(set2)) {
        (toRemove || (toRemove = [])).push(found2);
        set2 = found2.removeFromSet(set2);
      }
    } else if (mark3) {
      if (mark3.isInSet(node4.marks)) {
        toRemove = [mark3];
      }
    } else {
      toRemove = node4.marks;
    }
    if (toRemove && toRemove.length) {
      var end3 = Math.min(pos + node4.nodeSize, to);
      for (var i2 = 0; i2 < toRemove.length; i2++) {
        var style = toRemove[i2], found$1 = void 0;
        for (var j = 0; j < matched.length; j++) {
          var m2 = matched[j];
          if (m2.step == step2 - 1 && style.eq(matched[j].style)) {
            found$1 = m2;
          }
        }
        if (found$1) {
          found$1.to = end3;
          found$1.step = step2;
        } else {
          matched.push({ style, from: Math.max(pos, from4), to: end3, step: step2 });
        }
      }
    }
  });
  matched.forEach(function(m2) {
    return this$1$1.step(new RemoveMarkStep(m2.from, m2.to, m2.style));
  });
  return this;
};
Transform.prototype.clearIncompatible = function(pos, parentType, match) {
  if (match === void 0)
    match = parentType.contentMatch;
  var node4 = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i2 = 0; i2 < node4.childCount; i2++) {
    var child3 = node4.child(i2), end3 = cur + child3.nodeSize;
    var allowed = match.matchType(child3.type, child3.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end3, Slice.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child3.marks.length; j++) {
        if (!parentType.allowsMarkType(child3.marks[j].type)) {
          this.step(new RemoveMarkStep(cur, end3, child3.marks[j]));
        }
      }
    }
    cur = end3;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(Fragment.empty, true);
    this.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
    this.step(delSteps[i$1]);
  }
  return this;
};
function replaceStep(doc2, from4, to, slice5) {
  if (to === void 0)
    to = from4;
  if (slice5 === void 0)
    slice5 = Slice.empty;
  if (from4 == to && !slice5.size) {
    return null;
  }
  var $from = doc2.resolve(from4), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice5)) {
    return new ReplaceStep(from4, to, slice5);
  }
  return new Fitter($from, $to, slice5).fit();
}
Transform.prototype.replace = function(from4, to, slice5) {
  if (to === void 0)
    to = from4;
  if (slice5 === void 0)
    slice5 = Slice.empty;
  var step2 = replaceStep(this.doc, from4, to, slice5);
  if (step2) {
    this.step(step2);
  }
  return this;
};
Transform.prototype.replaceWith = function(from4, to, content2) {
  return this.replace(from4, to, new Slice(Fragment.from(content2), 0, 0));
};
Transform.prototype.delete = function(from4, to) {
  return this.replace(from4, to, Slice.empty);
};
Transform.prototype.insert = function(pos, content2) {
  return this.replaceWith(pos, pos, content2);
};
function fitsTrivially($from, $to, slice5) {
  return !slice5.openStart && !slice5.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice5.content);
}
var Fitter = function Fitter2($from, $to, slice5) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice5;
  this.frontier = [];
  for (var i2 = 0; i2 <= $from.depth; i2++) {
    var node4 = $from.node(i2);
    this.frontier.push({
      type: node4.type,
      match: node4.contentMatchAt($from.indexAfter(i2))
    });
  }
  this.placed = Fragment.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--) {
    this.placed = Fragment.from($from.node(i$1).copy(this.placed));
  }
};
var prototypeAccessors$1$2 = { depth: { configurable: true } };
prototypeAccessors$1$2.depth.get = function() {
  return this.frontier.length - 1;
};
Fitter.prototype.fit = function fit() {
  while (this.unplaced.size) {
    var fit2 = this.findFittable();
    if (fit2) {
      this.placeNodes(fit2);
    } else {
      this.openMore() || this.dropNode();
    }
  }
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) {
    return null;
  }
  var content2 = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content2.childCount == 1) {
    content2 = content2.firstChild.content;
    openStart--;
    openEnd--;
  }
  var slice5 = new Slice(content2, openStart, openEnd);
  if (moveInline > -1) {
    return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice5, placedSize);
  }
  if (slice5.size || $from.pos != this.$to.pos) {
    return new ReplaceStep($from.pos, $to.pos, slice5);
  }
};
Fitter.prototype.findFittable = function findFittable() {
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = void 0, parent = void 0;
      if (sliceDepth) {
        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref2 = this.frontier[frontierDepth];
        var type2 = ref2.type;
        var match = ref2.match;
        var wrap = void 0, inject = void 0;
        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : type2.compatibleContent(parent.type))) {
          return { sliceDepth, frontierDepth, parent, inject };
        } else if (pass == 2 && first && (wrap = match.findWrapping(first.type))) {
          return { sliceDepth, frontierDepth, parent, wrap };
        }
        if (parent && match.matchType(parent.type)) {
          break;
        }
      }
    }
  }
};
Fitter.prototype.openMore = function openMore() {
  var ref2 = this.unplaced;
  var content2 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt(content2, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) {
    return false;
  }
  this.unplaced = new Slice(content2, openStart + 1, Math.max(openEnd, inner.size + openStart >= content2.size - openEnd ? openStart + 1 : 0));
  return true;
};
Fitter.prototype.dropNode = function dropNode() {
  var ref2 = this.unplaced;
  var content2 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt(content2, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content2.size - openStart <= openStart + inner.size;
    this.unplaced = new Slice(dropFromFragment(content2, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new Slice(dropFromFragment(content2, openStart, 1), openStart, openEnd);
  }
};
Fitter.prototype.placeNodes = function placeNodes(ref2) {
  var sliceDepth = ref2.sliceDepth;
  var frontierDepth = ref2.frontierDepth;
  var parent = ref2.parent;
  var inject = ref2.inject;
  var wrap = ref2.wrap;
  while (this.depth > frontierDepth) {
    this.closeFrontierNode();
  }
  if (wrap) {
    for (var i2 = 0; i2 < wrap.length; i2++) {
      this.openFrontierNode(wrap[i2]);
    }
  }
  var slice5 = this.unplaced, fragment = parent ? parent.content : slice5.content;
  var openStart = slice5.openStart - sliceDepth;
  var taken = 0, add2 = [];
  var ref$1 = this.frontier[frontierDepth];
  var match = ref$1.match;
  var type2 = ref$1.type;
  if (inject) {
    for (var i$1 = 0; i$1 < inject.childCount; i$1++) {
      add2.push(inject.child(i$1));
    }
    match = match.matchFragment(inject);
  }
  var openEndCount = fragment.size + sliceDepth - (slice5.content.size - slice5.openEnd);
  while (taken < fragment.childCount) {
    var next = fragment.child(taken), matches2 = match.matchType(next.type);
    if (!matches2) {
      break;
    }
    taken++;
    if (taken > 1 || openStart == 0 || next.content.size) {
      match = matches2;
      add2.push(closeNodeStart(next.mark(type2.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) {
    openEndCount = -1;
  }
  this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));
  this.frontier[frontierDepth].match = match;
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
    this.closeFrontierNode();
  }
  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
    var node4 = cur.lastChild;
    this.frontier.push({ type: node4.type, match: node4.contentMatchAt(node4.childCount) });
    cur = node4.content;
  }
  this.unplaced = !toEnd ? new Slice(dropFromFragment(slice5.content, sliceDepth, taken), slice5.openStart, slice5.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice5.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice5.openEnd : sliceDepth - 1);
};
Fitter.prototype.mustMoveInline = function mustMoveInline() {
  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
    return -1;
  }
  var top2 = this.frontier[this.depth], level;
  if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
    return -1;
  }
  var ref2 = this.$to;
  var depth = ref2.depth;
  var after2 = this.$to.after(depth);
  while (depth > 1 && after2 == this.$to.end(--depth)) {
    ++after2;
  }
  return after2;
};
Fitter.prototype.findCloseLevel = function findCloseLevel($to) {
  scan:
    for (var i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
      var ref2 = this.frontier[i2];
      var match = ref2.match;
      var type2 = ref2.type;
      var dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
      var fit2 = contentAfterFits($to, i2, type2, match, dropInner);
      if (!fit2) {
        continue;
      }
      for (var d2 = i2 - 1; d2 >= 0; d2--) {
        var ref$1 = this.frontier[d2];
        var match$1 = ref$1.match;
        var type$1 = ref$1.type;
        var matches2 = contentAfterFits($to, d2, type$1, match$1, true);
        if (!matches2 || matches2.childCount) {
          continue scan;
        }
      }
      return { depth: i2, fit: fit2, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
    }
};
Fitter.prototype.close = function close2($to) {
  var close3 = this.findCloseLevel($to);
  if (!close3) {
    return null;
  }
  while (this.depth > close3.depth) {
    this.closeFrontierNode();
  }
  if (close3.fit.childCount) {
    this.placed = addToFragment(this.placed, close3.depth, close3.fit);
  }
  $to = close3.move;
  for (var d2 = close3.depth + 1; d2 <= $to.depth; d2++) {
    var node4 = $to.node(d2), add2 = node4.type.contentMatch.fillBefore(node4.content, true, $to.index(d2));
    this.openFrontierNode(node4.type, node4.attrs, add2);
  }
  return $to;
};
Fitter.prototype.openFrontierNode = function openFrontierNode(type2, attrs, content2) {
  var top2 = this.frontier[this.depth];
  top2.match = top2.match.matchType(type2);
  this.placed = addToFragment(this.placed, this.depth, Fragment.from(type2.create(attrs, content2)));
  this.frontier.push({ type: type2, match: type2.contentMatch });
};
Fitter.prototype.closeFrontierNode = function closeFrontierNode() {
  var open = this.frontier.pop();
  var add2 = open.match.fillBefore(Fragment.empty, true);
  if (add2.childCount) {
    this.placed = addToFragment(this.placed, this.frontier.length, add2);
  }
};
Object.defineProperties(Fitter.prototype, prototypeAccessors$1$2);
function dropFromFragment(fragment, depth, count) {
  if (depth == 0) {
    return fragment.cutByIndex(count);
  }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content2) {
  if (depth == 0) {
    return fragment.append(content2);
  }
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content2)));
}
function contentAt(fragment, depth) {
  for (var i2 = 0; i2 < depth; i2++) {
    fragment = fragment.firstChild.content;
  }
  return fragment;
}
function closeNodeStart(node4, openStart, openEnd) {
  if (openStart <= 0) {
    return node4;
  }
  var frag = node4.content;
  if (openStart > 1) {
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  }
  if (openStart > 0) {
    frag = node4.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) {
      frag = frag.append(node4.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
  }
  return node4.copy(frag);
}
function contentAfterFits($to, depth, type2, match, open) {
  var node4 = $to.node(depth), index3 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index3 == node4.childCount && !type2.compatibleContent(node4.type)) {
    return null;
  }
  var fit2 = match.fillBefore(node4.content, true, index3);
  return fit2 && !invalidMarks(type2, node4.content, index3) ? fit2 : null;
}
function invalidMarks(type2, fragment, start4) {
  for (var i2 = start4; i2 < fragment.childCount; i2++) {
    if (!type2.allowsMarks(fragment.child(i2).marks)) {
      return true;
    }
  }
  return false;
}
Transform.prototype.replaceRange = function(from4, to, slice5) {
  if (!slice5.size) {
    return this.deleteRange(from4, to);
  }
  var $from = this.doc.resolve(from4), $to = this.doc.resolve(to);
  if (fitsTrivially($from, $to, slice5)) {
    return this.step(new ReplaceStep(from4, to, slice5));
  }
  var targetDepths = coveredDepths($from, this.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) {
    targetDepths.pop();
  }
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (var d2 = $from.depth, pos = $from.pos - 1; d2 > 0; d2--, pos--) {
    var spec = $from.node(d2).type.spec;
    if (spec.defining || spec.isolating) {
      break;
    }
    if (targetDepths.indexOf(d2) > -1) {
      preferredTarget = d2;
    } else if ($from.before(d2) == pos) {
      targetDepths.splice(1, 0, -d2);
    }
  }
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [], preferredDepth = slice5.openStart;
  for (var content2 = slice5.content, i2 = 0; ; i2++) {
    var node4 = content2.firstChild;
    leftNodes.push(node4);
    if (i2 == slice5.openStart) {
      break;
    }
    content2 = node4.content;
  }
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
    preferredDepth -= 1;
  } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
    preferredDepth -= 2;
  }
  for (var j = slice5.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice5.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) {
      continue;
    }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index3, index3, insert.type, insert.marks)) {
        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice5.content, 0, slice5.openStart, openDepth), openDepth, slice5.openEnd));
      }
    }
  }
  var startSteps = this.steps.length;
  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
    this.replace(from4, to, slice5);
    if (this.steps.length > startSteps) {
      break;
    }
    var depth = targetDepths[i$2];
    if (depth < 0) {
      continue;
    }
    from4 = $from.before(depth);
    to = $to.after(depth);
  }
  return this;
};
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start4 = match.fillBefore(fragment).append(fragment);
    fragment = start4.append(match.matchFragment(start4).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
Transform.prototype.replaceRangeWith = function(from4, to, node4) {
  if (!node4.isInline && from4 == to && this.doc.resolve(from4).parent.content.size) {
    var point = insertPoint(this.doc, from4, node4.type);
    if (point != null) {
      from4 = to = point;
    }
  }
  return this.replaceRange(from4, to, new Slice(Fragment.from(node4), 0, 0));
};
Transform.prototype.deleteRange = function(from4, to) {
  var $from = this.doc.resolve(from4), $to = this.doc.resolve(to);
  var covered = coveredDepths($from, $to);
  for (var i2 = 0; i2 < covered.length; i2++) {
    var depth = covered[i2], last = i2 == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
      return this.delete($from.start(depth), $to.end(depth));
    }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
      return this.delete($from.before(depth), $to.after(depth));
    }
  }
  for (var d2 = 1; d2 <= $from.depth && d2 <= $to.depth; d2++) {
    if (from4 - $from.start(d2) == $from.depth - d2 && to > $from.end(d2) && $to.end(d2) - to != $to.depth - d2) {
      return this.delete($from.before(d2), to);
    }
  }
  return this.delete(from4, to);
};
function coveredDepths($from, $to) {
  var result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d2 = minDepth; d2 >= 0; d2--) {
    var start4 = $from.start(d2);
    if (start4 < $from.pos - ($from.depth - d2) || $to.end(d2) > $to.pos + ($to.depth - d2) || $from.node(d2).type.spec.isolating || $to.node(d2).type.spec.isolating) {
      break;
    }
    if (start4 == $to.start(d2) || d2 == $from.depth && d2 == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d2 && $to.start(d2 - 1) == start4 - 1) {
      result2.push(d2);
    }
  }
  return result2;
}
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = function Selection2($anchor, $head, ranges) {
  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  this.$anchor = $anchor;
  this.$head = $head;
};
var prototypeAccessors$3 = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
prototypeAccessors$3.anchor.get = function() {
  return this.$anchor.pos;
};
prototypeAccessors$3.head.get = function() {
  return this.$head.pos;
};
prototypeAccessors$3.from.get = function() {
  return this.$from.pos;
};
prototypeAccessors$3.to.get = function() {
  return this.$to.pos;
};
prototypeAccessors$3.$from.get = function() {
  return this.ranges[0].$from;
};
prototypeAccessors$3.$to.get = function() {
  return this.ranges[0].$to;
};
prototypeAccessors$3.empty.get = function() {
  var ranges = this.ranges;
  for (var i2 = 0; i2 < ranges.length; i2++) {
    if (ranges[i2].$from.pos != ranges[i2].$to.pos) {
      return false;
    }
  }
  return true;
};
Selection.prototype.content = function content() {
  return this.$from.node(0).slice(this.from, this.to, true);
};
Selection.prototype.replace = function replace2(tr, content2) {
  if (content2 === void 0)
    content2 = Slice.empty;
  var lastNode = content2.content.lastChild, lastParent = null;
  for (var i2 = 0; i2 < content2.openEnd; i2++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$1 = 0; i$1 < ranges.length; i$1++) {
    var ref2 = ranges[i$1];
    var $from = ref2.$from;
    var $to = ref2.$to;
    var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content2);
    if (i$1 == 0) {
      selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
};
Selection.prototype.replaceWith = function replaceWith(tr, node4) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i2 = 0; i2 < ranges.length; i2++) {
    var ref2 = ranges[i2];
    var $from = ref2.$from;
    var $to = ref2.$to;
    var mapping = tr.mapping.slice(mapFrom);
    var from4 = mapping.map($from.pos), to = mapping.map($to.pos);
    if (i2) {
      tr.deleteRange(from4, to);
    } else {
      tr.replaceRangeWith(from4, to, node4);
      selectionToInsertionEnd(tr, mapFrom, node4.isInline ? -1 : 1);
    }
  }
};
Selection.findFrom = function findFrom($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) {
    return inner;
  }
  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found2) {
      return found2;
    }
  }
};
Selection.near = function near($pos, bias) {
  if (bias === void 0)
    bias = 1;
  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
};
Selection.atStart = function atStart(doc2) {
  return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
};
Selection.atEnd = function atEnd(doc2) {
  return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
};
Selection.fromJSON = function fromJSON6(doc2, json) {
  if (!json || !json.type) {
    throw new RangeError("Invalid input for Selection.fromJSON");
  }
  var cls = classesById[json.type];
  if (!cls) {
    throw new RangeError("No selection type " + json.type + " defined");
  }
  return cls.fromJSON(doc2, json);
};
Selection.jsonID = function jsonID2(id, selectionClass) {
  if (id in classesById) {
    throw new RangeError("Duplicate use of selection JSON ID " + id);
  }
  classesById[id] = selectionClass;
  selectionClass.prototype.jsonID = id;
  return selectionClass;
};
Selection.prototype.getBookmark = function getBookmark() {
  return TextSelection.between(this.$anchor, this.$head).getBookmark();
};
Object.defineProperties(Selection.prototype, prototypeAccessors$3);
Selection.prototype.visible = true;
var SelectionRange = function SelectionRange2($from, $to) {
  this.$from = $from;
  this.$to = $to;
};
var TextSelection = /* @__PURE__ */ function(Selection3) {
  function TextSelection2($anchor, $head) {
    if ($head === void 0)
      $head = $anchor;
    Selection3.call(this, $anchor, $head);
  }
  if (Selection3)
    TextSelection2.__proto__ = Selection3;
  TextSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  TextSelection2.prototype.constructor = TextSelection2;
  var prototypeAccessors$12 = { $cursor: { configurable: true } };
  prototypeAccessors$12.$cursor.get = function() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  };
  TextSelection2.prototype.map = function map16(doc2, mapping) {
    var $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) {
      return Selection3.near($head);
    }
    var $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
  };
  TextSelection2.prototype.replace = function replace3(tr, content2) {
    if (content2 === void 0)
      content2 = Slice.empty;
    Selection3.prototype.replace.call(this, tr, content2);
    if (content2 == Slice.empty) {
      var marks2 = this.$from.marksAcross(this.$to);
      if (marks2) {
        tr.ensureMarks(marks2);
      }
    }
  };
  TextSelection2.prototype.eq = function eq12(other) {
    return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
  };
  TextSelection2.prototype.getBookmark = function getBookmark2() {
    return new TextBookmark(this.anchor, this.head);
  };
  TextSelection2.prototype.toJSON = function toJSON7() {
    return { type: "text", anchor: this.anchor, head: this.head };
  };
  TextSelection2.fromJSON = function fromJSON8(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number") {
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    }
    return new TextSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  };
  TextSelection2.create = function create5(doc2, anchor, head) {
    if (head === void 0)
      head = anchor;
    var $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  };
  TextSelection2.between = function between($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) {
      bias = dPos >= 0 ? 1 : -1;
    }
    if (!$head.parent.inlineContent) {
      var found2 = Selection3.findFrom($head, bias, true) || Selection3.findFrom($head, -bias, true);
      if (found2) {
        $head = found2.$head;
      } else {
        return Selection3.near($head, bias);
      }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection3.findFrom($anchor, -bias, true) || Selection3.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0) {
          $anchor = $head;
        }
      }
    }
    return new TextSelection2($anchor, $head);
  };
  Object.defineProperties(TextSelection2.prototype, prototypeAccessors$12);
  return TextSelection2;
}(Selection);
Selection.jsonID("text", TextSelection);
var TextBookmark = function TextBookmark2(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
TextBookmark.prototype.map = function map4(mapping) {
  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
};
TextBookmark.prototype.resolve = function resolve3(doc2) {
  return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
};
var NodeSelection = /* @__PURE__ */ function(Selection3) {
  function NodeSelection2($pos) {
    var node4 = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node4.nodeSize);
    Selection3.call(this, $pos, $end);
    this.node = node4;
  }
  if (Selection3)
    NodeSelection2.__proto__ = Selection3;
  NodeSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  NodeSelection2.prototype.constructor = NodeSelection2;
  NodeSelection2.prototype.map = function map16(doc2, mapping) {
    var ref2 = mapping.mapResult(this.anchor);
    var deleted = ref2.deleted;
    var pos = ref2.pos;
    var $pos = doc2.resolve(pos);
    if (deleted) {
      return Selection3.near($pos);
    }
    return new NodeSelection2($pos);
  };
  NodeSelection2.prototype.content = function content2() {
    return new Slice(Fragment.from(this.node), 0, 0);
  };
  NodeSelection2.prototype.eq = function eq12(other) {
    return other instanceof NodeSelection2 && other.anchor == this.anchor;
  };
  NodeSelection2.prototype.toJSON = function toJSON7() {
    return { type: "node", anchor: this.anchor };
  };
  NodeSelection2.prototype.getBookmark = function getBookmark2() {
    return new NodeBookmark(this.anchor);
  };
  NodeSelection2.fromJSON = function fromJSON8(doc2, json) {
    if (typeof json.anchor != "number") {
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    }
    return new NodeSelection2(doc2.resolve(json.anchor));
  };
  NodeSelection2.create = function create5(doc2, from4) {
    return new this(doc2.resolve(from4));
  };
  NodeSelection2.isSelectable = function isSelectable(node4) {
    return !node4.isText && node4.type.spec.selectable !== false;
  };
  return NodeSelection2;
}(Selection);
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = function NodeBookmark2(anchor) {
  this.anchor = anchor;
};
NodeBookmark.prototype.map = function map5(mapping) {
  var ref2 = mapping.mapResult(this.anchor);
  var deleted = ref2.deleted;
  var pos = ref2.pos;
  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
};
NodeBookmark.prototype.resolve = function resolve4(doc2) {
  var $pos = doc2.resolve(this.anchor), node4 = $pos.nodeAfter;
  if (node4 && NodeSelection.isSelectable(node4)) {
    return new NodeSelection($pos);
  }
  return Selection.near($pos);
};
var AllSelection = /* @__PURE__ */ function(Selection3) {
  function AllSelection2(doc2) {
    Selection3.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  if (Selection3)
    AllSelection2.__proto__ = Selection3;
  AllSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  AllSelection2.prototype.constructor = AllSelection2;
  AllSelection2.prototype.replace = function replace3(tr, content2) {
    if (content2 === void 0)
      content2 = Slice.empty;
    if (content2 == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      var sel = Selection3.atStart(tr.doc);
      if (!sel.eq(tr.selection)) {
        tr.setSelection(sel);
      }
    } else {
      Selection3.prototype.replace.call(this, tr, content2);
    }
  };
  AllSelection2.prototype.toJSON = function toJSON7() {
    return { type: "all" };
  };
  AllSelection2.fromJSON = function fromJSON8(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.map = function map16(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.eq = function eq12(other) {
    return other instanceof AllSelection2;
  };
  AllSelection2.prototype.getBookmark = function getBookmark2() {
    return AllBookmark;
  };
  return AllSelection2;
}(Selection);
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map: function map6() {
    return this;
  },
  resolve: function resolve5(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node4, pos, index3, dir, text3) {
  if (node4.inlineContent) {
    return TextSelection.create(doc2, pos);
  }
  for (var i2 = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node4.childCount : i2 >= 0; i2 += dir) {
    var child3 = node4.child(i2);
    if (!child3.isAtom) {
      var inner = findSelectionIn(doc2, child3, pos + dir, dir < 0 ? child3.childCount : 0, dir, text3);
      if (inner) {
        return inner;
      }
    } else if (!text3 && NodeSelection.isSelectable(child3)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child3.nodeSize : 0));
    }
    pos += child3.nodeSize * dir;
  }
}
function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  var step2 = tr.steps[last];
  if (!(step2 instanceof ReplaceStep || step2 instanceof ReplaceAroundStep)) {
    return;
  }
  var map16 = tr.mapping.maps[last], end3;
  map16.forEach(function(_from, _to, _newFrom, newTo) {
    if (end3 == null) {
      end3 = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end3), bias));
}
var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
var Transaction$1 = /* @__PURE__ */ function(Transform3) {
  function Transaction2(state) {
    Transform3.call(this, state.doc);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.curSelectionFor = 0;
    this.storedMarks = state.storedMarks;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
  }
  if (Transform3)
    Transaction2.__proto__ = Transform3;
  Transaction2.prototype = Object.create(Transform3 && Transform3.prototype);
  Transaction2.prototype.constructor = Transaction2;
  var prototypeAccessors2 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
  prototypeAccessors2.selection.get = function() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  };
  Transaction2.prototype.setSelection = function setSelection2(selection) {
    if (selection.$from.doc != this.doc) {
      throw new RangeError("Selection passed to setSelection must point at the current document");
    }
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  };
  prototypeAccessors2.selectionSet.get = function() {
    return (this.updated & UPDATED_SEL) > 0;
  };
  Transaction2.prototype.setStoredMarks = function setStoredMarks(marks2) {
    this.storedMarks = marks2;
    this.updated |= UPDATED_MARKS;
    return this;
  };
  Transaction2.prototype.ensureMarks = function ensureMarks(marks2) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks2)) {
      this.setStoredMarks(marks2);
    }
    return this;
  };
  Transaction2.prototype.addStoredMark = function addStoredMark(mark3) {
    return this.ensureMarks(mark3.addToSet(this.storedMarks || this.selection.$head.marks()));
  };
  Transaction2.prototype.removeStoredMark = function removeStoredMark(mark3) {
    return this.ensureMarks(mark3.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  };
  prototypeAccessors2.storedMarksSet.get = function() {
    return (this.updated & UPDATED_MARKS) > 0;
  };
  Transaction2.prototype.addStep = function addStep2(step2, doc2) {
    Transform3.prototype.addStep.call(this, step2, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  };
  Transaction2.prototype.setTime = function setTime(time) {
    this.time = time;
    return this;
  };
  Transaction2.prototype.replaceSelection = function replaceSelection(slice5) {
    this.selection.replace(this, slice5);
    return this;
  };
  Transaction2.prototype.replaceSelectionWith = function replaceSelectionWith(node4, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false) {
      node4 = node4.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    }
    selection.replaceWith(this, node4);
    return this;
  };
  Transaction2.prototype.deleteSelection = function deleteSelection2() {
    this.selection.replace(this);
    return this;
  };
  Transaction2.prototype.insertText = function insertText2(text3, from4, to) {
    if (to === void 0)
      to = from4;
    var schema = this.doc.type.schema;
    if (from4 == null) {
      if (!text3) {
        return this.deleteSelection();
      }
      return this.replaceSelectionWith(schema.text(text3), true);
    } else {
      if (!text3) {
        return this.deleteRange(from4, to);
      }
      var marks2 = this.storedMarks;
      if (!marks2) {
        var $from = this.doc.resolve(from4);
        marks2 = to == from4 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from4, to, schema.text(text3, marks2));
      if (!this.selection.empty) {
        this.setSelection(Selection.near(this.selection.$to));
      }
      return this;
    }
  };
  Transaction2.prototype.setMeta = function setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  };
  Transaction2.prototype.getMeta = function getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  };
  prototypeAccessors2.isGeneric.get = function() {
    for (var _2 in this.meta) {
      return false;
    }
    return true;
  };
  Transaction2.prototype.scrollIntoView = function scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  };
  prototypeAccessors2.scrolledIntoView.get = function() {
    return (this.updated & UPDATED_SCROLL) > 0;
  };
  Object.defineProperties(Transaction2.prototype, prototypeAccessors2);
  return Transaction2;
}(Transform);
function bind(f2, self) {
  return !self || !f2 ? f2 : f2.bind(self);
}
var FieldDesc = function FieldDesc2(name, desc, self) {
  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
};
var baseFields = [
  new FieldDesc("doc", {
    init: function init2(config2) {
      return config2.doc || config2.schema.topNodeType.createAndFill();
    },
    apply: function apply2(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init: function init3(config2, instance) {
      return config2.selection || Selection.atStart(instance.doc);
    },
    apply: function apply3(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init: function init4(config2) {
      return config2.storedMarks || null;
    },
    apply: function apply4(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init: function init5() {
      return 0;
    },
    apply: function apply5(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = function Configuration2(schema, plugins) {
  var this$1$1 = this;
  this.schema = schema;
  this.fields = baseFields.concat();
  this.plugins = [];
  this.pluginsByKey = /* @__PURE__ */ Object.create(null);
  if (plugins) {
    plugins.forEach(function(plugin) {
      if (this$1$1.pluginsByKey[plugin.key]) {
        throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
      }
      this$1$1.plugins.push(plugin);
      this$1$1.pluginsByKey[plugin.key] = plugin;
      if (plugin.spec.state) {
        this$1$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      }
    });
  }
};
var EditorState = function EditorState2(config2) {
  this.config = config2;
};
var prototypeAccessors$1$1 = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
prototypeAccessors$1$1.schema.get = function() {
  return this.config.schema;
};
prototypeAccessors$1$1.plugins.get = function() {
  return this.config.plugins;
};
EditorState.prototype.apply = function apply6(tr) {
  return this.applyTransaction(tr).state;
};
EditorState.prototype.filterTransaction = function filterTransaction(tr, ignore) {
  if (ignore === void 0)
    ignore = -1;
  for (var i2 = 0; i2 < this.config.plugins.length; i2++) {
    if (i2 != ignore) {
      var plugin = this.config.plugins[i2];
      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) {
        return false;
      }
    }
  }
  return true;
};
EditorState.prototype.applyTransaction = function applyTransaction(rootTr) {
  if (!this.filterTransaction(rootTr)) {
    return { state: this, transactions: [] };
  }
  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  for (; ; ) {
    var haveNew = false;
    for (var i2 = 0; i2 < this.config.plugins.length; i2++) {
      var plugin = this.config.plugins[i2];
      if (plugin.spec.appendTransaction) {
        var n2 = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
        var tr = n2 < trs.length && plugin.spec.appendTransaction.call(plugin, n2 ? trs.slice(n2) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i2)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j = 0; j < this.config.plugins.length; j++) {
              seen.push(j < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) {
          seen[i2] = { state: newState, n: trs.length };
        }
      }
    }
    if (!haveNew) {
      return { state: newState, transactions: trs };
    }
  }
};
EditorState.prototype.applyInner = function applyInner(tr) {
  if (!tr.before.eq(this.doc)) {
    throw new RangeError("Applying a mismatched transaction");
  }
  var newInstance = new EditorState(this.config), fields = this.config.fields;
  for (var i2 = 0; i2 < fields.length; i2++) {
    var field = fields[i2];
    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
  }
  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) {
    applyListeners[i$1](this, tr, newInstance);
  }
  return newInstance;
};
prototypeAccessors$1$1.tr.get = function() {
  return new Transaction$1(this);
};
EditorState.create = function create3(config2) {
  var $config = new Configuration(config2.doc ? config2.doc.type.schema : config2.schema, config2.plugins);
  var instance = new EditorState($config);
  for (var i2 = 0; i2 < $config.fields.length; i2++) {
    instance[$config.fields[i2].name] = $config.fields[i2].init(config2, instance);
  }
  return instance;
};
EditorState.prototype.reconfigure = function reconfigure(config2) {
  var $config = new Configuration(this.schema, config2.plugins);
  var fields = $config.fields, instance = new EditorState($config);
  for (var i2 = 0; i2 < fields.length; i2++) {
    var name = fields[i2].name;
    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i2].init(config2, instance);
  }
  return instance;
};
EditorState.prototype.toJSON = function toJSON6(pluginFields) {
  var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
  if (this.storedMarks) {
    result2.storedMarks = this.storedMarks.map(function(m2) {
      return m2.toJSON();
    });
  }
  if (pluginFields && typeof pluginFields == "object") {
    for (var prop in pluginFields) {
      if (prop == "doc" || prop == "selection") {
        throw new RangeError("The JSON fields `doc` and `selection` are reserved");
      }
      var plugin = pluginFields[prop], state = plugin.spec.state;
      if (state && state.toJSON) {
        result2[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    }
  }
  return result2;
};
EditorState.fromJSON = function fromJSON7(config2, json, pluginFields) {
  if (!json) {
    throw new RangeError("Invalid input for EditorState.fromJSON");
  }
  if (!config2.schema) {
    throw new RangeError("Required config field 'schema' missing");
  }
  var $config = new Configuration(config2.schema, config2.plugins);
  var instance = new EditorState($config);
  $config.fields.forEach(function(field) {
    if (field.name == "doc") {
      instance.doc = Node$1.fromJSON(config2.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) {
        instance.storedMarks = json.storedMarks.map(config2.schema.markFromJSON);
      }
    } else {
      if (pluginFields) {
        for (var prop in pluginFields) {
          var plugin = pluginFields[prop], state = plugin.spec.state;
          if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
            instance[field.name] = state.fromJSON.call(plugin, config2, json[prop], instance);
            return;
          }
        }
      }
      instance[field.name] = field.init(config2, instance);
    }
  });
  return instance;
};
EditorState.addApplyListener = function addApplyListener(f2) {
  applyListeners.push(f2);
};
EditorState.removeApplyListener = function removeApplyListener(f2) {
  var found2 = applyListeners.indexOf(f2);
  if (found2 > -1) {
    applyListeners.splice(found2, 1);
  }
};
Object.defineProperties(EditorState.prototype, prototypeAccessors$1$1);
var applyListeners = [];
function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) {
      val = val.bind(self);
    } else if (prop == "handleDOMEvents") {
      val = bindProps(val, self, {});
    }
    target[prop] = val;
  }
  return target;
}
var Plugin = function Plugin2(spec) {
  this.props = {};
  if (spec.props) {
    bindProps(spec.props, this, this.props);
  }
  this.spec = spec;
  this.key = spec.key ? spec.key.key : createKey("plugin");
};
Plugin.prototype.getState = function getState(state) {
  return state[this.key];
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys) {
    return name + "$" + ++keys[name];
  }
  keys[name] = 0;
  return name + "$";
}
var PluginKey = function PluginKey2(name) {
  if (name === void 0)
    name = "key";
  this.key = createKey(name);
};
PluginKey.prototype.get = function get2(state) {
  return state.config.pluginsByKey[this.key];
};
PluginKey.prototype.getState = function getState2(state) {
  return state[this.key];
};
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function peg$subclass(child3, parent) {
  function ctor() {
    this.constructor = child3;
  }
  ctor.prototype = parent.prototype;
  child3.prototype = new ctor();
}
function peg$SyntaxError(message, expected, found2, location) {
  this.message = message;
  this.expected = expected;
  this.found = found2;
  this.location = location;
  this.name = "SyntaxError";
  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}
peg$subclass(peg$SyntaxError, Error);
peg$SyntaxError.buildMessage = function(expected, found2) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return '"' + literalEscape(expectation.text) + '"';
    },
    "class": function(expectation) {
      var escapedParts = "", i2;
      for (i2 = 0; i2 < expectation.parts.length; i2++) {
        escapedParts += expectation.parts[i2] instanceof Array ? classEscape(expectation.parts[i2][0]) + "-" + classEscape(expectation.parts[i2][1]) : classEscape(expectation.parts[i2]);
      }
      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },
    any: function(expectation) {
      return "any character";
    },
    end: function(expectation) {
      return "end of input";
    },
    other: function(expectation) {
      return expectation.description;
    }
  };
  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }
  function literalEscape(s2) {
    return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
      return "\\x" + hex(ch);
    });
  }
  function classEscape(s2) {
    return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
      return "\\x" + hex(ch);
    });
  }
  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }
  function describeExpected(expected2) {
    var descriptions = new Array(expected2.length), i2, j;
    for (i2 = 0; i2 < expected2.length; i2++) {
      descriptions[i2] = describeExpectation(expected2[i2]);
    }
    descriptions.sort();
    if (descriptions.length > 0) {
      for (i2 = 1, j = 1; i2 < descriptions.length; i2++) {
        if (descriptions[i2 - 1] !== descriptions[i2]) {
          descriptions[j] = descriptions[i2];
          j++;
        }
      }
      descriptions.length = j;
    }
    switch (descriptions.length) {
      case 1:
        return descriptions[0];
      case 2:
        return descriptions[0] + " or " + descriptions[1];
      default:
        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
    }
  }
  function describeFound(found3) {
    return found3 ? '"' + literalEscape(found3) + '"' : "end of input";
  }
  return "Expected " + describeExpected(expected) + " but " + describeFound(found2) + " found.";
};
function peg$parse(input, options) {
  options = options !== void 0 ? options : {};
  var peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = "#", peg$c1 = peg$literalExpectation("#", false), peg$c2 = function() {
    return inPlural[0];
  }, peg$c3 = function() {
    return { type: "octothorpe" };
  }, peg$c4 = function(str) {
    return str.join("");
  }, peg$c5 = "{", peg$c6 = peg$literalExpectation("{", false), peg$c7 = "}", peg$c8 = peg$literalExpectation("}", false), peg$c9 = function(arg) {
    return {
      type: "argument",
      arg
    };
  }, peg$c10 = ",", peg$c11 = peg$literalExpectation(",", false), peg$c12 = "select", peg$c13 = peg$literalExpectation("select", false), peg$c14 = function(arg, m2) {
    if (options.strict) {
      inPlural.unshift(false);
    }
    return m2;
  }, peg$c15 = function(arg, cases) {
    if (options.strict)
      inPlural.shift();
    return {
      type: "select",
      arg,
      cases
    };
  }, peg$c16 = "plural", peg$c17 = peg$literalExpectation("plural", false), peg$c18 = "selectordinal", peg$c19 = peg$literalExpectation("selectordinal", false), peg$c20 = function(arg, m2) {
    inPlural.unshift(true);
    return m2;
  }, peg$c21 = function(arg, type2, offset3, cases) {
    var ls = (type2 === "selectordinal" ? options.ordinal : options.cardinal) || ["zero", "one", "two", "few", "many", "other"];
    if (ls && ls.length)
      cases.forEach(function(c2) {
        if (isNaN(c2.key) && ls.indexOf(c2.key) < 0)
          throw new Error("Invalid key `" + c2.key + "` for argument `" + arg + "`. Valid " + type2 + " keys for this locale are `" + ls.join("`, `") + "`, and explicit keys like `=0`.");
      });
    inPlural.shift();
    return {
      type: type2,
      arg,
      offset: offset3 || 0,
      cases
    };
  }, peg$c22 = function(arg, key, param) {
    return {
      type: "function",
      arg,
      key,
      param
    };
  }, peg$c23 = peg$otherExpectation("identifier"), peg$c24 = /^[^\t-\r \x85\u200E\u200F\u2028\u2029!-\/:-@[-\^`{-~\xA1-\xA7\xA9\xAB\xAC\xAE\xB0\xB1\xB6\xBB\xBF\xD7\xF7\u2010-\u2027\u2030-\u203E\u2041-\u2053\u2055-\u205E\u2190-\u245F\u2500-\u2775\u2794-\u2BFF\u2E00-\u2E7F\u3001-\u3003\u3008-\u3020\u3030\uFD3E\uFD3F\uFE45\uFE46]/, peg$c25 = peg$classExpectation([["	", "\r"], " ", "\x85", "\u200E", "\u200F", "\u2028", "\u2029", ["!", "/"], [":", "@"], ["[", "^"], "`", ["{", "~"], ["\xA1", "\xA7"], "\xA9", "\xAB", "\xAC", "\xAE", "\xB0", "\xB1", "\xB6", "\xBB", "\xBF", "\xD7", "\xF7", ["\u2010", "\u2027"], ["\u2030", "\u203E"], ["\u2041", "\u2053"], ["\u2055", "\u205E"], ["\u2190", "\u245F"], ["\u2500", "\u2775"], ["\u2794", "\u2BFF"], ["\u2E00", "\u2E7F"], ["\u3001", "\u3003"], ["\u3008", "\u3020"], "\u3030", "\uFD3E", "\uFD3F", "\uFE45", "\uFE46"], true, false), peg$c26 = function(key, tokens) {
    return { key, tokens };
  }, peg$c27 = function(tokens) {
    return tokens;
  }, peg$c28 = peg$otherExpectation("plural offset"), peg$c29 = "offset", peg$c30 = peg$literalExpectation("offset", false), peg$c31 = ":", peg$c32 = peg$literalExpectation(":", false), peg$c33 = function(d2) {
    return d2;
  }, peg$c34 = "=", peg$c35 = peg$literalExpectation("=", false), peg$c36 = "number", peg$c37 = peg$literalExpectation("number", false), peg$c38 = "date", peg$c39 = peg$literalExpectation("date", false), peg$c40 = "time", peg$c41 = peg$literalExpectation("time", false), peg$c42 = "spellout", peg$c43 = peg$literalExpectation("spellout", false), peg$c44 = "ordinal", peg$c45 = peg$literalExpectation("ordinal", false), peg$c46 = "duration", peg$c47 = peg$literalExpectation("duration", false), peg$c48 = function(key) {
    if (options.strict || /^\d/.test(key))
      return false;
    switch (key.toLowerCase()) {
      case "select":
      case "plural":
      case "selectordinal":
        return false;
      default:
        return true;
    }
  }, peg$c49 = function(key) {
    return key;
  }, peg$c50 = function(tokens) {
    return !options.strict;
  }, peg$c51 = function(tokens) {
    return { tokens };
  }, peg$c52 = function(parts) {
    return { tokens: [parts.join("")] };
  }, peg$c53 = peg$otherExpectation("a valid (strict) function parameter"), peg$c54 = /^[^'{}]/, peg$c55 = peg$classExpectation(["'", "{", "}"], true, false), peg$c56 = function(p2) {
    return p2.join("");
  }, peg$c57 = "'", peg$c58 = peg$literalExpectation("'", false), peg$c59 = function(quoted) {
    return quoted;
  }, peg$c60 = function(p2) {
    return "{" + p2.join("") + "}";
  }, peg$c61 = peg$otherExpectation("doubled apostrophe"), peg$c62 = "''", peg$c63 = peg$literalExpectation("''", false), peg$c64 = function() {
    return "'";
  }, peg$c65 = /^[^']/, peg$c66 = peg$classExpectation(["'"], true, false), peg$c67 = "'{", peg$c68 = peg$literalExpectation("'{", false), peg$c69 = function(str) {
    return "{" + str.join("");
  }, peg$c70 = "'}", peg$c71 = peg$literalExpectation("'}", false), peg$c72 = function(str) {
    return "}" + str.join("");
  }, peg$c73 = peg$otherExpectation("escaped string"), peg$c74 = "'#", peg$c75 = peg$literalExpectation("'#", false), peg$c76 = function(str) {
    return "#" + str.join("");
  }, peg$c77 = function(quotedOcto) {
    return quotedOcto[0];
  }, peg$c78 = peg$otherExpectation("plain char"), peg$c79 = /^[^{}#\0-\x08\x0E-\x1F\x7F]/, peg$c80 = peg$classExpectation(["{", "}", "#", ["\0", "\b"], ["", ""], "\x7F"], true, false), peg$c81 = function(octo) {
    return !inPlural[0];
  }, peg$c82 = function(octo) {
    return octo;
  }, peg$c83 = peg$otherExpectation("integer"), peg$c84 = /^[0-9]/, peg$c85 = peg$classExpectation([["0", "9"]], false, false), peg$c86 = peg$otherExpectation("white space"), peg$c87 = /^[\t-\r \x85\u200E\u200F\u2028\u2029]/, peg$c88 = peg$classExpectation([["	", "\r"], " ", "\x85", "\u200E", "\u200F", "\u2028", "\u2029"], false, false), peg$currPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
    }
    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }
  function peg$literalExpectation(text3, ignoreCase) {
    return { type: "literal", text: text3, ignoreCase };
  }
  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts, inverted, ignoreCase };
  }
  function peg$endExpectation() {
    return { type: "end" };
  }
  function peg$otherExpectation(description) {
    return { type: "other", description };
  }
  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p2;
    if (details) {
      return details;
    } else {
      p2 = pos - 1;
      while (!peg$posDetailsCache[p2]) {
        p2--;
      }
      details = peg$posDetailsCache[p2];
      details = {
        line: details.line,
        column: details.column
      };
      while (p2 < pos) {
        if (input.charCodeAt(p2) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }
        p2++;
      }
      peg$posDetailsCache[pos] = details;
      return details;
    }
  }
  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }
  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }
    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }
    peg$maxFailExpected.push(expected);
  }
  function peg$buildStructuredError(expected, found2, location) {
    return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found2), expected, found2, location);
  }
  function peg$parsestart() {
    var s0, s1;
    s0 = [];
    s1 = peg$parsetoken();
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parsetoken();
    }
    return s0;
  }
  function peg$parsetoken() {
    var s0, s1, s2;
    s0 = peg$parseargument();
    if (s0 === peg$FAILED) {
      s0 = peg$parseselect();
      if (s0 === peg$FAILED) {
        s0 = peg$parseplural();
        if (s0 === peg$FAILED) {
          s0 = peg$parsefunction();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
              s1 = peg$c0;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c1);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$c2();
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = peg$c3();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsechar();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parsechar();
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$c4(s1);
              }
              s0 = s1;
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseargument() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c6);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseid();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c7;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s5 !== peg$FAILED) {
              s1 = peg$c9(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseselect() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c6);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseid();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c10;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c11);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c12) {
                  s8 = peg$c12;
                  peg$currPos += 6;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c13);
                  }
                }
                if (s8 !== peg$FAILED) {
                  s8 = peg$c14(s3, s8);
                }
                s7 = s8;
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s9 = peg$c10;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c11);
                      }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = [];
                        s12 = peg$parseselectCase();
                        if (s12 !== peg$FAILED) {
                          while (s12 !== peg$FAILED) {
                            s11.push(s12);
                            s12 = peg$parseselectCase();
                          }
                        } else {
                          s11 = peg$FAILED;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                              s13 = peg$c7;
                              peg$currPos++;
                            } else {
                              s13 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c8);
                              }
                            }
                            if (s13 !== peg$FAILED) {
                              s1 = peg$c15(s3, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseplural() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c6);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseid();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c10;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c11);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c16) {
                  s8 = peg$c16;
                  peg$currPos += 6;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s8 === peg$FAILED) {
                  if (input.substr(peg$currPos, 13) === peg$c18) {
                    s8 = peg$c18;
                    peg$currPos += 13;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                }
                if (s8 !== peg$FAILED) {
                  s8 = peg$c20(s3, s8);
                }
                s7 = s8;
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s9 = peg$c10;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c11);
                      }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseoffset();
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = [];
                          s13 = peg$parsepluralCase();
                          if (s13 !== peg$FAILED) {
                            while (s13 !== peg$FAILED) {
                              s12.push(s13);
                              s13 = peg$parsepluralCase();
                            }
                          } else {
                            s12 = peg$FAILED;
                          }
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_();
                            if (s13 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 125) {
                                s14 = peg$c7;
                                peg$currPos++;
                              } else {
                                s14 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c8);
                                }
                              }
                              if (s14 !== peg$FAILED) {
                                s1 = peg$c21(s3, s7, s11, s12);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsefunction() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c6);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseid();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c10;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c11);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsefunctionKey();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsefunctionParam();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 125) {
                        s10 = peg$c7;
                        peg$currPos++;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c8);
                        }
                      }
                      if (s10 !== peg$FAILED) {
                        s1 = peg$c22(s3, s7, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseid() {
    var s0, s1, s2;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c24.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c25);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c24.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c23);
      }
    }
    return s0;
  }
  function peg$parseselectCase() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseid();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsecaseTokens();
          if (s4 !== peg$FAILED) {
            s1 = peg$c26(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsepluralCase() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsepluralKey();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsecaseTokens();
          if (s4 !== peg$FAILED) {
            s1 = peg$c26(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsecaseTokens() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c6);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 123) {
          s5 = peg$c5;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        peg$silentFails--;
        if (s5 !== peg$FAILED) {
          peg$currPos = s4;
          s4 = void 0;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsetoken();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsetoken();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c7;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s5 !== peg$FAILED) {
              s1 = peg$c27(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseoffset() {
    var s0, s1, s2, s3, s4, s5, s6, s7;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 6) === peg$c29) {
        s2 = peg$c29;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c30);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c31;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsedigits();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s1 = peg$c33(s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c28);
      }
    }
    return s0;
  }
  function peg$parsepluralKey() {
    var s0, s1, s2;
    s0 = peg$parseid();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 61) {
        s1 = peg$c34;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c35);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsedigits();
        if (s2 !== peg$FAILED) {
          s1 = peg$c33(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    return s0;
  }
  function peg$parsefunctionKey() {
    var s0, s1, s2, s3, s4, s5;
    if (input.substr(peg$currPos, 6) === peg$c36) {
      s0 = peg$c36;
      peg$currPos += 6;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c37);
      }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 4) === peg$c38) {
        s0 = peg$c38;
        peg$currPos += 4;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c39);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c40) {
          s0 = peg$c40;
          peg$currPos += 4;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c41);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c42) {
            s0 = peg$c42;
            peg$currPos += 8;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c43);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c44) {
              s0 = peg$c44;
              peg$currPos += 7;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 8) === peg$c46) {
                s0 = peg$c46;
                peg$currPos += 8;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c47);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 6) === peg$c12) {
                  s2 = peg$c12;
                  peg$currPos += 6;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c13);
                  }
                }
                peg$silentFails--;
                if (s2 === peg$FAILED) {
                  s1 = void 0;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$currPos;
                  peg$silentFails++;
                  if (input.substr(peg$currPos, 6) === peg$c16) {
                    s3 = peg$c16;
                    peg$currPos += 6;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  peg$silentFails--;
                  if (s3 === peg$FAILED) {
                    s2 = void 0;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    peg$silentFails++;
                    if (input.substr(peg$currPos, 13) === peg$c18) {
                      s4 = peg$c18;
                      peg$currPos += 13;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c19);
                      }
                    }
                    peg$silentFails--;
                    if (s4 === peg$FAILED) {
                      s3 = void 0;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parseid();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$c48(s4);
                        if (s5) {
                          s5 = void 0;
                        } else {
                          s5 = peg$FAILED;
                        }
                        if (s5 !== peg$FAILED) {
                          s1 = peg$c49(s4);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parsefunctionParam() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 44) {
        s2 = peg$c10;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c11);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsetoken();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsetoken();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$c50();
          if (s4) {
            s4 = void 0;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s1 = peg$c51(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c10;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsestrictFunctionParamPart();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsestrictFunctionParamPart();
          }
          if (s3 !== peg$FAILED) {
            s1 = peg$c52(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    return s0;
  }
  function peg$parsestrictFunctionParamPart() {
    var s0, s1, s2, s3;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c54.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c55);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c54.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s1 = peg$c56(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parsedoubleapos();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c57;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c58);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseinapos();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c57;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c58);
              }
            }
            if (s3 !== peg$FAILED) {
              s1 = peg$c59(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsestrictFunctionParamPart();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsestrictFunctionParamPart();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c7;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s3 !== peg$FAILED) {
                s1 = peg$c60(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c53);
      }
    }
    return s0;
  }
  function peg$parsedoubleapos() {
    var s0, s1;
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c62) {
      s1 = peg$c62;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c63);
      }
    }
    if (s1 !== peg$FAILED) {
      s1 = peg$c64();
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c61);
      }
    }
    return s0;
  }
  function peg$parseinapos() {
    var s0, s1, s2;
    s0 = peg$parsedoubleapos();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      if (peg$c65.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c66);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c65.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c66);
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$c4(s1);
      }
      s0 = s1;
    }
    return s0;
  }
  function peg$parsequotedCurly() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c67) {
      s1 = peg$c67;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c68);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseinapos();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseinapos();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c57;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c58);
          }
        }
        if (s3 !== peg$FAILED) {
          s1 = peg$c69(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c70) {
        s1 = peg$c70;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c71);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseinapos();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseinapos();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c57;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c58);
            }
          }
          if (s3 !== peg$FAILED) {
            s1 = peg$c72(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    return s0;
  }
  function peg$parsequoted() {
    var s0, s1, s2, s3, s4, s5;
    peg$silentFails++;
    s0 = peg$parsequotedCurly();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c74) {
        s3 = peg$c74;
        peg$currPos += 2;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c75);
        }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$parseinapos();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseinapos();
        }
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s5 = peg$c57;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c58);
            }
          }
          if (s5 !== peg$FAILED) {
            s3 = peg$c76(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$c2();
        if (s3) {
          s3 = void 0;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$c77(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c57;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c58);
          }
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c73);
      }
    }
    return s0;
  }
  function peg$parseplainChar() {
    var s0;
    peg$silentFails++;
    if (peg$c79.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c80);
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      if (peg$silentFails === 0) {
        peg$fail(peg$c78);
      }
    }
    return s0;
  }
  function peg$parsechar() {
    var s0, s1, s2;
    s0 = peg$parsedoubleapos();
    if (s0 === peg$FAILED) {
      s0 = peg$parsequoted();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$c81();
          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = peg$c82(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseplainChar();
        }
      }
    }
    return s0;
  }
  function peg$parsedigits() {
    var s0, s1, s2;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c84.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c85);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c84.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c85);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c83);
      }
    }
    return s0;
  }
  function peg$parse_() {
    var s0, s1, s2;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c87.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c88);
      }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      if (peg$c87.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c88);
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c86);
      }
    }
    return s0;
  }
  var inPlural = [false];
  peg$result = peg$startRuleFunction();
  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }
    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}
var parser = {
  SyntaxError: peg$SyntaxError,
  parse: peg$parse
};
var isString = function isString2(s2) {
  return typeof s2 === "string";
};
var isFunction = function isFunction2(f2) {
  return typeof f2 === "function";
};
var numberFormats = /* @__PURE__ */ new Map();
var dateFormats = /* @__PURE__ */ new Map();
function date(locales) {
  var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var memoize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  return function(value) {
    if (isString(value))
      value = new Date(value);
    if (memoize) {
      var key = cacheKey(locales, format2);
      var cachedFormatter = dateFormats.get(key);
      if (cachedFormatter) {
        return cachedFormatter.format(value);
      }
      var _formatter = new Intl.DateTimeFormat(locales, format2);
      dateFormats.set(key, _formatter);
      return _formatter.format(value);
    }
    var formatter = new Intl.DateTimeFormat(locales, format2);
    return formatter.format(value);
  };
}
function number(locales) {
  var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var memoize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  return function(value) {
    if (memoize) {
      var key = cacheKey(locales, format2);
      var cachedFormatter = numberFormats.get(key);
      if (cachedFormatter) {
        return cachedFormatter.format(value);
      }
      var _formatter2 = new Intl.NumberFormat(locales, format2);
      numberFormats.set(key, _formatter2);
      return _formatter2.format(value);
    }
    var formatter = new Intl.NumberFormat(locales, format2);
    return formatter.format(value);
  };
}
function cacheKey(locales) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var localeKey = Array.isArray(locales) ? locales.sort().join("-") : locales;
  return "".concat(localeKey, "-").concat(JSON.stringify(options));
}
var UNICODE_REGEX = /\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/g;
var defaultFormats = function defaultFormats2(locale, locales) {
  var localeData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    plurals: void 0
  };
  var formats = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  locales = locales || locale;
  var plurals = localeData.plurals;
  var style = function style2(format2) {
    return isString(format2) ? formats[format2] || {
      style: format2
    } : format2;
  };
  var replaceOctothorpe = function replaceOctothorpe2(value, message) {
    return function(ctx) {
      var msg = isFunction(message) ? message(ctx) : message;
      var norm = Array.isArray(msg) ? msg : [msg];
      var valueStr = number(locales)(value);
      return norm.map(function(m2) {
        return isString(m2) ? m2.replace("#", valueStr) : m2;
      });
    };
  };
  if (!plurals) {
    console.error("Plurals for locale ".concat(locale, " aren't loaded. Use i18n.loadLocaleData method to load plurals for specific locale. Using other plural rule as a fallback."));
  }
  return {
    plural: function plural(value, _ref) {
      var _ref$offset = _ref.offset, offset3 = _ref$offset === void 0 ? 0 : _ref$offset, rules = _objectWithoutProperties(_ref, ["offset"]);
      var message = rules[value] || rules[plurals === null || plurals === void 0 ? void 0 : plurals(value - offset3)] || rules.other;
      return replaceOctothorpe(value - offset3, message);
    },
    selectordinal: function selectordinal(value, _ref2) {
      var _ref2$offset = _ref2.offset, offset3 = _ref2$offset === void 0 ? 0 : _ref2$offset, rules = _objectWithoutProperties(_ref2, ["offset"]);
      var message = rules[value] || rules[plurals === null || plurals === void 0 ? void 0 : plurals(value - offset3, true)] || rules.other;
      return replaceOctothorpe(value - offset3, message);
    },
    select: function select(value, rules) {
      return rules[value] || rules.other;
    },
    number: function number$1(value, format2) {
      return number(locales, style(format2))(value);
    },
    date: function date$1(value, format2) {
      return date(locales, style(format2))(value);
    },
    undefined: function undefined$1(value) {
      return value;
    }
  };
};
function context(_ref3) {
  var locale = _ref3.locale, locales = _ref3.locales, values2 = _ref3.values, formats = _ref3.formats, localeData = _ref3.localeData;
  var formatters = defaultFormats(locale, locales, localeData, formats);
  var ctx = function ctx2(name, type2, format2) {
    var value = values2[name];
    var formatted = formatters[type2](value, format2);
    var message = isFunction(formatted) ? formatted(ctx2) : formatted;
    return Array.isArray(message) ? message.join("") : message;
  };
  return ctx;
}
function interpolate(translation, locale, locales, localeData) {
  return function(values2) {
    var formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var ctx = context({
      locale,
      locales,
      localeData,
      formats,
      values: values2
    });
    var formatMessage = function formatMessage2(message) {
      if (!Array.isArray(message))
        return message;
      return message.reduce(function(message2, token) {
        if (isString(token))
          return message2 + token;
        var _token = _slicedToArray(token, 3), name = _token[0], type2 = _token[1], format2 = _token[2];
        var interpolatedFormat = {};
        if (format2 != null && !isString(format2)) {
          Object.keys(format2).forEach(function(key) {
            interpolatedFormat[key] = formatMessage2(format2[key]);
          });
        } else {
          interpolatedFormat = format2;
        }
        var value = ctx(name, type2, interpolatedFormat);
        if (value == null)
          return message2;
        return message2 + value;
      }, "");
    };
    var result2 = formatMessage(translation);
    if (isString(result2) && UNICODE_REGEX.test(result2))
      return JSON.parse('"'.concat(result2.trim(), '"'));
    if (isString(result2))
      return result2.trim();
    return result2;
  };
}
function ownKeys$3(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function processTokens(tokens) {
  if (!tokens.filter(function(token) {
    return !isString(token);
  }).length) {
    return tokens.join("");
  }
  return tokens.map(function(token) {
    if (isString(token)) {
      return token;
    } else if (token.type === "octothorpe") {
      return "#";
    } else if (token.type === "argument") {
      return [token.arg];
    } else if (token.type === "function") {
      var _param = token.param && token.param.tokens[0];
      var param = typeof _param === "string" ? _param.trim() : _param;
      return [token.arg, token.key, param].filter(Boolean);
    }
    var offset3 = token.offset ? parseInt(token.offset) : void 0;
    var formatProps = {};
    token.cases.forEach(function(item) {
      formatProps[item.key] = processTokens(item.tokens);
    });
    return [token.arg, token.type, _objectSpread({
      offset: offset3
    }, formatProps)];
  });
}
function compile3(message) {
  try {
    return processTokens(parser.parse(message));
  } catch (e2) {
    console.error("Message cannot be parsed due to syntax errors: ".concat(message));
    return message;
  }
}
var EventEmitter = /* @__PURE__ */ function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this._events = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on(event, listener) {
      var _this = this;
      if (!this._hasEvent(event))
        this._events[event] = [];
      this._events[event].push(listener);
      return function() {
        return _this.removeListener(event, listener);
      };
    }
  }, {
    key: "removeListener",
    value: function removeListener(event, listener) {
      if (!this._hasEvent(event))
        return;
      var index3 = this._events[event].indexOf(listener);
      if (~index3)
        this._events[event].splice(index3, 1);
    }
  }, {
    key: "emit",
    value: function emit(event) {
      var _this2 = this;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (!this._hasEvent(event))
        return;
      this._events[event].map(function(listener) {
        return listener.apply(_this2, args);
      });
    }
  }, {
    key: "_hasEvent",
    value: function _hasEvent(event) {
      return Array.isArray(this._events[event]);
    }
  }]);
  return EventEmitter2;
}();
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result2);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var I18n = /* @__PURE__ */ function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper(I18n2);
  function I18n2(params) {
    var _this;
    _classCallCheck(this, I18n2);
    _this = _super.call(this);
    _this._messages = {};
    _this._localeData = {};
    if (params.missing != null)
      _this._missing = params.missing;
    if (params.messages != null)
      _this.load(params.messages);
    if (params.localeData != null)
      _this.loadLocaleData(params.localeData);
    if (params.locale != null || params.locales != null) {
      _this.activate(params.locale, params.locales);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "_loadLocaleData",
    value: function _loadLocaleData(locale, localeData) {
      if (this._localeData[locale] == null) {
        this._localeData[locale] = localeData;
      } else {
        Object.assign(this._localeData[locale], localeData);
      }
    }
  }, {
    key: "loadLocaleData",
    value: function loadLocaleData(localeOrAllData, localeData) {
      var _this2 = this;
      if (localeData != null) {
        this._loadLocaleData(localeOrAllData, localeData);
      } else {
        Object.keys(localeOrAllData).forEach(function(locale) {
          return _this2._loadLocaleData(locale, localeOrAllData[locale]);
        });
      }
      this.emit("change");
    }
  }, {
    key: "_load",
    value: function _load(locale, messages2) {
      if (this._messages[locale] == null) {
        this._messages[locale] = messages2;
      } else {
        Object.assign(this._messages[locale], messages2);
      }
    }
  }, {
    key: "load",
    value: function load(localeOrMessages, messages2) {
      var _this3 = this;
      if (messages2 != null) {
        this._load(localeOrMessages, messages2);
      } else {
        Object.keys(localeOrMessages).forEach(function(locale) {
          return _this3._load(locale, localeOrMessages[locale]);
        });
      }
      this.emit("change");
    }
  }, {
    key: "activate",
    value: function activate(locale, locales) {
      {
        if (!this._messages[locale]) {
          console.warn('Messages for locale "'.concat(locale, '" not loaded.'));
        }
        if (!this._localeData[locale]) {
          console.warn('Locale data for locale "'.concat(locale, `" not loaded. Plurals won't work correctly.`));
        }
      }
      this._locale = locale;
      this._locales = locales;
      this.emit("change");
    }
  }, {
    key: "_",
    value: function _2(id) {
      var values2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, message = _ref.message, formats = _ref.formats, context2 = _ref.context;
      if (!isString(id)) {
        values2 = id.values || values2;
        message = id.message;
        context2 = id.context;
        id = id.id;
      }
      var messageMissing = !context2 && !this.messages[id];
      var contextualMessageMissing = context2 && !this.messages[context2][id];
      var messageUnreachable = contextualMessageMissing || messageMissing;
      var missing = this._missing;
      if (missing && messageUnreachable) {
        return isFunction(missing) ? missing(this._locale, id, context2) : missing;
      }
      if (messageUnreachable) {
        this.emit("missing", {
          id,
          context: context2,
          locale: this._locale
        });
      }
      var translation;
      if (context2 && !contextualMessageMissing) {
        translation = this.messages[context2][id] || message || id;
      } else {
        translation = this.messages[id] || message || id;
      }
      {
        translation = isString(translation) ? compile3(translation) : translation;
      }
      if (isString(translation) && UNICODE_REGEX.test(translation))
        return JSON.parse('"'.concat(translation, '"'));
      if (isString(translation))
        return translation;
      return interpolate(translation, this._locale, this._locales, this.localeData)(values2, formats);
    }
  }, {
    key: "date",
    value: function date$1(value, format2) {
      return date(this._locales || this._locale, format2)(value);
    }
  }, {
    key: "number",
    value: function number$1(value, format2) {
      return number(this._locales || this._locale, format2)(value);
    }
  }, {
    key: "locale",
    get: function get4() {
      return this._locale;
    }
  }, {
    key: "locales",
    get: function get4() {
      return this._locales;
    }
  }, {
    key: "messages",
    get: function get4() {
      var _this$_messages$this$;
      return (_this$_messages$this$ = this._messages[this._locale]) !== null && _this$_messages$this$ !== void 0 ? _this$_messages$this$ : {};
    }
  }, {
    key: "localeData",
    get: function get4() {
      var _this$_localeData$thi;
      return (_this$_localeData$thi = this._localeData[this._locale]) !== null && _this$_localeData$thi !== void 0 ? _this$_localeData$thi : {};
    }
  }]);
  return I18n2;
}(EventEmitter);
function setupI18n() {
  var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return new I18n(params);
}
var i18n$1 = setupI18n();
const i18n = i18n$1;
var COPY_LABEL = {
  id: "extension.command.copy.label",
  comment: "Label for copy command.",
  message: "Copy"
};
var COPY_DESCRIPTION = {
  id: "extension.command.copy.description",
  comment: "Description for copy command.",
  message: "Copy the selected text"
};
var CUT_LABEL = {
  id: "extension.command.cut.label",
  comment: "Label for cut command.",
  message: "Cut"
};
var CUT_DESCRIPTION = {
  id: "extension.command.cut.description",
  comment: "Description for cut command.",
  message: "Cut the selected text"
};
var PASTE_LABEL = {
  id: "extension.command.paste.label",
  comment: "Label for paste command.",
  message: "Paste"
};
var PASTE_DESCRIPTION = {
  id: "extension.command.paste.description",
  comment: "Description for paste command.",
  message: "Paste content into the editor"
};
var SELECT_ALL_LABEL = {
  id: "extension.command.select-all.label",
  comment: "Label for select all command.",
  message: "Select all"
};
var SELECT_ALL_DESCRIPTION = {
  id: "extension.command.select-all.description",
  comment: "Description for select all command.",
  message: "Select all content within the editor"
};
var coreMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  COPY_LABEL,
  COPY_DESCRIPTION,
  CUT_LABEL,
  CUT_DESCRIPTION,
  PASTE_LABEL,
  PASTE_DESCRIPTION,
  SELECT_ALL_LABEL,
  SELECT_ALL_DESCRIPTION
});
var ESCAPE_KEY = {
  id: "keyboard.shortcut.escape",
  comment: "Label for escape key in shortcuts.",
  message: "Enter"
};
var COMMAND_KEY = {
  id: "keyboard.shortcut.command",
  comment: "Label for command key in shortcuts.",
  message: "Command"
};
var CONTROL_KEY = {
  id: "keyboard.shortcut.control",
  comment: "Label for control key in shortcuts.",
  message: "Control"
};
var ENTER_KEY = {
  id: "keyboard.shortcut.enter",
  comment: "Label for enter key in shortcuts.",
  message: "Enter"
};
var SHIFT_KEY = {
  id: "keyboard.shortcut.shift",
  comment: "Label for shift key in shortcuts.",
  message: "Shift"
};
var ALT_KEY = {
  id: "keyboard.shortcut.alt",
  comment: "Label for alt key in shortcuts.",
  message: "Alt"
};
var CAPS_LOCK_KEY = {
  id: "keyboard.shortcut.capsLock",
  comment: "Label for caps lock key in shortcuts.",
  message: "Caps Lock"
};
var BACKSPACE_KEY = {
  id: "keyboard.shortcut.backspace",
  comment: "Label for backspace key in shortcuts.",
  message: "Backspace"
};
var TAB_KEY = {
  id: "keyboard.shortcut.tab",
  comment: "Label for tab key in shortcuts.",
  message: "Tab"
};
var SPACE_KEY = {
  id: "keyboard.shortcut.space",
  comment: "Label for space key in shortcuts.",
  message: "Space"
};
var DELETE_KEY = {
  id: "keyboard.shortcut.delete",
  comment: "Label for delete key in shortcuts.",
  message: "Delete"
};
var PAGE_UP_KEY = {
  id: "keyboard.shortcut.pageUp",
  comment: "Label for page up key in shortcuts.",
  message: "Page Up"
};
var PAGE_DOWN_KEY = {
  id: "keyboard.shortcut.pageDown",
  comment: "Label for page down key in shortcuts.",
  message: "Page Down"
};
var HOME_KEY = {
  id: "keyboard.shortcut.home",
  comment: "Label for home key in shortcuts.",
  message: "Home"
};
var END_KEY = {
  id: "keyboard.shortcut.end",
  comment: "Label for end key in shortcuts.",
  message: "End"
};
var ARROW_LEFT_KEY = {
  id: "keyboard.shortcut.arrowLeft",
  comment: "Label for arrow left key in shortcuts.",
  message: "Arrow Left"
};
var ARROW_RIGHT_KEY = {
  id: "keyboard.shortcut.arrowRight",
  comment: "Label for arrow right key in shortcuts.",
  message: "Arrow Right"
};
var ARROW_UP_KEY = {
  id: "keyboard.shortcut.arrowUp",
  comment: "Label for arrow up key in shortcuts.",
  message: "Arrow Up"
};
var ARROW_DOWN_KEY = {
  id: "keyboard.shortcut.arrowDown",
  comment: "Label for arrowDown key in shortcuts.",
  message: "Arrow Down"
};
var coreUtilsMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ESCAPE_KEY,
  COMMAND_KEY,
  CONTROL_KEY,
  ENTER_KEY,
  SHIFT_KEY,
  ALT_KEY,
  CAPS_LOCK_KEY,
  BACKSPACE_KEY,
  TAB_KEY,
  SPACE_KEY,
  DELETE_KEY,
  PAGE_UP_KEY,
  PAGE_DOWN_KEY,
  HOME_KEY,
  END_KEY,
  ARROW_LEFT_KEY,
  ARROW_RIGHT_KEY,
  ARROW_UP_KEY,
  ARROW_DOWN_KEY
});
var LABEL$d = {
  id: "extension.command.toggle-blockquote.label",
  comment: "Label for blockquote formatting command.",
  message: "Blockquote"
};
var DESCRIPTION$a = {
  id: "extension.command.toggle-blockquote.description",
  comment: "Description for blockquote formatting command.",
  message: "Add blockquote formatting to the selected text"
};
var extensionBlockquoteMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LABEL: LABEL$d,
  DESCRIPTION: DESCRIPTION$a
});
var LABEL$c = {
  id: "extension.command.toggle-bold.label",
  comment: "Label for bold formatting command.",
  message: "Bold"
};
var DESCRIPTION$9 = {
  id: "extension.command.toggle-bold.description",
  comment: "Description for bold formatting command.",
  message: "Add bold formatting to the selected text"
};
var extensionBoldMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LABEL: LABEL$c,
  DESCRIPTION: DESCRIPTION$9
});
var LABEL$7 = {
  id: "extension.command.toggle-heading.label",
  comment: "Label for heading command with support for levels.",
  message: "{level, select, 1 {Heading 1}\n2 {Heading 2}\n3 {Heading 3}\n4 {Heading 4}\n5 {Heading 5}\n6 {Heading 6}\nother {Heading}}"
};
var extensionHeadingMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LABEL: LABEL$7
});
var UNDO_LABEL = {
  id: "extension.command.undo.label",
  comment: "Label for undo.",
  message: "Undo"
};
var UNDO_DESCRIPTION = {
  id: "extension.command.undo.description",
  comment: "Description for undo.",
  message: "Undo the most recent action"
};
var REDO_LABEL = {
  id: "extension.command.redo.label",
  comment: "Label for redo.",
  message: "Redo"
};
var REDO_DESCRIPTION = {
  id: "extension.command.redo.description",
  comment: "Description for redo.",
  message: "Redo the most recent action"
};
var extensionHistoryMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  UNDO_LABEL,
  UNDO_DESCRIPTION,
  REDO_LABEL,
  REDO_DESCRIPTION
});
var LABEL$6 = {
  id: "extension.command.toggle-italic.label",
  comment: "Label for italic formatting command.",
  message: "Italic"
};
var DESCRIPTION$4 = {
  id: "extension.command.toggle-italic.description",
  comment: "Description for italic formatting command.",
  message: "Italicize the selected text"
};
var extensionItalicMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LABEL: LABEL$6,
  DESCRIPTION: DESCRIPTION$4
});
var ORDERED_LIST_LABEL = {
  id: "extension.command.toggle-ordered-list.label",
  comment: "Label for inserting an ordered list into the editor.",
  message: "Ordered list"
};
var BULLET_LIST_LABEL = {
  id: "extension.command.toggle-bullet-list.description",
  comment: "Description for inserting a bullet list into the editor.",
  message: "Bulleted list"
};
var TASK_LIST_LABEL = {
  id: "extension.command.toggle-task-list.description",
  comment: "Description for inserting a task list into the editor.",
  message: "Tasked list"
};
var extensionListMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ORDERED_LIST_LABEL,
  BULLET_LIST_LABEL,
  TASK_LIST_LABEL
});
var INSERT_LABEL = {
  id: "extension.command.insert-paragraph.label",
  comment: "Label for inserting a paragraph.",
  message: "Insert Paragraph"
};
var INSERT_DESCRIPTION = {
  id: "extension.command.insert-paragraph.description",
  comment: "Description for inserting a paragraph.",
  message: "Insert a new paragraph"
};
var CONVERT_LABEL = {
  id: "extension.command.convert-paragraph.label",
  comment: "Label for converting the current node into a paragraph.",
  message: "Convert Paragraph"
};
var CONVERT_DESCRIPTION = {
  id: "extension.command.convert-paragraph.description",
  comment: "Description for converting a paragraph.",
  message: "Convert current block into a paragraph block."
};
var extensionParagraphMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  INSERT_LABEL,
  INSERT_DESCRIPTION,
  CONVERT_LABEL,
  CONVERT_DESCRIPTION
});
var LABEL$5 = {
  id: "extension.command.toggle-strike.label",
  comment: "Label for strike formatting command.",
  message: "Strikethrough"
};
var DESCRIPTION$3 = {
  id: "extension.command.toggle-strike.description",
  comment: "Description for strike formatting command.",
  message: "Strikethrough the selected text"
};
var extensionStrikeMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LABEL: LABEL$5,
  DESCRIPTION: DESCRIPTION$3
});
var LABEL$1 = {
  id: "extension.command.toggle-underline.label",
  comment: "Label for underline formatting command.",
  message: "Underline"
};
var DESCRIPTION$1 = {
  id: "extension.command.toggle-underline.description",
  comment: "Description for underline formatting command.",
  message: "Underline the selected text"
};
var extensionUnderlineMessages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LABEL: LABEL$1,
  DESCRIPTION: DESCRIPTION$1
});
var InputRule = function InputRule2(match, handler) {
  this.match = match;
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
};
function stringHandler(string) {
  return function(state, match, start4, end3) {
    var insert = string;
    if (match[1]) {
      var offset3 = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset3 + match[1].length);
      start4 += offset3;
      var cutOff = start4 - end3;
      if (cutOff > 0) {
        insert = match[0].slice(offset3 - cutOff, offset3) + insert;
        start4 = end3;
      }
    }
    return state.tr.insertText(insert, start4, end3);
  };
}
var MAX_MATCH = 500;
function inputRules(ref2) {
  var rules = ref2.rules;
  var plugin = new Plugin({
    state: {
      init: function init6() {
        return null;
      },
      apply: function apply8(tr, prev) {
        var stored = tr.getMeta(this);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput: function handleTextInput(view, from4, to, text3) {
        return run(view, from4, to, text3, rules, plugin);
      },
      handleDOMEvents: {
        compositionend: function(view) {
          setTimeout(function() {
            var ref3 = view.state.selection;
            var $cursor = ref3.$cursor;
            if ($cursor) {
              run(view, $cursor.pos, $cursor.pos, "", rules, plugin);
            }
          });
        }
      }
    },
    isInputRules: true
  });
  return plugin;
}
function run(view, from4, to, text3, rules, plugin) {
  if (view.composing) {
    return false;
  }
  var state = view.state, $from = state.doc.resolve(from4);
  if ($from.parent.type.spec.code) {
    return false;
  }
  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, "\uFFFC") + text3;
  for (var i2 = 0; i2 < rules.length; i2++) {
    var match = rules[i2].match.exec(textBefore);
    var tr = match && rules[i2].handler(state, match, from4 - (match[0].length - text3.length), to);
    if (!tr) {
      continue;
    }
    view.dispatch(tr.setMeta(plugin, { transform: tr, from: from4, to, text: text3 }));
    return true;
  }
  return false;
}
function undoInputRule(state, dispatch2) {
  var plugins = state.plugins;
  for (var i2 = 0; i2 < plugins.length; i2++) {
    var plugin = plugins[i2], undoable = void 0;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        var tr = state.tr, toUndo = undoable.transform;
        for (var j = toUndo.steps.length - 1; j >= 0; j--) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          var marks2 = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks2));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
        dispatch2(tr);
      }
      return true;
    }
  }
  return false;
}
new InputRule(/--$/, "\u2014");
new InputRule(/\.\.\.$/, "\u2026");
new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "\u201C");
new InputRule(/"$/, "\u201D");
new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "\u2018");
new InputRule(/'$/, "\u2019");
function wrappingInputRule(regexp, nodeType2, getAttrs, joinPredicate) {
  return new InputRule(regexp, function(state, match, start4, end3) {
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    var tr = state.tr.delete(start4, end3);
    var $start = tr.doc.resolve(start4), range2 = $start.blockRange(), wrapping = range2 && findWrapping3(range2, nodeType2, attrs);
    if (!wrapping) {
      return null;
    }
    tr.wrap(range2, wrapping);
    var before2 = tr.doc.resolve(start4 - 1).nodeBefore;
    if (before2 && before2.type == nodeType2 && canJoin(tr.doc, start4 - 1) && (!joinPredicate || joinPredicate(match, before2))) {
      tr.join(start4 - 1);
    }
    return tr;
  });
}
function textblockTypeInputRule(regexp, nodeType2, getAttrs) {
  return new InputRule(regexp, function(state, match, start4, end3) {
    var $start = state.doc.resolve(start4);
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType2)) {
      return null;
    }
    return state.tr.delete(start4, end3).setBlockType(start4, start4, nodeType2, attrs);
  });
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classExtractFieldDescriptor(receiver, privateMap, action2) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action2 + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
var result = {};
if (typeof navigator != "undefined" && typeof document != "undefined") {
  var ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var ie$1 = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
  result.gecko = !ie$1 && /gecko\/(\d+)/i.test(navigator.userAgent);
  result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome$1 = !ie$1 && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result.chrome = !!chrome$1;
  result.chrome_version = chrome$1 && +chrome$1[1];
  result.safari = !ie$1 && /Apple Computer/.test(navigator.vendor);
  result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
  result.mac = result.ios || /Mac/.test(navigator.platform);
  result.android = /Android \d/.test(navigator.userAgent);
  result.webkit = "webkitFontSmoothing" in document.documentElement.style;
  result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
}
var domIndex = function(node4) {
  for (var index3 = 0; ; index3++) {
    node4 = node4.previousSibling;
    if (!node4) {
      return index3;
    }
  }
};
var parentNode = function(node4) {
  var parent = node4.assignedSlot || node4.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node4, from4, to) {
  var range2 = reusedRange || (reusedRange = document.createRange());
  range2.setEnd(node4, to == null ? node4.nodeValue.length : to);
  range2.setStart(node4, from4 || 0);
  return range2;
};
var isEquivalentPosition = function(node4, off, targetNode, targetOff) {
  return targetNode && (scanFor(node4, off, targetNode, targetOff, -1) || scanFor(node4, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node4, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node4 == targetNode && off == targetOff) {
      return true;
    }
    if (off == (dir < 0 ? 0 : nodeSize(node4))) {
      var parent = node4.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc(node4) || atomElements.test(node4.nodeName) || node4.contentEditable == "false") {
        return false;
      }
      off = domIndex(node4) + (dir < 0 ? 0 : 1);
      node4 = parent;
    } else if (node4.nodeType == 1) {
      node4 = node4.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node4.contentEditable == "false") {
        return false;
      }
      off = dir < 0 ? nodeSize(node4) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node4) {
  return node4.nodeType == 3 ? node4.nodeValue.length : node4.childNodes.length;
}
function isOnEdge(node4, offset3, parent) {
  for (var atStart2 = offset3 == 0, atEnd2 = offset3 == nodeSize(node4); atStart2 || atEnd2; ) {
    if (node4 == parent) {
      return true;
    }
    var index3 = domIndex(node4);
    node4 = node4.parentNode;
    if (!node4) {
      return false;
    }
    atStart2 = atStart2 && index3 == 0;
    atEnd2 = atEnd2 && index3 == nodeSize(node4);
  }
}
function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) {
      break;
    }
  }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
    collapsed = false;
  }
  return collapsed;
};
function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function windowRect(doc2) {
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node4) {
  var rect = node4.getBoundingClientRect();
  var scaleX = rect.width / node4.offsetWidth || 1;
  var scaleY = rect.height / node4.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node4.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node4.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc2 = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent) {
      break;
    }
    if (parent.nodeType != 1) {
      continue;
    }
    var atTop = parent == doc2.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect(doc2) : clientRect(parent);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top")) {
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    } else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) {
      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    }
    if (rect.left < bounding.left + getSide(scrollThreshold, "left")) {
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    } else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) {
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    }
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) {
          parent.scrollTop += moveY;
        }
        if (moveX) {
          parent.scrollLeft += moveX;
        }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop) {
      break;
    }
  }
}
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (dom == view.dom || !view.dom.contains(dom)) {
      continue;
    }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  var stack = [], doc2 = dom.ownerDocument;
  for (; dom; dom = parentNode(dom)) {
    stack.push({ dom, top: dom.scrollTop, left: dom.scrollLeft });
    if (dom == doc2) {
      break;
    }
  }
  return stack;
}
function resetScrollPos(ref2) {
  var refDOM = ref2.refDOM;
  var refTop = ref2.refTop;
  var stack = ref2.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (var i2 = 0; i2 < stack.length; i2++) {
    var ref2 = stack[i2];
    var dom = ref2.dom;
    var top2 = ref2.top;
    var left2 = ref2.left;
    if (dom.scrollTop != top2 + dTop) {
      dom.scrollTop = top2 + dTop;
    }
    if (dom.scrollLeft != left2) {
      dom.scrollLeft = left2;
    }
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive) {
    return dom.setActive();
  }
  if (preventScrollSupported) {
    return dom.focus(preventScrollSupported);
  }
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node4, coords) {
  var closest2, dxClosest = 2e8, coordsClosest, offset3 = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child3 = node4.firstChild, childIndex = 0; child3; child3 = child3.nextSibling, childIndex++) {
    var rects = void 0;
    if (child3.nodeType == 1) {
      rects = child3.getClientRects();
    } else if (child3.nodeType == 3) {
      rects = textRange(child3).getClientRects();
    } else {
      continue;
    }
    for (var i2 = 0; i2 < rects.length; i2++) {
      var rect = rects[i2];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest2 = child3;
          dxClosest = dx;
          coordsClosest = dx && closest2.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
          if (child3.nodeType == 1 && dx) {
            offset3 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest2 && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
        offset3 = childIndex + 1;
      }
    }
  }
  if (closest2 && closest2.nodeType == 3) {
    return findOffsetInText(closest2, coordsClosest);
  }
  if (!closest2 || dxClosest && closest2.nodeType == 1) {
    return { node: node4, offset: offset3 };
  }
  return findOffsetInNode(closest2, coordsClosest);
}
function findOffsetInText(node4, coords) {
  var len = node4.nodeValue.length;
  var range2 = document.createRange();
  for (var i2 = 0; i2 < len; i2++) {
    range2.setEnd(node4, i2 + 1);
    range2.setStart(node4, i2);
    var rect = singleRect(range2, 1);
    if (rect.top == rect.bottom) {
      continue;
    }
    if (inRect(coords, rect)) {
      return { node: node4, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
  }
  return { node: node4, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
    return parent;
  }
  return dom;
}
function posFromElement(view, elt, coords) {
  var ref2 = findOffsetInNode(elt, coords);
  var node4 = ref2.node;
  var offset3 = ref2.offset;
  var bias = -1;
  if (node4.nodeType == 1 && !node4.firstChild) {
    var rect = node4.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node4, offset3, bias);
}
function posFromCaret(view, node4, offset3, coords) {
  var outside = -1;
  for (var cur = node4; ; ) {
    if (cur == view.dom) {
      break;
    }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) {
      return null;
    }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) {
        outside = desc.posBefore;
      } else if (rect.right < coords.left || rect.bottom < coords.top) {
        outside = desc.posAfter;
      } else {
        break;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node4, offset3);
}
function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
      var child3 = element.childNodes[i2];
      if (child3.nodeType == 1) {
        var rects = child3.getClientRects();
        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) {
            return elementFromPoint(child3, coords, rect);
          }
        }
      }
      if ((i2 = (i2 + 1) % len) == startI) {
        break;
      }
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  var assign, assign$1;
  var doc2 = view.dom.ownerDocument, node4, offset3;
  if (doc2.caretPositionFromPoint) {
    try {
      var pos$1 = doc2.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) {
        assign = pos$1, node4 = assign.offsetNode, offset3 = assign.offset;
      }
    } catch (_2) {
    }
  }
  if (!node4 && doc2.caretRangeFromPoint) {
    var range2 = doc2.caretRangeFromPoint(coords.left, coords.top);
    if (range2) {
      assign$1 = range2, node4 = assign$1.startContainer, offset3 = assign$1.startOffset;
    }
  }
  var elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) {
      return null;
    }
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) {
      return null;
    }
  }
  if (result.safari) {
    for (var p2 = elt; node4 && p2; p2 = parentNode(p2)) {
      if (p2.draggable) {
        node4 = offset3 = null;
      }
    }
  }
  elt = targetKludge(elt, coords);
  if (node4) {
    if (result.gecko && node4.nodeType == 1) {
      offset3 = Math.min(offset3, node4.childNodes.length);
      if (offset3 < node4.childNodes.length) {
        var next = node4.childNodes[offset3], box$1;
        if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left && box$1.bottom > coords.top) {
          offset3++;
        }
      }
    }
    if (node4 == view.dom && offset3 == node4.childNodes.length - 1 && node4.lastChild.nodeType == 1 && coords.top > node4.lastChild.getBoundingClientRect().bottom) {
      pos = view.state.doc.content.size;
    } else if (offset3 == 0 || node4.nodeType != 1 || node4.childNodes[offset3 - 1].nodeName != "BR") {
      pos = posFromCaret(view, node4, offset3, coords);
    }
  }
  if (pos == null) {
    pos = posFromElement(view, elt, coords);
  }
  var desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(object2, bias) {
  var rects = object2.getClientRects();
  return !rects.length ? object2.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  var ref2 = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node4 = ref2.node;
  var offset3 = ref2.offset;
  var supportEmptyRange = result.webkit || result.gecko;
  if (node4.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node4.nodeValue) || (side < 0 ? !offset3 : offset3 == node4.nodeValue.length))) {
      var rect = singleRect(textRange(node4, offset3, offset3), side);
      if (result.gecko && offset3 && /\s/.test(node4.nodeValue[offset3 - 1]) && offset3 < node4.nodeValue.length) {
        var rectBefore = singleRect(textRange(node4, offset3 - 1, offset3 - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node4, offset3, offset3 + 1), -1);
          if (rectAfter.top != rect.top) {
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
      }
      return rect;
    } else {
      var from4 = offset3, to = offset3, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset3) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset3 == node4.nodeValue.length) {
        from4--;
        takeSide = 1;
      } else if (side < 0) {
        from4--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node4, from4, to), takeSide), takeSide < 0);
    }
  }
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset3 && (side < 0 || offset3 == nodeSize(node4))) {
      var before2 = node4.childNodes[offset3 - 1];
      if (before2.nodeType == 1) {
        return flattenH(before2.getBoundingClientRect(), false);
      }
    }
    if (offset3 < nodeSize(node4)) {
      var after2 = node4.childNodes[offset3];
      if (after2.nodeType == 1) {
        return flattenH(after2.getBoundingClientRect(), true);
      }
    }
    return flattenH(node4.getBoundingClientRect(), side >= 0);
  }
  if (offset3 && (side < 0 || offset3 == nodeSize(node4))) {
    var before$1 = node4.childNodes[offset3 - 1];
    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1)) : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target) {
      return flattenV(singleRect(target, 1), false);
    }
  }
  if (offset3 < nodeSize(node4)) {
    var after$1 = node4.childNodes[offset3];
    while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) {
      after$1 = after$1.nextSibling;
    }
    var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, supportEmptyRange ? 0 : 1) : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) {
      return flattenV(singleRect(target$1, -1), true);
    }
  }
  return flattenV(singleRect(node4.nodeType == 3 ? textRange(node4) : node4, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0) {
    return rect;
  }
  var x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0) {
    return rect;
  }
  var y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f2) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) {
    view.updateState(state);
  }
  if (active != view.dom) {
    view.focus();
  }
  try {
    return f2();
  } finally {
    if (viewState != state) {
      view.updateState(viewState);
    }
    if (active != view.dom && active) {
      active.focus();
    }
  }
}
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function() {
    var ref2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref2.node;
    for (; ; ) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) {
        break;
      }
      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos(view, $pos.pos, 1);
    for (var child3 = dom.firstChild; child3; child3 = child3.nextSibling) {
      var boxes = void 0;
      if (child3.nodeType == 1) {
        boxes = child3.getClientRects();
      } else if (child3.nodeType == 3) {
        boxes = textRange(child3, 0, child3.nodeValue.length).getClientRects();
      } else {
        continue;
      }
      for (var i2 = 0; i2 < boxes.length; i2++) {
        var box = boxes[i2];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) {
          return false;
        }
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  if (!$head.parent.isTextblock) {
    return false;
  }
  var offset3 = $head.parentOffset, atStart2 = !offset3, atEnd2 = offset3 == $head.parent.content.size;
  var sel = view.root.getSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
    return dir == "left" || dir == "backward" ? atStart2 : atEnd2;
  }
  return withFlushedState(view, state, function() {
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) {
      sel.caretBidiLevel = oldBidiLevel;
    }
    return result2;
  });
}
var cachedState = null, cachedDir = null, cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) {
    return cachedResult;
  }
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
var ViewDesc = function ViewDesc2(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  dom.pmViewDesc = this;
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY;
};
var prototypeAccessors = { size: { configurable: true }, border: { configurable: true }, posBefore: { configurable: true }, posAtStart: { configurable: true }, posAfter: { configurable: true }, posAtEnd: { configurable: true }, contentLost: { configurable: true }, domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
ViewDesc.prototype.matchesWidget = function matchesWidget() {
  return false;
};
ViewDesc.prototype.matchesMark = function matchesMark() {
  return false;
};
ViewDesc.prototype.matchesNode = function matchesNode() {
  return false;
};
ViewDesc.prototype.matchesHack = function matchesHack(_nodeName) {
  return false;
};
ViewDesc.prototype.parseRule = function parseRule() {
  return null;
};
ViewDesc.prototype.stopEvent = function stopEvent() {
  return false;
};
prototypeAccessors.size.get = function() {
  var size = 0;
  for (var i2 = 0; i2 < this.children.length; i2++) {
    size += this.children[i2].size;
  }
  return size;
};
prototypeAccessors.border.get = function() {
  return 0;
};
ViewDesc.prototype.destroy = function destroy() {
  this.parent = null;
  if (this.dom.pmViewDesc == this) {
    this.dom.pmViewDesc = null;
  }
  for (var i2 = 0; i2 < this.children.length; i2++) {
    this.children[i2].destroy();
  }
};
ViewDesc.prototype.posBeforeChild = function posBeforeChild(child3) {
  for (var i2 = 0, pos = this.posAtStart; i2 < this.children.length; i2++) {
    var cur = this.children[i2];
    if (cur == child3) {
      return pos;
    }
    pos += cur.size;
  }
};
prototypeAccessors.posBefore.get = function() {
  return this.parent.posBeforeChild(this);
};
prototypeAccessors.posAtStart.get = function() {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
};
prototypeAccessors.posAfter.get = function() {
  return this.posBefore + this.size;
};
prototypeAccessors.posAtEnd.get = function() {
  return this.posAtStart + this.size - 2 * this.border;
};
ViewDesc.prototype.localPosFromDOM = function localPosFromDOM(dom, offset3, bias) {
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset3 - 1];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
        domBefore = domBefore.previousSibling;
      }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset3];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
        domAfter = domAfter.nextSibling;
      }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
    }
  }
  var atEnd2;
  if (dom == this.dom && this.contentDOM) {
    atEnd2 = offset3 > domIndex(this.contentDOM);
  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd2 = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset3 == 0) {
      for (var search = dom; ; search = search.parentNode) {
        if (search == this.dom) {
          atEnd2 = false;
          break;
        }
        if (search.parentNode.firstChild != search) {
          break;
        }
      }
    }
    if (atEnd2 == null && offset3 == dom.childNodes.length) {
      for (var search$1 = dom; ; search$1 = search$1.parentNode) {
        if (search$1 == this.dom) {
          atEnd2 = true;
          break;
        }
        if (search$1.parentNode.lastChild != search$1) {
          break;
        }
      }
    }
  }
  return (atEnd2 == null ? bias > 0 : atEnd2) ? this.posAtEnd : this.posAtStart;
};
ViewDesc.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
  for (var first = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom)) {
        first = false;
      } else {
        return desc;
      }
    }
  }
};
ViewDesc.prototype.getDesc = function getDesc(dom) {
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) {
    if (cur == this) {
      return desc;
    }
  }
};
ViewDesc.prototype.posFromDOM = function posFromDOM(dom, offset3, bias) {
  for (var scan = dom; scan; scan = scan.parentNode) {
    var desc = this.getDesc(scan);
    if (desc) {
      return desc.localPosFromDOM(dom, offset3, bias);
    }
  }
  return -1;
};
ViewDesc.prototype.descAt = function descAt(pos) {
  for (var i2 = 0, offset3 = 0; i2 < this.children.length; i2++) {
    var child3 = this.children[i2], end3 = offset3 + child3.size;
    if (offset3 == pos && end3 != offset3) {
      while (!child3.border && child3.children.length) {
        child3 = child3.children[0];
      }
      return child3;
    }
    if (pos < end3) {
      return child3.descAt(pos - offset3 - child3.border);
    }
    offset3 = end3;
  }
};
ViewDesc.prototype.domFromPos = function domFromPos(pos, side) {
  if (!this.contentDOM) {
    return { node: this.dom, offset: 0 };
  }
  var i2 = 0, offset3 = 0;
  for (var curPos = 0; i2 < this.children.length; i2++) {
    var child3 = this.children[i2], end3 = curPos + child3.size;
    if (end3 > pos || child3 instanceof TrailingHackViewDesc) {
      offset3 = pos - curPos;
      break;
    }
    curPos = end3;
  }
  if (offset3) {
    return this.children[i2].domFromPos(offset3 - this.children[i2].border, side);
  }
  for (var prev = void 0; i2 && !(prev = this.children[i2 - 1]).size && prev instanceof WidgetViewDesc && prev.widget.type.side >= 0; i2--) {
  }
  if (side <= 0) {
    var prev$1, enter2 = true;
    for (; ; i2--, enter2 = false) {
      prev$1 = i2 ? this.children[i2 - 1] : null;
      if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) {
        break;
      }
    }
    if (prev$1 && side && enter2 && !prev$1.border && !prev$1.domAtom) {
      return prev$1.domFromPos(prev$1.size, side);
    }
    return { node: this.contentDOM, offset: prev$1 ? domIndex(prev$1.dom) + 1 : 0 };
  } else {
    var next, enter$1 = true;
    for (; ; i2++, enter$1 = false) {
      next = i2 < this.children.length ? this.children[i2] : null;
      if (!next || next.dom.parentNode == this.contentDOM) {
        break;
      }
    }
    if (next && enter$1 && !next.border && !next.domAtom) {
      return next.domFromPos(0, side);
    }
    return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
  }
};
ViewDesc.prototype.parseRange = function parseRange(from4, to, base2) {
  if (base2 === void 0)
    base2 = 0;
  if (this.children.length == 0) {
    return { node: this.contentDOM, from: from4, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
  }
  var fromOffset = -1, toOffset = -1;
  for (var offset3 = base2, i2 = 0; ; i2++) {
    var child3 = this.children[i2], end3 = offset3 + child3.size;
    if (fromOffset == -1 && from4 <= end3) {
      var childBase = offset3 + child3.border;
      if (from4 >= childBase && to <= end3 - child3.border && child3.node && child3.contentDOM && this.contentDOM.contains(child3.contentDOM)) {
        return child3.parseRange(from4, to, childBase);
      }
      from4 = offset3;
      for (var j = i2; j > 0; j--) {
        var prev = this.children[j - 1];
        if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
          fromOffset = domIndex(prev.dom) + 1;
          break;
        }
        from4 -= prev.size;
      }
      if (fromOffset == -1) {
        fromOffset = 0;
      }
    }
    if (fromOffset > -1 && (end3 > to || i2 == this.children.length - 1)) {
      to = end3;
      for (var j$1 = i2 + 1; j$1 < this.children.length; j$1++) {
        var next = this.children[j$1];
        if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
          toOffset = domIndex(next.dom);
          break;
        }
        to += next.size;
      }
      if (toOffset == -1) {
        toOffset = this.contentDOM.childNodes.length;
      }
      break;
    }
    offset3 = end3;
  }
  return { node: this.contentDOM, from: from4, to, fromOffset, toOffset };
};
ViewDesc.prototype.emptyChildAt = function emptyChildAt(side) {
  if (this.border || !this.contentDOM || !this.children.length) {
    return false;
  }
  var child3 = this.children[side < 0 ? 0 : this.children.length - 1];
  return child3.size == 0 || child3.emptyChildAt(side);
};
ViewDesc.prototype.domAfterPos = function domAfterPos(pos) {
  var ref2 = this.domFromPos(pos, 0);
  var node4 = ref2.node;
  var offset3 = ref2.offset;
  if (node4.nodeType != 1 || offset3 == node4.childNodes.length) {
    throw new RangeError("No node after pos " + pos);
  }
  return node4.childNodes[offset3];
};
ViewDesc.prototype.setSelection = function setSelection(anchor, head, root, force) {
  var from4 = Math.min(anchor, head), to = Math.max(anchor, head);
  for (var i2 = 0, offset3 = 0; i2 < this.children.length; i2++) {
    var child3 = this.children[i2], end3 = offset3 + child3.size;
    if (from4 > offset3 && to < end3) {
      return child3.setSelection(anchor - offset3 - child3.border, head - offset3 - child3.border, root, force);
    }
    offset3 = end3;
  }
  var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
  var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
  var domSel = root.getSelection();
  var brKludge = false;
  if ((result.gecko || result.safari) && anchor == head) {
    var node4 = anchorDOM.node;
    var offset$12 = anchorDOM.offset;
    if (node4.nodeType == 3) {
      brKludge = offset$12 && node4.nodeValue[offset$12 - 1] == "\n";
      if (brKludge && offset$12 == node4.nodeValue.length) {
        for (var scan = node4, after2 = void 0; scan; scan = scan.parentNode) {
          if (after2 = scan.nextSibling) {
            if (after2.nodeName == "BR") {
              anchorDOM = headDOM = { node: after2.parentNode, offset: domIndex(after2) + 1 };
            }
            break;
          }
          var desc = scan.pmViewDesc;
          if (desc && desc.node && desc.node.isBlock) {
            break;
          }
        }
      }
    } else {
      var prev = node4.childNodes[offset$12 - 1];
      brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
    }
  }
  if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
    if (after$1 && after$1.contentEditable == "false") {
      force = true;
    }
  }
  if (!(force || brKludge && result.safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
    return;
  }
  var domSelExtended = false;
  if ((domSel.extend || anchor == head) && !brKludge) {
    domSel.collapse(anchorDOM.node, anchorDOM.offset);
    try {
      if (anchor != head) {
        domSel.extend(headDOM.node, headDOM.offset);
      }
      domSelExtended = true;
    } catch (err2) {
      if (!(err2 instanceof DOMException)) {
        throw err2;
      }
    }
  }
  if (!domSelExtended) {
    if (anchor > head) {
      var tmp = anchorDOM;
      anchorDOM = headDOM;
      headDOM = tmp;
    }
    var range2 = document.createRange();
    range2.setEnd(headDOM.node, headDOM.offset);
    range2.setStart(anchorDOM.node, anchorDOM.offset);
    domSel.removeAllRanges();
    domSel.addRange(range2);
  }
};
ViewDesc.prototype.ignoreMutation = function ignoreMutation(mutation) {
  return !this.contentDOM && mutation.type != "selection";
};
prototypeAccessors.contentLost.get = function() {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
};
ViewDesc.prototype.markDirty = function markDirty(from4, to) {
  for (var offset3 = 0, i2 = 0; i2 < this.children.length; i2++) {
    var child3 = this.children[i2], end3 = offset3 + child3.size;
    if (offset3 == end3 ? from4 <= end3 && to >= offset3 : from4 < end3 && to > offset3) {
      var startInside = offset3 + child3.border, endInside = end3 - child3.border;
      if (from4 >= startInside && to <= endInside) {
        this.dirty = from4 == offset3 || to == end3 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (from4 == startInside && to == endInside && (child3.contentLost || child3.dom.parentNode != this.contentDOM)) {
          child3.dirty = NODE_DIRTY;
        } else {
          child3.markDirty(from4 - startInside, to - startInside);
        }
        return;
      } else {
        child3.dirty = child3.dom == child3.contentDOM && child3.dom.parentNode == this.contentDOM && !child3.children.length ? CONTENT_DIRTY : NODE_DIRTY;
      }
    }
    offset3 = end3;
  }
  this.dirty = CONTENT_DIRTY;
};
ViewDesc.prototype.markParentsDirty = function markParentsDirty() {
  var level = 1;
  for (var node4 = this.parent; node4; node4 = node4.parent, level++) {
    var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
    if (node4.dirty < dirty) {
      node4.dirty = dirty;
    }
  }
};
prototypeAccessors.domAtom.get = function() {
  return false;
};
prototypeAccessors.ignoreForCoords.get = function() {
  return false;
};
Object.defineProperties(ViewDesc.prototype, prototypeAccessors);
var nothing = [];
var WidgetViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function WidgetViewDesc2(parent, widget2, view, pos) {
    var self, dom = widget2.type.toDOM;
    if (typeof dom == "function") {
      dom = dom(view, function() {
        if (!self) {
          return pos;
        }
        if (self.parent) {
          return self.parent.posBeforeChild(self);
        }
      });
    }
    if (!widget2.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = false;
      dom.classList.add("ProseMirror-widget");
    }
    ViewDesc3.call(this, parent, nothing, dom, null);
    this.widget = widget2;
    self = this;
  }
  if (ViewDesc3)
    WidgetViewDesc2.__proto__ = ViewDesc3;
  WidgetViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
  var prototypeAccessors$12 = { domAtom: { configurable: true } };
  WidgetViewDesc2.prototype.matchesWidget = function matchesWidget2(widget2) {
    return this.dirty == NOT_DIRTY && widget2.type.eq(this.widget.type);
  };
  WidgetViewDesc2.prototype.parseRule = function parseRule2() {
    return { ignore: true };
  };
  WidgetViewDesc2.prototype.stopEvent = function stopEvent2(event) {
    var stop2 = this.widget.spec.stopEvent;
    return stop2 ? stop2(event) : false;
  };
  WidgetViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  };
  WidgetViewDesc2.prototype.destroy = function destroy4() {
    this.widget.type.destroy(this.dom);
    ViewDesc3.prototype.destroy.call(this);
  };
  prototypeAccessors$12.domAtom.get = function() {
    return true;
  };
  Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$12);
  return WidgetViewDesc2;
}(ViewDesc);
var CompositionViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function CompositionViewDesc2(parent, dom, textDOM, text3) {
    ViewDesc3.call(this, parent, nothing, dom, null);
    this.textDOM = textDOM;
    this.text = text3;
  }
  if (ViewDesc3)
    CompositionViewDesc2.__proto__ = ViewDesc3;
  CompositionViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  CompositionViewDesc2.prototype.constructor = CompositionViewDesc2;
  var prototypeAccessors$22 = { size: { configurable: true } };
  prototypeAccessors$22.size.get = function() {
    return this.text.length;
  };
  CompositionViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset3) {
    if (dom != this.textDOM) {
      return this.posAtStart + (offset3 ? this.size : 0);
    }
    return this.posAtStart + offset3;
  };
  CompositionViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
    return { node: this.textDOM, offset: pos };
  };
  CompositionViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  };
  Object.defineProperties(CompositionViewDesc2.prototype, prototypeAccessors$22);
  return CompositionViewDesc2;
}(ViewDesc);
var MarkViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function MarkViewDesc2(parent, mark3, dom, contentDOM) {
    ViewDesc3.call(this, parent, [], dom, contentDOM);
    this.mark = mark3;
  }
  if (ViewDesc3)
    MarkViewDesc2.__proto__ = ViewDesc3;
  MarkViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  MarkViewDesc2.prototype.constructor = MarkViewDesc2;
  MarkViewDesc2.create = function create5(parent, mark3, inline2, view) {
    var custom = view.nodeViews[mark3.type.name];
    var spec = custom && custom(mark3, view, inline2);
    if (!spec || !spec.dom) {
      spec = DOMSerializer.renderSpec(document, mark3.type.spec.toDOM(mark3, inline2));
    }
    return new MarkViewDesc2(parent, mark3, spec.dom, spec.contentDOM || spec.dom);
  };
  MarkViewDesc2.prototype.parseRule = function parseRule2() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) {
      return null;
    }
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  };
  MarkViewDesc2.prototype.matchesMark = function matchesMark2(mark3) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark3);
  };
  MarkViewDesc2.prototype.markDirty = function markDirty2(from4, to) {
    ViewDesc3.prototype.markDirty.call(this, from4, to);
    if (this.dirty != NOT_DIRTY) {
      var parent = this.parent;
      while (!parent.node) {
        parent = parent.parent;
      }
      if (parent.dirty < this.dirty) {
        parent.dirty = this.dirty;
      }
      this.dirty = NOT_DIRTY;
    }
  };
  MarkViewDesc2.prototype.slice = function slice5(from4, to, view) {
    var copy5 = MarkViewDesc2.create(this.parent, this.mark, true, view);
    var nodes = this.children, size = this.size;
    if (to < size) {
      nodes = replaceNodes(nodes, to, size, view);
    }
    if (from4 > 0) {
      nodes = replaceNodes(nodes, 0, from4, view);
    }
    for (var i2 = 0; i2 < nodes.length; i2++) {
      nodes[i2].parent = copy5;
    }
    copy5.children = nodes;
    return copy5;
  };
  return MarkViewDesc2;
}(ViewDesc);
var NodeViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function NodeViewDesc2(parent, node4, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos) {
    ViewDesc3.call(this, parent, node4.isLeaf ? nothing : [], dom, contentDOM);
    this.nodeDOM = nodeDOM2;
    this.node = node4;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) {
      this.updateChildren(view, pos);
    }
  }
  if (ViewDesc3)
    NodeViewDesc2.__proto__ = ViewDesc3;
  NodeViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  NodeViewDesc2.prototype.constructor = NodeViewDesc2;
  var prototypeAccessors$32 = { size: { configurable: true }, border: { configurable: true }, domAtom: { configurable: true } };
  NodeViewDesc2.create = function create5(parent, node4, outerDeco, innerDeco, view, pos) {
    var assign;
    var custom = view.nodeViews[node4.type.name], descObj;
    var spec = custom && custom(node4, view, function() {
      if (!descObj) {
        return pos;
      }
      if (descObj.parent) {
        return descObj.parent.posBeforeChild(descObj);
      }
    }, outerDeco, innerDeco);
    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node4.isText) {
      if (!dom) {
        dom = document.createTextNode(node4.text);
      } else if (dom.nodeType != 3) {
        throw new RangeError("Text must be rendered as a DOM text node");
      }
    } else if (!dom) {
      assign = DOMSerializer.renderSpec(document, node4.type.spec.toDOM(node4)), dom = assign.dom, contentDOM = assign.contentDOM;
    }
    if (!contentDOM && !node4.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable")) {
        dom.contentEditable = false;
      }
      if (node4.type.spec.draggable) {
        dom.draggable = true;
      }
    }
    var nodeDOM2 = dom;
    dom = applyOuterDeco(dom, outerDeco, node4);
    if (spec) {
      return descObj = new CustomNodeViewDesc(parent, node4, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos + 1);
    } else if (node4.isText) {
      return new TextViewDesc(parent, node4, outerDeco, innerDeco, dom, nodeDOM2, view);
    } else {
      return new NodeViewDesc2(parent, node4, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos + 1);
    }
  };
  NodeViewDesc2.prototype.parseRule = function parseRule2() {
    var this$1$1 = this;
    if (this.node.type.spec.reparseInView) {
      return null;
    }
    var rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre") {
      rule.preserveWhitespace = "full";
    }
    if (this.contentDOM && !this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      rule.getContent = function() {
        return this$1$1.contentDOM ? Fragment.empty : this$1$1.node.content;
      };
    }
    return rule;
  };
  NodeViewDesc2.prototype.matchesNode = function matchesNode2(node4, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node4.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  };
  prototypeAccessors$32.size.get = function() {
    return this.node.nodeSize;
  };
  prototypeAccessors$32.border.get = function() {
    return this.node.isLeaf ? 0 : 1;
  };
  NodeViewDesc2.prototype.updateChildren = function updateChildren(view, pos) {
    var this$1$1 = this;
    var inline2 = this.node.inlineContent, off = pos;
    var composition = view.composing && this.localCompositionInfo(view, pos);
    var localComposition = composition && composition.pos > -1 ? composition : null;
    var compositionInChild = composition && composition.pos < 0;
    var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
    iterDeco(this.node, this.innerDeco, function(widget2, i2, insideNode) {
      if (widget2.spec.marks) {
        updater.syncToMarks(widget2.spec.marks, inline2, view);
      } else if (widget2.type.side >= 0 && !insideNode) {
        updater.syncToMarks(i2 == this$1$1.node.childCount ? Mark.none : this$1$1.node.child(i2).marks, inline2, view);
      }
      updater.placeWidget(widget2, view, off);
    }, function(child3, outerDeco, innerDeco, i2) {
      updater.syncToMarks(child3.marks, inline2, view);
      var compIndex;
      if (updater.findNodeMatch(child3, outerDeco, innerDeco, i2))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child3.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child3, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child3, outerDeco, innerDeco, view, i2))
        ;
      else {
        updater.addNode(child3, outerDeco, innerDeco, view, off);
      }
      off += child3.nodeSize;
    });
    updater.syncToMarks(nothing, inline2, view);
    if (this.node.isTextblock) {
      updater.addTextblockHacks();
    }
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition) {
        this.protectLocalComposition(view, localComposition);
      }
      renderDescs(this.contentDOM, this.children, view);
      if (result.ios) {
        iosHacks(this.dom);
      }
    }
  };
  NodeViewDesc2.prototype.localCompositionInfo = function localCompositionInfo(view, pos) {
    var ref2 = view.state.selection;
    var from4 = ref2.from;
    var to = ref2.to;
    if (!(view.state.selection instanceof TextSelection) || from4 < pos || to > pos + this.node.content.size) {
      return;
    }
    var sel = view.root.getSelection();
    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode)) {
      return;
    }
    if (this.node.inlineContent) {
      var text3 = textNode.nodeValue;
      var textPos = findTextInFragment(this.node.content, text3, from4 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text3 };
    } else {
      return { node: textNode, pos: -1 };
    }
  };
  NodeViewDesc2.prototype.protectLocalComposition = function protectLocalComposition(view, ref2) {
    var node4 = ref2.node;
    var pos = ref2.pos;
    var text3 = ref2.text;
    if (this.getDesc(node4)) {
      return;
    }
    var topNode = node4;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM) {
        break;
      }
      while (topNode.previousSibling) {
        topNode.parentNode.removeChild(topNode.previousSibling);
      }
      while (topNode.nextSibling) {
        topNode.parentNode.removeChild(topNode.nextSibling);
      }
      if (topNode.pmViewDesc) {
        topNode.pmViewDesc = null;
      }
    }
    var desc = new CompositionViewDesc(this, topNode, node4, text3);
    view.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text3.length, view, desc);
  };
  NodeViewDesc2.prototype.update = function update2(node4, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node4.sameMarkup(this.node)) {
      return false;
    }
    this.updateInner(node4, outerDeco, innerDeco, view);
    return true;
  };
  NodeViewDesc2.prototype.updateInner = function updateInner(node4, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node4;
    this.innerDeco = innerDeco;
    if (this.contentDOM) {
      this.updateChildren(view, this.posAtStart);
    }
    this.dirty = NOT_DIRTY;
  };
  NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco)) {
      return;
    }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };
  NodeViewDesc2.prototype.selectNode = function selectNode() {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.draggable = true;
    }
  };
  NodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.removeAttribute("draggable");
    }
  };
  prototypeAccessors$32.domAtom.get = function() {
    return this.node.isAtom;
  };
  Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$32);
  return NodeViewDesc2;
}(ViewDesc);
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  return new NodeViewDesc(null, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
}
var TextViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
  function TextViewDesc2(parent, node4, outerDeco, innerDeco, dom, nodeDOM2, view) {
    NodeViewDesc2.call(this, parent, node4, outerDeco, innerDeco, dom, null, nodeDOM2, view);
  }
  if (NodeViewDesc2)
    TextViewDesc2.__proto__ = NodeViewDesc2;
  TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  TextViewDesc2.prototype.constructor = TextViewDesc2;
  var prototypeAccessors$42 = { domAtom: { configurable: true } };
  TextViewDesc2.prototype.parseRule = function parseRule2() {
    var skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco) {
      skip = skip.parentNode;
    }
    return { skip: skip || true };
  };
  TextViewDesc2.prototype.update = function update2(node4, outerDeco, _2, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node4.sameMarkup(this.node)) {
      return false;
    }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node4.text != this.node.text) && node4.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node4.text;
      if (view.trackWrites == this.nodeDOM) {
        view.trackWrites = null;
      }
    }
    this.node = node4;
    this.dirty = NOT_DIRTY;
    return true;
  };
  TextViewDesc2.prototype.inParent = function inParent() {
    var parentDOM = this.parent.contentDOM;
    for (var n2 = this.nodeDOM; n2; n2 = n2.parentNode) {
      if (n2 == parentDOM) {
        return true;
      }
    }
    return false;
  };
  TextViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
    return { node: this.nodeDOM, offset: pos };
  };
  TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset3, bias) {
    if (dom == this.nodeDOM) {
      return this.posAtStart + Math.min(offset3, this.node.text.length);
    }
    return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset3, bias);
  };
  TextViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  };
  TextViewDesc2.prototype.slice = function slice5(from4, to, view) {
    var node4 = this.node.cut(from4, to), dom = document.createTextNode(node4.text);
    return new TextViewDesc2(this.parent, node4, this.outerDeco, this.innerDeco, dom, dom, view);
  };
  TextViewDesc2.prototype.markDirty = function markDirty2(from4, to) {
    NodeViewDesc2.prototype.markDirty.call(this, from4, to);
    if (this.dom != this.nodeDOM && (from4 == 0 || to == this.nodeDOM.nodeValue.length)) {
      this.dirty = NODE_DIRTY;
    }
  };
  prototypeAccessors$42.domAtom.get = function() {
    return false;
  };
  Object.defineProperties(TextViewDesc2.prototype, prototypeAccessors$42);
  return TextViewDesc2;
}(NodeViewDesc);
var TrailingHackViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function TrailingHackViewDesc2() {
    ViewDesc3.apply(this, arguments);
  }
  if (ViewDesc3)
    TrailingHackViewDesc2.__proto__ = ViewDesc3;
  TrailingHackViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  TrailingHackViewDesc2.prototype.constructor = TrailingHackViewDesc2;
  var prototypeAccessors$52 = { domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
  TrailingHackViewDesc2.prototype.parseRule = function parseRule2() {
    return { ignore: true };
  };
  TrailingHackViewDesc2.prototype.matchesHack = function matchesHack2(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  };
  prototypeAccessors$52.domAtom.get = function() {
    return true;
  };
  prototypeAccessors$52.ignoreForCoords.get = function() {
    return this.dom.nodeName == "IMG";
  };
  Object.defineProperties(TrailingHackViewDesc2.prototype, prototypeAccessors$52);
  return TrailingHackViewDesc2;
}(ViewDesc);
var CustomNodeViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
  function CustomNodeViewDesc2(parent, node4, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos) {
    NodeViewDesc2.call(this, parent, node4, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos);
    this.spec = spec;
  }
  if (NodeViewDesc2)
    CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
  CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
  CustomNodeViewDesc2.prototype.update = function update2(node4, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY) {
      return false;
    }
    if (this.spec.update) {
      var result2 = this.spec.update(node4, outerDeco, innerDeco);
      if (result2) {
        this.updateInner(node4, outerDeco, innerDeco, view);
      }
      return result2;
    } else if (!this.contentDOM && !node4.isLeaf) {
      return false;
    } else {
      return NodeViewDesc2.prototype.update.call(this, node4, outerDeco, innerDeco, view);
    }
  };
  CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.setSelection = function setSelection2(anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root, force);
  };
  CustomNodeViewDesc2.prototype.destroy = function destroy4() {
    if (this.spec.destroy) {
      this.spec.destroy();
    }
    NodeViewDesc2.prototype.destroy.call(this);
  };
  CustomNodeViewDesc2.prototype.stopEvent = function stopEvent2(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  };
  CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
  };
  return CustomNodeViewDesc2;
}(NodeViewDesc);
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i2 = 0; i2 < descs.length; i2++) {
    var desc = descs[i2], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM) {
    view.trackWrites = null;
  }
}
function OuterDecoLevel(nodeName) {
  if (nodeName) {
    this.nodeName = nodeName;
  }
}
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node4, needsWrap) {
  if (outerDeco.length == 0) {
    return noDeco;
  }
  var top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result2 = [top2];
  for (var i2 = 0; i2 < outerDeco.length; i2++) {
    var attrs = outerDeco[i2].type.attrs;
    if (!attrs) {
      continue;
    }
    if (attrs.nodeName) {
      result2.push(top2 = new OuterDecoLevel(attrs.nodeName));
    }
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) {
        continue;
      }
      if (needsWrap && result2.length == 1) {
        result2.push(top2 = new OuterDecoLevel(node4.isInline ? "span" : "div"));
      }
      if (name == "class") {
        top2.class = (top2.class ? top2.class + " " : "") + val;
      } else if (name == "style") {
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      } else if (name != "nodeName") {
        top2[name] = val;
      }
    }
  }
  return result2;
}
function patchOuterDeco(outerDOM, nodeDOM2, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) {
    return nodeDOM2;
  }
  var curDOM = nodeDOM2;
  for (var i2 = 0; i2 < curComputed.length; i2++) {
    var deco = curComputed[i2], prev = prevComputed[i2];
    if (i2) {
      var parent = void 0;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (var name in prev) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
      dom.removeAttribute(name);
    }
  }
  for (var name$1 in cur) {
    if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1]) {
      dom.setAttribute(name$1, cur[name$1]);
    }
  }
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
    for (var i2 = 0; i2 < prevList.length; i2++) {
      if (curList.indexOf(prevList[i2]) == -1) {
        dom.classList.remove(prevList[i2]);
      }
    }
    for (var i$1 = 0; i$1 < curList.length; i$1++) {
      if (prevList.indexOf(curList[i$1]) == -1) {
        dom.classList.add(curList[i$1]);
      }
    }
    if (dom.classList.length == 0) {
      dom.removeAttribute("class");
    }
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m2;
      while (m2 = prop.exec(prev.style)) {
        dom.style.removeProperty(m2[1]);
      }
    }
    if (cur.style) {
      dom.style.cssText += cur.style;
    }
  }
}
function applyOuterDeco(dom, deco, node4) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node4, dom.nodeType != 1));
}
function sameOuterDeco(a2, b) {
  if (a2.length != b.length) {
    return false;
  }
  for (var i2 = 0; i2 < a2.length; i2++) {
    if (!a2[i2].type.eq(b[i2].type)) {
      return false;
    }
  }
  return true;
}
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = function ViewTreeUpdater2(top2, lockedNode) {
  this.top = top2;
  this.lock = lockedNode;
  this.index = 0;
  this.stack = [];
  this.changed = false;
  this.preMatch = preMatch(top2.node.content, top2);
};
ViewTreeUpdater.prototype.destroyBetween = function destroyBetween(start4, end3) {
  if (start4 == end3) {
    return;
  }
  for (var i2 = start4; i2 < end3; i2++) {
    this.top.children[i2].destroy();
  }
  this.top.children.splice(start4, end3 - start4);
  this.changed = true;
};
ViewTreeUpdater.prototype.destroyRest = function destroyRest() {
  this.destroyBetween(this.index, this.top.children.length);
};
ViewTreeUpdater.prototype.syncToMarks = function syncToMarks(marks2, inline2, view) {
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks2.length);
  while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks2[keep]) && marks2[keep].type.spec.spanning !== false) {
    keep++;
  }
  while (keep < depth) {
    this.destroyRest();
    this.top.dirty = NOT_DIRTY;
    this.index = this.stack.pop();
    this.top = this.stack.pop();
    depth--;
  }
  while (depth < marks2.length) {
    this.stack.push(this.top, this.index + 1);
    var found2 = -1;
    for (var i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
      if (this.top.children[i2].matchesMark(marks2[depth])) {
        found2 = i2;
        break;
      }
    }
    if (found2 > -1) {
      if (found2 > this.index) {
        this.changed = true;
        this.destroyBetween(this.index, found2);
      }
      this.top = this.top.children[this.index];
    } else {
      var markDesc = MarkViewDesc.create(this.top, marks2[depth], inline2, view);
      this.top.children.splice(this.index, 0, markDesc);
      this.top = markDesc;
      this.changed = true;
    }
    this.index = 0;
    depth++;
  }
};
ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch(node4, outerDeco, innerDeco, index3) {
  var found2 = -1, targetDesc;
  if (index3 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index3 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node4, outerDeco, innerDeco)) {
    found2 = this.top.children.indexOf(targetDesc, this.index);
  } else {
    for (var i2 = this.index, e2 = Math.min(this.top.children.length, i2 + 5); i2 < e2; i2++) {
      var child3 = this.top.children[i2];
      if (child3.matchesNode(node4, outerDeco, innerDeco) && !this.preMatch.matched.has(child3)) {
        found2 = i2;
        break;
      }
    }
  }
  if (found2 < 0) {
    return false;
  }
  this.destroyBetween(this.index, found2);
  this.index++;
  return true;
};
ViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt(node4, outerDeco, innerDeco, index3, view) {
  var child3 = this.top.children[index3];
  if (!child3.update(node4, outerDeco, innerDeco, view)) {
    return false;
  }
  this.destroyBetween(this.index, index3);
  this.index = index3 + 1;
  return true;
};
ViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild(domNode) {
  for (; ; ) {
    var parent = domNode.parentNode;
    if (!parent) {
      return -1;
    }
    if (parent == this.top.contentDOM) {
      var desc = domNode.pmViewDesc;
      if (desc) {
        for (var i2 = this.index; i2 < this.top.children.length; i2++) {
          if (this.top.children[i2] == desc) {
            return i2;
          }
        }
      }
      return -1;
    }
    domNode = parent;
  }
};
ViewTreeUpdater.prototype.updateNextNode = function updateNextNode(node4, outerDeco, innerDeco, view, index3) {
  for (var i2 = this.index; i2 < this.top.children.length; i2++) {
    var next = this.top.children[i2];
    if (next instanceof NodeViewDesc) {
      var preMatch2 = this.preMatch.matched.get(next);
      if (preMatch2 != null && preMatch2 != index3) {
        return false;
      }
      var nextDOM = next.dom;
      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node4.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node4.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
      if (!locked && next.update(node4, outerDeco, innerDeco, view)) {
        this.destroyBetween(this.index, i2);
        if (next.dom != nextDOM) {
          this.changed = true;
        }
        this.index++;
        return true;
      }
      break;
    }
  }
  return false;
};
ViewTreeUpdater.prototype.addNode = function addNode2(node4, outerDeco, innerDeco, view, pos) {
  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node4, outerDeco, innerDeco, view, pos));
  this.changed = true;
};
ViewTreeUpdater.prototype.placeWidget = function placeWidget(widget2, view, pos) {
  var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
  if (next && next.matchesWidget(widget2) && (widget2 == next.widget || !next.widget.type.toDOM.parentNode)) {
    this.index++;
  } else {
    var desc = new WidgetViewDesc(this.top, widget2, view, pos);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};
ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks() {
  var lastChild = this.top.children[this.index - 1];
  while (lastChild instanceof MarkViewDesc) {
    lastChild = lastChild.children[lastChild.children.length - 1];
  }
  if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
    if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == "false") {
      this.addHackNode("IMG");
    }
    this.addHackNode("BR");
  }
};
ViewTreeUpdater.prototype.addHackNode = function addHackNode(nodeName) {
  if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
    this.index++;
  } else {
    var dom = document.createElement(nodeName);
    if (nodeName == "IMG") {
      dom.className = "ProseMirror-separator";
    }
    if (nodeName == "BR") {
      dom.className = "ProseMirror-trailingBreak";
    }
    this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));
    this.changed = true;
  }
};
function preMatch(frag, parentDesc) {
  var curDesc = parentDesc, descI = curDesc.children.length;
  var fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      var desc = void 0;
      for (; ; ) {
        if (descI) {
          var next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      var node4 = desc.node;
      if (!node4) {
        continue;
      }
      if (node4 != frag.child(fI - 1)) {
        break;
      }
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a2, b) {
  return a2.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  var locals3 = deco.locals(parent), offset3 = 0;
  if (locals3.length == 0) {
    for (var i2 = 0; i2 < parent.childCount; i2++) {
      var child3 = parent.child(i2);
      onNode(child3, locals3, deco.forChild(offset3, child3), i2);
      offset3 += child3.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    if (decoIndex < locals3.length && locals3[decoIndex].to == offset3) {
      var widget2 = locals3[decoIndex++], widgets = void 0;
      while (decoIndex < locals3.length && locals3[decoIndex].to == offset3) {
        (widgets || (widgets = [widget2])).push(locals3[decoIndex++]);
      }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) {
          onWidget(widgets[i$1], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget2, parentIndex, !!restNode);
      }
    }
    var child$1 = void 0, index3 = void 0;
    if (restNode) {
      index3 = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index3 = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var i$2 = 0; i$2 < active.length; i$2++) {
      if (active[i$2].to <= offset3) {
        active.splice(i$2--, 1);
      }
    }
    while (decoIndex < locals3.length && locals3[decoIndex].from <= offset3 && locals3[decoIndex].to > offset3) {
      active.push(locals3[decoIndex++]);
    }
    var end3 = offset3 + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end3;
      if (decoIndex < locals3.length && locals3[decoIndex].from < cutAt) {
        cutAt = locals3[decoIndex].from;
      }
      for (var i$3 = 0; i$3 < active.length; i$3++) {
        if (active[i$3].to < cutAt) {
          cutAt = active[i$3].to;
        }
      }
      if (cutAt < end3) {
        restNode = child$1.cut(cutAt - offset3);
        child$1 = child$1.cut(0, cutAt - offset3);
        end3 = cutAt;
        index3 = -1;
      }
    }
    var outerDeco = !active.length ? nothing : child$1.isInline && !child$1.isLeaf ? active.filter(function(d2) {
      return !d2.inline;
    }) : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset3, child$1), index3);
    offset3 = end3;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node4, offset3) {
  for (; ; ) {
    if (node4.nodeType == 3) {
      return node4;
    }
    if (node4.nodeType == 1 && offset3 > 0) {
      if (node4.childNodes.length > offset3 && node4.childNodes[offset3].nodeType == 3) {
        return node4.childNodes[offset3];
      }
      node4 = node4.childNodes[offset3 - 1];
      offset3 = nodeSize(node4);
    } else if (node4.nodeType == 1 && offset3 < node4.childNodes.length) {
      node4 = node4.childNodes[offset3];
      offset3 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text3, from4, to) {
  for (var i2 = 0, pos = 0; i2 < frag.childCount && pos <= to; ) {
    var child3 = frag.child(i2++), childStart = pos;
    pos += child3.nodeSize;
    if (!child3.isText) {
      continue;
    }
    var str = child3.text;
    while (i2 < frag.childCount) {
      var next = frag.child(i2++);
      pos += next.nodeSize;
      if (!next.isText) {
        break;
      }
      str += next.text;
    }
    if (pos >= from4 && childStart < to) {
      var found2 = str.lastIndexOf(text3, to - childStart - 1);
      if (found2 >= 0 && found2 + text3.length + childStart >= from4) {
        return childStart + found2;
      }
    }
  }
  return -1;
}
function replaceNodes(nodes, from4, to, view, replacement) {
  var result2 = [];
  for (var i2 = 0, off = 0; i2 < nodes.length; i2++) {
    var child3 = nodes[i2], start4 = off, end3 = off += child3.size;
    if (start4 >= to || end3 <= from4) {
      result2.push(child3);
    } else {
      if (start4 < from4) {
        result2.push(child3.slice(0, from4 - start4, view));
      }
      if (replacement) {
        result2.push(replacement);
        replacement = null;
      }
      if (end3 > to) {
        result2.push(child3.slice(to - start4, child3.size, view));
      }
    }
  }
  return result2;
}
function selectionFromDOM(view, origin) {
  var domSel = view.root.getSelection(), doc2 = view.state.doc;
  if (!domSel.focusNode) {
    return null;
  }
  var nearestDesc2 = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc2 && nearestDesc2.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) {
    return null;
  }
  var $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc2 && !nearestDesc2.node) {
      nearestDesc2 = nearestDesc2.parent;
    }
    if (nearestDesc2 && nearestDesc2.node.isAtom && NodeSelection.isSelectable(nearestDesc2.node) && nearestDesc2.parent && !(nearestDesc2.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc2.dom))) {
      var pos = nearestDesc2.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor < 0) {
      return null;
    }
    $anchor = doc2.resolve(anchor);
  }
  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force) {
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view)) {
    return;
  }
  if (!force && view.mouseDown && view.mouseDown.allowDefault && result.chrome) {
    var domSel = view.root.getSelection(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent) {
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      }
      if (!sel.empty && !sel.$from.parent.inlineContent) {
        resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) {
        resetEditable(resetEditableFrom);
      }
      if (resetEditableTo) {
        resetEditable(resetEditableTo);
      }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) {
        removeClassOnSelectionChange(view);
      }
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  var ref2 = view.docView.domFromPos(pos, 0);
  var node4 = ref2.node;
  var offset3 = ref2.offset;
  var after2 = offset3 < node4.childNodes.length ? node4.childNodes[offset3] : null;
  var before2 = offset3 ? node4.childNodes[offset3 - 1] : null;
  if (result.safari && after2 && after2.contentEditable == "false") {
    return setEditable(after2);
  }
  if ((!after2 || after2.contentEditable == "false") && (!before2 || before2.contentEditable == "false")) {
    if (after2) {
      return setEditable(after2);
    } else if (before2) {
      return setEditable(before2);
    }
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (result.safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  var doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node4 = domSel.anchorNode, offset3 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.hideSelectionGuard = function() {
    if (domSel.anchorNode != node4 || domSel.anchorOffset != offset3) {
      doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function() {
        if (!editorOwnsSelection(view) || view.state.selection.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        }
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  var domSel = view.root.getSelection(), range2 = document.createRange();
  var node4 = view.cursorWrapper.dom, img = node4.nodeName == "IMG";
  if (img) {
    range2.setEnd(node4.parentNode, domIndex(node4) + 1);
  } else {
    range2.setEnd(node4, 0);
  }
  range2.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range2);
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node4.disabled = true;
    node4.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) {
        desc.selectNode();
      }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) {
      view.lastSelectedViewDesc.deselectNode();
    }
    view.lastSelectedViewDesc = null;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function(f2) {
    return f2(view, $anchor, $head);
  }) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) {
    return false;
  }
  return hasSelection(view);
}
function hasSelection(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) {
    return false;
  }
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  var ref2 = state.selection;
  var $anchor = ref2.$anchor;
  var $head = ref2.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply7(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection) {
        return apply7(view, next);
      }
      return false;
    } else if (!(result.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node4 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node4 || node4.isText) {
        return false;
      }
      var nodePos = dir < 0 ? $head.pos - node4.nodeSize : $head.pos;
      if (!(node4.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) {
        return false;
      }
      if (NodeSelection.isSelectable(node4)) {
        return apply7(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node4.nodeSize) : $head));
      } else if (result.webkit) {
        return apply7(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node4.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply7(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var next$1 = moveSelectionBlock(view.state, dir);
    if (next$1) {
      return apply7(view, next$1);
    }
    return false;
  }
}
function nodeLen(node4) {
  return node4.nodeType == 3 ? node4.nodeValue.length : node4.childNodes.length;
}
function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft(view) {
  var sel = view.root.getSelection();
  var node4 = sel.focusNode, offset3 = sel.focusOffset;
  if (!node4) {
    return;
  }
  var moveNode, moveOffset, force = false;
  if (result.gecko && node4.nodeType == 1 && offset3 < nodeLen(node4) && isIgnorable(node4.childNodes[offset3])) {
    force = true;
  }
  for (; ; ) {
    if (offset3 > 0) {
      if (node4.nodeType != 1) {
        break;
      } else {
        var before2 = node4.childNodes[offset3 - 1];
        if (isIgnorable(before2)) {
          moveNode = node4;
          moveOffset = --offset3;
        } else if (before2.nodeType == 3) {
          node4 = before2;
          offset3 = node4.nodeValue.length;
        } else {
          break;
        }
      }
    } else if (isBlockNode(node4)) {
      break;
    } else {
      var prev = node4.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node4.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node4 = node4.parentNode;
        if (node4 == view.dom) {
          break;
        }
        offset3 = 0;
      } else {
        node4 = prev;
        offset3 = nodeLen(node4);
      }
    }
  }
  if (force) {
    setSelFocus(view, sel, node4, offset3);
  } else if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function skipIgnoredNodesRight(view) {
  var sel = view.root.getSelection();
  var node4 = sel.focusNode, offset3 = sel.focusOffset;
  if (!node4) {
    return;
  }
  var len = nodeLen(node4);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset3 < len) {
      if (node4.nodeType != 1) {
        break;
      }
      var after2 = node4.childNodes[offset3];
      if (isIgnorable(after2)) {
        moveNode = node4;
        moveOffset = ++offset3;
      } else {
        break;
      }
    } else if (isBlockNode(node4)) {
      break;
    } else {
      var next = node4.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node4 = node4.parentNode;
        if (node4 == view.dom) {
          break;
        }
        offset3 = len = 0;
      } else {
        node4 = next;
        offset3 = 0;
        len = nodeLen(node4);
      }
    }
  }
  if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view, sel, node4, offset3) {
  if (selectionCollapsed(sel)) {
    var range2 = document.createRange();
    range2.setEnd(node4, offset3);
    range2.setStart(node4, offset3);
    sel.removeAllRanges();
    sel.addRange(range2);
  } else if (sel.extend) {
    sel.extend(node4, offset3);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function() {
    if (view.state == state) {
      selectionToDOM(view);
    }
  }, 50);
}
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) {
    return false;
  }
  if (result.mac && mods.indexOf("m") > -1) {
    return false;
  }
  var $from = sel.$from;
  var $to = sel.$to;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection) {
      return apply7(view, next);
    }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply7(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection)) {
    return true;
  }
  var ref2 = view.state.selection;
  var $head = ref2.$head;
  var $anchor = ref2.$anchor;
  var empty2 = ref2.empty;
  if (!$head.sameParent($anchor)) {
    return true;
  }
  if (!empty2) {
    return false;
  }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
    return true;
  }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) {
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    } else {
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    }
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node4, state) {
  view.domObserver.stop();
  node4.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!result.safari || view.state.selection.$head.parentOffset > 0) {
    return;
  }
  var ref2 = view.root.getSelection();
  var focusNode = ref2.focusNode;
  var focusOffset = ref2.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child3 = focusNode.firstChild;
    switchEditable(view, child3, true);
    setTimeout(function() {
      return switchEditable(view, child3, false);
    }, 20);
  }
}
function getMods(event) {
  var result2 = "";
  if (event.ctrlKey) {
    result2 += "c";
  }
  if (event.metaKey) {
    result2 += "m";
  }
  if (event.altKey) {
    result2 += "a";
  }
  if (event.shiftKey) {
    result2 += "s";
  }
  return result2;
}
function captureKeyDown(view, event) {
  var code = event.keyCode, mods = getMods(event);
  if (code == 8 || result.mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code == 46 || result.mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37) {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 39) {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code == 38) {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 40) {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (result.mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function parseBetween(view, from_, to_) {
  var ref2 = view.docView.parseRange(from_, to_);
  var parent = ref2.node;
  var fromOffset = ref2.fromOffset;
  var toOffset = ref2.toOffset;
  var from4 = ref2.from;
  var to = ref2.to;
  var domSel = view.root.getSelection(), find2 = null, anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel)) {
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
  }
  if (result.chrome && view.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node4 = parent.childNodes[off - 1], desc = node4.pmViewDesc;
      if (node4.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size) {
        break;
      }
    }
  }
  var startDoc = view.state.doc;
  var parser2 = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from4);
  var sel = null, doc2 = parser2.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    editableContent: true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    var anchor$1 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null) {
      head = anchor$1;
    }
    sel = { anchor: anchor$1 + from4, head: head + from4 };
  }
  return { doc: doc2, sel, from: from4, to };
}
function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
}
function readDOMChange(view, from4, to, typeOver, addedNodes) {
  if (from4 < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") {
        tr$1.setMeta("pointer", true);
      } else if (origin == "key") {
        tr$1.scrollIntoView();
      }
      view.dispatch(tr$1);
    }
    return;
  }
  var $before = view.state.doc.resolve(from4);
  var shared = $before.sharedDepth(to);
  from4 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse3 = parseBetween(view, from4, to);
  if (result.chrome && view.cursorWrapper && parse3.sel && parse3.sel.anchor == view.cursorWrapper.deco.from) {
    var text3 = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text3 && text3.nodeValue ? text3.nodeValue.length : 1;
    parse3.sel = { anchor: parse3.sel.anchor + size, head: parse3.sel.anchor + size };
  }
  var doc2 = view.state.doc, compare = doc2.slice(parse3.from, parse3.to);
  var preferredPos, preferredSide;
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;
  var change = findDiff(compare.content, parse3.doc.content, parse3.from, preferredPos, preferredSide);
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse3.sel && parse3.sel.anchor != parse3.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) && addedNodes.some(function(n2) {
      return n2.nodeName == "DIV" || n2.nodeName == "P";
    }) && view.someProp("handleKeyDown", function(f2) {
      return f2(view, keyEvent(13, "Enter"));
    })) {
      view.lastIOSEnter = 0;
      return;
    } else {
      if (parse3.sel) {
        var sel$1 = resolveSelection(view, view.state.doc, parse3.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) {
          view.dispatch(view.state.tr.setSelection(sel$1));
        }
      }
      return;
    }
  }
  view.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse3.from && parse3.doc.textBetween(change.start - parse3.from - 1, change.start - parse3.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  var $from = parse3.doc.resolveNoCache(change.start - parse3.from);
  var $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  if ((result.ios && view.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n2) {
    return n2.nodeName == "DIV" || n2.nodeName == "P";
  })) || !inlineChange && $from.pos < parse3.doc.content.size && (nextSel = Selection.findFrom(parse3.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f2) {
    return f2(view, keyEvent(13, "Enter"));
  })) {
    view.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f2) {
    return f2(view, keyEvent(8, "Backspace"));
  })) {
    if (result.android && result.chrome) {
      view.domObserver.suppressSelectionUpdates();
    }
    return;
  }
  if (result.chrome && result.android && change.toB == change.from) {
    view.lastAndroidDelete = Date.now();
  }
  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse3.sel && parse3.sel.anchor == parse3.sel.head && parse3.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
    setTimeout(function() {
      view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  var chFrom = change.start, chTo = change.endA;
  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function() {
          return selectionToDOM(view);
        }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && ($from1 = doc2.resolve(change.start)) && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") {
        tr.addMark(chFrom, chTo, markChange.mark);
      } else {
        tr.removeMark(chFrom, chTo, markChange.mark);
      }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text$12 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function(f2) {
        return f2(view, chFrom, chTo, text$12);
      })) {
        return;
      }
      tr = view.state.tr.insertText(text$12, chFrom, chTo);
    }
  }
  if (!tr) {
    tr = view.state.tr.replace(chFrom, chTo, parse3.doc.slice(change.start - parse3.from, change.endB - parse3.from));
  }
  if (parse3.sel) {
    var sel$2 = resolveSelection(view, tr.doc, parse3.sel);
    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty && (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) && (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) || result.ie && sel$2.empty && sel$2.head == chFrom)) {
      tr.setSelection(sel$2);
    }
  }
  if (storedMarks) {
    tr.ensureMarks(storedMarks);
  }
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) {
    return null;
  }
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type2, mark3, update2;
  for (var i2 = 0; i2 < prevMarks.length; i2++) {
    added = prevMarks[i2].removeFromSet(added);
  }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
    removed = curMarks[i$1].removeFromSet(removed);
  }
  if (added.length == 1 && removed.length == 0) {
    mark3 = added[0];
    type2 = "add";
    update2 = function(node4) {
      return node4.mark(mark3.addToSet(node4.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark3 = removed[0];
    type2 = "remove";
    update2 = function(node4) {
      return node4.mark(mark3.removeFromSet(node4.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev.childCount; i$2++) {
    updated.push(update2(prev.child(i$2)));
  }
  if (Fragment.from(updated).eq(cur)) {
    return { mark: mark3, type: type2 };
  }
}
function looksLikeJoin(old, start4, end3, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end3 - start4 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
    return false;
  }
  var $start = old.resolve(start4);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
    return false;
  }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end3 || skipClosingAndOpening($next, true, false) < end3) {
    return false;
  }
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end3 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end3++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end3++;
    }
  }
  return end3;
}
function findDiff(a2, b, pos, preferredPos, preferredSide) {
  var start4 = a2.findDiffStart(b, pos);
  if (start4 == null) {
    return null;
  }
  var ref2 = a2.findDiffEnd(b, pos + a2.size, pos + b.size);
  var endA = ref2.a;
  var endB = ref2.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start4 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start4;
  }
  if (endA < start4 && a2.size < b.size) {
    var move2 = preferredPos <= start4 && preferredPos >= endA ? start4 - preferredPos : 0;
    start4 -= move2;
    endB = start4 + (endB - endA);
    endA = start4;
  } else if (endB < start4) {
    var move$1 = preferredPos <= start4 && preferredPos >= endB ? start4 - preferredPos : 0;
    start4 -= move$1;
    endA = start4 + (endA - endB);
    endB = start4;
  }
  return { start: start4, endA, endB };
}
function serializeForClipboard(view, slice5) {
  var context2 = [];
  var content2 = slice5.content;
  var openStart = slice5.openStart;
  var openEnd = slice5.openEnd;
  while (openStart > 1 && openEnd > 1 && content2.childCount == 1 && content2.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node4 = content2.firstChild;
    context2.push(node4.type.name, node4.attrs != node4.type.defaultAttrs ? node4.attrs : null);
    content2 = node4.content;
  }
  var serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  var doc2 = detachedDoc(), wrap = doc2.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content2, { document: doc2 }));
  var firstChild = wrap.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i2 = needsWrap.length - 1; i2 >= 0; i2--) {
      var wrapper = doc2.createElement(needsWrap[i2]);
      while (wrap.firstChild) {
        wrapper.appendChild(wrap.firstChild);
      }
      wrap.appendChild(wrapper);
      if (needsWrap[i2] != "tbody") {
        openStart++;
        openEnd++;
      }
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) {
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context2));
  }
  var text3 = view.someProp("clipboardTextSerializer", function(f2) {
    return f2(slice5);
  }) || slice5.content.textBetween(0, slice5.content.size, "\n\n");
  return { dom: wrap, text: text3 };
}
function parseFromClipboard(view, text3, html, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice5;
  if (!html && !text3) {
    return null;
  }
  var asText = text3 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", function(f2) {
      text3 = f2(text3, inCode || plainText);
    });
    if (inCode) {
      return text3 ? new Slice(Fragment.from(view.state.schema.text(text3.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    }
    var parsed = view.someProp("clipboardTextParser", function(f2) {
      return f2(text3, $context, plainText);
    });
    if (parsed) {
      slice5 = parsed;
    } else {
      var marks2 = $context.marks();
      var ref2 = view.state;
      var schema = ref2.schema;
      var serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text3.split(/(?:\r\n?|\n)+/).forEach(function(block) {
        var p2 = dom.appendChild(document.createElement("p"));
        if (block) {
          p2.appendChild(serializer.serializeNode(schema.text(block, marks2)));
        }
      });
    }
  } else {
    view.someProp("transformPastedHTML", function(f2) {
      html = f2(html);
    });
    dom = readHTML(html);
    if (result.webkit) {
      restoreReplacedSpaces(dom);
    }
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice5) {
    var parser2 = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice5 = parser2.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode: function ruleFromNode2(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName)) {
          return { ignore: true };
        }
      }
    });
  }
  if (sliceData) {
    slice5 = addContext(closeSlice(slice5, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else {
    slice5 = Slice.maxOpen(normalizeSiblings(slice5.content, $context), true);
    if (slice5.openStart || slice5.openEnd) {
      var openStart = 0, openEnd = 0;
      for (var node4 = slice5.content.firstChild; openStart < slice5.openStart && !node4.type.spec.isolating; openStart++, node4 = node4.firstChild) {
      }
      for (var node$1 = slice5.content.lastChild; openEnd < slice5.openEnd && !node$1.type.spec.isolating; openEnd++, node$1 = node$1.lastChild) {
      }
      slice5 = closeSlice(slice5, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", function(f2) {
    slice5 = f2(slice5);
  });
  return slice5;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) {
    return fragment;
  }
  var loop = function(d3) {
    var parent = $context.node(d3);
    var match = parent.contentMatchAt($context.index(d3));
    var lastWrap = void 0, result2 = [];
    fragment.forEach(function(node4) {
      if (!result2) {
        return;
      }
      var wrap = match.findWrapping(node4.type), inLast;
      if (!wrap) {
        return result2 = null;
      }
      if (inLast = result2.length && lastWrap.length && addToSibling(wrap, lastWrap, node4, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length) {
          result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
        }
        var wrapped = withWrappers(node4, wrap);
        result2.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap;
      }
    });
    if (result2) {
      return { v: Fragment.from(result2) };
    }
  };
  for (var d2 = $context.depth; d2 >= 0; d2--) {
    var returned = loop(d2);
    if (returned)
      return returned.v;
  }
  return fragment;
}
function withWrappers(node4, wrap, from4) {
  if (from4 === void 0)
    from4 = 0;
  for (var i2 = wrap.length - 1; i2 >= from4; i2--) {
    node4 = wrap[i2].create(null, Fragment.from(node4));
  }
  return node4;
}
function addToSibling(wrap, lastWrap, node4, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node4, sibling.lastChild, depth + 1);
    if (inner) {
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    }
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node4.type : wrap[depth + 1])) {
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node4, wrap, depth + 1))));
    }
  }
}
function closeRight(node4, depth) {
  if (depth == 0) {
    return node4;
  }
  var fragment = node4.content.replaceChild(node4.childCount - 1, closeRight(node4.lastChild, depth - 1));
  var fill = node4.contentMatchAt(node4.childCount).fillBefore(Fragment.empty, true);
  return node4.copy(fragment.append(fill));
}
function closeRange(fragment, side, from4, to, depth, openEnd) {
  var node4 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node4.content;
  if (depth < to - 1) {
    inner = closeRange(inner, side, from4, to, depth + 1, openEnd);
  }
  if (depth >= from4) {
    inner = side < 0 ? node4.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node4.contentMatchAt(node4.childCount).fillBefore(Fragment.empty, true));
  }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node4.copy(inner));
}
function closeSlice(slice5, openStart, openEnd) {
  if (openStart < slice5.openStart) {
    slice5 = new Slice(closeRange(slice5.content, -1, openStart, slice5.openStart, 0, slice5.openEnd), openStart, slice5.openEnd);
  }
  if (openEnd < slice5.openEnd) {
    slice5 = new Slice(closeRange(slice5.content, 1, openEnd, slice5.openEnd, 0, 0), slice5.openStart, openEnd);
  }
  return slice5;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) {
    html = html.slice(metas[0].length);
  }
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
    html = wrap.map(function(n2) {
      return "<" + n2 + ">";
    }).join("") + html + wrap.map(function(n2) {
      return "</" + n2 + ">";
    }).reverse().join("");
  }
  elt.innerHTML = html;
  if (wrap) {
    for (var i2 = 0; i2 < wrap.length; i2++) {
      elt = elt.querySelector(wrap[i2]) || elt;
    }
  }
  return elt;
}
function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var node4 = nodes[i2];
    if (node4.childNodes.length == 1 && node4.textContent == "\xA0" && node4.parentNode) {
      node4.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node4);
    }
  }
}
function addContext(slice5, context2) {
  if (!slice5.size) {
    return slice5;
  }
  var schema = slice5.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context2);
  } catch (e2) {
    return slice5;
  }
  var content2 = slice5.content;
  var openStart = slice5.openStart;
  var openEnd = slice5.openEnd;
  for (var i2 = array.length - 2; i2 >= 0; i2 -= 2) {
    var type2 = schema.nodes[array[i2]];
    if (!type2 || type2.hasRequiredAttrs()) {
      break;
    }
    content2 = Fragment.from(type2.create(array[i2 + 1], content2));
    openStart++;
    openEnd++;
  }
  return new Slice(content2, openStart, openEnd);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = result.ie && result.ie_version <= 11;
var SelectionState = function SelectionState2() {
  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
};
SelectionState.prototype.set = function set(sel) {
  this.anchorNode = sel.anchorNode;
  this.anchorOffset = sel.anchorOffset;
  this.focusNode = sel.focusNode;
  this.focusOffset = sel.focusOffset;
};
SelectionState.prototype.eq = function eq5(sel) {
  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
};
var DOMObserver = function DOMObserver2(view, handleDOMChange) {
  var this$1$1 = this;
  this.view = view;
  this.handleDOMChange = handleDOMChange;
  this.queue = [];
  this.flushingSoon = -1;
  this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
    for (var i2 = 0; i2 < mutations.length; i2++) {
      this$1$1.queue.push(mutations[i2]);
    }
    if (result.ie && result.ie_version <= 11 && mutations.some(function(m2) {
      return m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length;
    })) {
      this$1$1.flushSoon();
    } else {
      this$1$1.flush();
    }
  });
  this.currentSelection = new SelectionState();
  if (useCharData) {
    this.onCharData = function(e2) {
      this$1$1.queue.push({ target: e2.target, type: "characterData", oldValue: e2.prevValue });
      this$1$1.flushSoon();
    };
  }
  this.onSelectionChange = this.onSelectionChange.bind(this);
  this.suppressingSelectionUpdates = false;
};
DOMObserver.prototype.flushSoon = function flushSoon() {
  var this$1$1 = this;
  if (this.flushingSoon < 0) {
    this.flushingSoon = window.setTimeout(function() {
      this$1$1.flushingSoon = -1;
      this$1$1.flush();
    }, 20);
  }
};
DOMObserver.prototype.forceFlush = function forceFlush() {
  if (this.flushingSoon > -1) {
    window.clearTimeout(this.flushingSoon);
    this.flushingSoon = -1;
    this.flush();
  }
};
DOMObserver.prototype.start = function start2() {
  if (this.observer) {
    this.observer.observe(this.view.dom, observeOptions);
  }
  if (useCharData) {
    this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.connectSelection();
};
DOMObserver.prototype.stop = function stop() {
  var this$1$1 = this;
  if (this.observer) {
    var take = this.observer.takeRecords();
    if (take.length) {
      for (var i2 = 0; i2 < take.length; i2++) {
        this.queue.push(take[i2]);
      }
      window.setTimeout(function() {
        return this$1$1.flush();
      }, 20);
    }
    this.observer.disconnect();
  }
  if (useCharData) {
    this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.disconnectSelection();
};
DOMObserver.prototype.connectSelection = function connectSelection() {
  this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver.prototype.disconnectSelection = function disconnectSelection() {
  this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates() {
  var this$1$1 = this;
  this.suppressingSelectionUpdates = true;
  setTimeout(function() {
    return this$1$1.suppressingSelectionUpdates = false;
  }, 50);
};
DOMObserver.prototype.onSelectionChange = function onSelectionChange() {
  if (!hasFocusAndSelection(this.view)) {
    return;
  }
  if (this.suppressingSelectionUpdates) {
    return selectionToDOM(this.view);
  }
  if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
    var sel = this.view.root.getSelection();
    if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) {
      return this.flushSoon();
    }
  }
  this.flush();
};
DOMObserver.prototype.setCurSelection = function setCurSelection() {
  this.currentSelection.set(this.view.root.getSelection());
};
DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange(sel) {
  if (sel.rangeCount == 0) {
    return true;
  }
  var container = sel.getRangeAt(0).commonAncestorContainer;
  var desc = this.view.docView.nearestDesc(container);
  if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
    this.setCurSelection();
    return true;
  }
};
DOMObserver.prototype.flush = function flush() {
  if (!this.view.docView || this.flushingSoon > -1) {
    return;
  }
  var mutations = this.observer ? this.observer.takeRecords() : [];
  if (this.queue.length) {
    mutations = this.queue.concat(mutations);
    this.queue.length = 0;
  }
  var sel = this.view.root.getSelection();
  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);
  var from4 = -1, to = -1, typeOver = false, added = [];
  if (this.view.editable) {
    for (var i2 = 0; i2 < mutations.length; i2++) {
      var result$1 = this.registerMutation(mutations[i2], added);
      if (result$1) {
        from4 = from4 < 0 ? result$1.from : Math.min(result$1.from, from4);
        to = to < 0 ? result$1.to : Math.max(result$1.to, to);
        if (result$1.typeOver) {
          typeOver = true;
        }
      }
    }
  }
  if (result.gecko && added.length > 1) {
    var brs = added.filter(function(n2) {
      return n2.nodeName == "BR";
    });
    if (brs.length == 2) {
      var a2 = brs[0];
      var b = brs[1];
      if (a2.parentNode && a2.parentNode.parentNode == b.parentNode) {
        b.remove();
      } else {
        a2.remove();
      }
    }
  }
  if (from4 > -1 || newSel) {
    if (from4 > -1) {
      this.view.docView.markDirty(from4, to);
      checkCSS(this.view);
    }
    this.handleDOMChange(from4, to, typeOver, added);
    if (this.view.docView.dirty) {
      this.view.updateState(this.view.state);
    } else if (!this.currentSelection.eq(sel)) {
      selectionToDOM(this.view);
    }
    this.currentSelection.set(sel);
  }
};
DOMObserver.prototype.registerMutation = function registerMutation(mut, added) {
  if (added.indexOf(mut.target) > -1) {
    return null;
  }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) {
    return null;
  }
  if (!desc || desc.ignoreMutation(mut)) {
    return null;
  }
  if (mut.type == "childList") {
    for (var i2 = 0; i2 < mut.addedNodes.length; i2++) {
      added.push(mut.addedNodes[i2]);
    }
    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) {
      return { from: desc.posBefore, to: desc.posAfter };
    }
    var prev = mut.previousSibling, next = mut.nextSibling;
    if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
        var ref2 = mut.addedNodes[i$1];
        var previousSibling = ref2.previousSibling;
        var nextSibling = ref2.nextSibling;
        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) {
          prev = previousSibling;
        }
        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) {
          next = nextSibling;
        }
      }
    }
    var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
    var from4 = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
    var to = desc.localPosFromDOM(mut.target, toOffset, 1);
    return { from: from4, to };
  } else if (mut.type == "attributes") {
    return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
  } else {
    return {
      from: desc.posAtStart,
      to: desc.posAtEnd,
      typeOver: mut.target.nodeValue == mut.oldValue
    };
  }
};
var cssChecked = false;
function checkCSS(view) {
  if (cssChecked) {
    return;
  }
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal") {
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
  }
}
var handlers = {}, editHandlers = {};
function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = { time: 0, x: 0, y: 0, type: "" };
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;
  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;
  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;
  view.domObserver = new DOMObserver(view, function(from4, to, typeOver, added) {
    return readDOMChange(view, from4, to, typeOver, added);
  });
  view.domObserver.start();
  view.domChangeCount = 0;
  view.eventHandlers = /* @__PURE__ */ Object.create(null);
  var loop = function(event2) {
    var handler = handlers[event2];
    view.dom.addEventListener(event2, view.eventHandlers[event2] = function(event3) {
      if (eventBelongsToView(view, event3) && !runCustomHandler(view, event3) && (view.editable || !(event3.type in editHandlers))) {
        handler(view, event3);
      }
    });
  };
  for (var event in handlers)
    loop(event);
  if (result.safari) {
    view.dom.addEventListener("input", function() {
      return null;
    });
  }
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (var type2 in view.eventHandlers) {
    view.dom.removeEventListener(type2, view.eventHandlers[type2]);
  }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type2 in currentHandlers) {
      if (!view.eventHandlers[type2]) {
        view.dom.addEventListener(type2, view.eventHandlers[type2] = function(event) {
          return runCustomHandler(view, event);
        });
      }
    }
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles) {
    return true;
  }
  if (event.defaultPrevented) {
    return false;
  }
  for (var node4 = event.target; node4 != view.dom; node4 = node4.parentNode) {
    if (!node4 || node4.nodeType == 11 || node4.pmViewDesc && node4.pmViewDesc.stopEvent(event)) {
      return false;
    }
  }
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) {
    handlers[event.type](view, event);
  }
}
editHandlers.keydown = function(view, event) {
  view.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) {
    return;
  }
  view.lastKeyCode = event.keyCode;
  view.lastKeyCodeTime = Date.now();
  if (result.android && result.chrome && event.keyCode == 13) {
    return;
  }
  if (event.keyCode != 229) {
    view.domObserver.forceFlush();
  }
  if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.lastIOSEnter = now;
    view.lastIOSEnterFallbackTimeout = setTimeout(function() {
      if (view.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function(f2) {
          return f2(view, keyEvent(13, "Enter"));
        });
        view.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function(f2) {
    return f2(view, event);
  }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = function(view, e2) {
  if (e2.keyCode == 16) {
    view.shiftKey = false;
  }
};
editHandlers.keypress = function(view, event) {
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
    return;
  }
  if (view.someProp("handleKeyPress", function(f2) {
    return f2(view, event);
  })) {
    event.preventDefault();
    return;
  }
  var sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text3 = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function(f2) {
      return f2(view, sel.$from.pos, sel.$to.pos, text3);
    })) {
      view.dispatch(view.state.tr.insertText(text3).scrollIntoView());
    }
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside);
  var loop = function(i3) {
    if (view.someProp(propName, function(f2) {
      return i3 > $pos.depth ? f2(view, pos, $pos.nodeAfter, $pos.before(i3), event, true) : f2(view, pos, $pos.node(i3), $pos.before(i3), event, false);
    })) {
      return { v: true };
    }
  };
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var returned = loop(i2);
    if (returned)
      return returned.v;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused) {
    view.focus();
  }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") {
    tr.setMeta("pointer", true);
  }
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside), node4 = $pos.nodeAfter;
  if (node4 && node4.isAtom && NodeSelection.isSelectable(node4)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1) {
    return false;
  }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection) {
    selectedNode = sel.node;
  }
  var $pos = view.state.doc.resolve(inside);
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var node4 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    if (NodeSelection.isSelectable(node4)) {
      if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
        selectAt = $pos.before(sel.$from.depth);
      } else {
        selectAt = $pos.before(i2);
      }
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f2) {
    return f2(view, pos, event);
  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f2) {
    return f2(view, pos, event);
  });
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f2) {
    return f2(view, pos, event);
  }) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0) {
    return false;
  }
  var doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc2.resolve(inside);
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var node4 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    var nodePos = $pos.before(i2);
    if (node4.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node4.content.size), "pointer");
    } else if (NodeSelection.isSelectable(node4)) {
      updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
    } else {
      continue;
    }
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";
handlers.mousedown = function(view, event) {
  view.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(), type2 = "singleClick";
  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
    if (view.lastClick.type == "singleClick") {
      type2 = "doubleClick";
    } else if (view.lastClick.type == "doubleClick") {
      type2 = "tripleClick";
    }
  }
  view.lastClick = { time: now, x: event.clientX, y: event.clientY, type: type2 };
  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) {
    return;
  }
  if (type2 == "singleClick") {
    if (view.mouseDown) {
      view.mouseDown.done();
    }
    view.mouseDown = new MouseDown(view, pos, event, flushed);
  } else if ((type2 == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = function MouseDown2(view, pos, event, flushed) {
  var this$1$1 = this;
  this.view = view;
  this.startDoc = view.state.doc;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed;
  this.selectNode = event[selectNodeModifier];
  this.allowDefault = event.shiftKey;
  this.delayedSelectionSync = false;
  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }
  this.mightDrag = null;
  var target = flushed ? null : event.target;
  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
  this.target = targetDesc ? targetDesc.dom : null;
  var ref2 = view.state;
  var selection = ref2.selection;
  if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos) {
    this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: this.target && !this.target.draggable,
      setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")
    };
  }
  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.draggable = true;
    }
    if (this.mightDrag.setUneditable) {
      setTimeout(function() {
        if (this$1$1.view.mouseDown == this$1$1) {
          this$1$1.target.setAttribute("contentEditable", "false");
        }
      }, 20);
    }
    this.view.domObserver.start();
  }
  view.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view.root.addEventListener("mousemove", this.move = this.move.bind(this));
  setSelectionOrigin(view, "pointer");
};
MouseDown.prototype.done = function done() {
  var this$1$1 = this;
  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.removeAttribute("draggable");
    }
    if (this.mightDrag.setUneditable) {
      this.target.removeAttribute("contentEditable");
    }
    this.view.domObserver.start();
  }
  if (this.delayedSelectionSync) {
    setTimeout(function() {
      return selectionToDOM(this$1$1.view);
    });
  }
  this.view.mouseDown = null;
};
MouseDown.prototype.up = function up(event) {
  this.done();
  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
    return;
  }
  var pos = this.pos;
  if (this.view.state.doc != this.startDoc) {
    pos = this.view.posAtCoords(eventCoords(event));
  }
  if (this.allowDefault || !pos) {
    setSelectionOrigin(this.view, "pointer");
  } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (event.button == 0 && (this.flushed || result.safari && this.mightDrag && !this.mightDrag.node.isAtom || result.chrome && !(this.view.state.selection instanceof TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
    updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
    event.preventDefault();
  } else {
    setSelectionOrigin(this.view, "pointer");
  }
};
MouseDown.prototype.move = function move(event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
    this.allowDefault = true;
  }
  setSelectionOrigin(this.view, "pointer");
  if (event.buttons == 0) {
    this.done();
  }
};
handlers.touchdown = function(view) {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = function(view) {
  return forceDOMFlush(view);
};
function inOrNearComposition(view, event) {
  if (view.composing) {
    return true;
  }
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = result.android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state;
    var $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m2) {
      return m2.type.spec.inclusive === false;
    }))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.root.getSelection();
        for (var node4 = sel.focusNode, offset3 = sel.focusOffset; node4 && node4.nodeType == 1 && offset3 != 0; ) {
          var before2 = offset3 < 0 ? node4.lastChild : node4.childNodes[offset3 - 1];
          if (!before2) {
            break;
          }
          if (before2.nodeType == 3) {
            sel.collapse(before2, before2.nodeValue.length);
            break;
          } else {
            node4 = before2;
            offset3 = -1;
          }
        }
      }
    }
    view.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = function(view, event) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) {
    view.composingTimeout = setTimeout(function() {
      return endComposition(view);
    }, delay);
  }
}
function clearComposition(view) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.compositionNodes.length > 0) {
    view.compositionNodes.pop().markParentsDirty();
  }
}
function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate) {
  if (result.android && view.domObserver.flushingSoon >= 0) {
    return;
  }
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) {
      view.dispatch(view.state.tr.setSelection(sel));
    } else {
      view.updateState(view.state);
    }
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode) {
    return;
  }
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range2 = document.createRange();
  range2.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range2);
  setTimeout(function() {
    if (wrap.parentNode) {
      wrap.parentNode.removeChild(wrap);
    }
    view.focus();
  }, 50);
}
var brokenClipboardAPI = result.ie && result.ie_version < 15 || result.ios && result.webkit_version < 604;
handlers.copy = editHandlers.cut = function(view, e2) {
  var sel = view.state.selection, cut3 = e2.type == "cut";
  if (sel.empty) {
    return;
  }
  var data = brokenClipboardAPI ? null : e2.clipboardData;
  var slice5 = sel.content();
  var ref2 = serializeForClipboard(view, slice5);
  var dom = ref2.dom;
  var text3 = ref2.text;
  if (data) {
    e2.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text3);
  } else {
    captureCopy(view, dom);
  }
  if (cut3) {
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  }
};
function sliceSingleNode(slice5) {
  return slice5.openStart == 0 && slice5.openEnd == 0 && slice5.content.childCount == 1 ? slice5.content.firstChild : null;
}
function capturePaste(view, e2) {
  if (!view.dom.parentNode) {
    return;
  }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) {
    target.contentEditable = "true";
  }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function() {
    view.focus();
    if (target.parentNode) {
      target.parentNode.removeChild(target);
    }
    if (plainText) {
      doPaste(view, target.value, null, e2);
    } else {
      doPaste(view, target.textContent, target.innerHTML, e2);
    }
  }, 50);
}
function doPaste(view, text3, html, e2) {
  var slice5 = parseFromClipboard(view, text3, html, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function(f2) {
    return f2(view, e2, slice5 || Slice.empty);
  })) {
    return true;
  }
  if (!slice5) {
    return false;
  }
  var singleNode = sliceSingleNode(slice5);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice5);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers.paste = function(view, e2) {
  if (view.composing && !result.android) {
    return;
  }
  var data = brokenClipboardAPI ? null : e2.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e2)) {
    e2.preventDefault();
  } else {
    capturePaste(view, e2);
  }
};
var Dragging = function Dragging2(slice5, move2) {
  this.slice = slice5;
  this.move = move2;
};
var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";
handlers.dragstart = function(view, e2) {
  var mouseDown = view.mouseDown;
  if (mouseDown) {
    mouseDown.done();
  }
  if (!e2.dataTransfer) {
    return;
  }
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e2));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (e2.target && e2.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(e2.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView) {
      view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
    }
  }
  var slice5 = view.state.selection.content();
  var ref2 = serializeForClipboard(view, slice5);
  var dom = ref2.dom;
  var text3 = ref2.text;
  e2.dataTransfer.clearData();
  e2.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  e2.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) {
    e2.dataTransfer.setData("text/plain", text3);
  }
  view.dragging = new Dragging(slice5, !e2[dragCopyModifier]);
};
handlers.dragend = function(view) {
  var dragging = view.dragging;
  window.setTimeout(function() {
    if (view.dragging == dragging) {
      view.dragging = null;
    }
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = function(_2, e2) {
  return e2.preventDefault();
};
editHandlers.drop = function(view, e2) {
  var dragging = view.dragging;
  view.dragging = null;
  if (!e2.dataTransfer) {
    return;
  }
  var eventPos = view.posAtCoords(eventCoords(e2));
  if (!eventPos) {
    return;
  }
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) {
    return;
  }
  var slice5 = dragging && dragging.slice;
  if (slice5) {
    view.someProp("transformPasted", function(f2) {
      slice5 = f2(slice5);
    });
  } else {
    slice5 = parseFromClipboard(view, e2.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : e2.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move2 = dragging && !e2[dragCopyModifier];
  if (view.someProp("handleDrop", function(f2) {
    return f2(view, e2, slice5 || Slice.empty, move2);
  })) {
    e2.preventDefault();
    return;
  }
  if (!slice5) {
    return;
  }
  e2.preventDefault();
  var insertPos = slice5 ? dropPoint(view.state.doc, $mouse.pos, slice5) : $mouse.pos;
  if (insertPos == null) {
    insertPos = $mouse.pos;
  }
  var tr = view.state.tr;
  if (move2) {
    tr.deleteSelection();
  }
  var pos = tr.mapping.map(insertPos);
  var isNode = slice5.openStart == 0 && slice5.openEnd == 0 && slice5.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode) {
    tr.replaceRangeWith(pos, pos, slice5.content.firstChild);
  } else {
    tr.replaceRange(pos, pos, slice5);
  }
  if (tr.doc.eq(beforeInsert)) {
    return;
  }
  var $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice5.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice5.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    var end3 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
      return end3 = newTo;
    });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end3)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = function(view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function() {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection())) {
        selectionToDOM(view);
      }
    }, 20);
  }
};
handlers.blur = function(view, e2) {
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (e2.relatedTarget && view.dom.contains(e2.relatedTarget)) {
      view.domObserver.currentSelection.set({});
    }
    view.focused = false;
  }
};
handlers.beforeinput = function(view, event) {
  if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    var domChangeCount = view.domChangeCount;
    setTimeout(function() {
      if (view.domChangeCount != domChangeCount) {
        return;
      }
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent(8, "Backspace"));
      })) {
        return;
      }
      var ref2 = view.state.selection;
      var $cursor = ref2.$cursor;
      if ($cursor && $cursor.pos > 0) {
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }
    }, 50);
  }
};
for (var prop in editHandlers) {
  handlers[prop] = editHandlers[prop];
}
function compareObjs(a2, b) {
  if (a2 == b) {
    return true;
  }
  for (var p2 in a2) {
    if (a2[p2] !== b[p2]) {
      return false;
    }
  }
  for (var p$12 in b) {
    if (!(p$12 in a2)) {
      return false;
    }
  }
  return true;
}
var WidgetType = function WidgetType2(toDOM, spec) {
  this.spec = spec || noSpec;
  this.side = this.spec.side || 0;
  this.toDOM = toDOM;
};
WidgetType.prototype.map = function map7(mapping, span, offset3, oldOffset) {
  var ref2 = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
  var pos = ref2.pos;
  var deleted = ref2.deleted;
  return deleted ? null : new Decoration(pos - offset3, pos - offset3, this);
};
WidgetType.prototype.valid = function valid() {
  return true;
};
WidgetType.prototype.eq = function eq6(other) {
  return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
};
WidgetType.prototype.destroy = function destroy2(node4) {
  if (this.spec.destroy) {
    this.spec.destroy(node4);
  }
};
var InlineType = function InlineType2(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};
InlineType.prototype.map = function map8(mapping, span, offset3, oldOffset) {
  var from4 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset3;
  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset3;
  return from4 >= to ? null : new Decoration(from4, to, this);
};
InlineType.prototype.valid = function valid2(_2, span) {
  return span.from < span.to;
};
InlineType.prototype.eq = function eq7(other) {
  return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
};
InlineType.is = function is(span) {
  return span.type instanceof InlineType;
};
var NodeType2 = function NodeType3(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};
NodeType2.prototype.map = function map9(mapping, span, offset3, oldOffset) {
  var from4 = mapping.mapResult(span.from + oldOffset, 1);
  if (from4.deleted) {
    return null;
  }
  var to = mapping.mapResult(span.to + oldOffset, -1);
  if (to.deleted || to.pos <= from4.pos) {
    return null;
  }
  return new Decoration(from4.pos - offset3, to.pos - offset3, this);
};
NodeType2.prototype.valid = function valid3(node4, span) {
  var ref2 = node4.content.findIndex(span.from);
  var index3 = ref2.index;
  var offset3 = ref2.offset;
  var child3;
  return offset3 == span.from && !(child3 = node4.child(index3)).isText && offset3 + child3.nodeSize == span.to;
};
NodeType2.prototype.eq = function eq8(other) {
  return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
};
var Decoration = function Decoration2(from4, to, type2) {
  this.from = from4;
  this.to = to;
  this.type = type2;
};
var prototypeAccessors$1 = { spec: { configurable: true }, inline: { configurable: true } };
Decoration.prototype.copy = function copy4(from4, to) {
  return new Decoration(from4, to, this.type);
};
Decoration.prototype.eq = function eq9(other, offset3) {
  if (offset3 === void 0)
    offset3 = 0;
  return this.type.eq(other.type) && this.from + offset3 == other.from && this.to + offset3 == other.to;
};
Decoration.prototype.map = function map10(mapping, offset3, oldOffset) {
  return this.type.map(mapping, this, offset3, oldOffset);
};
Decoration.widget = function widget(pos, toDOM, spec) {
  return new Decoration(pos, pos, new WidgetType(toDOM, spec));
};
Decoration.inline = function inline(from4, to, attrs, spec) {
  return new Decoration(from4, to, new InlineType(attrs, spec));
};
Decoration.node = function node3(from4, to, attrs, spec) {
  return new Decoration(from4, to, new NodeType2(attrs, spec));
};
prototypeAccessors$1.spec.get = function() {
  return this.type.spec;
};
prototypeAccessors$1.inline.get = function() {
  return this.type instanceof InlineType;
};
Object.defineProperties(Decoration.prototype, prototypeAccessors$1);
var none = [], noSpec = {};
var DecorationSet = function DecorationSet2(local, children) {
  this.local = local && local.length ? local : none;
  this.children = children && children.length ? children : none;
};
DecorationSet.create = function create4(doc2, decorations) {
  return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
};
DecorationSet.prototype.find = function find(start4, end3, predicate) {
  var result2 = [];
  this.findInner(start4 == null ? 0 : start4, end3 == null ? 1e9 : end3, result2, 0, predicate);
  return result2;
};
DecorationSet.prototype.findInner = function findInner(start4, end3, result2, offset3, predicate) {
  for (var i2 = 0; i2 < this.local.length; i2++) {
    var span = this.local[i2];
    if (span.from <= end3 && span.to >= start4 && (!predicate || predicate(span.spec))) {
      result2.push(span.copy(span.from + offset3, span.to + offset3));
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] < end3 && this.children[i$1 + 1] > start4) {
      var childOff = this.children[i$1] + 1;
      this.children[i$1 + 2].findInner(start4 - childOff, end3 - childOff, result2, offset3 + childOff, predicate);
    }
  }
};
DecorationSet.prototype.map = function map11(mapping, doc2, options) {
  if (this == empty || mapping.maps.length == 0) {
    return this;
  }
  return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
};
DecorationSet.prototype.mapInner = function mapInner(mapping, node4, offset3, oldOffset, options) {
  var newLocal;
  for (var i2 = 0; i2 < this.local.length; i2++) {
    var mapped = this.local[i2].map(mapping, offset3, oldOffset);
    if (mapped && mapped.type.valid(node4, mapped)) {
      (newLocal || (newLocal = [])).push(mapped);
    } else if (options.onRemove) {
      options.onRemove(this.local[i2].spec);
    }
  }
  if (this.children.length) {
    return mapChildren(this.children, newLocal, mapping, node4, offset3, oldOffset, options);
  } else {
    return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty;
  }
};
DecorationSet.prototype.add = function add(doc2, decorations) {
  if (!decorations.length) {
    return this;
  }
  if (this == empty) {
    return DecorationSet.create(doc2, decorations);
  }
  return this.addInner(doc2, decorations, 0);
};
DecorationSet.prototype.addInner = function addInner(doc2, decorations, offset3) {
  var this$1$1 = this;
  var children, childIndex = 0;
  doc2.forEach(function(childNode, childOffset) {
    var baseOffset = childOffset + offset3, found2;
    if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset))) {
      return;
    }
    if (!children) {
      children = this$1$1.children.slice();
    }
    while (childIndex < children.length && children[childIndex] < childOffset) {
      childIndex += 3;
    }
    if (children[childIndex] == childOffset) {
      children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
    } else {
      children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
    }
    childIndex += 3;
  });
  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset3);
  for (var i2 = 0; i2 < local.length; i2++) {
    if (!local[i2].type.valid(doc2, local[i2])) {
      local.splice(i2--, 1);
    }
  }
  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
};
DecorationSet.prototype.remove = function remove(decorations) {
  if (decorations.length == 0 || this == empty) {
    return this;
  }
  return this.removeInner(decorations, 0);
};
DecorationSet.prototype.removeInner = function removeInner(decorations, offset3) {
  var children = this.children, local = this.local;
  for (var i2 = 0; i2 < children.length; i2 += 3) {
    var found2 = void 0, from4 = children[i2] + offset3, to = children[i2 + 1] + offset3;
    for (var j = 0, span = void 0; j < decorations.length; j++) {
      if (span = decorations[j]) {
        if (span.from > from4 && span.to < to) {
          decorations[j] = null;
          (found2 || (found2 = [])).push(span);
        }
      }
    }
    if (!found2) {
      continue;
    }
    if (children == this.children) {
      children = this.children.slice();
    }
    var removed = children[i2 + 2].removeInner(found2, from4 + 1);
    if (removed != empty) {
      children[i2 + 2] = removed;
    } else {
      children.splice(i2, 3);
      i2 -= 3;
    }
  }
  if (local.length) {
    for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
      if (span$1 = decorations[i$1]) {
        for (var j$1 = 0; j$1 < local.length; j$1++) {
          if (local[j$1].eq(span$1, offset3)) {
            if (local == this.local) {
              local = this.local.slice();
            }
            local.splice(j$1--, 1);
          }
        }
      }
    }
  }
  if (children == this.children && local == this.local) {
    return this;
  }
  return local.length || children.length ? new DecorationSet(local, children) : empty;
};
DecorationSet.prototype.forChild = function forChild(offset3, node4) {
  if (this == empty) {
    return this;
  }
  if (node4.isLeaf) {
    return DecorationSet.empty;
  }
  var child3, local;
  for (var i2 = 0; i2 < this.children.length; i2 += 3) {
    if (this.children[i2] >= offset3) {
      if (this.children[i2] == offset3) {
        child3 = this.children[i2 + 2];
      }
      break;
    }
  }
  var start4 = offset3 + 1, end3 = start4 + node4.content.size;
  for (var i$1 = 0; i$1 < this.local.length; i$1++) {
    var dec = this.local[i$1];
    if (dec.from < end3 && dec.to > start4 && dec.type instanceof InlineType) {
      var from4 = Math.max(start4, dec.from) - start4, to = Math.min(end3, dec.to) - start4;
      if (from4 < to) {
        (local || (local = [])).push(dec.copy(from4, to));
      }
    }
  }
  if (local) {
    var localSet = new DecorationSet(local.sort(byPos));
    return child3 ? new DecorationGroup([localSet, child3]) : localSet;
  }
  return child3 || empty;
};
DecorationSet.prototype.eq = function eq10(other) {
  if (this == other) {
    return true;
  }
  if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.local.length; i2++) {
    if (!this.local[i2].eq(other.local[i2])) {
      return false;
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] != other.children[i$1] || this.children[i$1 + 1] != other.children[i$1 + 1] || !this.children[i$1 + 2].eq(other.children[i$1 + 2])) {
      return false;
    }
  }
  return true;
};
DecorationSet.prototype.locals = function locals(node4) {
  return removeOverlap(this.localsInner(node4));
};
DecorationSet.prototype.localsInner = function localsInner(node4) {
  if (this == empty) {
    return none;
  }
  if (node4.inlineContent || !this.local.some(InlineType.is)) {
    return this.local;
  }
  var result2 = [];
  for (var i2 = 0; i2 < this.local.length; i2++) {
    if (!(this.local[i2].type instanceof InlineType)) {
      result2.push(this.local[i2]);
    }
  }
  return result2;
};
var empty = new DecorationSet();
DecorationSet.empty = empty;
DecorationSet.removeOverlap = removeOverlap;
var DecorationGroup = function DecorationGroup2(members) {
  this.members = members;
};
DecorationGroup.prototype.map = function map12(mapping, doc2) {
  var mappedDecos = this.members.map(function(member) {
    return member.map(mapping, doc2, noSpec);
  });
  return DecorationGroup.from(mappedDecos);
};
DecorationGroup.prototype.forChild = function forChild2(offset3, child3) {
  if (child3.isLeaf) {
    return DecorationSet.empty;
  }
  var found2 = [];
  for (var i2 = 0; i2 < this.members.length; i2++) {
    var result2 = this.members[i2].forChild(offset3, child3);
    if (result2 == empty) {
      continue;
    }
    if (result2 instanceof DecorationGroup) {
      found2 = found2.concat(result2.members);
    } else {
      found2.push(result2);
    }
  }
  return DecorationGroup.from(found2);
};
DecorationGroup.prototype.eq = function eq11(other) {
  if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.members.length; i2++) {
    if (!this.members[i2].eq(other.members[i2])) {
      return false;
    }
  }
  return true;
};
DecorationGroup.prototype.locals = function locals2(node4) {
  var result2, sorted = true;
  for (var i2 = 0; i2 < this.members.length; i2++) {
    var locals3 = this.members[i2].localsInner(node4);
    if (!locals3.length) {
      continue;
    }
    if (!result2) {
      result2 = locals3;
    } else {
      if (sorted) {
        result2 = result2.slice();
        sorted = false;
      }
      for (var j = 0; j < locals3.length; j++) {
        result2.push(locals3[j]);
      }
    }
  }
  return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
};
DecorationGroup.from = function from2(members) {
  switch (members.length) {
    case 0:
      return empty;
    case 1:
      return members[0];
    default:
      return new DecorationGroup(members);
  }
};
function mapChildren(oldChildren, newLocal, mapping, node4, offset3, oldOffset, options) {
  var children = oldChildren.slice();
  var shift2 = function(oldStart, oldEnd, newStart, newEnd) {
    for (var i3 = 0; i3 < children.length; i3 += 3) {
      var end3 = children[i3 + 1], dSize = void 0;
      if (end3 == -1 || oldStart > end3 + oldOffset) {
        continue;
      }
      if (oldEnd >= children[i3] + oldOffset) {
        children[i3 + 1] = -1;
      } else if (newStart >= offset3 && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i3] += dSize;
        children[i3 + 1] += dSize;
      }
    }
  };
  for (var i2 = 0; i2 < mapping.maps.length; i2++) {
    mapping.maps[i2].forEach(shift2);
  }
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
    if (children[i$1 + 1] == -1) {
      var from4 = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from4 - offset3;
      if (fromLocal < 0 || fromLocal >= node4.content.size) {
        mustRebuild = true;
        continue;
      }
      var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset3;
      var ref2 = node4.content.findIndex(fromLocal);
      var index3 = ref2.index;
      var childOffset = ref2.offset;
      var childNode = node4.maybeChild(index3);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[i$1 + 2].mapInner(mapping, childNode, from4 + 1, oldChildren[i$1] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i$1] = fromLocal;
          children[i$1 + 1] = toLocal;
          children[i$1 + 2] = mapped;
        } else {
          children[i$1 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping, offset3, oldOffset, options);
    var built = buildTree(decorations, node4, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
      if (children[i$2 + 1] < 0) {
        children.splice(i$2, 3);
        i$2 -= 3;
      }
    }
    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j < children.length && children[j] < from$1) {
        j += 3;
      }
      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }
  return new DecorationSet(newLocal && newLocal.sort(byPos), children);
}
function moveSpans(spans, offset3) {
  if (!offset3 || !spans.length) {
    return spans;
  }
  var result2 = [];
  for (var i2 = 0; i2 < spans.length; i2++) {
    var span = spans[i2];
    result2.push(new Decoration(span.from + offset3, span.to + offset3, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset3, oldOffset, options) {
  function gather(set2, oldOffset2) {
    for (var i3 = 0; i3 < set2.local.length; i3++) {
      var mapped = set2.local[i3].map(mapping, offset3, oldOffset2);
      if (mapped) {
        decorations.push(mapped);
      } else if (options.onRemove) {
        options.onRemove(set2.local[i3].spec);
      }
    }
    for (var i$1 = 0; i$1 < set2.children.length; i$1 += 3) {
      gather(set2.children[i$1 + 2], set2.children[i$1] + oldOffset2 + 1);
    }
  }
  for (var i2 = 0; i2 < children.length; i2 += 3) {
    if (children[i2 + 1] == -1) {
      gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
    }
  }
  return decorations;
}
function takeSpansForNode(spans, node4, offset3) {
  if (node4.isLeaf) {
    return null;
  }
  var end3 = offset3 + node4.nodeSize, found2 = null;
  for (var i2 = 0, span = void 0; i2 < spans.length; i2++) {
    if ((span = spans[i2]) && span.from > offset3 && span.to < end3) {
      (found2 || (found2 = [])).push(span);
      spans[i2] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  var result2 = [];
  for (var i2 = 0; i2 < array.length; i2++) {
    if (array[i2] != null) {
      result2.push(array[i2]);
    }
  }
  return result2;
}
function buildTree(spans, node4, offset3, options) {
  var children = [], hasNulls = false;
  node4.forEach(function(childNode, localStart) {
    var found2 = takeSpansForNode(spans, childNode, localStart + offset3);
    if (found2) {
      hasNulls = true;
      var subtree = buildTree(found2, childNode, offset3 + localStart + 1, options);
      if (subtree != empty) {
        children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    }
  });
  var locals3 = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset3).sort(byPos);
  for (var i2 = 0; i2 < locals3.length; i2++) {
    if (!locals3[i2].type.valid(node4, locals3[i2])) {
      if (options.onRemove) {
        options.onRemove(locals3[i2].spec);
      }
      locals3.splice(i2--, 1);
    }
  }
  return locals3.length || children.length ? new DecorationSet(locals3, children) : empty;
}
function byPos(a2, b) {
  return a2.from - b.from || a2.to - b.to;
}
function removeOverlap(spans) {
  var working = spans;
  for (var i2 = 0; i2 < working.length - 1; i2++) {
    var span = working[i2];
    if (span.from != span.to) {
      for (var j = i2 + 1; j < working.length; j++) {
        var next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[i2] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
    }
  }
  return working;
}
function insertAhead(array, i2, deco) {
  while (i2 < array.length && byPos(deco, array[i2]) > 0) {
    i2++;
  }
  array.splice(i2, 0, deco);
}
function viewDecorations(view) {
  var found2 = [];
  view.someProp("decorations", function(f2) {
    var result2 = f2(view.state);
    if (result2 && result2 != empty) {
      found2.push(result2);
    }
  });
  if (view.cursorWrapper) {
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  }
  return DecorationGroup.from(found2);
}
var EditorView = function EditorView2(place, props) {
  this._props = props;
  this.state = props.state;
  this.directPlugins = props.plugins || [];
  this.directPlugins.forEach(checkStateComponent);
  this.dispatch = this.dispatch.bind(this);
  this._root = null;
  this.focused = false;
  this.trackWrites = null;
  this.dom = place && place.mount || document.createElement("div");
  if (place) {
    if (place.appendChild) {
      place.appendChild(this.dom);
    } else if (place.apply) {
      place(this.dom);
    } else if (place.mount) {
      this.mounted = true;
    }
  }
  this.editable = getEditable(this);
  this.markCursor = null;
  this.cursorWrapper = null;
  updateCursorWrapper(this);
  this.nodeViews = buildNodeViews(this);
  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
  this.lastSelectedViewDesc = null;
  this.dragging = null;
  initInput(this);
  this.prevDirectPlugins = [];
  this.pluginViews = [];
  this.updatePluginViews();
};
var prototypeAccessors$2 = { props: { configurable: true }, root: { configurable: true }, isDestroyed: { configurable: true } };
prototypeAccessors$2.props.get = function() {
  if (this._props.state != this.state) {
    var prev = this._props;
    this._props = {};
    for (var name in prev) {
      this._props[name] = prev[name];
    }
    this._props.state = this.state;
  }
  return this._props;
};
EditorView.prototype.update = function update(props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) {
    ensureListeners(this);
  }
  this._props = props;
  if (props.plugins) {
    props.plugins.forEach(checkStateComponent);
    this.directPlugins = props.plugins;
  }
  this.updateStateInner(props.state, true);
};
EditorView.prototype.setProps = function setProps(props) {
  var updated = {};
  for (var name in this._props) {
    updated[name] = this._props[name];
  }
  updated.state = this.state;
  for (var name$1 in props) {
    updated[name$1] = props[name$1];
  }
  this.update(updated);
};
EditorView.prototype.updateState = function updateState(state) {
  this.updateStateInner(state, this.state.plugins != state.plugins);
};
EditorView.prototype.updateStateInner = function updateStateInner(state, reconfigured) {
  var this$1$1 = this;
  var prev = this.state, redraw = false, updateSel = false;
  if (state.storedMarks && this.composing) {
    clearComposition(this);
    updateSel = true;
  }
  this.state = state;
  if (reconfigured) {
    var nodeViews = buildNodeViews(this);
    if (changedNodeViews(nodeViews, this.nodeViews)) {
      this.nodeViews = nodeViews;
      redraw = true;
    }
    ensureListeners(this);
  }
  this.editable = getEditable(this);
  updateCursorWrapper(this);
  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
  var scroll = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  if (updateDoc || !state.selection.eq(prev.selection)) {
    updateSel = true;
  }
  var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
  if (updateSel) {
    this.domObserver.stop();
    var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
    if (updateDoc) {
      var chromeKludge = result.chrome ? this.trackWrites = this.root.getSelection().focusNode : null;
      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.updateOuterDeco([]);
        this.docView.destroy();
        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      if (chromeKludge && !this.trackWrites) {
        forceSelUpdate = true;
      }
    }
    if (forceSelUpdate || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
      selectionToDOM(this, forceSelUpdate);
    } else {
      syncNodeSelection(this, state.selection);
      this.domObserver.setCurSelection();
    }
    this.domObserver.start();
  }
  this.updatePluginViews(prev);
  if (scroll == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll == "to selection") {
    var startDOM = this.root.getSelection().focusNode;
    if (this.someProp("handleScrollToSelection", function(f2) {
      return f2(this$1$1);
    }))
      ;
    else if (state.selection instanceof NodeSelection) {
      scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
    }
  } else if (oldScrollPos) {
    resetScrollPos(oldScrollPos);
  }
};
EditorView.prototype.destroyPluginViews = function destroyPluginViews() {
  var view;
  while (view = this.pluginViews.pop()) {
    if (view.destroy) {
      view.destroy();
    }
  }
};
EditorView.prototype.updatePluginViews = function updatePluginViews(prevState) {
  if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
    this.prevDirectPlugins = this.directPlugins;
    this.destroyPluginViews();
    for (var i2 = 0; i2 < this.directPlugins.length; i2++) {
      var plugin = this.directPlugins[i2];
      if (plugin.spec.view) {
        this.pluginViews.push(plugin.spec.view(this));
      }
    }
    for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {
      var plugin$1 = this.state.plugins[i$1];
      if (plugin$1.spec.view) {
        this.pluginViews.push(plugin$1.spec.view(this));
      }
    }
  } else {
    for (var i$2 = 0; i$2 < this.pluginViews.length; i$2++) {
      var pluginView = this.pluginViews[i$2];
      if (pluginView.update) {
        pluginView.update(this, prevState);
      }
    }
  }
};
EditorView.prototype.someProp = function someProp(propName, f2) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f2 ? f2(prop) : prop)) {
    return value;
  }
  for (var i2 = 0; i2 < this.directPlugins.length; i2++) {
    var prop$1 = this.directPlugins[i2].props[propName];
    if (prop$1 != null && (value = f2 ? f2(prop$1) : prop$1)) {
      return value;
    }
  }
  var plugins = this.state.plugins;
  if (plugins) {
    for (var i$1 = 0; i$1 < plugins.length; i$1++) {
      var prop$2 = plugins[i$1].props[propName];
      if (prop$2 != null && (value = f2 ? f2(prop$2) : prop$2)) {
        return value;
      }
    }
  }
};
EditorView.prototype.hasFocus = function hasFocus() {
  return this.root.activeElement == this.dom;
};
EditorView.prototype.focus = function focus() {
  this.domObserver.stop();
  if (this.editable) {
    focusPreventScroll(this.dom);
  }
  selectionToDOM(this);
  this.domObserver.start();
};
prototypeAccessors$2.root.get = function() {
  var cached = this._root;
  if (cached == null) {
    for (var search = this.dom.parentNode; search; search = search.parentNode) {
      if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
        if (!search.getSelection) {
          Object.getPrototypeOf(search).getSelection = function() {
            return document.getSelection();
          };
        }
        return this._root = search;
      }
    }
  }
  return cached || document;
};
EditorView.prototype.posAtCoords = function posAtCoords$1(coords) {
  return posAtCoords(this, coords);
};
EditorView.prototype.coordsAtPos = function coordsAtPos$1(pos, side) {
  if (side === void 0)
    side = 1;
  return coordsAtPos(this, pos, side);
};
EditorView.prototype.domAtPos = function domAtPos(pos, side) {
  if (side === void 0)
    side = 0;
  return this.docView.domFromPos(pos, side);
};
EditorView.prototype.nodeDOM = function nodeDOM(pos) {
  var desc = this.docView.descAt(pos);
  return desc ? desc.nodeDOM : null;
};
EditorView.prototype.posAtDOM = function posAtDOM(node4, offset3, bias) {
  if (bias === void 0)
    bias = -1;
  var pos = this.docView.posFromDOM(node4, offset3, bias);
  if (pos == null) {
    throw new RangeError("DOM position not inside the editor");
  }
  return pos;
};
EditorView.prototype.endOfTextblock = function endOfTextblock$1(dir, state) {
  return endOfTextblock(this, state || this.state, dir);
};
EditorView.prototype.destroy = function destroy3() {
  if (!this.docView) {
    return;
  }
  destroyInput(this);
  this.destroyPluginViews();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};
prototypeAccessors$2.isDestroyed.get = function() {
  return this.docView == null;
};
EditorView.prototype.dispatchEvent = function dispatchEvent$1(event) {
  return dispatchEvent(this, event);
};
EditorView.prototype.dispatch = function dispatch(tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) {
    dispatchTransaction.call(this, tr);
  } else {
    this.updateState(this.state.apply(tr));
  }
};
Object.defineProperties(EditorView.prototype, prototypeAccessors$2);
function computeDocDeco(view) {
  var attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";
  view.someProp("attributes", function(value) {
    if (typeof value == "function") {
      value = value(view.state);
    }
    if (value) {
      for (var attr in value) {
        if (attr == "class") {
          attrs.class += " " + value[attr];
        }
        if (attr == "style") {
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
          attrs[attr] = String(value[attr]);
        }
      }
    }
  });
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", function(value) {
    return value(view.state) === false;
  });
}
function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  var result2 = {};
  view.someProp("nodeViews", function(obj) {
    for (var prop in obj) {
      if (!Object.prototype.hasOwnProperty.call(result2, prop)) {
        result2[prop] = obj[prop];
      }
    }
  });
  return result2;
}
function changedNodeViews(a2, b) {
  var nA = 0, nB = 0;
  for (var prop in a2) {
    if (a2[prop] != b[prop]) {
      return true;
    }
    nA++;
  }
  for (var _2 in b) {
    nB++;
  }
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) {
    throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
}
var escapeStringRegexp = (string) => {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
function _checkPrivateRedeclaration$5(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec$5(obj, privateMap, value) {
  _checkPrivateRedeclaration$5(obj, privateMap);
  privateMap.set(obj, value);
}
var ExitReason;
(function(ExitReason2) {
  ExitReason2["End"] = "exit-end";
  ExitReason2["Removed"] = "delete";
  ExitReason2["Split"] = "exit-split";
  ExitReason2["InvalidSplit"] = "invalid-exit-split";
  ExitReason2["MoveEnd"] = "move-end";
  ExitReason2["MoveStart"] = "move-start";
  ExitReason2["JumpForward"] = "jump-forward-exit";
  ExitReason2["JumpBackward"] = "jump-backward-exit";
  ExitReason2["SelectionOutside"] = "selection-outside";
})(ExitReason || (ExitReason = {}));
var ChangeReason;
(function(ChangeReason2) {
  ChangeReason2["Start"] = "start";
  ChangeReason2["Text"] = "change-character";
  ChangeReason2["SelectionInside"] = "selection-inside";
  ChangeReason2["Move"] = "move";
  ChangeReason2["JumpBackward"] = "jump-backward-change";
  ChangeReason2["JumpForward"] = "jump-forward-change";
})(ChangeReason || (ChangeReason = {}));
function isChange(compare) {
  return !!(compare.prev && compare.next && compare.prev.text.full !== compare.next.text.full);
}
function isMove(compare) {
  return !!(compare.prev && compare.next && compare.prev.range.cursor !== compare.next.range.cursor);
}
function isEntry(compare) {
  return !!(!compare.prev && compare.next);
}
function isExit(compare) {
  return !!(compare.prev && !compare.next);
}
function isJump(compare) {
  return !!(compare.prev && compare.next && compare.prev.range.from !== compare.next.range.from);
}
[ExitReason.MoveEnd, ExitReason.MoveStart, ExitReason.SelectionOutside, ExitReason.JumpForward, ExitReason.JumpBackward];
[ChangeReason.JumpBackward, ChangeReason.JumpForward, ChangeReason.Move, ChangeReason.SelectionInside];
function isInvalidSplitReason(value) {
  return value === ExitReason.InvalidSplit;
}
var exitJump = [ExitReason.JumpBackward, ExitReason.JumpForward];
var changeJump = [ChangeReason.JumpBackward, ChangeReason.JumpForward];
function isJumpReason(map16) {
  var _map$exit, _map$change;
  return includes(exitJump, (_map$exit = map16.exit) === null || _map$exit === void 0 ? void 0 : _map$exit.exitReason) || includes(changeJump, (_map$change = map16.change) === null || _map$change === void 0 ? void 0 : _map$change.changeReason);
}
function isValidMatch(match) {
  return !!(match && match.query.full.length >= match.suggester.matchOffset);
}
function isTextSelection$1(value) {
  return isObject$1(value) && value instanceof TextSelection;
}
function createMatchWithReason(props) {
  var match = props.match, changeReason = props.changeReason, exitReason = props.exitReason;
  return _objectSpread2$3(_objectSpread2$3({}, match), {}, {
    changeReason,
    exitReason
  });
}
function isPrefixValid(prefix, options) {
  var invalidPrefixCharacters = options.invalidPrefixCharacters, validPrefixCharacters = options.validPrefixCharacters;
  if (invalidPrefixCharacters) {
    var regex = new RegExp(regexToString(invalidPrefixCharacters));
    return !regex.test(prefix);
  }
  {
    var _regex = new RegExp(regexToString(validPrefixCharacters));
    return _regex.test(prefix);
  }
}
function findPosition(props) {
  var text3 = props.text, regexp = props.regexp, $pos = props.$pos, suggester = props.suggester;
  var start4 = $pos.start();
  var position;
  findMatches(text3, regexp).forEach((match) => {
    var matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
    if (isPrefixValid(matchPrefix, suggester)) {
      var from4 = match.index + start4;
      var fullMatch = match[0];
      var charMatch = match[1];
      if (!isString$1(fullMatch) || !isString$1(charMatch)) {
        return;
      }
      var to = from4 + fullMatch.length;
      var cursor = Math.min(to, $pos.pos);
      var matchLength = cursor - from4;
      if (from4 < $pos.pos && to >= $pos.pos) {
        position = {
          range: {
            from: from4,
            to,
            cursor
          },
          match,
          query: {
            partial: fullMatch.slice(charMatch.length, matchLength),
            full: fullMatch.slice(charMatch.length)
          },
          text: {
            partial: fullMatch.slice(0, matchLength),
            full: fullMatch
          },
          textAfter: $pos.doc.textBetween(to, $pos.end(), NULL_CHARACTER, NULL_CHARACTER),
          textBefore: $pos.doc.textBetween(start4, from4, NULL_CHARACTER, NULL_CHARACTER),
          suggester
        };
      }
    }
  });
  return position;
}
function findMatch(props) {
  var $pos = props.$pos, suggester = props.suggester;
  var char = suggester.char, name = suggester.name, startOfLine = suggester.startOfLine, supportedCharacters = suggester.supportedCharacters, matchOffset = suggester.matchOffset, multiline = suggester.multiline, caseInsensitive = suggester.caseInsensitive;
  var regexp = createRegexFromSuggester({
    char,
    matchOffset,
    startOfLine,
    supportedCharacters,
    multiline,
    caseInsensitive
  });
  var text3 = $pos.doc.textBetween($pos.before(), $pos.end(), NULL_CHARACTER, NULL_CHARACTER);
  return findPosition({
    suggester,
    text: text3,
    regexp,
    $pos,
    char,
    name
  });
}
function recheckMatch(props) {
  var state = props.state, match = props.match;
  try {
    return findMatch({
      $pos: state.doc.resolve(match.range.cursor),
      suggester: match.suggester
    });
  } catch (_unused) {
    return;
  }
}
function createInsertReason(props) {
  var prev = props.prev, next = props.next, state = props.state;
  if (!next && prev.range.from >= state.doc.nodeSize) {
    return {
      exit: createMatchWithReason({
        match: prev,
        exitReason: ExitReason.Removed
      })
    };
  }
  if (!next || !prev.query.partial) {
    return {
      exit: createMatchWithReason({
        match: prev,
        exitReason: ExitReason.InvalidSplit
      })
    };
  }
  if (prev.range.to === next.range.cursor) {
    return {
      exit: createMatchWithReason({
        match: next,
        exitReason: ExitReason.End
      })
    };
  }
  if (prev.query.partial) {
    return {
      exit: createMatchWithReason({
        match: next,
        exitReason: ExitReason.Split
      })
    };
  }
  return {};
}
function findJumpReason(props) {
  var prev = props.prev, next = props.next, state = props.state;
  var value = object();
  var updatedPrevious = recheckMatch({
    state,
    match: prev
  });
  var _ref = updatedPrevious && updatedPrevious.query.full !== prev.query.full ? createInsertReason({
    prev,
    next: updatedPrevious,
    state
  }) : value, exit = _ref.exit;
  var isJumpForward = prev.range.from < next.range.from;
  if (isJumpForward) {
    return {
      exit: exit !== null && exit !== void 0 ? exit : createMatchWithReason({
        match: prev,
        exitReason: ExitReason.JumpForward
      }),
      change: createMatchWithReason({
        match: next,
        changeReason: ChangeReason.JumpForward
      })
    };
  }
  return {
    exit: exit !== null && exit !== void 0 ? exit : createMatchWithReason({
      match: prev,
      exitReason: ExitReason.JumpBackward
    }),
    change: createMatchWithReason({
      match: next,
      changeReason: ChangeReason.JumpBackward
    })
  };
}
function findExitReason(props) {
  var match = props.match, state = props.state, $pos = props.$pos;
  var selection = state.selection;
  var updatedPrevious = recheckMatch({
    match,
    state
  });
  if (!updatedPrevious || updatedPrevious.text.full !== match.text.full) {
    return createInsertReason({
      prev: match,
      next: updatedPrevious,
      state
    });
  }
  if (!selection.empty && (selection.from <= match.range.from || selection.to >= match.range.to)) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: ExitReason.SelectionOutside
      })
    };
  }
  if ($pos.pos > match.range.to) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: ExitReason.MoveEnd
      })
    };
  }
  if ($pos.pos <= match.range.from) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: ExitReason.MoveStart
      })
    };
  }
  return {};
}
function findReason(props) {
  var prev = props.prev, next = props.next, state = props.state, $pos = props.$pos;
  var value = object();
  if (!prev && !next) {
    return value;
  }
  var compare = {
    prev,
    next
  };
  if (isJump(compare)) {
    return findJumpReason({
      prev: compare.prev,
      next: compare.next,
      state
    });
  }
  if (isEntry(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: ChangeReason.Start
      })
    };
  }
  if (isExit(compare)) {
    return findExitReason({
      $pos,
      match: compare.prev,
      state
    });
  }
  if (isChange(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: ChangeReason.Text
      })
    };
  }
  if (isMove(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: state.selection.empty ? ChangeReason.Move : ChangeReason.SelectionInside
      })
    };
  }
  return value;
}
function hasParentNode($pos, types) {
  for (var depth = $pos.depth; depth > 0; depth--) {
    var node4 = $pos.node(depth);
    if (types.includes(node4.type.name)) {
      return true;
    }
  }
  return false;
}
function markActiveInRange(resolvedRange, marks2) {
  var $from = resolvedRange.$from, $to = resolvedRange.$to;
  if (rangeHasMarks(resolvedRange, marks2)) {
    return true;
  }
  return range($from.pos, $to.pos).some((value) => positionHasMarks($from.doc.resolve(value), marks2));
}
function rangeHasMarks(resolvedRange, marks2) {
  var _$from$marksAcross;
  var $from = resolvedRange.$from, $to = resolvedRange.$to;
  var setOfMarks = new Set(((_$from$marksAcross = $from.marksAcross($to)) !== null && _$from$marksAcross !== void 0 ? _$from$marksAcross : []).map((mark3) => mark3.type.name));
  return marks2.some((item) => setOfMarks.has(item));
}
function positionHasMarks($pos, marks2) {
  var setOfMarks = new Set($pos.marks().map((mark3) => mark3.type.name));
  return marks2.some((item) => setOfMarks.has(item));
}
function isPositionValidForSuggester(suggester, resolvedRange) {
  var $cursor = resolvedRange.$cursor;
  var validMarks = suggester.validMarks, validNodes = suggester.validNodes, invalidMarks2 = suggester.invalidMarks, invalidNodes = suggester.invalidNodes;
  if (!validMarks && !validNodes && isEmptyArray(invalidMarks2) && isEmptyArray(invalidNodes)) {
    return true;
  }
  if (validMarks && !rangeHasMarks(resolvedRange, validMarks)) {
    return false;
  }
  if (validNodes && !hasParentNode($cursor, validNodes)) {
    return false;
  }
  if (!validMarks && markActiveInRange(resolvedRange, invalidMarks2)) {
    return false;
  }
  if (!validNodes && hasParentNode($cursor, invalidNodes)) {
    return false;
  }
  return true;
}
function findFromSuggesters(props) {
  var suggesters = props.suggesters, $pos = props.$pos, selectionEmpty = props.selectionEmpty;
  var _iterator = _createForOfIteratorHelper(suggesters), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var suggester = _step.value;
      if (suggester.emptySelectionsOnly && !selectionEmpty) {
        continue;
      }
      try {
        var match = findMatch({
          suggester,
          $pos
        });
        if (!match) {
          continue;
        }
        var resolvedRange = {
          $from: $pos.doc.resolve(match.range.from),
          $to: $pos.doc.resolve(match.range.to),
          $cursor: $pos
        };
        if (isPositionValidForSuggester(suggester, resolvedRange) && suggester.isValidPosition(resolvedRange, match)) {
          return match;
        }
      } catch (_unused2) {
      }
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  return;
}
function regexToString(regexOrString) {
  return isRegExp(regexOrString) ? regexOrString.source : regexOrString;
}
function getRegexPrefix(onlyStartOfLine) {
  return onlyStartOfLine ? "^" : "";
}
function getRegexSupportedCharacters(supportedCharacters, matchOffset) {
  return "(?:".concat(regexToString(supportedCharacters), "){").concat(matchOffset, ",}");
}
function getCharAsRegex(char) {
  return isString$1(char) ? new RegExp(escapeStringRegexp(char)) : char;
}
function createRegexFromSuggester(props) {
  var char = props.char, matchOffset = props.matchOffset, startOfLine = props.startOfLine, supportedCharacters = props.supportedCharacters, _props$captureChar = props.captureChar, captureChar = _props$captureChar === void 0 ? true : _props$captureChar, _props$caseInsensitiv = props.caseInsensitive, caseInsensitive = _props$caseInsensitiv === void 0 ? false : _props$caseInsensitiv, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline;
  var flags = "g".concat(multiline ? "m" : "").concat(caseInsensitive ? "i" : "");
  var charRegex = getCharAsRegex(char).source;
  if (captureChar) {
    charRegex = "(".concat(charRegex, ")");
  }
  return new RegExp("".concat(getRegexPrefix(startOfLine)).concat(charRegex).concat(getRegexSupportedCharacters(supportedCharacters, matchOffset)), flags);
}
var DEFAULT_SUGGESTER = {
  appendTransaction: false,
  priority: 50,
  ignoredTag: "span",
  matchOffset: 0,
  disableDecorations: false,
  startOfLine: false,
  suggestClassName: "suggest",
  suggestTag: "span",
  supportedCharacters: /\w+/,
  validPrefixCharacters: /^[\s\0]?$/,
  invalidPrefixCharacters: null,
  ignoredClassName: null,
  invalidMarks: [],
  invalidNodes: [],
  validMarks: null,
  validNodes: null,
  isValidPosition: () => true,
  checkNextValidSelection: null,
  emptySelectionsOnly: false,
  caseInsensitive: false,
  multiline: false,
  captureChar: true
};
var IGNORE_SUGGEST_META_KEY = "__ignore_prosemirror_suggest_update__";
var _docChanged = /* @__PURE__ */ new WeakMap();
var _ignoreNextExit = /* @__PURE__ */ new WeakMap();
var _suggesters = /* @__PURE__ */ new WeakMap();
var _next = /* @__PURE__ */ new WeakMap();
var _prev = /* @__PURE__ */ new WeakMap();
var _handlerMatches = /* @__PURE__ */ new WeakMap();
var _ignored = /* @__PURE__ */ new WeakMap();
var _removed = /* @__PURE__ */ new WeakMap();
var _lastChangeFromAppend = /* @__PURE__ */ new WeakMap();
class SuggestState {
  static create(suggesters) {
    return new SuggestState(suggesters);
  }
  get decorationSet() {
    return _classPrivateFieldGet(this, _ignored);
  }
  get removed() {
    return _classPrivateFieldGet(this, _removed);
  }
  get match() {
    return _classPrivateFieldGet(this, _next) ? _classPrivateFieldGet(this, _next) : _classPrivateFieldGet(this, _prev) && _classPrivateFieldGet(this, _handlerMatches).exit ? _classPrivateFieldGet(this, _prev) : void 0;
  }
  constructor(_suggesters2) {
    _classPrivateFieldInitSpec$5(this, _docChanged, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec$5(this, _ignoreNextExit, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec$5(this, _suggesters, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$5(this, _next, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$5(this, _prev, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$5(this, _handlerMatches, {
      writable: true,
      value: object()
    });
    _classPrivateFieldInitSpec$5(this, _ignored, {
      writable: true,
      value: DecorationSet.empty
    });
    _classPrivateFieldInitSpec$5(this, _removed, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec$5(this, _lastChangeFromAppend, {
      writable: true,
      value: false
    });
    _defineProperty$3(this, "setMarkRemoved", () => {
      _classPrivateFieldSet(this, _removed, true);
    });
    _defineProperty$3(this, "findNextTextSelection", (selection) => {
      var doc2 = selection.$from.doc;
      var pos = Math.min(doc2.nodeSize - 2, selection.to + 1);
      var $pos = doc2.resolve(pos);
      var nextSelection = Selection.findFrom($pos, 1, true);
      if (!isTextSelection$1(nextSelection)) {
        return;
      }
      return nextSelection;
    });
    _defineProperty$3(this, "ignoreNextExit", () => {
      _classPrivateFieldSet(this, _ignoreNextExit, true);
    });
    _defineProperty$3(this, "addIgnored", (_ref) => {
      var from4 = _ref.from, name = _ref.name, _ref$specific = _ref.specific, specific = _ref$specific === void 0 ? false : _ref$specific;
      var suggester = _classPrivateFieldGet(this, _suggesters).find((value) => value.name === name);
      if (!suggester) {
        throw new Error("No suggester exists for the name provided: ".concat(name));
      }
      var offset3 = isString$1(suggester.char) ? suggester.char.length : 1;
      var to = from4 + offset3;
      var attributes = suggester.ignoredClassName ? {
        class: suggester.ignoredClassName
      } : {};
      var decoration = Decoration.inline(from4, to, _objectSpread2$3({
        nodeName: suggester.ignoredTag
      }, attributes), {
        name,
        specific,
        char: suggester.char
      });
      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).add(this.view.state.doc, [decoration]));
    });
    _defineProperty$3(this, "removeIgnored", (_ref2) => {
      var from4 = _ref2.from, name = _ref2.name;
      var suggester = _classPrivateFieldGet(this, _suggesters).find((value) => value.name === name);
      if (!suggester) {
        throw new Error("No suggester exists for the name provided: ".concat(name));
      }
      var offset3 = isString$1(suggester.char) ? suggester.char.length : 1;
      var decoration = _classPrivateFieldGet(this, _ignored).find(from4, from4 + offset3)[0];
      if (!decoration || decoration.spec.name !== name) {
        return;
      }
      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).remove([decoration]));
    });
    _defineProperty$3(this, "clearIgnored", (name) => {
      if (!name) {
        _classPrivateFieldSet(this, _ignored, DecorationSet.empty);
        return;
      }
      var decorations = _classPrivateFieldGet(this, _ignored).find();
      var decorationsToClear = decorations.filter((_ref3) => {
        var spec = _ref3.spec;
        return spec.name === name;
      });
      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).remove(decorationsToClear));
    });
    _defineProperty$3(this, "findMatchAtPosition", ($pos, name) => {
      var suggesters = name ? _classPrivateFieldGet(this, _suggesters).filter((suggester) => suggester.name === name) : _classPrivateFieldGet(this, _suggesters);
      return findFromSuggesters({
        suggesters,
        $pos,
        docChanged: false,
        selectionEmpty: true
      });
    });
    _defineProperty$3(this, "setLastChangeFromAppend", () => {
      _classPrivateFieldSet(this, _lastChangeFromAppend, true);
    });
    var mapper = createSuggesterMapper();
    _classPrivateFieldSet(this, _suggesters, _suggesters2.map(mapper));
    _classPrivateFieldSet(this, _suggesters, sort(_classPrivateFieldGet(this, _suggesters), (a2, b) => b.priority - a2.priority));
  }
  init(view) {
    this.view = view;
    return this;
  }
  createProps(match) {
    var _match$suggester = match.suggester, name = _match$suggester.name, char = _match$suggester.char;
    return _objectSpread2$3({
      view: this.view,
      addIgnored: this.addIgnored,
      clearIgnored: this.clearIgnored,
      ignoreNextExit: this.ignoreNextExit,
      setMarkRemoved: this.setMarkRemoved,
      name,
      char
    }, match);
  }
  shouldRunExit() {
    if (_classPrivateFieldGet(this, _ignoreNextExit)) {
      _classPrivateFieldSet(this, _ignoreNextExit, false);
      return false;
    }
    return true;
  }
  updateWithNextSelection(tr) {
    var nextSelection = this.findNextTextSelection(tr.selection);
    if (!nextSelection) {
      return;
    }
    var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(this, _suggesters)), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _classPrivateFieldGet2, _classPrivateFieldGet3, _suggester$checkNextV;
        var suggester = _step.value;
        var change = (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _handlerMatches).change) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.suggester.name;
        var exit = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _handlerMatches).exit) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.suggester.name;
        (_suggester$checkNextV = suggester.checkNextValidSelection) === null || _suggester$checkNextV === void 0 ? void 0 : _suggester$checkNextV.call(suggester, nextSelection.$from, tr, {
          change,
          exit
        });
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
  }
  changeHandler(tr, appendTransaction) {
    var _classPrivateFieldGet4 = _classPrivateFieldGet(this, _handlerMatches), change = _classPrivateFieldGet4.change, exit = _classPrivateFieldGet4.exit;
    var match = this.match;
    if (!change && !exit || !isValidMatch(match)) {
      return;
    }
    var shouldRunExit = appendTransaction === (exit === null || exit === void 0 ? void 0 : exit.suggester.appendTransaction) && this.shouldRunExit();
    var shouldRunChange = appendTransaction === (change === null || change === void 0 ? void 0 : change.suggester.appendTransaction);
    if (!shouldRunExit && !shouldRunChange) {
      return;
    }
    if (change && exit && isJumpReason({
      change,
      exit
    })) {
      var exitDetails = this.createProps(exit);
      var changeDetails = this.createProps(change);
      var movedForwards = exit.range.from < change.range.from;
      if (movedForwards) {
        shouldRunExit && exit.suggester.onChange(exitDetails, tr);
        shouldRunChange && change.suggester.onChange(changeDetails, tr);
      } else {
        shouldRunExit && exit.suggester.onChange(exitDetails, tr);
        shouldRunChange && change.suggester.onChange(changeDetails, tr);
      }
      if (shouldRunExit) {
        _classPrivateFieldSet(this, _removed, false);
      }
      return;
    }
    if (change && shouldRunChange) {
      change.suggester.onChange(this.createProps(change), tr);
    }
    if (exit && shouldRunExit) {
      exit.suggester.onChange(this.createProps(exit), tr);
      _classPrivateFieldSet(this, _removed, false);
      if (isInvalidSplitReason(exit.exitReason)) {
        _classPrivateFieldSet(this, _handlerMatches, object());
      }
    }
    return;
  }
  mapIgnoredDecorations(tr) {
    var ignored = _classPrivateFieldGet(this, _ignored).map(tr.mapping, tr.doc);
    var decorations = ignored.find();
    var invalid = decorations.filter((_ref4) => {
      var from4 = _ref4.from, to = _ref4.to, spec = _ref4.spec;
      var charLength = isString$1(spec.char) ? spec.char.length : 1;
      if (to - from4 !== charLength) {
        return true;
      }
      return false;
    });
    _classPrivateFieldSet(this, _ignored, ignored.remove(invalid));
  }
  shouldIgnoreMatch(_ref5) {
    var range2 = _ref5.range, name = _ref5.suggester.name;
    var decorations = _classPrivateFieldGet(this, _ignored).find();
    var shouldIgnore = decorations.some((_ref6) => {
      var spec = _ref6.spec, from4 = _ref6.from;
      if (from4 !== range2.from) {
        return false;
      }
      return spec.specific ? spec.name === name : true;
    });
    return shouldIgnore;
  }
  resetState() {
    _classPrivateFieldSet(this, _handlerMatches, object());
    _classPrivateFieldSet(this, _next, void 0);
    _classPrivateFieldSet(this, _removed, false);
    _classPrivateFieldSet(this, _lastChangeFromAppend, false);
  }
  updateReasons(props) {
    var $pos = props.$pos, state = props.state;
    var docChanged = _classPrivateFieldGet(this, _docChanged);
    var suggesters = _classPrivateFieldGet(this, _suggesters);
    var selectionEmpty = state.selection.empty;
    var match = isTextSelection$1(state.selection) ? findFromSuggesters({
      suggesters,
      $pos,
      docChanged,
      selectionEmpty
    }) : void 0;
    _classPrivateFieldSet(this, _next, match && this.shouldIgnoreMatch(match) ? void 0 : match);
    _classPrivateFieldSet(this, _handlerMatches, findReason({
      next: _classPrivateFieldGet(this, _next),
      prev: _classPrivateFieldGet(this, _prev),
      state,
      $pos
    }));
  }
  addSuggester(suggester) {
    var previous = _classPrivateFieldGet(this, _suggesters).find((item) => item.name === suggester.name);
    var mapper = createSuggesterMapper();
    if (previous) {
      _classPrivateFieldSet(this, _suggesters, _classPrivateFieldGet(this, _suggesters).map((item) => item === previous ? mapper(suggester) : item));
    } else {
      var suggesters = [..._classPrivateFieldGet(this, _suggesters), mapper(suggester)];
      _classPrivateFieldSet(this, _suggesters, sort(suggesters, (a2, b) => b.priority - a2.priority));
    }
    return () => this.removeSuggester(suggester.name);
  }
  removeSuggester(suggester) {
    var name = isString$1(suggester) ? suggester : suggester.name;
    _classPrivateFieldSet(this, _suggesters, _classPrivateFieldGet(this, _suggesters).filter((item) => item.name !== name));
    this.clearIgnored(name);
  }
  toJSON() {
    return this.match;
  }
  apply(props) {
    var _classPrivateFieldGet5 = _classPrivateFieldGet(this, _handlerMatches), exit = _classPrivateFieldGet5.exit, change = _classPrivateFieldGet5.change;
    if (_classPrivateFieldGet(this, _lastChangeFromAppend)) {
      _classPrivateFieldSet(this, _lastChangeFromAppend, false);
      if (!(exit !== null && exit !== void 0 && exit.suggester.appendTransaction) && !(change !== null && change !== void 0 && change.suggester.appendTransaction)) {
        return this;
      }
    }
    var tr = props.tr, state = props.state;
    var transactionHasChanged = tr.docChanged || tr.selectionSet;
    var shouldIgnoreUpdate = tr.getMeta(IGNORE_SUGGEST_META_KEY);
    if (shouldIgnoreUpdate || !transactionHasChanged && !_classPrivateFieldGet(this, _removed)) {
      return this;
    }
    _classPrivateFieldSet(this, _docChanged, tr.docChanged);
    this.mapIgnoredDecorations(tr);
    if (exit) {
      this.resetState();
    }
    _classPrivateFieldSet(this, _prev, _classPrivateFieldGet(this, _next));
    this.updateReasons({
      $pos: tr.selection.$from,
      state
    });
    return this;
  }
  createDecorations(state) {
    var match = this.match;
    if (!isValidMatch(match)) {
      return _classPrivateFieldGet(this, _ignored);
    }
    var disableDecorations = match.suggester.disableDecorations;
    var shouldSkip = isFunction$1(disableDecorations) ? disableDecorations(state, match) : disableDecorations;
    if (shouldSkip) {
      return _classPrivateFieldGet(this, _ignored);
    }
    var range2 = match.range, suggester = match.suggester;
    var name = suggester.name, suggestTag = suggester.suggestTag, suggestClassName = suggester.suggestClassName;
    var from4 = range2.from, to = range2.to;
    return this.shouldIgnoreMatch(match) ? _classPrivateFieldGet(this, _ignored) : _classPrivateFieldGet(this, _ignored).add(state.doc, [Decoration.inline(from4, to, {
      nodeName: suggestTag,
      class: name ? "".concat(suggestClassName, " suggest-").concat(name) : suggestClassName
    }, {
      name
    })]);
  }
}
function createSuggesterMapper() {
  var names = /* @__PURE__ */ new Set();
  return (suggester) => {
    if (names.has(suggester.name)) {
      throw new Error("A suggester already exists with the name '".concat(suggester.name, "'. The name provided must be unique."));
    }
    var suggesterWithDefaults = _objectSpread2$3(_objectSpread2$3({}, DEFAULT_SUGGESTER), suggester);
    names.add(suggester.name);
    return suggesterWithDefaults;
  };
}
var suggestPluginKey = new PluginKey("suggest");
function getSuggestPluginState(state) {
  return suggestPluginKey.getState(state);
}
function addSuggester(state, suggester) {
  return getSuggestPluginState(state).addSuggester(suggester);
}
function ignoreUpdateForSuggest(tr) {
  tr.setMeta(IGNORE_SUGGEST_META_KEY, true);
}
function removeSuggester(state, suggester) {
  return getSuggestPluginState(state).removeSuggester(suggester);
}
function suggest() {
  for (var _len = arguments.length, suggesters = new Array(_len), _key = 0; _key < _len; _key++) {
    suggesters[_key] = arguments[_key];
  }
  var pluginState = SuggestState.create(suggesters);
  return new Plugin({
    key: suggestPluginKey,
    view: (_view2) => {
      pluginState.init(_view2);
      return {
        update: (view) => {
          return pluginState.changeHandler(view.state.tr, false);
        }
      };
    },
    state: {
      init: () => {
        return pluginState;
      },
      apply: (tr, _pluginState, _oldState, state) => {
        return pluginState.apply({
          tr,
          state
        });
      }
    },
    appendTransaction: (_2, __, state) => {
      var tr = state.tr;
      pluginState.updateWithNextSelection(tr);
      pluginState.changeHandler(tr, true);
      if (tr.docChanged || tr.steps.length > 0 || tr.selectionSet || tr.storedMarksSet) {
        pluginState.setLastChangeFromAppend();
        return tr;
      }
      return null;
    },
    props: {
      decorations: (state) => {
        return pluginState.createDecorations(state);
      }
    }
  });
}
var _excluded$d = ["state", "dispatch", "view", "tr"];
function chainableEditorState(tr, state) {
  var proto = Object.getPrototypeOf(state);
  var selection = tr.selection;
  var doc2 = tr.doc;
  var storedMarks = tr.storedMarks;
  var properties = object();
  for (var _i = 0, _Object$entries = Object.entries(state); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
    properties[key] = {
      value
    };
  }
  return Object.create(proto, _objectSpread2$3(_objectSpread2$3({}, properties), {}, {
    storedMarks: {
      get() {
        return storedMarks;
      }
    },
    selection: {
      get() {
        return selection;
      }
    },
    doc: {
      get() {
        return doc2;
      }
    },
    tr: {
      get() {
        selection = tr.selection;
        doc2 = tr.doc;
        storedMarks = tr.storedMarks;
        return tr;
      }
    }
  }));
}
function convertCommand(commandFunction) {
  return (_ref) => {
    var state = _ref.state, dispatch2 = _ref.dispatch, view = _ref.view, tr = _ref.tr;
    return commandFunction(chainableEditorState(tr, state), dispatch2, view);
  };
}
function nonChainable(commandFunction) {
  return (props) => {
    var _props$view;
    !(props.dispatch === void 0 || props.dispatch === ((_props$view = props.view) === null || _props$view === void 0 ? void 0 : _props$view.dispatch)) ? invariant(false, {
      code: ErrorConstant.NON_CHAINABLE_COMMAND
    }) : void 0;
    return commandFunction(props);
  };
}
function chainCommands$1() {
  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {
    commands[_key] = arguments[_key];
  }
  return (_ref2) => {
    var state = _ref2.state, dispatch2 = _ref2.dispatch, view = _ref2.view, tr = _ref2.tr, rest = _objectWithoutProperties(_ref2, _excluded$d);
    var _iterator = _createForOfIteratorHelper(commands), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var element = _step.value;
        if (element(_objectSpread2$3({
          state,
          dispatch: dispatch2,
          view,
          tr
        }, rest))) {
          return true;
        }
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    return false;
  };
}
var environment = {
  get isBrowser() {
    return !!("object".document !== "undefined" && window.navigator && window.navigator.userAgent);
  },
  get isJSDOM() {
    return environment.isBrowser && window.navigator.userAgent.includes("jsdom");
  },
  get isNode() {
    return typeof process !== "undefined" && process.versions != null && process.versions.node != null;
  },
  get isIos() {
    return environment.isBrowser && /iPod|iPhone|iPad/.test(navigator.platform);
  },
  get isMac() {
    return environment.isBrowser && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
  },
  get isApple() {
    return environment.isNode ? process.platform === "darwin" : environment.isBrowser ? /Mac|iPod|iPhone|iPad/.test(window.navigator.platform) : false;
  },
  get isDevelopment() {
    return false;
  },
  get isTest() {
    return false;
  },
  get isProduction() {
    return false;
  }
};
function getStyle(element, property) {
  var _element$ownerDocumen, _element$ownerDocumen2;
  var view = (_element$ownerDocumen = (_element$ownerDocumen2 = element.ownerDocument) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.defaultView) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : window;
  var style = view.getComputedStyle(element);
  return style.getPropertyValue(property);
}
function isDomNode(domNode) {
  return isObject$1(Node) ? domNode instanceof Node : isObject$1(domNode) && isNumber(Cast(domNode).nodeType) && isString$1(Cast(domNode).nodeName);
}
function isElementDomNode(domNode) {
  return isDomNode(domNode) && domNode.nodeType === Node.ELEMENT_NODE;
}
function isNodeOfType(props) {
  var types = props.types, node4 = props.node;
  if (!node4) {
    return false;
  }
  var matches2 = (type2) => {
    return type2 === node4.type || type2 === node4.type.name;
  };
  if (isArray(types)) {
    return types.some(matches2);
  }
  return matches2(types);
}
function findParentNode(props) {
  var predicate = props.predicate, selection = props.selection;
  var $pos = isEditorState(selection) ? selection.selection.$from : isSelection(selection) ? selection.$from : selection;
  for (var depth = $pos.depth; depth > 0; depth--) {
    var _node2 = $pos.node(depth);
    var _pos = depth > 0 ? $pos.before(depth) : 0;
    var start4 = $pos.start(depth);
    var end3 = _pos + _node2.nodeSize;
    if (predicate(_node2, _pos)) {
      return {
        pos: _pos,
        depth,
        node: _node2,
        start: start4,
        end: end3
      };
    }
  }
  return;
}
function findNodeAtPosition($pos) {
  var depth = $pos.depth;
  var pos = depth > 0 ? $pos.before(depth) : 0;
  var node4 = $pos.node(depth);
  var start4 = $pos.start(depth);
  var end3 = pos + node4.nodeSize;
  return {
    pos,
    start: start4,
    node: node4,
    end: end3,
    depth
  };
}
function findParentNodeOfType(props) {
  var types = props.types, selection = props.selection;
  return findParentNode({
    predicate: (node4) => isNodeOfType({
      types,
      node: node4
    }),
    selection
  });
}
function findSelectedNodeOfType(props) {
  var types = props.types, selection = props.selection;
  if (!isNodeSelection(selection) || !isNodeOfType({
    types,
    node: selection.node
  })) {
    return;
  }
  return {
    pos: selection.$from.pos,
    depth: selection.$from.depth,
    start: selection.$from.start(),
    end: selection.$from.pos + selection.node.nodeSize,
    node: selection.node
  };
}
function isSelectionEmpty(value) {
  return isSelection(value) ? value.empty : value.selection.empty;
}
function hasTransactionChanged(tr) {
  return tr.docChanged || tr.selectionSet;
}
function isNodeActive(props) {
  return !!getActiveNode(props);
}
function getActiveNode(props) {
  var _findSelectedNodeOfTy;
  var state = props.state, type2 = props.type, attrs = props.attrs;
  var selection = state.selection, doc2 = state.doc;
  var nodeType2 = isString$1(type2) ? doc2.type.schema.nodes[type2] : type2;
  !nodeType2 ? invariant(false, {
    code: ErrorConstant.SCHEMA,
    message: "No node exists for ".concat(type2)
  }) : void 0;
  var active = (_findSelectedNodeOfTy = findSelectedNodeOfType({
    selection,
    types: type2
  })) !== null && _findSelectedNodeOfTy !== void 0 ? _findSelectedNodeOfTy : findParentNode({
    predicate: (node4) => node4.type === nodeType2,
    selection
  });
  if (!attrs || isEmptyObject(attrs) || !active) {
    return active;
  }
  return active.node.hasMarkup(nodeType2, _objectSpread2$3(_objectSpread2$3({}, active.node.attrs), attrs)) ? active : void 0;
}
function chainKeyBindingCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    commands[_key2] = arguments[_key2];
  }
  return (props) => {
    if (!isNonEmptyArray(commands)) {
      return false;
    }
    var command2 = commands[0], rest = commands.slice(1);
    var calledNext = false;
    var createNext = function createNext2() {
      for (var _len2 = arguments.length, nextCommands = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
        nextCommands[_key3] = arguments[_key3];
      }
      return () => {
        if (!isNonEmptyArray(nextCommands)) {
          return false;
        }
        calledNext = true;
        var nextRest = nextCommands.slice(1);
        return chainKeyBindingCommands(...nextCommands)(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
          next: createNext2(...nextRest)
        }));
      };
    };
    var next = createNext(...rest);
    var exitEarly = command2(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
      next
    }));
    if (calledNext || exitEarly) {
      return exitEarly;
    }
    return next();
  };
}
function mergeKeyBindingCreator(extensionKeymaps, mapper) {
  var previousCommandsMap = /* @__PURE__ */ new Map();
  var mappedCommands = object();
  var _iterator4 = _createForOfIteratorHelper(extensionKeymaps), _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
      var extensionKeymap = _step4.value;
      var _iterator5 = _createForOfIteratorHelper(entries(extensionKeymap)), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var _previousCommandsMap$;
          var _step5$value = _slicedToArray(_step5.value, 2), key = _step5$value[0], newCommand = _step5$value[1];
          var previousCommands = (_previousCommandsMap$ = previousCommandsMap.get(key)) !== null && _previousCommandsMap$ !== void 0 ? _previousCommandsMap$ : [];
          var commands = [...previousCommands, newCommand];
          var _command = chainKeyBindingCommands(...commands);
          previousCommandsMap.set(key, commands);
          mappedCommands[key] = mapper(_command);
        }
      } catch (err2) {
        _iterator5.e(err2);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err2) {
    _iterator4.e(err2);
  } finally {
    _iterator4.f();
  }
  return mappedCommands;
}
function mergeProsemirrorKeyBindings(extensionKeymaps) {
  return mergeKeyBindingCreator(extensionKeymaps, (command2) => (state, dispatch2, view) => {
    return command2({
      state,
      dispatch: dispatch2,
      view,
      tr: state.tr,
      next: () => false
    });
  });
}
function containsAttributes(nodeOrMark, attrs) {
  var _nodeOrMark$attrs;
  var currentAttrs = (_nodeOrMark$attrs = nodeOrMark.attrs) !== null && _nodeOrMark$attrs !== void 0 ? _nodeOrMark$attrs : {};
  return Object.entries(attrs).every((_ref3) => {
    var _ref4 = _slicedToArray(_ref3, 2), name = _ref4[0], value = _ref4[1];
    return currentAttrs[name] === value;
  });
}
var _excluded$1$3 = ["content", "schema", "document", "fragment"], _excluded2$1$1 = ["json", "schema"];
function isRangeStep(step2) {
  return isValidStep(step2, [AddMarkStep, ReplaceAroundStep, ReplaceStep, RemoveMarkStep]);
}
function isRemirrorType(value) {
  return isObject$1(value);
}
function isIdentifierOfType(value, type2) {
  return isArray(type2) ? includes(type2, value[__INTERNAL_REMIRROR_IDENTIFIER_KEY__]) : type2 === value[__INTERNAL_REMIRROR_IDENTIFIER_KEY__];
}
function isNodeType(value) {
  return isObject$1(value) && value instanceof NodeType$1;
}
function getNodeType(type2, schema) {
  return isString$1(type2) ? assertGet(schema.nodes, type2) : type2;
}
function isMarkType(value) {
  return isObject$1(value) && value instanceof MarkType;
}
function getMarkType(type2, schema) {
  return isString$1(type2) ? assertGet(schema.marks, type2) : type2;
}
function isProsemirrorNode(value) {
  return isObject$1(value) && value instanceof Node$1;
}
function isProsemirrorFragment(value) {
  return isObject$1(value) && value instanceof Fragment;
}
function isProsemirrorMark(value) {
  return isObject$1(value) && value instanceof Mark;
}
function isEditorState(value) {
  return isObject$1(value) && value instanceof EditorState;
}
function isTextSelection(value) {
  return isObject$1(value) && value instanceof TextSelection;
}
function isAllSelection(value) {
  return isObject$1(value) && value instanceof AllSelection;
}
function isSelection(value) {
  return isObject$1(value) && value instanceof Selection;
}
function isResolvedPos(value) {
  return isObject$1(value) && value instanceof ResolvedPos;
}
function rangeHasMark2(props) {
  var trState = props.trState, from4 = props.from, to = props.to, type2 = props.type, _props$attrs = props.attrs, attrs = _props$attrs === void 0 ? {} : _props$attrs;
  var doc2 = trState.doc;
  var markType = getMarkType(type2, doc2.type.schema);
  if (Object.keys(attrs).length === 0) {
    return doc2.rangeHasMark(from4, to, markType);
  }
  var found2 = false;
  if (to > from4) {
    doc2.nodesBetween(from4, to, (node4) => {
      var _node$marks;
      if (found2) {
        return false;
      }
      var marks2 = (_node$marks = node4.marks) !== null && _node$marks !== void 0 ? _node$marks : [];
      found2 = marks2.some((mark3) => {
        if (mark3.type !== markType) {
          return false;
        }
        return containsAttributes(mark3, attrs);
      });
      return !found2;
    });
  }
  return found2;
}
function isNodeSelection(value) {
  return isObject$1(value) && value instanceof NodeSelection;
}
function isMarkActive(props) {
  var trState = props.trState, type2 = props.type, _props$attrs2 = props.attrs, attrs = _props$attrs2 === void 0 ? {} : _props$attrs2, from4 = props.from, to = props.to;
  var selection = trState.selection, doc2 = trState.doc, storedMarks = trState.storedMarks;
  var markType = isString$1(type2) ? doc2.type.schema.marks[type2] : type2;
  !markType ? invariant(false, {
    code: ErrorConstant.SCHEMA,
    message: "Mark type: ".concat(type2, " does not exist on the current schema.")
  }) : void 0;
  if (from4 && to) {
    try {
      return Math.max(from4, to) < doc2.nodeSize && rangeHasMark2(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
        from: from4,
        to
      }));
    } catch (_unused) {
      return false;
    }
  }
  if (selection.empty) {
    var marks2 = storedMarks !== null && storedMarks !== void 0 ? storedMarks : selection.$from.marks();
    return marks2.some((mark3) => {
      if (mark3.type !== type2) {
        return false;
      }
      return containsAttributes(mark3, attrs !== null && attrs !== void 0 ? attrs : {});
    });
  }
  return rangeHasMark2(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
    from: selection.from,
    to: selection.to
  }));
}
function isDocNodeEmpty(node4) {
  var nodeChild = node4.content.firstChild;
  if (node4.childCount !== 1 || !nodeChild) {
    return false;
  }
  return nodeChild.type.isBlock && !nodeChild.childCount && nodeChild.nodeSize === 2 && (isNullOrUndefined(nodeChild.marks) || nodeChild.marks.length === 0);
}
function isDefaultDocNode(doc2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var defaultDoc = getDefaultDocNode(doc2.type.schema);
  if (!defaultDoc) {
    return false;
  }
  var ignoreAttributes = options.ignoreAttributes, ignoreDocAttributes = options.ignoreDocAttributes;
  if (ignoreAttributes) {
    return prosemirrorNodeEquals(defaultDoc, doc2);
  }
  if (ignoreDocAttributes) {
    return defaultDoc.content.eq(doc2.content);
  }
  return defaultDoc.eq(doc2);
}
function prosemirrorNodeEquals(node4, other) {
  if (node4 === other) {
    return true;
  }
  var identicalMarkup = node4.type === other.type && Mark.sameSet(node4.marks, other.marks);
  function contentEquals() {
    if (node4.content === other.content) {
      return true;
    }
    if (node4.content.size !== other.content.size) {
      return false;
    }
    var nodeChildren = [];
    var otherChildren = [];
    node4.content.forEach((node5) => nodeChildren.push(node5));
    other.content.forEach((node5) => otherChildren.push(node5));
    var _iterator = _createForOfIteratorHelper(nodeChildren.entries()), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), index3 = _step$value[0], nodeChild = _step$value[1];
        var otherChild = otherChildren[index3];
        if (!otherChild) {
          return false;
        }
        if (!prosemirrorNodeEquals(nodeChild, otherChild)) {
          return false;
        }
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    return true;
  }
  return identicalMarkup && contentEquals();
}
function getDefaultDocNode(schema) {
  var _schema$nodes$doc$cre, _schema$nodes$doc;
  return (_schema$nodes$doc$cre = (_schema$nodes$doc = schema.nodes.doc) === null || _schema$nodes$doc === void 0 ? void 0 : _schema$nodes$doc.createAndFill()) !== null && _schema$nodes$doc$cre !== void 0 ? _schema$nodes$doc$cre : void 0;
}
function getDefaultBlockNode(schema) {
  for (var _i = 0, _Object$values = Object.values(schema.nodes); _i < _Object$values.length; _i++) {
    var type2 = _Object$values[_i];
    if (type2.name === "doc") {
      continue;
    }
    if (type2.isBlock || type2.isTextblock) {
      return type2;
    }
  }
  invariant(false, {
    code: ErrorConstant.SCHEMA,
    message: "No default block node found for the provided schema."
  });
}
function isDefaultBlockNode(node4) {
  return node4.type === getDefaultBlockNode(node4.type.schema);
}
function isEmptyBlockNode(node4) {
  return !!node4 && node4.type.isBlock && !node4.textContent && !node4.childCount;
}
function getMarkRange($pos, type2, $end) {
  var start4 = $pos.parent.childAfter($pos.parentOffset);
  if (!start4.node) {
    return;
  }
  var typeName = isString$1(type2) ? type2 : type2.name;
  var mark3 = start4.node.marks.find((_ref) => {
    var markType = _ref.type;
    return markType.name === typeName;
  });
  var startIndex = $pos.index();
  var startPos = $pos.start() + start4.offset;
  var endIndex = startIndex + 1;
  var endPos = startPos + start4.node.nodeSize;
  if (!mark3) {
    if ($end && endPos < $end.pos) {
      return getMarkRange($pos.doc.resolve(endPos + 1), type2, $end);
    }
    return;
  }
  while (startIndex > 0 && mark3.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && mark3.isInSet($pos.parent.child(endIndex).marks)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  var text3 = $pos.doc.textBetween(startPos, endPos, LEAF_NODE_REPLACING_CHARACTER, "\n\n");
  return {
    from: startPos,
    to: endPos,
    text: text3,
    mark: mark3
  };
}
function isValidStep(step2, StepTypes) {
  return StepTypes.length === 0 || StepTypes.some((Constructor) => step2 instanceof Constructor);
}
function getChangedRanges(tr) {
  var StepTypes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var ranges = [];
  var rawRanges = [];
  var _iterator2 = _createForOfIteratorHelper(tr.steps), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var step2 = _step2.value;
      if (!isValidStep(step2, StepTypes)) {
        continue;
      }
      var stepMap = step2.getMap();
      if (stepMap.ranges.length === 0 && isRangeStep(step2)) {
        var from4 = step2.from, to = step2.to;
        if (from4 === void 0 || to === void 0) {
          continue;
        }
        rawRanges.push({
          from: from4,
          to
        });
      } else {
        step2.getMap().forEach((_2, __, from5, to2) => {
          rawRanges.push({
            from: from5,
            to: to2
          });
        });
      }
    }
  } catch (err2) {
    _iterator2.e(err2);
  } finally {
    _iterator2.f();
  }
  var sortedRanges = sort(rawRanges, (a2, z2) => a2.from - z2.from);
  var _iterator3 = _createForOfIteratorHelper(sortedRanges), _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var _step3$value = _step3.value, _from = _step3$value.from, _to = _step3$value.to;
      var lastRange = ranges[ranges.length - 1];
      var noOverlap = !lastRange || lastRange.to < _from;
      if (noOverlap) {
        ranges.push({
          from: _from,
          to: _to,
          prevFrom: tr.mapping.invert().map(_from, -1),
          prevTo: tr.mapping.invert().map(_to)
        });
      } else if (lastRange) {
        lastRange.to = Math.max(lastRange.from, _to);
      }
    }
  } catch (err2) {
    _iterator3.e(err2);
  } finally {
    _iterator3.f();
  }
  return uniqueBy$1(ranges, (_ref2) => {
    var from5 = _ref2.from, to2 = _ref2.to, prevFrom = _ref2.prevFrom, prevTo = _ref2.prevTo;
    return "".concat(from5, "_").concat(to2, "_").concat(prevFrom, "_").concat(prevTo);
  });
}
function getTextContentFromSlice(slice5) {
  var _slice$content$firstC, _slice$content$firstC2;
  return (_slice$content$firstC = (_slice$content$firstC2 = slice5.content.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.textContent) !== null && _slice$content$firstC !== void 0 ? _slice$content$firstC : "";
}
function getSelectedGroup(state, exclude) {
  if (!isTextSelection(state.selection)) {
    return;
  }
  var _state$selection = state.selection, from4 = _state$selection.from, to = _state$selection.to;
  var getChar = (start4, end3) => getTextContentFromSlice(TextSelection.create(state.doc, start4, end3).content());
  for (var char = getChar(from4 - 1, from4); char && !exclude.test(char); from4--, char = getChar(from4 - 1, from4)) {
  }
  for (var _char = getChar(to, to + 1); _char && !exclude.test(_char); to++, _char = getChar(to, to + 1)) {
  }
  if (from4 === to) {
    return;
  }
  var text3 = state.doc.textBetween(from4, to, LEAF_NODE_REPLACING_CHARACTER, "\n\n");
  return {
    from: from4,
    to,
    text: text3
  };
}
function getSelectedWord(state) {
  return getSelectedGroup(state, /\W/);
}
function getMatchString(match) {
  var index3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var value = isArray(match) ? match[index3] : match;
  assert(isString$1(value), "No match string found for match ".concat(match));
  return value !== null && value !== void 0 ? value : "";
}
function getCursor(selection) {
  return isTextSelection(selection) ? selection.$cursor : void 0;
}
function isDocNode(node4, schema) {
  if (!isProsemirrorNode(node4)) {
    return false;
  }
  if (schema) {
    return node4.type === schema.nodes.doc;
  }
  return node4.type.name === "doc";
}
function isAnchorHeadObject(value) {
  return isObject$1(value) && isNumber(value.anchor) && isNumber(value.head);
}
function getTextSelection(selection, doc2) {
  var max3 = doc2.nodeSize - 2;
  var min3 = 0;
  var pos;
  var clampToDocument = (value) => clamp$1({
    min: min3,
    max: max3,
    value
  });
  if (isSelection(selection)) {
    return selection;
  }
  if (selection === "all") {
    return new AllSelection(doc2);
  }
  if (selection === "start") {
    pos = min3;
  } else if (selection === "end") {
    pos = max3;
  } else if (isResolvedPos(selection)) {
    pos = selection.pos;
  } else {
    pos = selection;
  }
  if (isNumber(pos)) {
    pos = clampToDocument(pos);
    return TextSelection.near(doc2.resolve(pos));
  }
  if (isAnchorHeadObject(pos)) {
    var _anchor = clampToDocument(pos.anchor);
    var _head = clampToDocument(pos.head);
    return TextSelection.create(doc2, _anchor, _head);
  }
  var anchor = clampToDocument(pos.from);
  var head = clampToDocument(pos.to);
  return TextSelection.create(doc2, anchor, head);
}
var MAX_ATTEMPTS = 3;
function createDocumentNode(props) {
  var content2 = props.content, schema = props.schema, document2 = props.document, stringHandler2 = props.stringHandler, onError = props.onError, _props$attempts = props.attempts, attempts = _props$attempts === void 0 ? 0 : _props$attempts;
  var attemptsRemaining = onError && attempts <= MAX_ATTEMPTS || attempts === 0;
  !attemptsRemaining ? invariant(false, {
    code: ErrorConstant.INVALID_CONTENT,
    message: "The invalid content has been called recursively more than ${MAX_ATTEMPTS} times. The content is invalid and the error handler has not been able to recover properly."
  }) : void 0;
  if (isString$1(content2)) {
    !stringHandler2 ? invariant(false, {
      code: ErrorConstant.INVALID_CONTENT,
      message: "The string '".concat(content2, "' was added to the editor, but no `stringHandler` was added. Please provide a valid string handler which transforms your content to a `ProsemirrorNode` to prevent this error.")
    }) : void 0;
    var options = {
      document: document2,
      content: content2,
      schema
    };
    return stringHandler2(options);
  }
  if (isEditorState(content2)) {
    return content2.doc;
  }
  if (isProsemirrorNode(content2)) {
    return content2;
  }
  try {
    return schema.nodeFromJSON(content2);
  } catch (error) {
    var details = getInvalidContent({
      schema,
      error,
      json: content2
    });
    var transformedContent = onError === null || onError === void 0 ? void 0 : onError(details);
    !transformedContent ? invariant(false, {
      code: ErrorConstant.INVALID_CONTENT,
      message: "An error occurred when processing the content. Please provide an `onError` handler to process the invalid content: ".concat(JSON.stringify(details.invalidContent, null, 2))
    }) : void 0;
    return createDocumentNode(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
      content: transformedContent,
      attempts: attempts + 1
    }));
  }
}
function shouldUseDomEnvironment(forceEnvironment) {
  return forceEnvironment === "dom" || environment.isBrowser && !forceEnvironment;
}
function getDocument$1(forceEnvironment) {
  {
    return document;
  }
}
function prosemirrorNodeToDom(node4) {
  var document2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getDocument$1();
  var fragment = isDocNode(node4, node4.type.schema) ? node4.content : Fragment.from(node4);
  return DOMSerializer.fromSchema(node4.type.schema).serializeFragment(fragment, {
    document: document2
  });
}
function elementFromString(html, document2) {
  var _defaultView, _ref3;
  var parser2 = new ((_defaultView = (_ref3 = document2 !== null && document2 !== void 0 ? document2 : getDocument$1()) === null || _ref3 === void 0 ? void 0 : _ref3.defaultView) !== null && _defaultView !== void 0 ? _defaultView : window).DOMParser();
  return parser2.parseFromString("<body>".concat(html, "</body>"), "text/html").body;
}
function prosemirrorNodeToHtml(node4) {
  var document2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getDocument$1();
  var element = document2.createElement("div");
  element.append(prosemirrorNodeToDom(node4, document2));
  return element.innerHTML;
}
function htmlToProsemirrorNode(props) {
  var content2 = props.content, schema = props.schema;
  props.document;
  var _props$fragment = props.fragment, fragment = _props$fragment === void 0 ? false : _props$fragment, parseOptions = _objectWithoutProperties(props, _excluded$1$3);
  var element = elementFromString(content2);
  var parser2 = DOMParser.fromSchema(schema);
  return fragment ? parser2.parseSlice(element, _objectSpread2$3(_objectSpread2$3({}, defaultParseOptions), parseOptions)).content : parser2.parse(element, _objectSpread2$3(_objectSpread2$3({}, defaultParseOptions), parseOptions));
}
var defaultParseOptions = {
  preserveWhitespace: false
};
function omitExtraAttributes(attrs, extra) {
  var extraAttributeNames = keys$1(extra.defaults());
  return omit2(_objectSpread2$3({}, attrs), extraAttributeNames);
}
var transformers = {
  remove(json, invalidContent) {
    var newJSON = json;
    var _iterator7 = _createForOfIteratorHelper(invalidContent), _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
        var block = _step7.value;
        if (block.invalidParentNode) {
          continue;
        }
        newJSON = unset(block.path, newJSON);
      }
    } catch (err2) {
      _iterator7.e(err2);
    } finally {
      _iterator7.f();
    }
    return newJSON;
  }
};
function getInvalidContent(_ref4) {
  var json = _ref4.json, schema = _ref4.schema, extra = _objectWithoutProperties(_ref4, _excluded2$1$1);
  var validMarks = new Set(keys$1(schema.marks));
  var validNodes = new Set(keys$1(schema.nodes));
  var invalidContent = checkForInvalidContent({
    json,
    path: [],
    validNodes,
    validMarks
  });
  return _objectSpread2$3({
    json,
    invalidContent,
    transformers
  }, extra);
}
function checkForInvalidContent(props) {
  var json = props.json, validMarks = props.validMarks, validNodes = props.validNodes, _props$path = props.path, path = _props$path === void 0 ? [] : _props$path;
  var valid4 = {
    validMarks,
    validNodes
  };
  var invalidNodes = [];
  var type2 = json.type, marks2 = json.marks, content2 = json.content;
  var _props$invalidParentM = props.invalidParentMark, invalidParentMark = _props$invalidParentM === void 0 ? false : _props$invalidParentM, _props$invalidParentN = props.invalidParentNode, invalidParentNode = _props$invalidParentN === void 0 ? false : _props$invalidParentN;
  if (marks2) {
    var invalidMarks2 = [];
    var _iterator8 = _createForOfIteratorHelper(marks2.entries()), _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
        var _step8$value = _slicedToArray(_step8.value, 2), index3 = _step8$value[0], mark3 = _step8$value[1];
        var name = isString$1(mark3) ? mark3 : mark3.type;
        if (validMarks.has(name)) {
          continue;
        }
        invalidMarks2.unshift({
          name,
          path: [...path, "marks", "".concat(index3)],
          type: "mark",
          invalidParentMark,
          invalidParentNode
        });
        invalidParentMark = true;
      }
    } catch (err2) {
      _iterator8.e(err2);
    } finally {
      _iterator8.f();
    }
    invalidNodes.push(...invalidMarks2);
  }
  if (!validNodes.has(type2)) {
    invalidNodes.push({
      name: type2,
      type: "node",
      path,
      invalidParentMark,
      invalidParentNode
    });
    invalidParentNode = true;
  }
  if (content2) {
    var invalidContent = [];
    var _iterator9 = _createForOfIteratorHelper(content2.entries()), _step9;
    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
        var _step9$value = _slicedToArray(_step9.value, 2), _index = _step9$value[0], value = _step9$value[1];
        invalidContent.unshift(...checkForInvalidContent(_objectSpread2$3(_objectSpread2$3({}, valid4), {}, {
          json: value,
          path: [...path, "content", "".concat(_index)],
          invalidParentMark,
          invalidParentNode
        })));
      }
    } catch (err2) {
      _iterator9.e(err2);
    } finally {
      _iterator9.f();
    }
    invalidNodes.unshift(...invalidContent);
  }
  return invalidNodes;
}
function isEndOfTextBlock(selection) {
  return !!(isTextSelection(selection) && selection.$cursor && selection.$cursor.parentOffset >= selection.$cursor.parent.content.size);
}
function isStartOfTextBlock(selection) {
  return !!(isTextSelection(selection) && selection.$cursor && selection.$cursor.parentOffset <= 0);
}
function isStartOfDoc(selection) {
  var selectionAtStart = Selection.atStart(selection.$anchor.doc);
  return !!(isStartOfTextBlock(selection) && selectionAtStart.anchor === selection.anchor);
}
function updateMark(props) {
  return (_ref) => {
    var dispatch2 = _ref.dispatch, tr = _ref.tr;
    var type2 = props.type, _props$attrs = props.attrs, attrs = _props$attrs === void 0 ? object() : _props$attrs, appendText = props.appendText, range2 = props.range;
    var selection = range2 ? TextSelection.create(tr.doc, range2.from, range2.to) : tr.selection;
    var $from = selection.$from, from4 = selection.from, to = selection.to;
    var applicable = $from.depth === 0 ? tr.doc.type.allowsMarkType(type2) : false;
    tr.doc.nodesBetween(from4, to, (node4) => {
      if (applicable) {
        return false;
      }
      if (node4.inlineContent && node4.type.allowsMarkType(type2)) {
        applicable = true;
        return;
      }
      return;
    });
    if (!applicable) {
      return false;
    }
    dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.addMark(from4, to, type2.create(attrs)) && appendText ? tr.insertText(appendText) : tr);
    return true;
  };
}
function lift(_ref2) {
  var tr = _ref2.tr, dispatch2 = _ref2.dispatch;
  var _tr$selection = tr.selection, $from = _tr$selection.$from, $to = _tr$selection.$to;
  var range2 = $from.blockRange($to);
  var target = range2 && liftTarget(range2);
  if (!isNumber(target) || !range2) {
    return false;
  }
  dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.lift(range2, target).scrollIntoView());
  return true;
}
function wrapIn(type2) {
  var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var selection = arguments.length > 2 ? arguments[2] : void 0;
  return function(props) {
    var tr = props.tr, dispatch2 = props.dispatch, state = props.state;
    var nodeType2 = isString$1(type2) ? assertGet(state.schema.nodes, type2) : type2;
    var _getTextSelection = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc), from4 = _getTextSelection.from, to = _getTextSelection.to;
    var $from = tr.doc.resolve(from4);
    var $to = tr.doc.resolve(to);
    var blockRange2 = $from.blockRange($to);
    var wrapping = blockRange2 && findWrapping3(blockRange2, nodeType2, attrs);
    if (!wrapping || !blockRange2) {
      return false;
    }
    dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.wrap(blockRange2, wrapping).scrollIntoView());
    return true;
  };
}
function toggleWrap(nodeType2) {
  var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var selection = arguments.length > 2 ? arguments[2] : void 0;
  return (props) => {
    var tr = props.tr, state = props.state;
    var type2 = isString$1(nodeType2) ? assertGet(state.schema.nodes, nodeType2) : nodeType2;
    var activeNode = getActiveNode({
      state: tr,
      type: type2,
      attrs
    });
    if (activeNode) {
      return lift(props);
    }
    return wrapIn(nodeType2, attrs, selection)(props);
  };
}
function setBlockType(nodeType2, attrs, selection) {
  var preserveAttrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  return function(props) {
    var tr = props.tr, dispatch2 = props.dispatch, state = props.state;
    var type2 = isString$1(nodeType2) ? assertGet(state.schema.nodes, nodeType2) : nodeType2;
    var _getTextSelection2 = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc), from4 = _getTextSelection2.from, to = _getTextSelection2.to;
    var applicable = false;
    var activeAttrs;
    tr.doc.nodesBetween(from4, to, (node4, pos) => {
      if (applicable) {
        return false;
      }
      if (!node4.isTextblock || node4.hasMarkup(type2, attrs)) {
        return;
      }
      if (node4.type === type2) {
        applicable = true;
        activeAttrs = node4.attrs;
        return;
      }
      var $pos = tr.doc.resolve(pos);
      var index3 = $pos.index();
      applicable = $pos.parent.canReplaceWith(index3, index3 + 1, type2);
      if (applicable) {
        activeAttrs = $pos.parent.attrs;
      }
      return;
    });
    if (!applicable) {
      return false;
    }
    dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.setBlockType(from4, to, type2, _objectSpread2$3(_objectSpread2$3({}, preserveAttrs ? activeAttrs : {}), attrs)).scrollIntoView());
    return true;
  };
}
function toggleBlockItem(toggleProps) {
  return (props) => {
    var _toggleProps$toggleTy;
    var tr = props.tr, state = props.state;
    var type2 = toggleProps.type, attrs = toggleProps.attrs, _toggleProps$preserve = toggleProps.preserveAttrs, preserveAttrs = _toggleProps$preserve === void 0 ? true : _toggleProps$preserve;
    var activeNode = getActiveNode({
      state: tr,
      type: type2,
      attrs
    });
    var toggleType = (_toggleProps$toggleTy = toggleProps.toggleType) !== null && _toggleProps$toggleTy !== void 0 ? _toggleProps$toggleTy : getDefaultBlockNode(state.schema);
    if (activeNode) {
      return setBlockType(toggleType, _objectSpread2$3(_objectSpread2$3({}, preserveAttrs ? activeNode.node.attrs : {}), attrs))(props);
    }
    var toggleNode = getActiveNode({
      state: tr,
      type: toggleType,
      attrs
    });
    return setBlockType(type2, _objectSpread2$3(_objectSpread2$3({}, preserveAttrs ? toggleNode === null || toggleNode === void 0 ? void 0 : toggleNode.node.attrs : {}), attrs))(props);
  };
}
function isChrome() {
  var minVersion = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var parsedAgent = navigator.userAgent.match(/Chrom(e|ium)\/(\d+)\./);
  return parsedAgent ? Number.parseInt(assertGet(parsedAgent, 2), 10) >= minVersion : false;
}
function preserveSelection(selection, tr) {
  var head = selection.head, empty2 = selection.empty, anchor = selection.anchor;
  var _iterator = _createForOfIteratorHelper(tr.steps), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var step2 = _step.value;
      var map16 = step2.getMap();
      head = map16.map(head);
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  if (empty2) {
    tr.setSelection(TextSelection.create(tr.doc, head));
  } else {
    tr.setSelection(TextSelection.create(tr.doc, anchor, head));
  }
}
function replaceText(props) {
  var _props$attrs2 = props.attrs, attrs = _props$attrs2 === void 0 ? {} : _props$attrs2, _props$appendText = props.appendText, appendText = _props$appendText === void 0 ? "" : _props$appendText, _props$content = props.content, content2 = _props$content === void 0 ? "" : _props$content, _props$keepSelection = props.keepSelection, keepSelection = _props$keepSelection === void 0 ? false : _props$keepSelection, range2 = props.range;
  return (_ref3) => {
    var _ref4, _props$selection, _schema$nodes$props$t;
    var state = _ref3.state, tr = _ref3.tr, dispatch2 = _ref3.dispatch;
    var schema = state.schema;
    var selection = getTextSelection((_ref4 = (_props$selection = props.selection) !== null && _props$selection !== void 0 ? _props$selection : range2) !== null && _ref4 !== void 0 ? _ref4 : tr.selection, tr.doc);
    var index3 = selection.$from.index();
    var from4 = selection.from, to = selection.to, $from = selection.$from;
    var type2 = isString$1(props.type) ? (_schema$nodes$props$t = schema.nodes[props.type]) !== null && _schema$nodes$props$t !== void 0 ? _schema$nodes$props$t : schema.marks[props.type] : props.type;
    !(isString$1(props.type) ? type2 : true) ? invariant(false, {
      code: ErrorConstant.SCHEMA,
      message: "Schema contains no marks or nodes with name ".concat(type2)
    }) : void 0;
    if (isNodeType(type2)) {
      if (!$from.parent.canReplaceWith(index3, index3, type2)) {
        return false;
      }
      tr.replaceWith(from4, to, type2.create(attrs, content2 ? schema.text(content2) : void 0));
    } else {
      !content2 ? invariant(false, {
        message: "`replaceText` cannot be called without content when using a mark type"
      }) : void 0;
      tr.replaceWith(from4, to, schema.text(content2, isMarkType(type2) ? [type2.create(attrs)] : void 0));
    }
    if (appendText) {
      tr.insertText(appendText);
    }
    if (keepSelection) {
      preserveSelection(state.selection, tr);
    }
    if (dispatch2) {
      if (isChrome(60)) {
        var _document$getSelectio;
        (_document$getSelectio = document.getSelection()) === null || _document$getSelectio === void 0 ? void 0 : _document$getSelectio.empty();
      }
      dispatch2(tr);
    }
    return true;
  };
}
function removeMark(props) {
  return (_ref5) => {
    var _ref6, _props$selection2;
    var dispatch2 = _ref5.dispatch, tr = _ref5.tr, state = _ref5.state;
    var type2 = props.type, _props$expand = props.expand, expand = _props$expand === void 0 ? true : _props$expand, range2 = props.range;
    var selection = getTextSelection((_ref6 = (_props$selection2 = props.selection) !== null && _props$selection2 !== void 0 ? _props$selection2 : range2) !== null && _ref6 !== void 0 ? _ref6 : tr.selection, tr.doc);
    var markType = isString$1(type2) ? state.schema.marks[type2] : type2;
    var from4 = selection.from, to = selection.to, $from = selection.$from, $to = selection.$to;
    !markType ? invariant(false, {
      code: ErrorConstant.SCHEMA,
      message: "Mark type: ".concat(type2, " does not exist on the current schema.")
    }) : void 0;
    var markRange = getMarkRange($from, markType, $to);
    if (expand && markRange) {
      from4 = markRange.from;
      to = markRange.to;
    }
    dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.removeMark(from4, isNumber(to) ? to : from4, markType));
    return true;
  };
}
function isCommandKey(key) {
  var allowedKeys = ["command", "cmd", "meta"];
  if (environment.isMac) {
    allowedKeys.push("mod");
  }
  return allowedKeys.includes(key);
}
function isControlKey(key) {
  var allowedKeys = ["control", "ctrl"];
  if (!environment.isMac) {
    allowedKeys.push("mod");
  }
  return allowedKeys.includes(key);
}
function getShortcutSymbols(shortcut) {
  var symbols = [];
  var _iterator = _createForOfIteratorHelper(shortcut.split("-")), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var key = _step.value;
      key = key.toLowerCase();
      if (isCommandKey(key)) {
        symbols.push({
          type: "modifier",
          symbol: "\u2318",
          key: "command",
          i18n: coreUtilsMessages.COMMAND_KEY
        });
        continue;
      }
      if (isControlKey(key)) {
        symbols.push({
          type: "modifier",
          symbol: "\u2303",
          key: "control",
          i18n: coreUtilsMessages.CONTROL_KEY
        });
        continue;
      }
      switch (key) {
        case "shift":
          symbols.push({
            type: "modifier",
            symbol: "\u21E7",
            key,
            i18n: coreUtilsMessages.SHIFT_KEY
          });
          continue;
        case "alt":
          symbols.push({
            type: "modifier",
            symbol: "\u2325",
            key,
            i18n: coreUtilsMessages.ALT_KEY
          });
          continue;
        case "\n":
        case "\r":
        case "enter":
          symbols.push({
            type: "named",
            symbol: "\u21B5",
            key,
            i18n: coreUtilsMessages.ENTER_KEY
          });
          continue;
        case "backspace":
          symbols.push({
            type: "named",
            symbol: "\u232B",
            key,
            i18n: coreUtilsMessages.BACKSPACE_KEY
          });
          continue;
        case "delete":
          symbols.push({
            type: "named",
            symbol: "\u2326",
            key,
            i18n: coreUtilsMessages.DELETE_KEY
          });
          continue;
        case "escape":
          symbols.push({
            type: "named",
            symbol: "\u241B",
            key,
            i18n: coreUtilsMessages.ESCAPE_KEY
          });
          continue;
        case "tab":
          symbols.push({
            type: "named",
            symbol: "\u21E5",
            key,
            i18n: coreUtilsMessages.TAB_KEY
          });
          continue;
        case "capslock":
          symbols.push({
            type: "named",
            symbol: "\u21EA",
            key,
            i18n: coreUtilsMessages.CAPS_LOCK_KEY
          });
          continue;
        case "space":
          symbols.push({
            type: "named",
            symbol: "\u2423",
            key,
            i18n: coreUtilsMessages.SPACE_KEY
          });
          continue;
        case "pageup":
          symbols.push({
            type: "named",
            symbol: "\u2912",
            key,
            i18n: coreUtilsMessages.PAGE_UP_KEY
          });
          continue;
        case "pagedown":
          symbols.push({
            type: "named",
            symbol: "\u2913",
            key,
            i18n: coreUtilsMessages.PAGE_DOWN_KEY
          });
          continue;
        case "home":
          symbols.push({
            type: "named",
            key,
            i18n: coreUtilsMessages.HOME_KEY
          });
          continue;
        case "end":
          symbols.push({
            type: "named",
            key,
            i18n: coreUtilsMessages.END_KEY
          });
          continue;
        case "arrowleft":
          symbols.push({
            type: "named",
            symbol: "\u2190",
            key,
            i18n: coreUtilsMessages.ARROW_LEFT_KEY
          });
          continue;
        case "arrowright":
          symbols.push({
            type: "named",
            symbol: "\u2192",
            key,
            i18n: coreUtilsMessages.ARROW_RIGHT_KEY
          });
          continue;
        case "arrowup":
          symbols.push({
            type: "named",
            symbol: "\u2192",
            key,
            i18n: coreUtilsMessages.ARROW_UP_KEY
          });
          continue;
        case "arrowdown":
          symbols.push({
            type: "named",
            symbol: "\u2193",
            key,
            i18n: coreUtilsMessages.ARROW_DOWN_KEY
          });
          continue;
        default:
          symbols.push({
            type: "char",
            key
          });
          continue;
      }
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  return symbols;
}
function findChildren(props) {
  var node4 = props.node, predicate = props.predicate, _props$descend = props.descend, descend = _props$descend === void 0 ? true : _props$descend, action2 = props.action;
  !isProsemirrorNode(node4) ? invariant(false, {
    code: ErrorConstant.INTERNAL,
    message: 'Invalid "node" parameter passed to "findChildren".'
  }) : void 0;
  !isFunction$1(predicate) ? invariant(false, {
    code: ErrorConstant.INTERNAL,
    message: 'Invalid "predicate" parameter passed to "findChildren".'
  }) : void 0;
  var result2 = [];
  node4.descendants((child3, pos) => {
    var nodeWithPosition = {
      node: child3,
      pos
    };
    var isMatch = predicate(nodeWithPosition);
    if (!isMatch) {
      return descend;
    }
    result2.push(nodeWithPosition);
    action2 === null || action2 === void 0 ? void 0 : action2(nodeWithPosition);
    return descend;
  });
  return result2;
}
function findNodeByPredicate(_ref) {
  var predicate = _ref.predicate;
  return (props) => findChildren(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
    predicate
  }));
}
findNodeByPredicate({
  predicate: (child3) => child3.node.isText
});
findNodeByPredicate({
  predicate: (child3) => child3.node.isInline
});
findNodeByPredicate({
  predicate: (child3) => child3.node.isBlock
});
function markInputRule(props) {
  var regexp = props.regexp, type2 = props.type, getAttributes = props.getAttributes, _props$ignoreWhitespa = props.ignoreWhitespace, ignoreWhitespace = _props$ignoreWhitespa === void 0 ? false : _props$ignoreWhitespa, beforeDispatch = props.beforeDispatch, updateCaptured = props.updateCaptured, shouldSkip = props.shouldSkip, invalidMarks2 = props.invalidMarks;
  var markType;
  var rule = new InputRule(regexp, (state, match, start4, end3) => {
    var tr = state.tr, schema = state.schema;
    if (!markType) {
      markType = isString$1(type2) ? schema.marks[type2] : type2;
      !markType ? invariant(false, {
        code: ErrorConstant.SCHEMA,
        message: "Mark type: ".concat(type2, " does not exist on the current schema.")
      }) : void 0;
    }
    var captureGroup = match[1];
    var fullMatch = match[0];
    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end: end3,
      start: start4,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks: invalidMarks2,
      shouldSkip,
      updateCaptured
    });
    if (!details) {
      return null;
    }
    start4 = details.start;
    end3 = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;
    var attributes = isFunction$1(getAttributes) ? getAttributes(match) : getAttributes;
    var markEnd = end3;
    var initialStoredMarks = [];
    if (captureGroup) {
      var _tr$storedMarks;
      var startSpaces = fullMatch.search(/\S/);
      var textStart = start4 + fullMatch.indexOf(captureGroup);
      var textEnd = textStart + captureGroup.length;
      initialStoredMarks = (_tr$storedMarks = tr.storedMarks) !== null && _tr$storedMarks !== void 0 ? _tr$storedMarks : [];
      if (textEnd < end3) {
        tr.delete(textEnd, end3);
      }
      if (textStart > start4) {
        tr.delete(start4 + startSpaces, textStart);
      }
      markEnd = start4 + startSpaces + captureGroup.length;
    }
    tr.addMark(start4, markEnd, markType.create(attributes));
    tr.setStoredMarks(initialStoredMarks);
    beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
      tr,
      match,
      start: start4,
      end: end3
    });
    return tr;
  });
  return rule;
}
function gatherDetails(_ref) {
  var _updateCaptured, _details$captureGroup, _details$fullMatch, _details$start, _details$end, _captureGroup2, _rule$shouldSkip;
  var captureGroup = _ref.captureGroup, fullMatch = _ref.fullMatch, end3 = _ref.end, start4 = _ref.start, rule = _ref.rule, ignoreWhitespace = _ref.ignoreWhitespace, shouldSkip = _ref.shouldSkip, updateCaptured = _ref.updateCaptured, state = _ref.state, invalidMarks2 = _ref.invalidMarks;
  if (fullMatch == null) {
    return null;
  }
  var details = (_updateCaptured = updateCaptured === null || updateCaptured === void 0 ? void 0 : updateCaptured({
    captureGroup,
    fullMatch,
    start: start4,
    end: end3
  })) !== null && _updateCaptured !== void 0 ? _updateCaptured : {};
  captureGroup = (_details$captureGroup = details.captureGroup) !== null && _details$captureGroup !== void 0 ? _details$captureGroup : captureGroup;
  fullMatch = (_details$fullMatch = details.fullMatch) !== null && _details$fullMatch !== void 0 ? _details$fullMatch : fullMatch;
  start4 = (_details$start = details.start) !== null && _details$start !== void 0 ? _details$start : start4;
  end3 = (_details$end = details.end) !== null && _details$end !== void 0 ? _details$end : end3;
  var $from = state.doc.resolve(start4);
  var $to = state.doc.resolve(end3);
  if (invalidMarks2 && markActiveInRange({
    $from,
    $to
  }, invalidMarks2) || rule.invalidMarks && markActiveInRange({
    $from,
    $to
  }, rule.invalidMarks) || ignoreWhitespace && ((_captureGroup2 = captureGroup) === null || _captureGroup2 === void 0 ? void 0 : _captureGroup2.trim()) === "" || shouldSkip !== null && shouldSkip !== void 0 && shouldSkip({
    state,
    captureGroup,
    fullMatch,
    start: start4,
    end: end3,
    ruleType: "mark"
  }) || (_rule$shouldSkip = rule.shouldSkip) !== null && _rule$shouldSkip !== void 0 && _rule$shouldSkip.call(rule, {
    state,
    captureGroup,
    fullMatch,
    start: start4,
    end: end3,
    ruleType: "mark"
  })) {
    return null;
  }
  return {
    captureGroup,
    end: end3,
    fullMatch,
    start: start4
  };
}
function deleteSelection(state, dispatch2) {
  if (state.selection.empty) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.deleteSelection().scrollIntoView());
  }
  return true;
}
function joinBackward(state, dispatch2, view) {
  var ref2 = state.selection;
  var $cursor = ref2.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
    return false;
  }
  var $cut = findCutBefore($cursor);
  if (!$cut) {
    var range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
    if (target == null) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.lift(range2, target).scrollIntoView());
    }
    return true;
  }
  var before2 = $cut.nodeBefore;
  if (!before2.type.spec.isolating && deleteBarrier(state, $cut, dispatch2)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(before2, "end") || NodeSelection.isSelectable(before2))) {
    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before2, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before2.nodeSize));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (before2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2) {
      dispatch2(state.tr.delete($cut.pos - before2.nodeSize, $cut.pos).scrollIntoView());
    }
    return true;
  }
  return false;
}
function textblockAt(node4, side, only) {
  for (; node4; node4 = side == "start" ? node4.firstChild : node4.lastChild) {
    if (node4.isTextblock) {
      return true;
    }
    if (only && node4.childCount != 1) {
      return false;
    }
  }
  return false;
}
function selectNodeBackward(state, dispatch2, view) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  var empty2 = ref2.empty;
  var $cut = $head;
  if (!empty2) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) {
      return false;
    }
    $cut = findCutBefore($head);
  }
  var node4 = $cut && $cut.nodeBefore;
  if (!node4 || !NodeSelection.isSelectable(node4)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node4.nodeSize)).scrollIntoView());
  }
  return true;
}
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i2 = $pos.depth - 1; i2 >= 0; i2--) {
      if ($pos.index(i2) > 0) {
        return $pos.doc.resolve($pos.before(i2 + 1));
      }
      if ($pos.node(i2).type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function joinForward(state, dispatch2, view) {
  var ref2 = state.selection;
  var $cursor = ref2.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
    return false;
  }
  var $cut = findCutAfter($cursor);
  if (!$cut) {
    return false;
  }
  var after2 = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch2)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(after2, "start") || NodeSelection.isSelectable(after2))) {
    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after2, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2) {
      dispatch2(state.tr.delete($cut.pos, $cut.pos + after2.nodeSize).scrollIntoView());
    }
    return true;
  }
  return false;
}
function selectNodeForward(state, dispatch2, view) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  var empty2 = ref2.empty;
  var $cut = $head;
  if (!empty2) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) {
      return false;
    }
    $cut = findCutAfter($head);
  }
  var node4 = $cut && $cut.nodeAfter;
  if (!node4 || !NodeSelection.isSelectable(node4)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  }
  return true;
}
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i2 = $pos.depth - 1; i2 >= 0; i2--) {
      var parent = $pos.node(i2);
      if ($pos.index(i2) + 1 < parent.childCount) {
        return $pos.doc.resolve($pos.after(i2 + 1));
      }
      if (parent.type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function newlineInCode(state, dispatch2) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  var $anchor = ref2.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.insertText("\n").scrollIntoView());
  }
  return true;
}
function defaultBlockAt(match) {
  for (var i2 = 0; i2 < match.edgeCount; i2++) {
    var ref2 = match.edge(i2);
    var type2 = ref2.type;
    if (type2.isTextblock && !type2.hasRequiredAttrs()) {
      return type2;
    }
  }
  return null;
}
function exitCode(state, dispatch2) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  var $anchor = ref2.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  var above = $head.node(-1), after2 = $head.indexAfter(-1), type2 = defaultBlockAt(above.contentMatchAt(after2));
  if (!above.canReplaceWith(after2, after2, type2)) {
    return false;
  }
  if (dispatch2) {
    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type2.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function createParagraphNear(state, dispatch2) {
  var sel = state.selection;
  var $from = sel.$from;
  var $to = sel.$to;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) {
    return false;
  }
  var type2 = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type2 || !type2.isTextblock) {
    return false;
  }
  if (dispatch2) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type2.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function liftEmptyBlock(state, dispatch2) {
  var ref2 = state.selection;
  var $cursor = ref2.$cursor;
  if (!$cursor || $cursor.parent.content.size) {
    return false;
  }
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before2 = $cursor.before();
    if (canSplit(state.doc, before2)) {
      if (dispatch2) {
        dispatch2(state.tr.split(before2).scrollIntoView());
      }
      return true;
    }
  }
  var range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
  if (target == null) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.lift(range2, target).scrollIntoView());
  }
  return true;
}
function splitBlock(state, dispatch2) {
  var ref2 = state.selection;
  var $from = ref2.$from;
  var $to = ref2.$to;
  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.split($from.pos).scrollIntoView());
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch2) {
    var atEnd2 = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) {
      tr.deleteSelection();
    }
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types = atEnd2 && deflt ? [{ type: deflt }] : null;
    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{ type: deflt }])) {
      types = [{ type: deflt }];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd2 && !$from.parentOffset && $from.parent.type != deflt) {
        var first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function selectParentNode(state, dispatch2) {
  var ref2 = state.selection;
  var $from = ref2.$from;
  var to = ref2.to;
  var pos;
  var same = $from.sharedDepth(to);
  if (same == 0) {
    return false;
  }
  pos = $from.before(same);
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  }
  return true;
}
function selectAll(state, dispatch2) {
  if (dispatch2) {
    dispatch2(state.tr.setSelection(new AllSelection(state.doc)));
  }
  return true;
}
function joinMaybeClear(state, $pos, dispatch2) {
  var before2 = $pos.nodeBefore, after2 = $pos.nodeAfter, index3 = $pos.index();
  if (!before2 || !after2 || !before2.type.compatibleContent(after2.type)) {
    return false;
  }
  if (!before2.content.size && $pos.parent.canReplace(index3 - 1, index3)) {
    if (dispatch2) {
      dispatch2(state.tr.delete($pos.pos - before2.nodeSize, $pos.pos).scrollIntoView());
    }
    return true;
  }
  if (!$pos.parent.canReplace(index3, index3 + 1) || !(after2.isTextblock || canJoin(state.doc, $pos.pos))) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.clearIncompatible($pos.pos, before2.type, before2.contentMatchAt(before2.childCount)).join($pos.pos).scrollIntoView());
  }
  return true;
}
function deleteBarrier(state, $cut, dispatch2) {
  var before2 = $cut.nodeBefore, after2 = $cut.nodeAfter, conn, match;
  if (before2.type.spec.isolating || after2.type.spec.isolating) {
    return false;
  }
  if (joinMaybeClear(state, $cut, dispatch2)) {
    return true;
  }
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before2.contentMatchAt(before2.childCount)).findWrapping(after2.type)) && match.matchType(conn[0] || after2.type).validEnd) {
    if (dispatch2) {
      var end3 = $cut.pos + after2.nodeSize, wrap = Fragment.empty;
      for (var i2 = conn.length - 1; i2 >= 0; i2--) {
        wrap = Fragment.from(conn[i2].create(null, wrap));
      }
      wrap = Fragment.from(before2.copy(wrap));
      var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end3, $cut.pos, end3, new Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end3 + 2 * conn.length;
      if (canJoin(tr.doc, joinAt)) {
        tr.join(joinAt);
      }
      dispatch2(tr.scrollIntoView());
    }
    return true;
  }
  var selAfter = Selection.findFrom($cut, 1);
  var range2 = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range2 && liftTarget(range2);
  if (target != null && target >= $cut.depth) {
    if (dispatch2) {
      dispatch2(state.tr.lift(range2, target).scrollIntoView());
    }
    return true;
  }
  if (canDelAfter && textblockAt(after2, "start", true) && textblockAt(before2, "end")) {
    var at = before2, wrap$1 = [];
    for (; ; ) {
      wrap$1.push(at);
      if (at.isTextblock) {
        break;
      }
      at = at.lastChild;
    }
    var afterText = after2, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild) {
      afterDepth++;
    }
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch2) {
        var end$1 = Fragment.empty;
        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) {
          end$1 = Fragment.from(wrap$1[i$1].copy(end$1));
        }
        var tr$1 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after2.nodeSize, $cut.pos + afterDepth, $cut.pos + after2.nodeSize - afterDepth, new Slice(end$1, wrap$1.length, 0), 0, true));
        dispatch2(tr$1.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch2) {
    var sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    var depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth) {
        return false;
      }
      depth--;
    }
    if (!$pos.node(depth).isTextblock) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    }
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function markApplies$1(doc2, ranges, type2) {
  var loop = function(i3) {
    var ref2 = ranges[i3];
    var $from = ref2.$from;
    var $to = ref2.$to;
    var can = $from.depth == 0 ? doc2.type.allowsMarkType(type2) : false;
    doc2.nodesBetween($from.pos, $to.pos, function(node4) {
      if (can) {
        return false;
      }
      can = node4.inlineContent && node4.type.allowsMarkType(type2);
    });
    if (can) {
      return { v: true };
    }
  };
  for (var i2 = 0; i2 < ranges.length; i2++) {
    var returned = loop(i2);
    if (returned)
      return returned.v;
  }
  return false;
}
function toggleMark$1(markType, attrs) {
  return function(state, dispatch2) {
    var ref2 = state.selection;
    var empty2 = ref2.empty;
    var $cursor = ref2.$cursor;
    var ranges = ref2.ranges;
    if (empty2 && !$cursor || !markApplies$1(state.doc, ranges, markType)) {
      return false;
    }
    if (dispatch2) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks())) {
          dispatch2(state.tr.removeStoredMark(markType));
        } else {
          dispatch2(state.tr.addStoredMark(markType.create(attrs)));
        }
      } else {
        var has = false, tr = state.tr;
        for (var i2 = 0; !has && i2 < ranges.length; i2++) {
          var ref$1 = ranges[i2];
          var $from = ref$1.$from;
          var $to = ref$1.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }
        for (var i$1 = 0; i$1 < ranges.length; i$1++) {
          var ref$2 = ranges[i$1];
          var $from$1 = ref$2.$from;
          var $to$1 = ref$2.$to;
          if (has) {
            tr.removeMark($from$1.pos, $to$1.pos, markType);
          } else {
            var from4 = $from$1.pos, to = $to$1.pos, start4 = $from$1.nodeAfter, end3 = $to$1.nodeBefore;
            var spaceStart = start4 && start4.isText ? /^\s*/.exec(start4.text)[0].length : 0;
            var spaceEnd = end3 && end3.isText ? /\s*$/.exec(end3.text)[0].length : 0;
            if (from4 + spaceStart < to) {
              from4 += spaceStart;
              to -= spaceEnd;
            }
            tr.addMark(from4, to, markType.create(attrs));
          }
        }
        dispatch2(tr.scrollIntoView());
      }
    }
    return true;
  };
}
function chainCommands() {
  var commands = [], len = arguments.length;
  while (len--)
    commands[len] = arguments[len];
  return function(state, dispatch2, view) {
    for (var i2 = 0; i2 < commands.length; i2++) {
      if (commands[i2](state, dispatch2, view)) {
        return true;
      }
    }
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (var key$2 in pcBaseKeymap) {
  macBaseKeymap[key$2] = pcBaseKeymap[key$2];
}
pcBaseKeymap.Home = selectTextblockStart;
pcBaseKeymap.End = selectTextblockEnd;
var mac$2 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" ? os.platform() == "darwin" : false;
var baseKeymap = mac$2 ? macBaseKeymap : pcBaseKeymap;
let createNanoEvents = () => ({
  events: {},
  emit(event, ...args) {
    (this.events[event] || []).forEach((i2) => i2(...args));
  },
  on(event, cb) {
    (this.events[event] = this.events[event] || []).push(cb);
    return () => this.events[event] = (this.events[event] || []).filter((i2) => i2 !== cb);
  }
});
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context2) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context2 && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context2) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac$1 || +chrome[1] < 57) || gecko && mac$1;
for (var i$1 = 0; i$1 < 10; i$1++)
  base[48 + i$1] = base[96 + i$1] = String(i$1);
for (var i$1 = 1; i$1 <= 24; i$1++)
  base[i$1 + 111] = "F" + i$1;
for (var i$1 = 65; i$1 <= 90; i$1++) {
  base[i$1] = String.fromCharCode(i$1 + 32);
  shift[i$1] = String.fromCharCode(i$1);
}
for (var code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}
var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
  if (result2 == "Space") {
    result2 = " ";
  }
  var alt, ctrl, shift2, meta;
  for (var i2 = 0; i2 < parts.length - 1; i2++) {
    var mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (mac) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error("Unrecognized modifier name: " + mod);
    }
  }
  if (alt) {
    result2 = "Alt-" + result2;
  }
  if (ctrl) {
    result2 = "Ctrl-" + result2;
  }
  if (meta) {
    result2 = "Meta-" + result2;
  }
  if (shift2) {
    result2 = "Shift-" + result2;
  }
  return result2;
}
function normalize(map16) {
  var copy5 = /* @__PURE__ */ Object.create(null);
  for (var prop in map16) {
    copy5[normalizeKeyName(prop)] = map16[prop];
  }
  return copy5;
}
function modifiers(name, event, shift2) {
  if (event.altKey) {
    name = "Alt-" + name;
  }
  if (event.ctrlKey) {
    name = "Ctrl-" + name;
  }
  if (event.metaKey) {
    name = "Meta-" + name;
  }
  if (shift2 !== false && event.shiftKey) {
    name = "Shift-" + name;
  }
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  var map16 = normalize(bindings);
  return function(view, event) {
    var name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map16[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) {
      return true;
    }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
      var fromCode = map16[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) {
        return true;
      }
    } else if (isChar && event.shiftKey) {
      var withShift = map16[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) {
        return true;
      }
    }
    return false;
  };
}
function pasteRules(pasteRules2) {
  var sortedPasteRules = sort(pasteRules2, (a2, z2) => {
    var _z$priority, _a$priority;
    return ((_z$priority = z2.priority) !== null && _z$priority !== void 0 ? _z$priority : ExtensionPriority.Low) - ((_a$priority = a2.priority) !== null && _a$priority !== void 0 ? _a$priority : ExtensionPriority.Low);
  });
  var regexPasteRules2 = [];
  var filePasteRules = [];
  var _iterator = _createForOfIteratorHelper(sortedPasteRules), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var rule = _step.value;
      if (isRegexPastRule(rule)) {
        regexPasteRules2.push(rule);
      } else {
        filePasteRules.push(rule);
      }
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  var _view2;
  return new Plugin({
    key: pastePluginKey,
    view: (editorView) => {
      _view2 = editorView;
      return {};
    },
    props: {
      transformPasted: (slice5) => {
        var $pos = _view2.state.selection.$from;
        var nodeName = $pos.node().type.name;
        var markNames = new Set($pos.marks().map((mark3) => mark3.type.name));
        var _iterator2 = _createForOfIteratorHelper(regexPasteRules2), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _rule$ignoredNodes, _rule$ignoredMarks, _slice$content$firstC, _slice$content$firstC2;
            var rule2 = _step2.value;
            if ((_rule$ignoredNodes = rule2.ignoredNodes) !== null && _rule$ignoredNodes !== void 0 && _rule$ignoredNodes.includes(nodeName) || (_rule$ignoredMarks = rule2.ignoredMarks) !== null && _rule$ignoredMarks !== void 0 && _rule$ignoredMarks.some((ignored) => markNames.has(ignored))) {
              continue;
            }
            var textContent = (_slice$content$firstC = (_slice$content$firstC2 = slice5.content.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.textContent) !== null && _slice$content$firstC !== void 0 ? _slice$content$firstC : "";
            var canBeReplaced = !_view2.state.selection.empty && slice5.content.childCount === 1 && textContent;
            var _match = findMatches(textContent, rule2.regexp)[0];
            if (canBeReplaced && _match && rule2.type === "mark" && rule2.replaceSelection) {
              var _view$state$selection = _view2.state.selection, from4 = _view$state$selection.from, to = _view$state$selection.to;
              var textSlice = _view2.state.doc.slice(from4, to);
              var _textContent = textSlice.content.textBetween(0, textSlice.content.size);
              if (typeof rule2.replaceSelection !== "boolean" ? rule2.replaceSelection(_textContent) : rule2.replaceSelection) {
                var _ret = function() {
                  var newTextNodes = [];
                  var getAttributes = rule2.getAttributes, markType = rule2.markType;
                  var attributes = isFunction$1(getAttributes) ? getAttributes(_match, true) : getAttributes;
                  var mark3 = markType.create(attributes);
                  textSlice.content.forEach((textNode) => {
                    if (textNode.isText) {
                      var marks2 = mark3.addToSet(textNode.marks);
                      newTextNodes.push(textNode.mark(marks2));
                    }
                  });
                  return {
                    v: Slice.maxOpen(Fragment.fromArray(newTextNodes))
                  };
                }();
                if (typeof _ret === "object")
                  return _ret.v;
              }
            }
            slice5 = new Slice(regexPasteRuleHandler(slice5.content, rule2, _view2.state.schema), slice5.openStart, slice5.openEnd);
          }
        } catch (err2) {
          _iterator2.e(err2);
        } finally {
          _iterator2.f();
        }
        return slice5;
      },
      handleDOMEvents: {
        paste: (view, event) => {
          var _view$props$editable, _view$props;
          if (!((_view$props$editable = (_view$props = view.props).editable) !== null && _view$props$editable !== void 0 && _view$props$editable.call(_view$props, view.state))) {
            return false;
          }
          var clipboardData = event.clipboardData;
          if (!clipboardData) {
            return false;
          }
          var allFiles = [...clipboardData.items].map((data) => data.getAsFile()).filter((file) => !!file);
          if (allFiles.length === 0) {
            return false;
          }
          var selection = view.state.selection;
          var _iterator3 = _createForOfIteratorHelper(filePasteRules), _step3;
          try {
            var _loop = function _loop2() {
              var _step3$value = _step3.value, fileHandler = _step3$value.fileHandler, regexp = _step3$value.regexp;
              var files = regexp ? allFiles.filter((file) => regexp.test(file.type)) : allFiles;
              if (files.length === 0) {
                return "continue";
              }
              if (fileHandler({
                event,
                files,
                selection,
                view,
                type: "paste"
              })) {
                event.preventDefault();
                return {
                  v: true
                };
              }
            };
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var _ret2 = _loop();
              if (_ret2 === "continue")
                continue;
              if (typeof _ret2 === "object")
                return _ret2.v;
            }
          } catch (err2) {
            _iterator3.e(err2);
          } finally {
            _iterator3.f();
          }
          return false;
        },
        drop: (view, event) => {
          var _view$props$editable2, _view$props2, _view$posAtCoords$pos, _view$posAtCoords;
          if (!((_view$props$editable2 = (_view$props2 = view.props).editable) !== null && _view$props$editable2 !== void 0 && _view$props$editable2.call(_view$props2, view.state))) {
            return false;
          }
          var dataTransfer = event.dataTransfer, clientX = event.clientX, clientY = event.clientY;
          if (!dataTransfer) {
            return false;
          }
          var allFiles = getDataTransferFiles(event);
          if (allFiles.length === 0) {
            return false;
          }
          var pos = (_view$posAtCoords$pos = (_view$posAtCoords = view.posAtCoords({
            left: clientX,
            top: clientY
          })) === null || _view$posAtCoords === void 0 ? void 0 : _view$posAtCoords.pos) !== null && _view$posAtCoords$pos !== void 0 ? _view$posAtCoords$pos : view.state.selection.anchor;
          var _iterator4 = _createForOfIteratorHelper(filePasteRules), _step4;
          try {
            var _loop2 = function _loop22() {
              var _step4$value = _step4.value, fileHandler = _step4$value.fileHandler, regexp = _step4$value.regexp;
              var files = regexp ? allFiles.filter((file) => regexp.test(file.type)) : allFiles;
              if (files.length === 0) {
                return "continue";
              }
              if (fileHandler({
                event,
                files,
                pos,
                view,
                type: "drop"
              })) {
                event.preventDefault();
                return {
                  v: true
                };
              }
            };
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var _ret3 = _loop2();
              if (_ret3 === "continue")
                continue;
              if (typeof _ret3 === "object")
                return _ret3.v;
            }
          } catch (err2) {
            _iterator4.e(err2);
          } finally {
            _iterator4.f();
          }
          return false;
        }
      }
    }
  });
}
var pastePluginKey = new PluginKey("pasteRule");
function createPasteRuleHandler(transformer, schema) {
  return function handler(props) {
    var fragment = props.fragment, rule = props.rule, nodes = props.nodes;
    var regexp = rule.regexp, ignoreWhitespace = rule.ignoreWhitespace, ignoredMarks = rule.ignoredMarks, ignoredNodes = rule.ignoredNodes;
    fragment.forEach((child3) => {
      var _child$text;
      if (ignoredNodes !== null && ignoredNodes !== void 0 && ignoredNodes.includes(child3.type.name) || isCodeNode(child3)) {
        nodes.push(child3);
        return;
      }
      if (!child3.isText) {
        nodes.push(child3.copy(handler({
          fragment: child3.content,
          rule,
          nodes: []
        })));
        return;
      }
      if (child3.marks.some((mark3) => isCodeMark(mark3) || (ignoredMarks === null || ignoredMarks === void 0 ? void 0 : ignoredMarks.includes(mark3.type.name)))) {
        nodes.push(child3);
        return;
      }
      var text3 = (_child$text = child3.text) !== null && _child$text !== void 0 ? _child$text : "";
      var pos = 0;
      var _iterator5 = _createForOfIteratorHelper(findMatches(text3, regexp)), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var _match2 = _step5.value;
          var capturedValue = _match2[1];
          var fullValue = _match2[0];
          if (ignoreWhitespace && (capturedValue === null || capturedValue === void 0 ? void 0 : capturedValue.trim()) === "" || !fullValue) {
            return;
          }
          var start4 = _match2.index;
          var end3 = start4 + fullValue.length;
          if (start4 > 0) {
            nodes.push(child3.cut(pos, start4));
          }
          var textNode = child3.cut(start4, end3);
          if (fullValue && capturedValue) {
            var startSpaces = fullValue.search(/\S/);
            var textStart = start4 + fullValue.indexOf(capturedValue);
            var textEnd = textStart + capturedValue.length;
            if (startSpaces) {
              nodes.push(child3.cut(start4, start4 + startSpaces));
            }
            textNode = child3.cut(textStart, textEnd);
          }
          transformer({
            nodes,
            rule,
            textNode,
            match: _match2,
            schema
          });
          pos = end3;
        }
      } catch (err2) {
        _iterator5.e(err2);
      } finally {
        _iterator5.f();
      }
      if (text3 && pos < text3.length) {
        nodes.push(child3.cut(pos));
      }
    });
    return Fragment.fromArray(nodes);
  };
}
function markRuleTransformer(props) {
  var _ref;
  var nodes = props.nodes, rule = props.rule, textNode = props.textNode, match = props.match, schema = props.schema;
  var transformMatch = rule.transformMatch, getAttributes = rule.getAttributes, markType = rule.markType;
  var attributes = isFunction$1(getAttributes) ? getAttributes(match, false) : getAttributes;
  var transformedCapturedValue = transformMatch === null || transformMatch === void 0 ? void 0 : transformMatch(match);
  if (transformedCapturedValue === "") {
    return;
  }
  var text3 = (_ref = transformedCapturedValue !== null && transformedCapturedValue !== void 0 ? transformedCapturedValue : textNode.text) !== null && _ref !== void 0 ? _ref : "";
  var mark3 = markType.create(attributes);
  var marks2 = mark3.addToSet(textNode.marks);
  nodes.push(schema.text(text3, marks2));
}
function textRuleTransformer(props) {
  var _ref2;
  var nodes = props.nodes, rule = props.rule, textNode = props.textNode, match = props.match, schema = props.schema;
  var transformMatch = rule.transformMatch;
  var transformedCapturedValue = transformMatch === null || transformMatch === void 0 ? void 0 : transformMatch(match);
  if (transformedCapturedValue === "") {
    return;
  }
  var text3 = (_ref2 = transformedCapturedValue !== null && transformedCapturedValue !== void 0 ? transformedCapturedValue : textNode.text) !== null && _ref2 !== void 0 ? _ref2 : "";
  nodes.push(schema.text(text3, textNode.marks));
}
function nodeRuleTransformer(props) {
  var nodes = props.nodes, rule = props.rule, textNode = props.textNode, match = props.match;
  var getAttributes = rule.getAttributes, nodeType2 = rule.nodeType, getContent = rule.getContent;
  var attributes = isFunction$1(getAttributes) ? getAttributes(match, false) : getAttributes;
  var content2 = (getContent ? getContent(match) : textNode) || void 0;
  nodes.push(nodeType2.createChecked(attributes, content2));
}
function regexPasteRuleHandler(fragment, rule, schema) {
  var nodes = [];
  switch (rule.type) {
    case "mark":
      return createPasteRuleHandler(markRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });
    case "node":
      return createPasteRuleHandler(nodeRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });
    default:
      return createPasteRuleHandler(textRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });
  }
}
var regexPasteRules = ["mark", "node", "text"];
function isRegexPastRule(rule) {
  return includes(regexPasteRules, rule.type);
}
function isCodeNode(node4) {
  var _node$type$spec$group;
  return node4.type.spec.code || ((_node$type$spec$group = node4.type.spec.group) === null || _node$type$spec$group === void 0 ? void 0 : _node$type$spec$group.split(" ").includes("code"));
}
function isCodeMark(mark3) {
  var _mark$type$spec$group;
  return mark3.type.name === "code" || ((_mark$type$spec$group = mark3.type.spec.group) === null || _mark$type$spec$group === void 0 ? void 0 : _mark$type$spec$group.split(" ").includes("code"));
}
function getDataTransferFiles(event) {
  var _dataTransfer$files, _dataTransfer$items;
  var dataTransfer = event.dataTransfer;
  if (!dataTransfer) {
    return [];
  }
  if (((_dataTransfer$files = dataTransfer.files) === null || _dataTransfer$files === void 0 ? void 0 : _dataTransfer$files.length) > 0) {
    return [...dataTransfer.files];
  }
  if ((_dataTransfer$items = dataTransfer.items) !== null && _dataTransfer$items !== void 0 && _dataTransfer$items.length) {
    return [...dataTransfer.items].map((item) => item.getAsFile()).filter((item) => !!item);
  }
  return [];
}
function defaultEquals(valueA, valueB) {
  return valueA === valueB;
}
function getChangedOptions(props) {
  var previousOptions = props.previousOptions, update2 = props.update, _props$equals = props.equals, equals = _props$equals === void 0 ? defaultEquals : _props$equals;
  var next = freeze(_objectSpread2$3(_objectSpread2$3({}, previousOptions), update2));
  var changes = object();
  var optionKeys = keys$1(previousOptions);
  var _iterator = _createForOfIteratorHelper(optionKeys), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var key = _step.value;
      var previousValue = previousOptions[key];
      var value = next[key];
      if (equals(previousValue, value)) {
        changes[key] = {
          changed: false
        };
        continue;
      }
      changes[key] = {
        changed: true,
        previousValue,
        value
      };
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  var pickChanged = (keys2) => {
    var picked = object();
    var _iterator2 = _createForOfIteratorHelper(keys2), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var key2 = _step2.value;
        var item = changes[key2];
        if (item !== null && item !== void 0 && item.changed) {
          picked[key2] = item.value;
        }
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
    return picked;
  };
  return {
    changes: freeze(changes),
    options: next,
    pickChanged
  };
}
var codeLabelMap = {
  [ErrorConstant.DUPLICATE_HELPER_NAMES]: "helper method",
  [ErrorConstant.DUPLICATE_COMMAND_NAMES]: "command method"
};
function throwIfNameNotUnique(props) {
  var name = props.name, set2 = props.set, code = props.code;
  var label = codeLabelMap[code];
  !!set2.has(name) ? invariant(false, {
    code,
    message: "There is a naming conflict for the name: ".concat(name, " used in this '").concat(label, "'. Please rename or remove from the editor to avoid runtime errors.")
  }) : void 0;
  set2.add(name);
}
var IGNORE = "__IGNORE__";
var GENERAL_OPTIONS = "__ALL__";
class BaseClass {
  get options() {
    return this._options;
  }
  get dynamicKeys() {
    return this._dynamicKeys;
  }
  get initialOptions() {
    return this._initialOptions;
  }
  constructor(defaultOptions2) {
    for (var _len = arguments.length, _ref = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      _ref[_key - 1] = arguments[_key];
    }
    var options = _ref[0];
    this._mappedHandlers = object();
    this.populateMappedHandlers();
    this._options = this._initialOptions = deepMerge(defaultOptions2, this.constructor.defaultOptions, options !== null && options !== void 0 ? options : object(), this.createDefaultHandlerOptions());
    this._dynamicKeys = this.getDynamicKeys();
    this.init();
  }
  init() {
  }
  getDynamicKeys() {
    var dynamicKeys = [];
    var _this$constructor = this.constructor, customHandlerKeys = _this$constructor.customHandlerKeys, handlerKeys = _this$constructor.handlerKeys, staticKeys = _this$constructor.staticKeys;
    var _iterator = _createForOfIteratorHelper(keys$1(this._options)), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _key2 = _step.value;
        if (staticKeys.includes(_key2) || handlerKeys.includes(_key2) || customHandlerKeys.includes(_key2)) {
          continue;
        }
        dynamicKeys.push(_key2);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    return dynamicKeys;
  }
  ensureAllKeysAreDynamic(update2) {
    var invalid = [];
    var _iterator2 = _createForOfIteratorHelper(keys$1(update2)), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _key3 = _step2.value;
        if (this._dynamicKeys.includes(_key3)) {
          continue;
        }
        invalid.push(_key3);
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
    !isEmptyArray(invalid) ? invariant(false, {
      code: ErrorConstant.INVALID_SET_EXTENSION_OPTIONS,
      message: "Invalid properties passed into the 'setOptions()' method: ".concat(JSON.stringify(invalid), ".")
    }) : void 0;
  }
  setOptions(update2) {
    var _this$onSetOptions;
    var previousOptions = this.getDynamicOptions();
    this.ensureAllKeysAreDynamic(update2);
    var _getChangedOptions = getChangedOptions({
      previousOptions,
      update: update2
    }), changes = _getChangedOptions.changes, options = _getChangedOptions.options, pickChanged = _getChangedOptions.pickChanged;
    this.updateDynamicOptions(options);
    (_this$onSetOptions = this.onSetOptions) === null || _this$onSetOptions === void 0 ? void 0 : _this$onSetOptions.call(this, {
      reason: "set",
      changes,
      options,
      pickChanged,
      initialOptions: this._initialOptions
    });
  }
  resetOptions() {
    var _this$onSetOptions2;
    var previousOptions = this.getDynamicOptions();
    var _getChangedOptions2 = getChangedOptions({
      previousOptions,
      update: this._initialOptions
    }), changes = _getChangedOptions2.changes, options = _getChangedOptions2.options, pickChanged = _getChangedOptions2.pickChanged;
    this.updateDynamicOptions(options);
    (_this$onSetOptions2 = this.onSetOptions) === null || _this$onSetOptions2 === void 0 ? void 0 : _this$onSetOptions2.call(this, {
      reason: "reset",
      options,
      changes,
      pickChanged,
      initialOptions: this._initialOptions
    });
  }
  getDynamicOptions() {
    return omit2(this._options, [...this.constructor.customHandlerKeys, ...this.constructor.handlerKeys]);
  }
  updateDynamicOptions(options) {
    this._options = _objectSpread2$3(_objectSpread2$3({}, this._options), options);
  }
  populateMappedHandlers() {
    var _iterator3 = _createForOfIteratorHelper(this.constructor.handlerKeys), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var _key4 = _step3.value;
        this._mappedHandlers[_key4] = [];
      }
    } catch (err2) {
      _iterator3.e(err2);
    } finally {
      _iterator3.f();
    }
  }
  createDefaultHandlerOptions() {
    var _this = this;
    var methods = object();
    var _iterator4 = _createForOfIteratorHelper(this.constructor.handlerKeys), _step4;
    try {
      var _loop = function _loop2() {
        var key = _step4.value;
        methods[key] = function() {
          var _handlerKeyOptions$ke;
          var handlerKeyOptions = _this.constructor.handlerKeyOptions;
          var reducer2 = (_handlerKeyOptions$ke = handlerKeyOptions[key]) === null || _handlerKeyOptions$ke === void 0 ? void 0 : _handlerKeyOptions$ke.reducer;
          for (var _len2 = arguments.length, args = new Array(_len2), _key5 = 0; _key5 < _len2; _key5++) {
            args[_key5] = arguments[_key5];
          }
          var returnValue = reducer2 === null || reducer2 === void 0 ? void 0 : reducer2.getDefault(...args);
          var _iterator5 = _createForOfIteratorHelper(_this._mappedHandlers[key]), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var _step5$value = _slicedToArray(_step5.value, 2), handler = _step5$value[1];
              var _value = handler(...args);
              returnValue = reducer2 ? reducer2.accumulator(returnValue, _value, ...args) : _value;
              if (shouldReturnEarly(handlerKeyOptions, returnValue, key)) {
                return returnValue;
              }
            }
          } catch (err2) {
            _iterator5.e(err2);
          } finally {
            _iterator5.f();
          }
          return returnValue;
        };
      };
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
        _loop();
      }
    } catch (err2) {
      _iterator4.e(err2);
    } finally {
      _iterator4.f();
    }
    return methods;
  }
  addHandler(key, method) {
    var priority = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ExtensionPriority.Default;
    this._mappedHandlers[key].push([priority, method]);
    this.sortHandlers(key);
    return () => this._mappedHandlers[key] = this._mappedHandlers[key].filter((_ref2) => {
      var _ref3 = _slicedToArray(_ref2, 2), handler = _ref3[1];
      return handler !== method;
    });
  }
  hasHandlers(key) {
    var _this$_mappedHandlers;
    return ((_this$_mappedHandlers = this._mappedHandlers[key]) !== null && _this$_mappedHandlers !== void 0 ? _this$_mappedHandlers : []).length > 0;
  }
  sortHandlers(key) {
    this._mappedHandlers[key] = sort(this._mappedHandlers[key], (_ref4, _ref5) => {
      var _ref6 = _slicedToArray(_ref4, 1), a2 = _ref6[0];
      var _ref7 = _slicedToArray(_ref5, 1), z2 = _ref7[0];
      return z2 - a2;
    });
  }
  addCustomHandler(key, value) {
    var _this$onAddCustomHand, _this$onAddCustomHand2;
    return (_this$onAddCustomHand = (_this$onAddCustomHand2 = this.onAddCustomHandler) === null || _this$onAddCustomHand2 === void 0 ? void 0 : _this$onAddCustomHand2.call(this, {
      [key]: value
    })) !== null && _this$onAddCustomHand !== void 0 ? _this$onAddCustomHand : noop$1;
  }
}
_defineProperty$3(BaseClass, "defaultOptions", {});
_defineProperty$3(BaseClass, "staticKeys", []);
_defineProperty$3(BaseClass, "handlerKeys", []);
_defineProperty$3(BaseClass, "handlerKeyOptions", {});
_defineProperty$3(BaseClass, "customHandlerKeys", []);
function shouldReturnEarly(handlerKeyOptions, returnValue, handlerKey) {
  var generalOptions = handlerKeyOptions[GENERAL_OPTIONS];
  var handlerOptions = handlerKeyOptions[handlerKey];
  if (!generalOptions && !handlerOptions) {
    return false;
  }
  if (handlerOptions && handlerOptions.earlyReturnValue !== IGNORE && (isFunction$1(handlerOptions.earlyReturnValue) ? handlerOptions.earlyReturnValue(returnValue) === true : returnValue === handlerOptions.earlyReturnValue)) {
    return true;
  }
  if (generalOptions && generalOptions.earlyReturnValue !== IGNORE && (isFunction$1(generalOptions.earlyReturnValue) ? generalOptions.earlyReturnValue(returnValue) === true : returnValue === generalOptions.earlyReturnValue)) {
    return true;
  }
  return false;
}
class Extension extends BaseClass {
  get priority() {
    var _ref, _this$priorityOverrid;
    return (_ref = (_this$priorityOverrid = this.priorityOverride) !== null && _this$priorityOverrid !== void 0 ? _this$priorityOverrid : this.options.priority) !== null && _ref !== void 0 ? _ref : this.constructor.defaultPriority;
  }
  get constructorName() {
    return "".concat(pascalCase(this.name), "Extension");
  }
  get store() {
    !this._store ? invariant(false, {
      code: ErrorConstant.MANAGER_PHASE_ERROR,
      message: "An error occurred while attempting to access the 'extension.store' when the Manager has not yet set created the lifecycle methods."
    }) : void 0;
    return freeze(this._store, {
      requireKeys: true
    });
  }
  get extensions() {
    return this._extensions;
  }
  constructor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    super(defaultOptions$1, ...args);
    this._extensions = uniqueBy$1(this.createExtensions(), (extension3) => extension3.constructor);
    this.extensionMap = /* @__PURE__ */ new Map();
    var _iterator = _createForOfIteratorHelper(this._extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var extension2 = _step.value;
        this.extensionMap.set(extension2.constructor, extension2);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
  }
  replaceChildExtension(constructor, extension2) {
    if (!this.extensionMap.has(constructor)) {
      return;
    }
    this.extensionMap.set(constructor, extension2);
    this._extensions = this.extensions.map((currentExtension) => extension2.constructor === constructor ? extension2 : currentExtension);
  }
  createExtensions() {
    return [];
  }
  getExtension(Constructor) {
    var extension2 = this.extensionMap.get(Constructor);
    !extension2 ? invariant(false, {
      code: ErrorConstant.INVALID_GET_EXTENSION,
      message: "'".concat(Constructor.name, "' does not exist within the preset: '").concat(this.name, "'")
    }) : void 0;
    return extension2;
  }
  isOfType(Constructor) {
    return this.constructor === Constructor;
  }
  setStore(store2) {
    if (this._store) {
      return;
    }
    this._store = store2;
  }
  clone() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return new this.constructor(...args);
  }
  setPriority(priority) {
    this.priorityOverride = priority;
  }
}
_defineProperty$3(Extension, "defaultPriority", ExtensionPriority.Default);
class PlainExtension extends Extension {
  static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.PlainExtensionConstructor;
  }
  get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.PlainExtension;
  }
}
class MarkExtension extends Extension {
  static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.MarkExtensionConstructor;
  }
  get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.MarkExtension;
  }
  get type() {
    return assertGet(this.store.schema.marks, this.name);
  }
  constructor() {
    super(...arguments);
  }
}
_defineProperty$3(MarkExtension, "disableExtraAttributes", false);
class NodeExtension extends Extension {
  static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.NodeExtensionConstructor;
  }
  get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.NodeExtension;
  }
  get type() {
    return assertGet(this.store.schema.nodes, this.name);
  }
  constructor() {
    super(...arguments);
  }
}
_defineProperty$3(NodeExtension, "disableExtraAttributes", false);
var defaultOptions$1 = {
  priority: void 0,
  extraAttributes: {},
  disableExtraAttributes: false,
  exclude: {}
};
function isExtension(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, [RemirrorIdentifier.PlainExtension, RemirrorIdentifier.MarkExtension, RemirrorIdentifier.NodeExtension]);
}
function isExtensionConstructor(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, [RemirrorIdentifier.PlainExtensionConstructor, RemirrorIdentifier.MarkExtensionConstructor, RemirrorIdentifier.NodeExtensionConstructor]);
}
function isPlainExtension(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, RemirrorIdentifier.PlainExtension);
}
function isNodeExtension(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, RemirrorIdentifier.NodeExtension);
}
function isMarkExtension(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, RemirrorIdentifier.MarkExtension);
}
var _excluded$2$2 = ["defaultOptions", "customHandlerKeys", "handlerKeys", "staticKeys", "defaultPriority", "handlerKeyOptions"];
function extension(options) {
  return (ReadonlyConstructor) => {
    var _ref, _ref2, _ref3;
    var defaultOptions2 = options.defaultOptions, customHandlerKeys = options.customHandlerKeys, handlerKeys = options.handlerKeys, staticKeys = options.staticKeys, defaultPriority = options.defaultPriority, handlerKeyOptions = options.handlerKeyOptions, rest = _objectWithoutProperties(options, _excluded$2$2);
    var Constructor = Cast(ReadonlyConstructor);
    if (defaultOptions2) {
      Constructor.defaultOptions = defaultOptions2;
    }
    if (defaultPriority) {
      Constructor.defaultPriority = defaultPriority;
    }
    if (handlerKeyOptions) {
      Constructor.handlerKeyOptions = handlerKeyOptions;
    }
    Constructor.staticKeys = (_ref = staticKeys) !== null && _ref !== void 0 ? _ref : [];
    Constructor.handlerKeys = (_ref2 = handlerKeys) !== null && _ref2 !== void 0 ? _ref2 : [];
    Constructor.customHandlerKeys = (_ref3 = customHandlerKeys) !== null && _ref3 !== void 0 ? _ref3 : [];
    for (var _i = 0, _Object$entries = Object.entries(rest); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
      if (Constructor[key]) {
        continue;
      }
      Constructor[key] = value;
    }
    return Cast(Constructor);
  };
}
class AttributesExtension extends PlainExtension {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty$3(this, "attributeList", []);
    _defineProperty$3(this, "attributeObject", object());
    _defineProperty$3(this, "updateAttributes", function() {
      var triggerUpdate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      _this.transformAttributes();
      if (triggerUpdate) {
        _this.store.commands.forceUpdate("attributes");
      }
    });
  }
  get name() {
    return "attributes";
  }
  onCreate() {
    this.transformAttributes();
    this.store.setExtensionStore("updateAttributes", this.updateAttributes);
  }
  transformAttributes() {
    var _this$store$managerSe;
    this.attributeObject = object();
    if ((_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.attributes) {
      this.store.setStoreKey("attributes", this.attributeObject);
      return;
    }
    this.attributeList = [];
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _extension$options$ex, _extension$createAttr, _extension$classNames;
        var extension2 = _step.value;
        if ((_extension$options$ex = extension2.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.attributes) {
          continue;
        }
        var createdAttributes = (_extension$createAttr = extension2.createAttributes) === null || _extension$createAttr === void 0 ? void 0 : _extension$createAttr.call(extension2);
        var attributes = _objectSpread2$3(_objectSpread2$3({}, createdAttributes), {}, {
          class: cx2(...(_extension$classNames = extension2.classNames) !== null && _extension$classNames !== void 0 ? _extension$classNames : [], createdAttributes === null || createdAttributes === void 0 ? void 0 : createdAttributes.class)
        });
        this.attributeList.unshift(attributes);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper(this.attributeList), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _attributes = _step2.value;
        this.attributeObject = _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, this.attributeObject), _attributes), {}, {
          class: cx2(this.attributeObject.class, _attributes.class)
        });
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
    this.store.setStoreKey("attributes", this.attributeObject);
  }
}
function helper() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedHelp;
    ((_target$decoratedHelp = target.decoratedHelpers) !== null && _target$decoratedHelp !== void 0 ? _target$decoratedHelp : target.decoratedHelpers = {})[propertyKey] = options;
  };
}
function command() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedComm;
    ((_target$decoratedComm = target.decoratedCommands) !== null && _target$decoratedComm !== void 0 ? _target$decoratedComm : target.decoratedCommands = {})[propertyKey] = options;
  };
}
function keyBinding(options) {
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedKeyb;
    ((_target$decoratedKeyb = target.decoratedKeybindings) !== null && _target$decoratedKeyb !== void 0 ? _target$decoratedKeyb : target.decoratedKeybindings = {})[propertyKey] = options;
  };
}
class DelayedCommand {
  constructor(promiseCreator) {
    _defineProperty$3(this, "failureHandlers", []);
    _defineProperty$3(this, "successHandlers", []);
    _defineProperty$3(this, "validateHandlers", []);
    _defineProperty$3(this, "generateCommand", () => {
      return (props) => {
        var isValid = true;
        var view = props.view, tr = props.tr, dispatch2 = props.dispatch;
        if (!view) {
          return false;
        }
        var _iterator = _createForOfIteratorHelper(this.validateHandlers), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var handler = _step.value;
            if (!handler(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
              dispatch: () => {
              }
            }))) {
              isValid = false;
              break;
            }
          }
        } catch (err2) {
          _iterator.e(err2);
        } finally {
          _iterator.f();
        }
        if (!dispatch2 || !isValid) {
          return isValid;
        }
        var deferred = this.promiseCreator(props);
        deferred.then((value) => {
          this.runHandlers(this.successHandlers, {
            value,
            state: view.state,
            tr: view.state.tr,
            dispatch: view.dispatch,
            view
          });
        }).catch((error) => {
          this.runHandlers(this.failureHandlers, {
            error,
            state: view.state,
            tr: view.state.tr,
            dispatch: view.dispatch,
            view
          });
        });
        dispatch2(tr);
        return true;
      };
    });
    this.promiseCreator = promiseCreator;
  }
  validate(handler) {
    var method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "push";
    this.validateHandlers[method](handler);
    return this;
  }
  success(handler) {
    var method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "push";
    this.successHandlers[method](handler);
    return this;
  }
  failure(handler) {
    var method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "push";
    this.failureHandlers[method](handler);
    return this;
  }
  runHandlers(handlers2, param) {
    var _param$dispatch;
    var _iterator2 = _createForOfIteratorHelper(handlers2), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var handler = _step2.value;
        if (!handler(_objectSpread2$3(_objectSpread2$3({}, param), {}, {
          dispatch: () => {
          }
        }))) {
          break;
        }
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
    (_param$dispatch = param.dispatch) === null || _param$dispatch === void 0 ? void 0 : _param$dispatch.call(param, param.tr);
  }
}
function toggleMark(props) {
  var type2 = props.type, attrs = props.attrs, range2 = props.range, selection = props.selection;
  return (props2) => {
    var dispatch2 = props2.dispatch, tr = props2.tr, state = props2.state;
    var markType = isString$1(type2) ? state.schema.marks[type2] : type2;
    !markType ? invariant(false, {
      code: ErrorConstant.SCHEMA,
      message: "Mark type: ".concat(type2, " does not exist on the current schema.")
    }) : void 0;
    if (range2 || selection) {
      var _ref2;
      var _getTextSelection = getTextSelection((_ref2 = selection !== null && selection !== void 0 ? selection : range2) !== null && _ref2 !== void 0 ? _ref2 : tr.selection, tr.doc), from4 = _getTextSelection.from, to = _getTextSelection.to;
      isMarkActive(_objectSpread2$3({
        trState: tr,
        type: type2
      }, range2)) ? dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.removeMark(from4, to, markType)) : dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.addMark(from4, to, markType.create(attrs)));
      return true;
    }
    return convertCommand(toggleMark$1(markType, attrs))(props2);
  };
}
function markApplies(type2, doc2, ranges) {
  var _iterator3 = _createForOfIteratorHelper(ranges), _step3;
  try {
    var _loop = function _loop2() {
      var _step3$value = _step3.value, $from = _step3$value.$from, $to = _step3$value.$to;
      var markIsAllowed = $from.depth === 0 ? doc2.type.allowsMarkType(type2) : false;
      doc2.nodesBetween($from.pos, $to.pos, (node4) => {
        if (markIsAllowed) {
          return false;
        }
        markIsAllowed = node4.inlineContent && node4.type.allowsMarkType(type2);
        return;
      });
      if (markIsAllowed) {
        return {
          v: true
        };
      }
    };
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var _ret = _loop();
      if (typeof _ret === "object")
        return _ret.v;
    }
  } catch (err2) {
    _iterator3.e(err2);
  } finally {
    _iterator3.f();
  }
  return false;
}
function applyMark(type2, attrs, selectionPoint) {
  return (_ref3) => {
    var tr = _ref3.tr, dispatch2 = _ref3.dispatch, state = _ref3.state;
    var selection = getTextSelection(selectionPoint !== null && selectionPoint !== void 0 ? selectionPoint : tr.selection, tr.doc);
    var $cursor = getCursor(selection);
    var markType = isString$1(type2) ? state.schema.marks[type2] : type2;
    !markType ? invariant(false, {
      code: ErrorConstant.SCHEMA,
      message: "Mark type: ".concat(type2, " does not exist on the current schema.")
    }) : void 0;
    if (selection.empty && !$cursor || !markApplies(markType, tr.doc, selection.ranges)) {
      return false;
    }
    if (!dispatch2) {
      return true;
    }
    if ($cursor) {
      tr.removeStoredMark(markType);
      if (attrs) {
        tr.addStoredMark(markType.create(attrs));
      }
      dispatch2(tr);
      return true;
    }
    var containsMark = false;
    var _iterator4 = _createForOfIteratorHelper(selection.ranges), _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
        var _step4$value = _step4.value, $from = _step4$value.$from, $to = _step4$value.$to;
        if (containsMark) {
          break;
        }
        containsMark = tr.doc.rangeHasMark($from.pos, $to.pos, markType);
      }
    } catch (err2) {
      _iterator4.e(err2);
    } finally {
      _iterator4.f();
    }
    var _iterator5 = _createForOfIteratorHelper(selection.ranges), _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
        var _step5$value = _step5.value, _$from = _step5$value.$from, _$to = _step5$value.$to;
        if (containsMark) {
          tr.removeMark(_$from.pos, _$to.pos, markType);
        }
        if (attrs) {
          tr.addMark(_$from.pos, _$to.pos, markType.create(attrs));
        }
      }
    } catch (err2) {
      _iterator5.e(err2);
    } finally {
      _iterator5.f();
    }
    dispatch2(tr);
    return true;
  };
}
function insertText(text3) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return (_ref4) => {
    var tr = _ref4.tr, dispatch2 = _ref4.dispatch, state = _ref4.state;
    var schema = state.schema;
    var selection = tr.selection;
    var _options$from = options.from, from4 = _options$from === void 0 ? selection.from : _options$from, _options$to = options.to, to = _options$to === void 0 ? from4 !== null && from4 !== void 0 ? from4 : selection.to : _options$to, _options$marks = options.marks, marks2 = _options$marks === void 0 ? {} : _options$marks;
    if (!dispatch2) {
      return true;
    }
    tr.insertText(text3, from4, to);
    var end3 = assertGet(tr.steps, tr.steps.length - 1).getMap().map(to);
    var _iterator6 = _createForOfIteratorHelper(entries(marks2)), _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
        var _step6$value = _slicedToArray(_step6.value, 2), markName = _step6$value[0], attributes = _step6$value[1];
        tr.addMark(from4, end3, assertGet(schema.marks, markName).create(attributes));
      }
    } catch (err2) {
      _iterator6.e(err2);
    } finally {
      _iterator6.f();
    }
    dispatch2(tr);
    return true;
  };
}
var _dec$9$1, _dec2$4$1, _dec3$4$1, _dec4$4, _dec5$3, _dec6$2, _dec7$2, _dec8$2, _dec9$1, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _class$9$1, _class2$4$1;
var CommandsExtension = (_dec$9$1 = extension({
  defaultPriority: ExtensionPriority.Highest,
  defaultOptions: {
    trackerClassName: "remirror-tracker-position",
    trackerNodeName: "span"
  },
  staticKeys: ["trackerClassName", "trackerNodeName"]
}), _dec2$4$1 = command(), _dec3$4$1 = command(), _dec4$4 = command(), _dec5$3 = command(), _dec6$2 = command(), _dec7$2 = command(), _dec8$2 = command(), _dec9$1 = command(), _dec10 = command(), _dec11 = command(), _dec12 = command(), _dec13 = command(), _dec14 = command(), _dec15 = command(), _dec16 = command(), _dec17 = command(), _dec18 = command(), _dec19 = command(), _dec20 = command(), _dec21 = command(), _dec22 = command(), _dec23 = command(), _dec24 = command(), _dec25 = command({
  description: (_ref) => {
    var t2 = _ref.t;
    return t2(coreMessages.SELECT_ALL_DESCRIPTION);
  },
  label: (_ref2) => {
    var t2 = _ref2.t;
    return t2(coreMessages.SELECT_ALL_LABEL);
  },
  shortcut: NamedShortcut.SelectAll
}), _dec26 = command({
  description: (_ref3) => {
    var t2 = _ref3.t;
    return t2(coreMessages.COPY_DESCRIPTION);
  },
  label: (_ref4) => {
    var t2 = _ref4.t;
    return t2(coreMessages.COPY_LABEL);
  },
  shortcut: NamedShortcut.Copy,
  icon: "fileCopyLine"
}), _dec27 = command({
  description: (_ref5) => {
    var t2 = _ref5.t;
    return t2(coreMessages.PASTE_DESCRIPTION);
  },
  label: (_ref6) => {
    var t2 = _ref6.t;
    return t2(coreMessages.PASTE_LABEL);
  },
  shortcut: NamedShortcut.Paste,
  icon: "clipboardLine"
}), _dec28 = command({
  description: (_ref7) => {
    var t2 = _ref7.t;
    return t2(coreMessages.CUT_DESCRIPTION);
  },
  label: (_ref8) => {
    var t2 = _ref8.t;
    return t2(coreMessages.CUT_LABEL);
  },
  shortcut: NamedShortcut.Cut,
  icon: "scissorsFill"
}), _dec29 = command(), _dec30 = helper(), _dec31 = helper(), _dec32 = helper(), _dec$9$1(_class$9$1 = (_class2$4$1 = class CommandsExtension2 extends PlainExtension {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty$3(this, "decorated", /* @__PURE__ */ new Map());
    _defineProperty$3(this, "forceUpdateTransaction", function(tr) {
      var _this$getCommandMeta = _this.getCommandMeta(tr), forcedUpdates = _this$getCommandMeta.forcedUpdates;
      for (var _len = arguments.length, keys2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        keys2[_key - 1] = arguments[_key];
      }
      _this.setCommandMeta(tr, {
        forcedUpdates: uniqueArray([...forcedUpdates, ...keys2])
      });
      return tr;
    });
  }
  get name() {
    return "commands";
  }
  get transaction() {
    var state = this.store.getState();
    if (!this._transaction) {
      this._transaction = state.tr;
    }
    var isValid = this._transaction.before.eq(state.doc);
    var hasSteps = !isEmptyArray(this._transaction.steps);
    if (!isValid) {
      var _tr = state.tr;
      if (hasSteps) {
        var _iterator = _createForOfIteratorHelper(this._transaction.steps), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var step2 = _step.value;
            _tr.step(step2);
          }
        } catch (err2) {
          _iterator.e(err2);
        } finally {
          _iterator.f();
        }
      }
      this._transaction = _tr;
    }
    return this._transaction;
  }
  onCreate() {
    this.store.setStoreKey("getForcedUpdates", this.getForcedUpdates.bind(this));
  }
  onView(view) {
    var _this2 = this;
    var _this$store = this.store, extensions = _this$store.extensions, helpers = _this$store.helpers;
    var commands = object();
    var names = /* @__PURE__ */ new Set();
    var allDecoratedCommands = object();
    var chain = (tr) => {
      var customChain = object();
      var getTr = () => tr !== null && tr !== void 0 ? tr : this.transaction;
      var commandChain = [];
      var getChain = () => commandChain;
      for (var _i = 0, _Object$entries = Object.entries(commands); _i < _Object$entries.length; _i++) {
        var _allDecoratedCommands;
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), name = _Object$entries$_i[0], _command = _Object$entries$_i[1];
        if ((_allDecoratedCommands = allDecoratedCommands[name]) !== null && _allDecoratedCommands !== void 0 && _allDecoratedCommands.disableChaining) {
          continue;
        }
        customChain[name] = this.chainedFactory({
          chain: customChain,
          command: _command.original,
          getTr,
          getChain
        });
      }
      var dispatch2 = (transaction) => {
        !(transaction === getTr()) ? invariant(false, {
          message: "Chaining currently only supports `CommandFunction` methods which do not use the `state.tr` property. Instead you should use the provided `tr` property."
        }) : void 0;
      };
      customChain.run = function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var commands2 = commandChain;
        commandChain = [];
        var _iterator2 = _createForOfIteratorHelper(commands2), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var cmd = _step2.value;
            if (!cmd(dispatch2) && options.exitEarly) {
              return;
            }
          }
        } catch (err2) {
          _iterator2.e(err2);
        } finally {
          _iterator2.f();
        }
        view.dispatch(getTr());
      };
      customChain.tr = () => {
        var commands2 = commandChain;
        commandChain = [];
        var _iterator3 = _createForOfIteratorHelper(commands2), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var cmd = _step3.value;
            cmd(dispatch2);
          }
        } catch (err2) {
          _iterator3.e(err2);
        } finally {
          _iterator3.f();
        }
        return getTr();
      };
      customChain.enabled = () => {
        var _iterator4 = _createForOfIteratorHelper(commandChain), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var cmd = _step4.value;
            if (!cmd()) {
              return false;
            }
          }
        } catch (err2) {
          _iterator4.e(err2);
        } finally {
          _iterator4.f();
        }
        return true;
      };
      return customChain;
    };
    var _iterator5 = _createForOfIteratorHelper(extensions), _step5;
    try {
      var _loop = function _loop2() {
        var _extension$createComm, _extension$createComm2, _extension$decoratedC;
        var extension2 = _step5.value;
        var extensionCommands = (_extension$createComm = (_extension$createComm2 = extension2.createCommands) === null || _extension$createComm2 === void 0 ? void 0 : _extension$createComm2.call(extension2)) !== null && _extension$createComm !== void 0 ? _extension$createComm : {};
        var decoratedCommands = (_extension$decoratedC = extension2.decoratedCommands) !== null && _extension$decoratedC !== void 0 ? _extension$decoratedC : {};
        var active = {};
        allDecoratedCommands = _objectSpread2$3(_objectSpread2$3({}, allDecoratedCommands), {}, {
          decoratedCommands
        });
        var _loop22 = function _loop23() {
          var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2), commandName = _Object$entries3$_i[0], options = _Object$entries3$_i[1];
          var shortcut = isString$1(options.shortcut) && options.shortcut.startsWith("_|") ? {
            shortcut: helpers.getNamedShortcut(options.shortcut, extension2.options)
          } : void 0;
          _this2.updateDecorated(commandName, _objectSpread2$3(_objectSpread2$3({}, options), {}, {
            name: extension2.name
          }, shortcut));
          extensionCommands[commandName] = extension2[commandName].bind(extension2);
          if (options.active) {
            active[commandName] = () => {
              var _options$active, _options$active2;
              return (_options$active = (_options$active2 = options.active) === null || _options$active2 === void 0 ? void 0 : _options$active2.call(options, extension2.options, _this2.store)) !== null && _options$active !== void 0 ? _options$active : false;
            };
          }
        };
        for (var _i3 = 0, _Object$entries3 = Object.entries(decoratedCommands); _i3 < _Object$entries3.length; _i3++) {
          _loop22();
        }
        if (isEmptyObject(extensionCommands)) {
          return "continue";
        }
        _this2.addCommands({
          active,
          names,
          commands,
          extensionCommands
        });
      };
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
        var _ret = _loop();
        if (_ret === "continue")
          continue;
      }
    } catch (err2) {
      _iterator5.e(err2);
    } finally {
      _iterator5.f();
    }
    var chainProperty = chain();
    for (var _i2 = 0, _Object$entries2 = Object.entries(chainProperty); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2), key = _Object$entries2$_i[0], _command2 = _Object$entries2$_i[1];
      chain[key] = _command2;
    }
    this.store.setStoreKey("commands", commands);
    this.store.setStoreKey("chain", chain);
    this.store.setExtensionStore("commands", commands);
    this.store.setExtensionStore("chain", chain);
  }
  onStateUpdate(_ref9) {
    var state = _ref9.state;
    this._transaction = state.tr;
  }
  createPlugin() {
    return {};
  }
  customDispatch(command2) {
    return command2;
  }
  insertText(text3) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (isString$1(text3)) {
      return insertText(text3, options);
    }
    return this.store.createPlaceholderCommand({
      promise: text3,
      placeholder: {
        type: "inline"
      },
      onSuccess: (value, range2, props) => {
        return this.insertText(value, _objectSpread2$3(_objectSpread2$3({}, options), range2))(props);
      }
    }).generateCommand();
  }
  selectText(selection) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return (_ref10) => {
      var tr = _ref10.tr, dispatch2 = _ref10.dispatch;
      var textSelection = getTextSelection(selection, tr.doc);
      var selectionUnchanged = tr.selection.anchor === textSelection.anchor && tr.selection.head === textSelection.head;
      if (selectionUnchanged && !options.forceUpdate) {
        return false;
      }
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.setSelection(textSelection));
      return true;
    };
  }
  selectMark(type2) {
    return (props) => {
      var tr = props.tr;
      var range2 = getMarkRange(tr.selection.$from, type2);
      if (!range2) {
        return false;
      }
      return this.store.commands.selectText.original({
        from: range2.from,
        to: range2.to
      })(props);
    };
  }
  delete(range2) {
    return (_ref11) => {
      var tr = _ref11.tr, dispatch2 = _ref11.dispatch;
      var _ref12 = range2 !== null && range2 !== void 0 ? range2 : tr.selection, from4 = _ref12.from, to = _ref12.to;
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.delete(from4, to));
      return true;
    };
  }
  emptyUpdate(action2) {
    return (_ref13) => {
      var tr = _ref13.tr, dispatch2 = _ref13.dispatch;
      if (dispatch2) {
        action2 === null || action2 === void 0 ? void 0 : action2();
        dispatch2(tr);
      }
      return true;
    };
  }
  forceUpdate() {
    for (var _len2 = arguments.length, keys2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys2[_key2] = arguments[_key2];
    }
    return (_ref14) => {
      var tr = _ref14.tr, dispatch2 = _ref14.dispatch;
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(this.forceUpdateTransaction(tr, ...keys2));
      return true;
    };
  }
  updateNodeAttributes(pos, attrs) {
    return (_ref15) => {
      var tr = _ref15.tr, dispatch2 = _ref15.dispatch;
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.setNodeMarkup(pos, void 0, attrs));
      return true;
    };
  }
  setContent(content2, selection) {
    return (props) => {
      var tr = props.tr, dispatch2 = props.dispatch;
      var state = this.store.manager.createState({
        content: content2,
        selection
      });
      if (!state) {
        return false;
      }
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.replaceRangeWith(0, tr.doc.nodeSize - 2, state.doc));
      return true;
    };
  }
  resetContent() {
    return (props) => {
      var tr = props.tr, dispatch2 = props.dispatch;
      var doc2 = this.store.manager.createEmptyDoc();
      if (doc2) {
        return this.setContent(doc2)(props);
      }
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.delete(0, tr.doc.nodeSize));
      return true;
    };
  }
  emptySelection() {
    return (_ref16) => {
      var tr = _ref16.tr, dispatch2 = _ref16.dispatch;
      if (tr.selection.empty) {
        return false;
      }
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.setSelection(TextSelection.create(tr.doc, tr.selection.anchor)));
      return true;
    };
  }
  insertNewLine() {
    return (_ref17) => {
      var dispatch2 = _ref17.dispatch, tr = _ref17.tr;
      if (!isTextSelection(tr.selection)) {
        return false;
      }
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.insertText("\n"));
      return true;
    };
  }
  insertNode(node4) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return (_ref18) => {
      var _ref19, _options$marks;
      var dispatch2 = _ref18.dispatch, tr = _ref18.tr, state = _ref18.state;
      var attrs = options.attrs, range2 = options.range, selection = options.selection, _options$replaceEmpty = options.replaceEmptyParentBlock, replaceEmptyParentBlock = _options$replaceEmpty === void 0 ? false : _options$replaceEmpty;
      var _getTextSelection = getTextSelection((_ref19 = selection !== null && selection !== void 0 ? selection : range2) !== null && _ref19 !== void 0 ? _ref19 : tr.selection, tr.doc), from4 = _getTextSelection.from, to = _getTextSelection.to, $from = _getTextSelection.$from;
      if (isProsemirrorNode(node4) || isProsemirrorFragment(node4)) {
        var pos = $from.before($from.depth);
        dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(replaceEmptyParentBlock && from4 === to && isEmptyBlockNode($from.parent) ? tr.replaceWith(pos, pos + $from.parent.nodeSize, node4) : tr.replaceWith(from4, to, node4));
        return true;
      }
      var nodeType2 = isString$1(node4) ? state.schema.nodes[node4] : node4;
      !nodeType2 ? invariant(false, {
        code: ErrorConstant.SCHEMA,
        message: "The requested node type ".concat(node4, " does not exist in the schema.")
      }) : void 0;
      var marks2 = (_options$marks = options.marks) === null || _options$marks === void 0 ? void 0 : _options$marks.map((mark3) => {
        if (mark3 instanceof Mark) {
          return mark3;
        }
        var markType = isString$1(mark3) ? state.schema.marks[mark3] : mark3;
        !markType ? invariant(false, {
          code: ErrorConstant.SCHEMA,
          message: "The requested mark type ".concat(mark3, " does not exist in the schema.")
        }) : void 0;
        return markType.create();
      });
      var content2 = nodeType2.createAndFill(attrs, isString$1(options.content) ? state.schema.text(options.content) : options.content, marks2);
      if (!content2) {
        return false;
      }
      var isReplacement = from4 !== to;
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(isReplacement ? tr.replaceRangeWith(from4, to, content2) : tr.insert(from4, content2));
      return true;
    };
  }
  focus(position) {
    return (props) => {
      var dispatch2 = props.dispatch, tr = props.tr;
      var view = this.store.view;
      if (position === false) {
        return false;
      }
      if (view.hasFocus() && (position === void 0 || position === true)) {
        return false;
      }
      if (position === void 0 || position === true) {
        var _tr$selection = tr.selection, _tr$selection$from = _tr$selection.from, from4 = _tr$selection$from === void 0 ? 0 : _tr$selection$from, _tr$selection$to = _tr$selection.to, to = _tr$selection$to === void 0 ? from4 : _tr$selection$to;
        position = {
          from: from4,
          to
        };
      }
      if (dispatch2) {
        this.delayedFocus();
      }
      return this.selectText(position)(props);
    };
  }
  blur(position) {
    return (props) => {
      var view = this.store.view;
      if (!view.hasFocus()) {
        return false;
      }
      requestAnimationFrame(() => {
        view.dom.blur();
      });
      return position ? this.selectText(position)(props) : true;
    };
  }
  setBlockNodeType(nodeType2, attrs, selection) {
    var preserveAttrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    return setBlockType(nodeType2, attrs, selection, preserveAttrs);
  }
  toggleWrappingNode(nodeType2, attrs, selection) {
    return toggleWrap(nodeType2, attrs, selection);
  }
  toggleBlockNodeItem(toggleProps) {
    return toggleBlockItem(toggleProps);
  }
  wrapInNode(nodeType2, attrs, range2) {
    return wrapIn(nodeType2, attrs, range2);
  }
  applyMark(markType, attrs, selection) {
    return applyMark(markType, attrs, selection);
  }
  toggleMark(props) {
    return toggleMark(props);
  }
  removeMark(props) {
    return removeMark(props);
  }
  setMeta(name, value) {
    return (_ref20) => {
      var tr = _ref20.tr;
      tr.setMeta(name, value);
      return true;
    };
  }
  selectAll() {
    return this.selectText("all");
  }
  copy() {
    return (props) => {
      if (props.tr.selection.empty) {
        return false;
      }
      if (props.dispatch) {
        document.execCommand("copy");
      }
      return true;
    };
  }
  paste() {
    return this.store.createPlaceholderCommand({
      promise: () => navigator.clipboard.readText(),
      placeholder: {
        type: "inline"
      },
      onSuccess: (value, selection, props) => {
        return this.insertNode(htmlToProsemirrorNode({
          content: value,
          schema: props.state.schema
        }), {
          selection
        })(props);
      }
    }).generateCommand();
  }
  cut() {
    return (props) => {
      if (props.tr.selection.empty) {
        return false;
      }
      if (props.dispatch) {
        document.execCommand("cut");
      }
      return true;
    };
  }
  replaceText(props) {
    return replaceText(props);
  }
  getAllCommandOptions() {
    var uiCommands = {};
    var _iterator6 = _createForOfIteratorHelper(this.decorated), _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
        var _step6$value = _slicedToArray(_step6.value, 2), name = _step6$value[0], options = _step6$value[1];
        if (isEmptyObject(options)) {
          continue;
        }
        uiCommands[name] = options;
      }
    } catch (err2) {
      _iterator6.e(err2);
    } finally {
      _iterator6.f();
    }
    return uiCommands;
  }
  getCommandOptions(name) {
    return this.decorated.get(name);
  }
  getCommandProp() {
    return {
      tr: this.transaction,
      dispatch: this.store.view.dispatch,
      state: this.store.view.state,
      view: this.store.view
    };
  }
  updateDecorated(name, options) {
    var _this$decorated$get;
    if (!options) {
      this.decorated.delete(name);
      return;
    }
    var decoratorOptions = (_this$decorated$get = this.decorated.get(name)) !== null && _this$decorated$get !== void 0 ? _this$decorated$get : {
      name: ""
    };
    this.decorated.set(name, _objectSpread2$3(_objectSpread2$3({}, decoratorOptions), options));
  }
  handleIosFocus() {
    if (!environment.isIos) {
      return;
    }
    this.store.view.dom.focus();
  }
  delayedFocus() {
    this.handleIosFocus();
    requestAnimationFrame(() => {
      this.store.view.focus();
      this.store.view.dispatch(this.transaction.scrollIntoView());
    });
  }
  getForcedUpdates(tr) {
    return this.getCommandMeta(tr).forcedUpdates;
  }
  getCommandMeta(tr) {
    var _tr$getMeta;
    var meta = (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : {};
    return _objectSpread2$3(_objectSpread2$3({}, DEFAULT_COMMAND_META), meta);
  }
  setCommandMeta(tr, update2) {
    var meta = this.getCommandMeta(tr);
    tr.setMeta(this.pluginKey, _objectSpread2$3(_objectSpread2$3({}, meta), update2));
  }
  addCommands(props) {
    var extensionCommands = props.extensionCommands, commands = props.commands, names = props.names, active = props.active;
    var _iterator7 = _createForOfIteratorHelper(entries(extensionCommands)), _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
        var _step7$value = _slicedToArray(_step7.value, 2), name = _step7$value[0], _command3 = _step7$value[1];
        throwIfNameNotUnique({
          name,
          set: names,
          code: ErrorConstant.DUPLICATE_COMMAND_NAMES
        });
        !!forbiddenNames.has(name) ? true ? invariant(false, {
          code: ErrorConstant.DUPLICATE_COMMAND_NAMES,
          message: "The command name you chose is forbidden."
        }) : invariant(false) : void 0;
        commands[name] = this.createUnchainedCommand(_command3, active[name]);
      }
    } catch (err2) {
      _iterator7.e(err2);
    } finally {
      _iterator7.f();
    }
  }
  unchainedFactory(props) {
    var _this3 = this;
    return function() {
      var _props$shouldDispatch = props.shouldDispatch, shouldDispatch = _props$shouldDispatch === void 0 ? true : _props$shouldDispatch, command2 = props.command;
      var view = _this3.store.view;
      var state = view.state;
      var dispatch2;
      if (shouldDispatch) {
        dispatch2 = view.dispatch;
      }
      return command2(...arguments)({
        state,
        dispatch: dispatch2,
        view,
        tr: state.tr
      });
    };
  }
  createUnchainedCommand(command2, active) {
    var unchainedCommand = this.unchainedFactory({
      command: command2
    });
    unchainedCommand.enabled = this.unchainedFactory({
      command: command2,
      shouldDispatch: false
    });
    unchainedCommand.isEnabled = unchainedCommand.enabled;
    unchainedCommand.original = command2;
    unchainedCommand.active = active;
    return unchainedCommand;
  }
  chainedFactory(props) {
    var _this4 = this;
    return function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var chained = props.chain, command2 = props.command, getTr = props.getTr, getChain = props.getChain;
      var lazyChain = getChain();
      var view = _this4.store.view;
      var state = view.state;
      lazyChain.push((dispatch2) => {
        return command2(...args)({
          state,
          dispatch: dispatch2,
          view,
          tr: getTr()
        });
      });
      return chained;
    };
  }
}, _applyDecoratedDescriptor(_class2$4$1.prototype, "customDispatch", [_dec2$4$1], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "customDispatch"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "insertText", [_dec3$4$1], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "insertText"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "selectText", [_dec4$4], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "selectText"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "selectMark", [_dec5$3], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "selectMark"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "delete", [_dec6$2], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "delete"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "emptyUpdate", [_dec7$2], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "emptyUpdate"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "forceUpdate", [_dec8$2], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "forceUpdate"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "updateNodeAttributes", [_dec9$1], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "updateNodeAttributes"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "setContent", [_dec10], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "setContent"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "resetContent", [_dec11], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "resetContent"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "emptySelection", [_dec12], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "emptySelection"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "insertNewLine", [_dec13], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "insertNewLine"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "insertNode", [_dec14], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "insertNode"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "focus", [_dec15], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "focus"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "blur", [_dec16], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "blur"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "setBlockNodeType", [_dec17], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "setBlockNodeType"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "toggleWrappingNode", [_dec18], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "toggleWrappingNode"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "toggleBlockNodeItem", [_dec19], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "toggleBlockNodeItem"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "wrapInNode", [_dec20], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "wrapInNode"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "applyMark", [_dec21], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "applyMark"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "toggleMark", [_dec22], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "toggleMark"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "removeMark", [_dec23], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "removeMark"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "setMeta", [_dec24], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "setMeta"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "selectAll", [_dec25], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "selectAll"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "copy", [_dec26], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "copy"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "paste", [_dec27], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "paste"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "cut", [_dec28], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "cut"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "replaceText", [_dec29], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "replaceText"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "getAllCommandOptions", [_dec30], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "getAllCommandOptions"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "getCommandOptions", [_dec31], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "getCommandOptions"), _class2$4$1.prototype), _applyDecoratedDescriptor(_class2$4$1.prototype, "getCommandProp", [_dec32], Object.getOwnPropertyDescriptor(_class2$4$1.prototype, "getCommandProp"), _class2$4$1.prototype), _class2$4$1)) || _class$9$1);
var DEFAULT_COMMAND_META = {
  forcedUpdates: []
};
var forbiddenNames = /* @__PURE__ */ new Set(["run", "chain", "original", "raw", "enabled", "tr"]);
var _excluded$1$2 = ["nodeName", "className"];
var _dec$8$1, _dec2$3$1, _dec3$3$1, _dec4$3$1, _dec5$2$1, _dec6$1, _dec7$1, _dec8$1, _class$8$1, _class2$3$1;
var DecorationsExtension = (_dec$8$1 = extension({
  defaultOptions: {
    persistentSelectionClass: void 0,
    placeholderClassName: "placeholder",
    placeholderNodeName: "span"
  },
  staticKeys: ["placeholderClassName", "placeholderNodeName"],
  handlerKeys: ["decorations"],
  handlerKeyOptions: {
    decorations: {
      reducer: {
        accumulator: (accumulated, latestValue, state) => {
          return accumulated.add(state.doc, latestValue.find());
        },
        getDefault: () => DecorationSet.empty
      }
    }
  },
  defaultPriority: ExtensionPriority.Low
}), _dec2$3$1 = command(), _dec3$3$1 = command(), _dec4$3$1 = command(), _dec5$2$1 = command(), _dec6$1 = command(), _dec7$1 = helper(), _dec8$1 = helper(), _dec$8$1(_class$8$1 = (_class2$3$1 = class DecorationsExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "placeholders", DecorationSet.empty);
    _defineProperty$3(this, "placeholderWidgets", /* @__PURE__ */ new Map());
    _defineProperty$3(this, "createPlaceholderCommand", (props) => {
      var id = uniqueId();
      var promise = props.promise, placeholder = props.placeholder, onFailure = props.onFailure, onSuccess = props.onSuccess;
      return new DelayedCommand(promise).validate((props2) => {
        return this.addPlaceholder(id, placeholder)(props2);
      }).success((props2) => {
        var state = props2.state, tr = props2.tr, dispatch2 = props2.dispatch, view = props2.view, value = props2.value;
        var range2 = this.store.helpers.findPlaceholder(id);
        if (!range2) {
          var _onFailure;
          var error = new Error("The placeholder has been removed");
          return (_onFailure = onFailure === null || onFailure === void 0 ? void 0 : onFailure({
            error,
            state,
            tr,
            dispatch: dispatch2,
            view
          })) !== null && _onFailure !== void 0 ? _onFailure : false;
        }
        this.removePlaceholder(id)({
          state,
          tr,
          view,
          dispatch: () => {
          }
        });
        return onSuccess(value, range2, {
          state,
          tr,
          dispatch: dispatch2,
          view
        });
      }).failure((props2) => {
        var _onFailure2;
        this.removePlaceholder(id)(_objectSpread2$3(_objectSpread2$3({}, props2), {}, {
          dispatch: () => {
          }
        }));
        return (_onFailure2 = onFailure === null || onFailure === void 0 ? void 0 : onFailure(props2)) !== null && _onFailure2 !== void 0 ? _onFailure2 : false;
      });
    });
  }
  get name() {
    return "decorations";
  }
  onCreate() {
    this.store.setExtensionStore("createPlaceholderCommand", this.createPlaceholderCommand);
  }
  createPlugin() {
    var _this = this;
    return {
      state: {
        init: () => {
        },
        apply: (tr) => {
          var _this$getMeta = this.getMeta(tr), added = _this$getMeta.added, clearTrackers = _this$getMeta.clearTrackers, removed = _this$getMeta.removed, updated = _this$getMeta.updated;
          if (clearTrackers) {
            this.placeholders = DecorationSet.empty;
            var _iterator = _createForOfIteratorHelper(this.placeholderWidgets), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _widget$spec$onDestro, _widget$spec;
                var _step$value = _slicedToArray(_step.value, 2), widget2 = _step$value[1];
                (_widget$spec$onDestro = (_widget$spec = widget2.spec).onDestroy) === null || _widget$spec$onDestro === void 0 ? void 0 : _widget$spec$onDestro.call(_widget$spec, this.store.view, widget2.spec.element);
              }
            } catch (err2) {
              _iterator.e(err2);
            } finally {
              _iterator.f();
            }
            this.placeholderWidgets.clear();
            return;
          }
          this.placeholders = this.placeholders.map(tr.mapping, tr.doc, {
            onRemove: (spec) => {
              var widget3 = this.placeholderWidgets.get(spec.id);
              if (widget3) {
                var _widget$spec$onDestro2, _widget$spec2;
                (_widget$spec$onDestro2 = (_widget$spec2 = widget3.spec).onDestroy) === null || _widget$spec$onDestro2 === void 0 ? void 0 : _widget$spec$onDestro2.call(_widget$spec2, this.store.view, widget3.spec.element);
              }
            }
          });
          var _iterator2 = _createForOfIteratorHelper(this.placeholderWidgets), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var _widget$spec$onUpdate, _widget$spec3;
              var _step2$value = _slicedToArray(_step2.value, 2), _widget = _step2$value[1];
              (_widget$spec$onUpdate = (_widget$spec3 = _widget.spec).onUpdate) === null || _widget$spec$onUpdate === void 0 ? void 0 : _widget$spec$onUpdate.call(_widget$spec3, this.store.view, _widget.from, _widget.spec.element, _widget.spec.data);
            }
          } catch (err2) {
            _iterator2.e(err2);
          } finally {
            _iterator2.f();
          }
          var _iterator3 = _createForOfIteratorHelper(added), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var placeholder = _step3.value;
              if (placeholder.type === "inline") {
                this.addInlinePlaceholder(placeholder, tr);
                continue;
              }
              if (placeholder.type === "node") {
                this.addNodePlaceholder(placeholder, tr);
                continue;
              }
              if (placeholder.type === "widget") {
                this.addWidgetPlaceholder(placeholder, tr);
                continue;
              }
            }
          } catch (err2) {
            _iterator3.e(err2);
          } finally {
            _iterator3.f();
          }
          var _iterator4 = _createForOfIteratorHelper(updated), _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var _step4$value = _step4.value, id = _step4$value.id, _data = _step4$value.data;
              var _widget2 = this.placeholderWidgets.get(id);
              if (!_widget2) {
                continue;
              }
              var updatedWidget = Decoration.widget(_widget2.from, _widget2.spec.element, _objectSpread2$3(_objectSpread2$3({}, _widget2.spec), {}, {
                data: _data
              }));
              this.placeholders = this.placeholders.remove([_widget2]).add(tr.doc, [updatedWidget]);
              this.placeholderWidgets.set(id, updatedWidget);
            }
          } catch (err2) {
            _iterator4.e(err2);
          } finally {
            _iterator4.f();
          }
          var _iterator5 = _createForOfIteratorHelper(removed), _step5;
          try {
            var _loop = function _loop2() {
              var id2 = _step5.value;
              var found2 = _this.placeholders.find(void 0, void 0, (spec) => spec.id === id2 && spec.__type === __type);
              var widget3 = _this.placeholderWidgets.get(id2);
              if (widget3) {
                var _widget$spec$onDestro3, _widget$spec4;
                (_widget$spec$onDestro3 = (_widget$spec4 = widget3.spec).onDestroy) === null || _widget$spec$onDestro3 === void 0 ? void 0 : _widget$spec$onDestro3.call(_widget$spec4, _this.store.view, widget3.spec.element);
              }
              _this.placeholders = _this.placeholders.remove(found2);
              _this.placeholderWidgets.delete(id2);
            };
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              _loop();
            }
          } catch (err2) {
            _iterator5.e(err2);
          } finally {
            _iterator5.f();
          }
        }
      },
      props: {
        decorations: (state) => {
          var decorationSet = this.options.decorations(state);
          decorationSet = decorationSet.add(state.doc, this.placeholders.find());
          var _iterator6 = _createForOfIteratorHelper(this.store.extensions), _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
              var _extension = _step6.value;
              if (!_extension.createDecorations) {
                continue;
              }
              var decorations = _extension.createDecorations(state).find();
              decorationSet = decorationSet.add(state.doc, decorations);
            }
          } catch (err2) {
            _iterator6.e(err2);
          } finally {
            _iterator6.f();
          }
          return decorationSet;
        },
        handleDOMEvents: {
          blur: (view) => {
            if (this.options.persistentSelectionClass) {
              view.dispatch(view.state.tr.setMeta(persistentSelectionFocusKey, false));
            }
            return false;
          },
          focus: (view) => {
            if (this.options.persistentSelectionClass) {
              view.dispatch(view.state.tr.setMeta(persistentSelectionFocusKey, true));
            }
            return false;
          }
        }
      }
    };
  }
  updateDecorations() {
    return (_ref) => {
      var tr = _ref.tr, dispatch2 = _ref.dispatch;
      return dispatch2 !== null && dispatch2 !== void 0 && dispatch2(tr), true;
    };
  }
  addPlaceholder(id, placeholder, deleteSelection2) {
    return (_ref2) => {
      var dispatch2 = _ref2.dispatch, tr = _ref2.tr;
      return this.addPlaceholderTransaction(id, placeholder, tr, !dispatch2) ? (dispatch2 !== null && dispatch2 !== void 0 && dispatch2(deleteSelection2 ? tr.deleteSelection() : tr), true) : false;
    };
  }
  updatePlaceholder(id, data) {
    return (_ref3) => {
      var dispatch2 = _ref3.dispatch, tr = _ref3.tr;
      return this.updatePlaceholderTransaction({
        id,
        data,
        tr,
        checkOnly: !dispatch2
      }) ? (dispatch2 !== null && dispatch2 !== void 0 && dispatch2(tr), true) : false;
    };
  }
  removePlaceholder(id) {
    return (_ref4) => {
      var dispatch2 = _ref4.dispatch, tr = _ref4.tr;
      return this.removePlaceholderTransaction({
        id,
        tr,
        checkOnly: !dispatch2
      }) ? (dispatch2 !== null && dispatch2 !== void 0 && dispatch2(tr), true) : false;
    };
  }
  clearPlaceholders() {
    return (_ref5) => {
      var tr = _ref5.tr, dispatch2 = _ref5.dispatch;
      return this.clearPlaceholdersTransaction({
        tr,
        checkOnly: !dispatch2
      }) ? (dispatch2 !== null && dispatch2 !== void 0 && dispatch2(tr), true) : false;
    };
  }
  findPlaceholder(id) {
    return this.findAllPlaceholders().get(id);
  }
  findAllPlaceholders() {
    var trackers = /* @__PURE__ */ new Map();
    var found2 = this.placeholders.find(void 0, void 0, (spec) => spec.__type === __type);
    var _iterator7 = _createForOfIteratorHelper(found2), _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
        var decoration = _step7.value;
        trackers.set(decoration.spec.id, {
          from: decoration.from,
          to: decoration.to
        });
      }
    } catch (err2) {
      _iterator7.e(err2);
    } finally {
      _iterator7.f();
    }
    return trackers;
  }
  createDecorations(state) {
    var _this$store$view, _this$store$helpers$i, _this$store$helpers;
    var persistentSelectionClass = this.options.persistentSelectionClass;
    if (!persistentSelectionClass || (_this$store$view = this.store.view) !== null && _this$store$view !== void 0 && _this$store$view.hasFocus() || (_this$store$helpers$i = (_this$store$helpers = this.store.helpers).isInteracting) !== null && _this$store$helpers$i !== void 0 && _this$store$helpers$i.call(_this$store$helpers)) {
      return DecorationSet.empty;
    }
    return generatePersistentSelectionDecorations(state, DecorationSet.empty, {
      class: isString$1(persistentSelectionClass) ? persistentSelectionClass : "selection"
    });
  }
  onApplyState() {
  }
  addWidgetPlaceholder(placeholder, tr) {
    var _createElement;
    var pos = placeholder.pos, createElement = placeholder.createElement, onDestroy = placeholder.onDestroy, onUpdate = placeholder.onUpdate, className = placeholder.className, nodeName = placeholder.nodeName, id = placeholder.id, type2 = placeholder.type;
    var element = (_createElement = createElement === null || createElement === void 0 ? void 0 : createElement(this.store.view, pos)) !== null && _createElement !== void 0 ? _createElement : document.createElement(nodeName);
    element.classList.add(className);
    var decoration = Decoration.widget(pos, element, {
      id,
      __type,
      type: type2,
      element,
      onDestroy,
      onUpdate
    });
    this.placeholderWidgets.set(id, decoration);
    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  addInlinePlaceholder(placeholder, tr) {
    var _placeholder$from = placeholder.from, from4 = _placeholder$from === void 0 ? tr.selection.from : _placeholder$from, _placeholder$to = placeholder.to, to = _placeholder$to === void 0 ? tr.selection.to : _placeholder$to, className = placeholder.className, nodeName = placeholder.nodeName, id = placeholder.id, type2 = placeholder.type;
    var decoration;
    if (from4 === to) {
      var _element = document.createElement(nodeName);
      _element.classList.add(className);
      decoration = Decoration.widget(from4, _element, {
        id,
        type: type2,
        __type,
        widget: _element
      });
    } else {
      decoration = Decoration.inline(from4, to, {
        nodeName,
        class: className
      }, {
        id,
        __type
      });
    }
    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  addNodePlaceholder(placeholder, tr) {
    var pos = placeholder.pos, className = placeholder.className, nodeName = placeholder.nodeName, id = placeholder.id;
    var $pos = isNumber(pos) ? tr.doc.resolve(pos) : tr.selection.$from;
    var found2 = isNumber(pos) ? $pos.nodeAfter ? {
      pos,
      end: $pos.nodeAfter.nodeSize
    } : void 0 : findNodeAtPosition($pos);
    if (!found2) {
      return;
    }
    var decoration = Decoration.node(found2.pos, found2.end, {
      nodeName,
      class: className
    }, {
      id,
      __type
    });
    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  withRequiredBase(id, placeholder) {
    var _this$options = this.options, placeholderNodeName = _this$options.placeholderNodeName, placeholderClassName = _this$options.placeholderClassName;
    var _placeholder$nodeName = placeholder.nodeName, nodeName = _placeholder$nodeName === void 0 ? placeholderNodeName : _placeholder$nodeName, className = placeholder.className, rest = _objectWithoutProperties(placeholder, _excluded$1$2);
    var classes = (className ? [placeholderClassName, className] : [placeholderClassName]).join(" ");
    return _objectSpread2$3(_objectSpread2$3({
      nodeName,
      className: classes
    }, rest), {}, {
      id
    });
  }
  getMeta(tr) {
    var _tr$getMeta;
    var meta = (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : {};
    return _objectSpread2$3(_objectSpread2$3({}, DEFAULT_PLACEHOLDER_META), meta);
  }
  setMeta(tr, update2) {
    var meta = this.getMeta(tr);
    tr.setMeta(this.pluginKey, _objectSpread2$3(_objectSpread2$3({}, meta), update2));
  }
  addPlaceholderTransaction(id, placeholder, tr) {
    var checkOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var existingPosition = this.findPlaceholder(id);
    if (existingPosition) {
      return false;
    }
    if (checkOnly) {
      return true;
    }
    var _this$getMeta2 = this.getMeta(tr), added = _this$getMeta2.added;
    this.setMeta(tr, {
      added: [...added, this.withRequiredBase(id, placeholder)]
    });
    return true;
  }
  updatePlaceholderTransaction(props) {
    var id = props.id, tr = props.tr, _props$checkOnly = props.checkOnly, checkOnly = _props$checkOnly === void 0 ? false : _props$checkOnly, data = props.data;
    var existingPosition = this.findPlaceholder(id);
    if (!existingPosition) {
      return false;
    }
    if (checkOnly) {
      return true;
    }
    var _this$getMeta3 = this.getMeta(tr), updated = _this$getMeta3.updated;
    this.setMeta(tr, {
      updated: uniqueArray([...updated, {
        id,
        data
      }])
    });
    return true;
  }
  removePlaceholderTransaction(props) {
    var id = props.id, tr = props.tr, _props$checkOnly2 = props.checkOnly, checkOnly = _props$checkOnly2 === void 0 ? false : _props$checkOnly2;
    var existingPosition = this.findPlaceholder(id);
    if (!existingPosition) {
      return false;
    }
    if (checkOnly) {
      return true;
    }
    var _this$getMeta4 = this.getMeta(tr), removed = _this$getMeta4.removed;
    this.setMeta(tr, {
      removed: uniqueArray([...removed, id])
    });
    return true;
  }
  clearPlaceholdersTransaction(props) {
    var tr = props.tr, _props$checkOnly3 = props.checkOnly, checkOnly = _props$checkOnly3 === void 0 ? false : _props$checkOnly3;
    var positionTrackerState = this.getPluginState();
    if (positionTrackerState === DecorationSet.empty) {
      return false;
    }
    if (checkOnly) {
      return true;
    }
    this.setMeta(tr, {
      clearTrackers: true
    });
    return true;
  }
}, _applyDecoratedDescriptor(_class2$3$1.prototype, "updateDecorations", [_dec2$3$1], Object.getOwnPropertyDescriptor(_class2$3$1.prototype, "updateDecorations"), _class2$3$1.prototype), _applyDecoratedDescriptor(_class2$3$1.prototype, "addPlaceholder", [_dec3$3$1], Object.getOwnPropertyDescriptor(_class2$3$1.prototype, "addPlaceholder"), _class2$3$1.prototype), _applyDecoratedDescriptor(_class2$3$1.prototype, "updatePlaceholder", [_dec4$3$1], Object.getOwnPropertyDescriptor(_class2$3$1.prototype, "updatePlaceholder"), _class2$3$1.prototype), _applyDecoratedDescriptor(_class2$3$1.prototype, "removePlaceholder", [_dec5$2$1], Object.getOwnPropertyDescriptor(_class2$3$1.prototype, "removePlaceholder"), _class2$3$1.prototype), _applyDecoratedDescriptor(_class2$3$1.prototype, "clearPlaceholders", [_dec6$1], Object.getOwnPropertyDescriptor(_class2$3$1.prototype, "clearPlaceholders"), _class2$3$1.prototype), _applyDecoratedDescriptor(_class2$3$1.prototype, "findPlaceholder", [_dec7$1], Object.getOwnPropertyDescriptor(_class2$3$1.prototype, "findPlaceholder"), _class2$3$1.prototype), _applyDecoratedDescriptor(_class2$3$1.prototype, "findAllPlaceholders", [_dec8$1], Object.getOwnPropertyDescriptor(_class2$3$1.prototype, "findAllPlaceholders"), _class2$3$1.prototype), _class2$3$1)) || _class$8$1);
var DEFAULT_PLACEHOLDER_META = {
  added: [],
  updated: [],
  clearTrackers: false,
  removed: []
};
var __type = "placeholderDecoration";
var persistentSelectionFocusKey = "persistentSelectionFocus";
function generatePersistentSelectionDecorations(state, decorationSet, attrs) {
  var selection = state.selection, doc2 = state.doc;
  if (selection.empty) {
    return decorationSet;
  }
  var from4 = selection.from, to = selection.to;
  var decoration = isNodeSelection(selection) ? Decoration.node(from4, to, attrs) : Decoration.inline(from4, to, attrs);
  return decorationSet.add(doc2, [decoration]);
}
var _dec$7$1, _dec2$2$1, _dec3$2$1, _dec4$2$1, _dec5$1$1, _dec6, _dec7, _dec8, _dec9, _class$7$1, _class2$2$1;
var HelpersExtension = (_dec$7$1 = extension({}), _dec2$2$1 = helper(), _dec3$2$1 = helper(), _dec4$2$1 = helper(), _dec5$1$1 = helper(), _dec6 = command(), _dec7 = helper(), _dec8 = helper(), _dec9 = helper(), _dec$7$1(_class$7$1 = (_class2$2$1 = class HelpersExtension2 extends PlainExtension {
  get name() {
    return "helpers";
  }
  onCreate() {
    var _this = this;
    this.store.setStringHandler("text", this.textToProsemirrorNode.bind(this));
    this.store.setStringHandler("html", htmlToProsemirrorNode);
    var helpers = object();
    var active = object();
    var attrs = object();
    var names = /* @__PURE__ */ new Set();
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      var _loop = function _loop2() {
        var _extension$createHelp, _extension$createHelp2;
        var extension2 = _step.value;
        if (isNodeExtension(extension2)) {
          active[extension2.name] = (attrs2) => {
            return isNodeActive({
              state: _this.store.getState(),
              type: extension2.type,
              attrs: attrs2
            });
          };
          attrs[extension2.name] = (attrs2) => {
            var _getActiveNode;
            return (_getActiveNode = getActiveNode({
              state: _this.store.getState(),
              type: extension2.type,
              attrs: attrs2
            })) === null || _getActiveNode === void 0 ? void 0 : _getActiveNode.node.attrs;
          };
        }
        if (isMarkExtension(extension2)) {
          active[extension2.name] = (attrs2) => {
            return isMarkActive({
              trState: _this.store.getState(),
              type: extension2.type,
              attrs: attrs2
            });
          };
          attrs[extension2.name] = (attrs2) => {
            var markRange = getMarkRange(_this.store.getState().selection.$from, extension2.type);
            if (!markRange || !attrs2) {
              return markRange === null || markRange === void 0 ? void 0 : markRange.mark.attrs;
            }
            if (containsAttributes(markRange.mark, attrs2)) {
              return markRange.mark.attrs;
            }
            return;
          };
        }
        var extensionHelpers = (_extension$createHelp = (_extension$createHelp2 = extension2.createHelpers) === null || _extension$createHelp2 === void 0 ? void 0 : _extension$createHelp2.call(extension2)) !== null && _extension$createHelp !== void 0 ? _extension$createHelp : {};
        for (var _i = 0, _Object$keys = Object.keys((_extension$decoratedH = extension2.decoratedHelpers) !== null && _extension$decoratedH !== void 0 ? _extension$decoratedH : {}); _i < _Object$keys.length; _i++) {
          var _extension$decoratedH;
          var helperName = _Object$keys[_i];
          extensionHelpers[helperName] = extension2[helperName].bind(extension2);
        }
        if (isEmptyObject(extensionHelpers)) {
          return "continue";
        }
        var _iterator2 = _createForOfIteratorHelper(entries(extensionHelpers)), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), name = _step2$value[0], _helper = _step2$value[1];
            throwIfNameNotUnique({
              name,
              set: names,
              code: ErrorConstant.DUPLICATE_HELPER_NAMES
            });
            helpers[name] = _helper;
          }
        } catch (err2) {
          _iterator2.e(err2);
        } finally {
          _iterator2.f();
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _ret = _loop();
        if (_ret === "continue")
          continue;
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    this.store.setStoreKey("attrs", attrs);
    this.store.setStoreKey("active", active);
    this.store.setStoreKey("helpers", helpers);
    this.store.setExtensionStore("attrs", attrs);
    this.store.setExtensionStore("active", active);
    this.store.setExtensionStore("helpers", helpers);
  }
  isSelectionEmpty() {
    var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.store.getState();
    return isSelectionEmpty(state);
  }
  getStateJSON() {
    var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.store.getState();
    return state.toJSON();
  }
  getJSON() {
    var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.store.getState();
    return state.doc.toJSON();
  }
  getRemirrorJSON() {
    var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.store.getState();
    return this.getJSON(state);
  }
  insertHtml(html, options) {
    return (props) => {
      var state = props.state;
      var fragment = htmlToProsemirrorNode({
        content: html,
        schema: state.schema,
        fragment: true
      });
      return this.store.commands.insertNode.original(fragment, options)(props);
    };
  }
  getText() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$lineBreakDivider = _ref.lineBreakDivider, lineBreakDivider = _ref$lineBreakDivider === void 0 ? "\n\n" : _ref$lineBreakDivider, _ref$state = _ref.state, state = _ref$state === void 0 ? this.store.getState() : _ref$state;
    return state.doc.textBetween(0, state.doc.content.size, lineBreakDivider, NULL_CHARACTER);
  }
  getTextBetween(from4, to) {
    var doc2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.store.getState().doc;
    return doc2.textBetween(from4, to, "\n\n", NULL_CHARACTER);
  }
  getHTML() {
    var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.store.getState();
    return prosemirrorNodeToHtml(state.doc, this.store.document);
  }
  textToProsemirrorNode(options) {
    var content2 = "<pre>".concat(options.content, "</pre>");
    return this.store.stringHandlers.html(_objectSpread2$3(_objectSpread2$3({}, options), {}, {
      content: content2
    }));
  }
}, _applyDecoratedDescriptor(_class2$2$1.prototype, "isSelectionEmpty", [_dec2$2$1], Object.getOwnPropertyDescriptor(_class2$2$1.prototype, "isSelectionEmpty"), _class2$2$1.prototype), _applyDecoratedDescriptor(_class2$2$1.prototype, "getStateJSON", [_dec3$2$1], Object.getOwnPropertyDescriptor(_class2$2$1.prototype, "getStateJSON"), _class2$2$1.prototype), _applyDecoratedDescriptor(_class2$2$1.prototype, "getJSON", [_dec4$2$1], Object.getOwnPropertyDescriptor(_class2$2$1.prototype, "getJSON"), _class2$2$1.prototype), _applyDecoratedDescriptor(_class2$2$1.prototype, "getRemirrorJSON", [_dec5$1$1], Object.getOwnPropertyDescriptor(_class2$2$1.prototype, "getRemirrorJSON"), _class2$2$1.prototype), _applyDecoratedDescriptor(_class2$2$1.prototype, "insertHtml", [_dec6], Object.getOwnPropertyDescriptor(_class2$2$1.prototype, "insertHtml"), _class2$2$1.prototype), _applyDecoratedDescriptor(_class2$2$1.prototype, "getText", [_dec7], Object.getOwnPropertyDescriptor(_class2$2$1.prototype, "getText"), _class2$2$1.prototype), _applyDecoratedDescriptor(_class2$2$1.prototype, "getTextBetween", [_dec8], Object.getOwnPropertyDescriptor(_class2$2$1.prototype, "getTextBetween"), _class2$2$1.prototype), _applyDecoratedDescriptor(_class2$2$1.prototype, "getHTML", [_dec9], Object.getOwnPropertyDescriptor(_class2$2$1.prototype, "getHTML"), _class2$2$1.prototype), _class2$2$1)) || _class$7$1);
var _dec$6$1, _class$6$1;
var InputRulesExtension = (_dec$6$1 = extension({
  defaultPriority: ExtensionPriority.Default,
  handlerKeys: ["shouldSkipInputRule"],
  handlerKeyOptions: {
    shouldSkipInputRule: {
      earlyReturnValue: true
    }
  }
}), _dec$6$1(_class$6$1 = class InputRulesExtension2 extends PlainExtension {
  get name() {
    return "inputRules";
  }
  onCreate() {
    this.store.setExtensionStore("rebuildInputRules", this.rebuildInputRules.bind(this));
  }
  createExternalPlugins() {
    return [this.generateInputRulesPlugin()];
  }
  generateInputRulesPlugin() {
    var rules = [];
    var invalidMarks2 = this.store.markTags[ExtensionTag.ExcludeInputRules];
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _this$store$managerSe, _extension$options$ex;
        var _extension = _step.value;
        if ((_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.inputRules || !_extension.createInputRules || (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.inputRules) {
          continue;
        }
        var _iterator2 = _createForOfIteratorHelper(_extension.createInputRules()), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var rule = _step2.value;
            rule.shouldSkip = this.options.shouldSkipInputRule;
            rule.invalidMarks = invalidMarks2;
            rules.push(rule);
          }
        } catch (err2) {
          _iterator2.e(err2);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    return inputRules({
      rules
    });
  }
  rebuildInputRules() {
    this.store.updateExtensionPlugins(this);
  }
}) || _class$6$1);
var _dec$5$1, _dec2$1$2, _dec3$1$2, _dec4$1$1, _dec5$4, _class$5$1, _class2$1$2;
var KeymapExtension = (_dec$5$1 = extension({
  defaultPriority: ExtensionPriority.Low,
  defaultOptions: {
    shortcuts: "default",
    undoInputRuleOnBackspace: true,
    selectParentNodeOnEscape: false,
    excludeBaseKeymap: false,
    exitMarksOnArrowPress: true
  },
  customHandlerKeys: ["keymap"]
}), _dec2$1$2 = keyBinding({
  shortcut: "ArrowRight",
  isActive: (options) => options.exitMarksOnArrowPress
}), _dec3$1$2 = keyBinding({
  shortcut: "ArrowLeft",
  isActive: (options) => options.exitMarksOnArrowPress
}), _dec4$1$1 = keyBinding({
  shortcut: "Backspace",
  isActive: (options) => options.exitMarksOnArrowPress
}), _dec5$4 = helper(), _dec$5$1(_class$5$1 = (_class2$1$2 = class KeymapExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "extraKeyBindings", []);
    _defineProperty$3(this, "backwardMarkExitTracker", /* @__PURE__ */ new Map());
    _defineProperty$3(this, "onAddCustomHandler", (_ref) => {
      var _this$store$rebuildKe, _this$store;
      var keymap2 = _ref.keymap;
      if (!keymap2) {
        return;
      }
      this.extraKeyBindings = [...this.extraKeyBindings, keymap2];
      (_this$store$rebuildKe = (_this$store = this.store).rebuildKeymap) === null || _this$store$rebuildKe === void 0 ? void 0 : _this$store$rebuildKe.call(_this$store);
      return () => {
        var _this$store$rebuildKe2, _this$store2;
        this.extraKeyBindings = this.extraKeyBindings.filter((binding) => binding !== keymap2);
        (_this$store$rebuildKe2 = (_this$store2 = this.store).rebuildKeymap) === null || _this$store$rebuildKe2 === void 0 ? void 0 : _this$store$rebuildKe2.call(_this$store2);
      };
    });
    _defineProperty$3(this, "rebuildKeymap", () => {
      this.store.updateExtensionPlugins(this);
    });
  }
  get name() {
    return "keymap";
  }
  get shortcutMap() {
    var shortcuts2 = this.options.shortcuts;
    return isString$1(shortcuts2) ? keyboardShortcuts[shortcuts2] : shortcuts2;
  }
  onCreate() {
    this.store.setExtensionStore("rebuildKeymap", this.rebuildKeymap);
  }
  createExternalPlugins() {
    var _this$store$managerSe;
    if ((_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.keymap) {
      return [];
    }
    return [this.generateKeymap()];
  }
  generateKeymap() {
    var extensionKeymaps = [];
    var shortcutMap = this.shortcutMap;
    var commandsExtension = this.store.getExtension(CommandsExtension);
    var extractNamesFactory = (extension2) => (shortcut) => extractShortcutNames({
      shortcut,
      map: shortcutMap,
      store: this.store,
      options: extension2.options
    });
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _extension$decoratedK, _extension$options$ex;
        var _extension = _step.value;
        var decoratedKeybindings = (_extension$decoratedK = _extension.decoratedKeybindings) !== null && _extension$decoratedK !== void 0 ? _extension$decoratedK : {};
        if ((_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.keymap) {
          continue;
        }
        if (_extension.createKeymap) {
          extensionKeymaps.push(updateNamedKeys(_extension.createKeymap(extractNamesFactory(_extension)), shortcutMap));
        }
        var _iterator2 = _createForOfIteratorHelper(entries(decoratedKeybindings)), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _options$priority;
            var _step2$value = _slicedToArray(_step2.value, 2), name = _step2$value[0], options = _step2$value[1];
            if (options.isActive && !options.isActive(_extension.options, this.store)) {
              continue;
            }
            var _keyBinding = _extension[name].bind(_extension);
            var shortcutNames = extractShortcutNames({
              shortcut: options.shortcut,
              map: shortcutMap,
              options: _extension.options,
              store: this.store
            });
            var _priority = isFunction$1(options.priority) ? options.priority(_extension.options, this.store) : (_options$priority = options.priority) !== null && _options$priority !== void 0 ? _options$priority : ExtensionPriority.Low;
            var bindingObject = object();
            var _iterator3 = _createForOfIteratorHelper(shortcutNames), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var _shortcut = _step3.value;
                bindingObject[_shortcut] = _keyBinding;
              }
            } catch (err2) {
              _iterator3.e(err2);
            } finally {
              _iterator3.f();
            }
            extensionKeymaps.push([_priority, bindingObject]);
            if (options.command) {
              commandsExtension.updateDecorated(options.command, {
                shortcut: shortcutNames
              });
            }
          }
        } catch (err2) {
          _iterator2.e(err2);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    var sortedKeymaps = this.sortKeymaps([...this.extraKeyBindings, ...extensionKeymaps]);
    var mappedCommands = mergeProsemirrorKeyBindings(sortedKeymaps);
    return keymap(mappedCommands);
  }
  arrowRightShortcut(props) {
    var excludedMarks = this.store.markTags[ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[ExtensionTag.PreventExits];
    return this.exitMarkForwards(excludedMarks, excludedNodes)(props);
  }
  arrowLeftShortcut(props) {
    var excludedMarks = this.store.markTags[ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[ExtensionTag.PreventExits];
    return chainKeyBindingCommands(this.exitNodeBackwards(excludedNodes), this.exitMarkBackwards(excludedMarks, excludedNodes))(props);
  }
  backspace(props) {
    var excludedMarks = this.store.markTags[ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[ExtensionTag.PreventExits];
    return chainKeyBindingCommands(this.exitNodeBackwards(excludedNodes, true), this.exitMarkBackwards(excludedMarks, excludedNodes, true))(props);
  }
  createKeymap() {
    var _this$options = this.options, selectParentNodeOnEscape = _this$options.selectParentNodeOnEscape, undoInputRuleOnBackspace = _this$options.undoInputRuleOnBackspace, excludeBaseKeymap = _this$options.excludeBaseKeymap;
    var baseKeyBindings = object();
    if (!excludeBaseKeymap) {
      var _iterator4 = _createForOfIteratorHelper(entries(baseKeymap)), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var _step4$value = _slicedToArray(_step4.value, 2), key = _step4$value[0], value = _step4$value[1];
          baseKeyBindings[key] = convertCommand(value);
        }
      } catch (err2) {
        _iterator4.e(err2);
      } finally {
        _iterator4.f();
      }
    }
    if (undoInputRuleOnBackspace && baseKeymap.Backspace) {
      baseKeyBindings.Backspace = convertCommand(chainCommands(undoInputRule, baseKeymap.Backspace));
    }
    if (selectParentNodeOnEscape) {
      baseKeyBindings.Escape = convertCommand(selectParentNode);
    }
    return [ExtensionPriority.Low, baseKeyBindings];
  }
  getNamedShortcut(shortcut) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!shortcut.startsWith("_|")) {
      return [shortcut];
    }
    return extractShortcutNames({
      shortcut,
      map: this.shortcutMap,
      store: this.store,
      options
    });
  }
  onSetOptions(props) {
    var changes = props.changes;
    if (changes.excludeBaseKeymap.changed || changes.selectParentNodeOnEscape.changed || changes.undoInputRuleOnBackspace.changed) {
      var _this$store$rebuildKe3, _this$store3;
      (_this$store$rebuildKe3 = (_this$store3 = this.store).rebuildKeymap) === null || _this$store$rebuildKe3 === void 0 ? void 0 : _this$store$rebuildKe3.call(_this$store3);
    }
  }
  sortKeymaps(bindings) {
    return sort(bindings.map((binding) => isArray(binding) ? binding : [ExtensionPriority.Default, binding]), (a2, z2) => z2[0] - a2[0]).map((binding) => binding[1]);
  }
  exitMarkForwards(excludedMarks, excludedNodes) {
    return (props) => {
      var tr = props.tr, dispatch2 = props.dispatch;
      if (!isEndOfTextBlock(tr.selection)) {
        return false;
      }
      var isInsideExcludedNode = findParentNodeOfType({
        selection: tr.selection,
        types: excludedNodes
      });
      if (isInsideExcludedNode) {
        return false;
      }
      var $pos = tr.selection.$from;
      var marksToRemove = $pos.marks().filter((mark4) => !excludedMarks.includes(mark4.type.name));
      if (isEmptyArray(marksToRemove)) {
        return false;
      }
      if (!dispatch2) {
        return true;
      }
      var _iterator5 = _createForOfIteratorHelper(marksToRemove), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var mark3 = _step5.value;
          tr.removeStoredMark(mark3);
        }
      } catch (err2) {
        _iterator5.e(err2);
      } finally {
        _iterator5.f();
      }
      dispatch2(tr.insertText(" ", tr.selection.from));
      return true;
    };
  }
  exitNodeBackwards(excludedNodes) {
    var startOfDoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return (props) => {
      var tr = props.tr;
      var checker = startOfDoc ? isStartOfDoc : isStartOfTextBlock;
      if (!checker(tr.selection)) {
        return false;
      }
      var node4 = tr.selection.$anchor.node();
      if (!isEmptyBlockNode(node4) || isDefaultBlockNode(node4) || excludedNodes.includes(node4.type.name)) {
        return false;
      }
      return this.store.commands.toggleBlockNodeItem.original({
        type: node4.type
      })(props);
    };
  }
  exitMarkBackwards(excludedMarks, excludedNodes) {
    var startOfDoc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return (props) => {
      var _tr$storedMarks;
      var tr = props.tr, dispatch2 = props.dispatch;
      var checker = startOfDoc ? isStartOfDoc : isStartOfTextBlock;
      if (!checker(tr.selection) || this.backwardMarkExitTracker.has(tr.selection.anchor)) {
        this.backwardMarkExitTracker.clear();
        return false;
      }
      var isInsideExcludedNode = findParentNodeOfType({
        selection: tr.selection,
        types: excludedNodes
      });
      if (isInsideExcludedNode) {
        return false;
      }
      var marksToRemove = [...(_tr$storedMarks = tr.storedMarks) !== null && _tr$storedMarks !== void 0 ? _tr$storedMarks : [], ...tr.selection.$from.marks()].filter((mark4) => !excludedMarks.includes(mark4.type.name));
      if (isEmptyArray(marksToRemove)) {
        return false;
      }
      if (!dispatch2) {
        return true;
      }
      var _iterator6 = _createForOfIteratorHelper(marksToRemove), _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
          var mark3 = _step6.value;
          tr.removeStoredMark(mark3);
        }
      } catch (err2) {
        _iterator6.e(err2);
      } finally {
        _iterator6.f();
      }
      this.backwardMarkExitTracker.set(tr.selection.anchor, true);
      dispatch2(tr);
      return true;
    };
  }
}, _applyDecoratedDescriptor(_class2$1$2.prototype, "arrowRightShortcut", [_dec2$1$2], Object.getOwnPropertyDescriptor(_class2$1$2.prototype, "arrowRightShortcut"), _class2$1$2.prototype), _applyDecoratedDescriptor(_class2$1$2.prototype, "arrowLeftShortcut", [_dec3$1$2], Object.getOwnPropertyDescriptor(_class2$1$2.prototype, "arrowLeftShortcut"), _class2$1$2.prototype), _applyDecoratedDescriptor(_class2$1$2.prototype, "backspace", [_dec4$1$1], Object.getOwnPropertyDescriptor(_class2$1$2.prototype, "backspace"), _class2$1$2.prototype), _applyDecoratedDescriptor(_class2$1$2.prototype, "getNamedShortcut", [_dec5$4], Object.getOwnPropertyDescriptor(_class2$1$2.prototype, "getNamedShortcut"), _class2$1$2.prototype), _class2$1$2)) || _class$5$1);
function isNamedShortcut(value) {
  return includes(values(NamedShortcut), value);
}
function extractShortcutNames(_ref2) {
  var shortcut = _ref2.shortcut, map16 = _ref2.map, options = _ref2.options, store2 = _ref2.store;
  if (isString$1(shortcut)) {
    return [normalizeShortcutName(shortcut, map16)];
  }
  if (isArray(shortcut)) {
    return shortcut.map((value) => normalizeShortcutName(value, map16));
  }
  shortcut = shortcut(options, store2);
  return extractShortcutNames({
    shortcut,
    map: map16,
    options,
    store: store2
  });
}
function normalizeShortcutName(value, shortcutMap) {
  return isNamedShortcut(value) ? shortcutMap[value] : value;
}
function updateNamedKeys(prioritizedBindings, shortcutMap) {
  var updatedBindings = {};
  var previousBindings;
  var priority;
  if (isArray(prioritizedBindings)) {
    var _prioritizedBindings = _slicedToArray(prioritizedBindings, 2);
    priority = _prioritizedBindings[0];
    previousBindings = _prioritizedBindings[1];
  } else {
    previousBindings = prioritizedBindings;
  }
  var _iterator7 = _createForOfIteratorHelper(entries(previousBindings)), _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
      var _step7$value = _slicedToArray(_step7.value, 2), shortcutName = _step7$value[0], commandFunction = _step7$value[1];
      updatedBindings[normalizeShortcutName(shortcutName, shortcutMap)] = commandFunction;
    }
  } catch (err2) {
    _iterator7.e(err2);
  } finally {
    _iterator7.f();
  }
  return isUndefined(priority) ? updatedBindings : [priority, updatedBindings];
}
var DEFAULT_SHORTCUTS = {
  [NamedShortcut.Copy]: "Mod-c",
  [NamedShortcut.Cut]: "Mod-x",
  [NamedShortcut.Paste]: "Mod-p",
  [NamedShortcut.PastePlain]: "Mod-Shift-p",
  [NamedShortcut.SelectAll]: "Mod-a",
  [NamedShortcut.Undo]: "Mod-z",
  [NamedShortcut.Redo]: environment.isMac ? "Shift-Mod-z" : "Mod-y",
  [NamedShortcut.Bold]: "Mod-b",
  [NamedShortcut.Italic]: "Mod-i",
  [NamedShortcut.Underline]: "Mod-u",
  [NamedShortcut.Strike]: "Mod-d",
  [NamedShortcut.Code]: "Mod-`",
  [NamedShortcut.Paragraph]: "Mod-Shift-0",
  [NamedShortcut.H1]: "Mod-Shift-1",
  [NamedShortcut.H2]: "Mod-Shift-2",
  [NamedShortcut.H3]: "Mod-Shift-3",
  [NamedShortcut.H4]: "Mod-Shift-4",
  [NamedShortcut.H5]: "Mod-Shift-5",
  [NamedShortcut.H6]: "Mod-Shift-6",
  [NamedShortcut.TaskList]: "Mod-Shift-7",
  [NamedShortcut.BulletList]: "Mod-Shift-8",
  [NamedShortcut.OrderedList]: "Mod-Shift-9",
  [NamedShortcut.Quote]: "Mod->",
  [NamedShortcut.Divider]: "Mod-Shift-|",
  [NamedShortcut.Codeblock]: "Mod-Shift-~",
  [NamedShortcut.ClearFormatting]: "Mod-Shift-C",
  [NamedShortcut.Superscript]: "Mod-.",
  [NamedShortcut.Subscript]: "Mod-,",
  [NamedShortcut.LeftAlignment]: "Mod-Shift-L",
  [NamedShortcut.CenterAlignment]: "Mod-Shift-E",
  [NamedShortcut.RightAlignment]: "Mod-Shift-R",
  [NamedShortcut.JustifyAlignment]: "Mod-Shift-J",
  [NamedShortcut.InsertLink]: "Mod-k",
  [NamedShortcut.Find]: "Mod-f",
  [NamedShortcut.FindBackwards]: "Mod-Shift-f",
  [NamedShortcut.FindReplace]: "Mod-Shift-H",
  [NamedShortcut.AddFootnote]: "Mod-Alt-f",
  [NamedShortcut.AddComment]: "Mod-Alt-m",
  [NamedShortcut.ContextMenu]: "Mod-Shift-\\",
  [NamedShortcut.IncreaseFontSize]: "Mod-Shift-.",
  [NamedShortcut.DecreaseFontSize]: "Mod-Shift-,",
  [NamedShortcut.IncreaseIndent]: "Tab",
  [NamedShortcut.DecreaseIndent]: "Shift-Tab",
  [NamedShortcut.Shortcuts]: "Mod-/",
  [NamedShortcut.Format]: environment.isMac ? "Alt-Shift-f" : "Shift-Ctrl-f"
};
var GOOGLE_DOC_SHORTCUTS = _objectSpread2$3(_objectSpread2$3({}, DEFAULT_SHORTCUTS), {}, {
  [NamedShortcut.Strike]: "Mod-Shift-S",
  [NamedShortcut.Code]: "Mod-Shift-M",
  [NamedShortcut.Paragraph]: "Mod-Alt-0",
  [NamedShortcut.H1]: "Mod-Alt-1",
  [NamedShortcut.H2]: "Mod-Alt-2",
  [NamedShortcut.H3]: "Mod-Alt-3",
  [NamedShortcut.H4]: "Mod-Alt-4",
  [NamedShortcut.H5]: "Mod-Alt-5",
  [NamedShortcut.H6]: "Mod-Alt-6",
  [NamedShortcut.OrderedList]: "Mod-Alt-7",
  [NamedShortcut.BulletList]: "Mod-Alt-8",
  [NamedShortcut.Quote]: "Mod-Alt-9",
  [NamedShortcut.ClearFormatting]: "Mod-\\",
  [NamedShortcut.IncreaseIndent]: "Mod-[",
  [NamedShortcut.DecreaseIndent]: "Mod-]"
});
var keyboardShortcuts = {
  default: DEFAULT_SHORTCUTS,
  googleDoc: GOOGLE_DOC_SHORTCUTS
};
class NodeViewsExtension extends PlainExtension {
  get name() {
    return "nodeViews";
  }
  createPlugin() {
    var _this$store$managerSe;
    var nodeViewList = [];
    var nodeViews = object();
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var extension2 = _step.value;
        if (!extension2.createNodeViews) {
          continue;
        }
        var _nodeView = extension2.createNodeViews();
        nodeViewList.unshift(isFunction$1(_nodeView) ? {
          [extension2.name]: _nodeView
        } : _nodeView);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    nodeViewList.unshift((_this$store$managerSe = this.store.managerSettings.nodeViews) !== null && _this$store$managerSe !== void 0 ? _this$store$managerSe : {});
    for (var _i = 0, _nodeViewList = nodeViewList; _i < _nodeViewList.length; _i++) {
      var nodeView = _nodeViewList[_i];
      Object.assign(nodeViews, nodeView);
    }
    return {
      props: {
        nodeViews
      }
    };
  }
}
class PasteRulesExtension extends PlainExtension {
  get name() {
    return "pasteRules";
  }
  createExternalPlugins() {
    return [this.generatePasteRulesPlugin()];
  }
  generatePasteRulesPlugin() {
    var extensionPasteRules = [];
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _this$store$managerSe, _extension$options$ex;
        var extension2 = _step.value;
        if ((_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.pasteRules || !extension2.createPasteRules || (_extension$options$ex = extension2.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.pasteRules) {
          continue;
        }
        var value = extension2.createPasteRules();
        var rules = isArray(value) ? value : [value];
        extensionPasteRules.push(...rules);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    return pasteRules(extensionPasteRules);
  }
}
var _dec$4$1, _class$4$1;
var PluginsExtension = (_dec$4$1 = extension({
  defaultPriority: ExtensionPriority.Highest,
  handlerKeys: ["applyState", "appendTransaction"]
}), _dec$4$1(_class$4$1 = class PluginsExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "plugins", []);
    _defineProperty$3(this, "managerPlugins", []);
    _defineProperty$3(this, "applyStateHandlers", []);
    _defineProperty$3(this, "initStateHandlers", []);
    _defineProperty$3(this, "appendTransactionHandlers", []);
    _defineProperty$3(this, "pluginKeys", object());
    _defineProperty$3(this, "stateGetters", /* @__PURE__ */ new Map());
    _defineProperty$3(this, "getPluginStateCreator", (key) => (state) => {
      return key.getState(state !== null && state !== void 0 ? state : this.store.getState());
    });
    _defineProperty$3(this, "getStateByName", (identifier) => {
      var stateGetter = this.stateGetters.get(identifier);
      !stateGetter ? invariant(false, {
        message: "No plugin exists for the requested extension name."
      }) : void 0;
      return stateGetter();
    });
  }
  get name() {
    return "plugins";
  }
  onCreate() {
    var _this$store = this.store, setStoreKey = _this$store.setStoreKey, setExtensionStore = _this$store.setExtensionStore, managerSettings = _this$store.managerSettings, extensions = _this$store.extensions;
    this.updateExtensionStore();
    var _managerSettings$plug = managerSettings.plugins, plugins = _managerSettings$plug === void 0 ? [] : _managerSettings$plug;
    this.updatePlugins(plugins, this.managerPlugins);
    var _iterator = _createForOfIteratorHelper(extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _extension = _step.value;
        if (_extension.onApplyState) {
          this.applyStateHandlers.push(_extension.onApplyState.bind(_extension));
        }
        if (_extension.onInitState) {
          this.initStateHandlers.push(_extension.onInitState.bind(_extension));
        }
        if (_extension.onAppendTransaction) {
          this.appendTransactionHandlers.push(_extension.onAppendTransaction.bind(_extension));
        }
        this.extractExtensionPlugins(_extension);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    this.managerPlugins = plugins;
    this.store.setStoreKey("plugins", this.plugins);
    setStoreKey("pluginKeys", this.pluginKeys);
    setStoreKey("getPluginState", this.getStateByName);
    setExtensionStore("getPluginState", this.getStateByName);
  }
  createPlugin() {
    return {
      appendTransaction: (transactions, previousState, state) => {
        var tr = state.tr;
        var props = {
          previousState,
          tr,
          transactions,
          state
        };
        var _iterator2 = _createForOfIteratorHelper(this.appendTransactionHandlers), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var handler = _step2.value;
            handler(props);
          }
        } catch (err2) {
          _iterator2.e(err2);
        } finally {
          _iterator2.f();
        }
        this.options.appendTransaction(props);
        return tr.docChanged || tr.steps.length > 0 || tr.selectionSet || tr.storedMarksSet ? tr : void 0;
      },
      state: {
        init: (_2, state) => {
          var _iterator3 = _createForOfIteratorHelper(this.initStateHandlers), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var handler = _step3.value;
              handler(state);
            }
          } catch (err2) {
            _iterator3.e(err2);
          } finally {
            _iterator3.f();
          }
        },
        apply: (tr, _2, previousState, state) => {
          var props = {
            previousState,
            state,
            tr
          };
          var _iterator4 = _createForOfIteratorHelper(this.applyStateHandlers), _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var handler = _step4.value;
              handler(props);
            }
          } catch (err2) {
            _iterator4.e(err2);
          } finally {
            _iterator4.f();
          }
          this.options.applyState(props);
        }
      }
    };
  }
  extractExtensionPlugins(extension2) {
    var _this$store$managerSe, _extension$options$ex;
    var isNotPluginCreator = !extension2.createPlugin && !extension2.createExternalPlugins;
    if (isNotPluginCreator || (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.plugins || (_extension$options$ex = extension2.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.plugins) {
      return;
    }
    if (extension2.createPlugin) {
      var key = new PluginKey(extension2.name);
      this.pluginKeys[extension2.name] = key;
      var getter = this.getPluginStateCreator(key);
      extension2.pluginKey = key;
      extension2.constructor.prototype.getPluginState = getter;
      this.stateGetters.set(extension2.name, getter);
      this.stateGetters.set(extension2.constructor, getter);
      var pluginSpec = _objectSpread2$3(_objectSpread2$3({}, extension2.createPlugin()), {}, {
        key
      });
      var plugin = new Plugin(pluginSpec);
      this.updatePlugins([plugin], extension2.plugin ? [extension2.plugin] : void 0);
      extension2.plugin = plugin;
    }
    if (extension2.createExternalPlugins) {
      var externalPlugins = extension2.createExternalPlugins();
      this.updatePlugins(externalPlugins, extension2.externalPlugins);
      extension2.externalPlugins = externalPlugins;
    }
  }
  updatePlugins(plugins, previous) {
    if (!previous || isEmptyArray(previous)) {
      this.plugins = [...this.plugins, ...plugins];
      return;
    }
    if (plugins.length !== previous.length) {
      this.plugins = [...this.plugins.filter((plugin2) => !previous.includes(plugin2)), ...plugins];
      return;
    }
    var pluginMap = /* @__PURE__ */ new Map();
    var _iterator5 = _createForOfIteratorHelper(plugins.entries()), _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
        var _step5$value = _slicedToArray(_step5.value, 2), index3 = _step5$value[0], plugin = _step5$value[1];
        pluginMap.set(assertGet(previous, index3), plugin);
      }
    } catch (err2) {
      _iterator5.e(err2);
    } finally {
      _iterator5.f();
    }
    this.plugins = this.plugins.map((plugin2) => {
      return previous.includes(plugin2) ? pluginMap.get(plugin2) : plugin2;
    });
  }
  updateExtensionStore() {
    var setExtensionStore = this.store.setExtensionStore;
    setExtensionStore("updatePlugins", this.updatePlugins.bind(this));
    setExtensionStore("dispatchPluginUpdate", this.dispatchPluginUpdate.bind(this));
    setExtensionStore("updateExtensionPlugins", this.updateExtensionPlugins.bind(this));
  }
  updateExtensionPlugins(value) {
    var extension2 = isExtension(value) ? value : isExtensionConstructor(value) ? this.store.manager.getExtension(value) : this.store.extensions.find((extension3) => extension3.name === value);
    !extension2 ? invariant(false, {
      code: ErrorConstant.INVALID_MANAGER_EXTENSION,
      message: "The extension ".concat(value, " does not exist within the editor.")
    }) : void 0;
    this.extractExtensionPlugins(extension2);
    this.store.setStoreKey("plugins", this.plugins);
    this.dispatchPluginUpdate();
  }
  dispatchPluginUpdate() {
    !(this.store.phase >= ManagerPhase.EditorView) ? invariant(false, {
      code: ErrorConstant.MANAGER_PHASE_ERROR,
      message: "`dispatchPluginUpdate` should only be called after the view has been added to the manager."
    }) : void 0;
    var _this$store2 = this.store, view = _this$store2.view, updateState2 = _this$store2.updateState;
    var newState = view.state.reconfigure({
      plugins: this.plugins
    });
    updateState2(newState);
  }
}) || _class$4$1);
var _excluded$c = ["parseDOM"];
var _dec$3$1, _class$3$1;
var SchemaExtension = (_dec$3$1 = extension({
  defaultPriority: ExtensionPriority.Highest
}), _dec$3$1(_class$3$1 = class SchemaExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "dynamicAttributes", {
      marks: object(),
      nodes: object()
    });
  }
  get name() {
    return "schema";
  }
  onCreate() {
    var _this = this;
    var _this$store = this.store, managerSettings = _this$store.managerSettings, tags = _this$store.tags, markNames = _this$store.markNames, nodeNames = _this$store.nodeNames, extensions = _this$store.extensions;
    var defaultBlockNode = managerSettings.defaultBlockNode, disableExtraAttributes = managerSettings.disableExtraAttributes, nodeOverride = managerSettings.nodeOverride, markOverride = managerSettings.markOverride;
    var isValidDefaultBlockNode = (name) => !!(name && tags[ExtensionTag.Block].includes(name));
    if (managerSettings.schema) {
      var _getSpecFromSchema = getSpecFromSchema(managerSettings.schema), _nodes = _getSpecFromSchema.nodes, _marks = _getSpecFromSchema.marks;
      this.addSchema(managerSettings.schema, _nodes, _marks);
      return;
    }
    var nodes = isValidDefaultBlockNode(defaultBlockNode) ? {
      doc: object(),
      [defaultBlockNode]: object()
    } : object();
    var marks2 = object();
    var namedExtraAttributes = getNamedSchemaAttributes({
      settings: managerSettings,
      gatheredSchemaAttributes: this.gatherExtraAttributes(extensions),
      nodeNames,
      markNames,
      tags
    });
    var _iterator = _createForOfIteratorHelper(extensions), _step;
    try {
      var _loop = function _loop2() {
        var extension2 = _step.value;
        namedExtraAttributes[extension2.name] = _objectSpread2$3(_objectSpread2$3({}, namedExtraAttributes[extension2.name]), extension2.options.extraAttributes);
        var ignoreExtraAttributes = disableExtraAttributes === true || extension2.options.disableExtraAttributes === true || extension2.constructor.disableExtraAttributes === true;
        if (isNodeExtension(extension2)) {
          var _createSpec = createSpec({
            createExtensionSpec: (extra, override) => extension2.createNodeSpec(extra, override),
            extraAttributes: assertGet(namedExtraAttributes, extension2.name),
            override: _objectSpread2$3(_objectSpread2$3({}, nodeOverride), extension2.options.nodeOverride),
            ignoreExtraAttributes,
            name: extension2.constructorName,
            tags: extension2.tags
          }), spec = _createSpec.spec, dynamic = _createSpec.dynamic;
          extension2.spec = spec;
          nodes[extension2.name] = spec;
          if (Object.keys(dynamic).length > 0) {
            _this.dynamicAttributes.nodes[extension2.name] = dynamic;
          }
        }
        if (isMarkExtension(extension2)) {
          var _extension$tags;
          var _createSpec2 = createSpec({
            createExtensionSpec: (extra, override) => extension2.createMarkSpec(extra, override),
            extraAttributes: assertGet(namedExtraAttributes, extension2.name),
            override: _objectSpread2$3(_objectSpread2$3({}, markOverride), extension2.options.markOverride),
            ignoreExtraAttributes,
            name: extension2.constructorName,
            tags: (_extension$tags = extension2.tags) !== null && _extension$tags !== void 0 ? _extension$tags : []
          }), _spec = _createSpec2.spec, _dynamic = _createSpec2.dynamic;
          extension2.spec = _spec;
          marks2[extension2.name] = _spec;
          if (Object.keys(_dynamic).length > 0) {
            _this.dynamicAttributes.marks[extension2.name] = _dynamic;
          }
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    var schema = new Schema({
      nodes,
      marks: marks2,
      topNode: "doc"
    });
    this.addSchema(schema, nodes, marks2);
  }
  createPlugin() {
    return {
      appendTransaction: (transactions, _2, nextState) => {
        var tr = nextState.tr;
        var documentHasChanged = transactions.some((tr2) => tr2.docChanged);
        if (!documentHasChanged) {
          return null;
        }
        if (Object.keys(this.dynamicAttributes.nodes).length === 0 && Object.keys(this.dynamicAttributes.marks).length === 0) {
          return null;
        }
        tr.doc.descendants((child3, pos) => {
          this.checkAndUpdateDynamicNodes(child3, pos, tr);
          this.checkAndUpdateDynamicMarks(child3, pos, tr);
          return true;
        });
        return tr.steps.length > 0 ? tr : null;
      }
    };
  }
  addSchema(schema, nodes, marks2) {
    this.store.setStoreKey("nodes", nodes);
    this.store.setStoreKey("marks", marks2);
    this.store.setStoreKey("schema", schema);
    this.store.setExtensionStore("schema", schema);
    this.store.setStoreKey("defaultBlockNode", getDefaultBlockNode(schema).name);
    for (var _i = 0, _Object$values = Object.values(schema.nodes); _i < _Object$values.length; _i++) {
      var type2 = _Object$values[_i];
      if (type2.name === "doc") {
        continue;
      }
      if (type2.isBlock || type2.isTextblock) {
        break;
      }
    }
  }
  checkAndUpdateDynamicNodes(node4, pos, tr) {
    var _iterator2 = _createForOfIteratorHelper(entries(this.dynamicAttributes.nodes)), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _step2$value = _slicedToArray(_step2.value, 2), _name = _step2$value[0], dynamic = _step2$value[1];
        if (node4.type.name !== _name) {
          continue;
        }
        var _iterator3 = _createForOfIteratorHelper(entries(dynamic)), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), attributeName = _step3$value[0], attributeCreator = _step3$value[1];
            if (!isNullOrUndefined(node4.attrs[attributeName])) {
              continue;
            }
            var attrs = _objectSpread2$3(_objectSpread2$3({}, node4.attrs), {}, {
              [attributeName]: attributeCreator(node4)
            });
            tr.setNodeMarkup(pos, void 0, attrs);
            ignoreUpdateForSuggest(tr);
          }
        } catch (err2) {
          _iterator3.e(err2);
        } finally {
          _iterator3.f();
        }
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
  }
  checkAndUpdateDynamicMarks(node4, pos, tr) {
    var _this2 = this;
    var _iterator4 = _createForOfIteratorHelper(entries(this.dynamicAttributes.marks)), _step4;
    try {
      var _loop2 = function _loop22() {
        var _step4$value = _slicedToArray(_step4.value, 2), name = _step4$value[0], dynamic = _step4$value[1];
        var type2 = assertGet(_this2.store.schema.marks, name);
        var mark3 = node4.marks.find((mark4) => mark4.type.name === name);
        if (!mark3) {
          return "continue";
        }
        var _iterator5 = _createForOfIteratorHelper(entries(dynamic)), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var _step5$value = _slicedToArray(_step5.value, 2), attributeName = _step5$value[0], attributeCreator = _step5$value[1];
            if (!isNullOrUndefined(mark3.attrs[attributeName])) {
              continue;
            }
            var range2 = getMarkRange(tr.doc.resolve(pos), type2);
            if (!range2) {
              continue;
            }
            var from4 = range2.from, to = range2.to;
            var newMark = type2.create(_objectSpread2$3(_objectSpread2$3({}, mark3.attrs), {}, {
              [attributeName]: attributeCreator(mark3)
            }));
            tr.removeMark(from4, to, type2).addMark(from4, to, newMark);
            ignoreUpdateForSuggest(tr);
          }
        } catch (err2) {
          _iterator5.e(err2);
        } finally {
          _iterator5.f();
        }
      };
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
        var _ret = _loop2();
        if (_ret === "continue")
          continue;
      }
    } catch (err2) {
      _iterator4.e(err2);
    } finally {
      _iterator4.f();
    }
  }
  gatherExtraAttributes(extensions) {
    var extraSchemaAttributes = [];
    var _iterator6 = _createForOfIteratorHelper(extensions), _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
        var _extension = _step6.value;
        if (!_extension.createSchemaAttributes) {
          continue;
        }
        extraSchemaAttributes.push(..._extension.createSchemaAttributes());
      }
    } catch (err2) {
      _iterator6.e(err2);
    } finally {
      _iterator6.f();
    }
    return extraSchemaAttributes;
  }
}) || _class$3$1);
function getNamedSchemaAttributes(props) {
  var _settings$extraAttrib;
  var settings = props.settings, gatheredSchemaAttributes = props.gatheredSchemaAttributes, nodeNames = props.nodeNames, markNames = props.markNames, tags = props.tags;
  var extraAttributes = object();
  if (settings.disableExtraAttributes) {
    return extraAttributes;
  }
  var extraSchemaAttributes = [...gatheredSchemaAttributes, ...(_settings$extraAttrib = settings.extraAttributes) !== null && _settings$extraAttrib !== void 0 ? _settings$extraAttrib : []];
  for (var _i2 = 0, _arr = extraSchemaAttributes !== null && extraSchemaAttributes !== void 0 ? extraSchemaAttributes : []; _i2 < _arr.length; _i2++) {
    var attributeGroup = _arr[_i2];
    var identifiers = getIdentifiers({
      identifiers: attributeGroup.identifiers,
      nodeNames,
      markNames,
      tags
    });
    var _iterator7 = _createForOfIteratorHelper(identifiers), _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
        var _extraAttributes$iden;
        var identifier = _step7.value;
        var currentValue = (_extraAttributes$iden = extraAttributes[identifier]) !== null && _extraAttributes$iden !== void 0 ? _extraAttributes$iden : {};
        extraAttributes[identifier] = _objectSpread2$3(_objectSpread2$3({}, currentValue), attributeGroup.attributes);
      }
    } catch (err2) {
      _iterator7.e(err2);
    } finally {
      _iterator7.f();
    }
  }
  return extraAttributes;
}
function isIdentifiersObject(value) {
  return isPlainObject$1(value) && isArray(value.tags);
}
function getIdentifiers(props) {
  var identifiers = props.identifiers, nodeNames = props.nodeNames, markNames = props.markNames, tags = props.tags;
  if (identifiers === "nodes") {
    return nodeNames;
  }
  if (identifiers === "marks") {
    return markNames;
  }
  if (identifiers === "all") {
    return [...nodeNames, ...markNames];
  }
  if (isArray(identifiers)) {
    return identifiers;
  }
  !isIdentifiersObject(identifiers) ? invariant(false, {
    code: ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES,
    message: "Invalid value passed as an identifier when creating `extraAttributes`."
  }) : void 0;
  var _identifiers$tags = identifiers.tags, extensionTags = _identifiers$tags === void 0 ? [] : _identifiers$tags, _identifiers$names = identifiers.names, extensionNames = _identifiers$names === void 0 ? [] : _identifiers$names, _identifiers$behavior = identifiers.behavior, behavior = _identifiers$behavior === void 0 ? "any" : _identifiers$behavior, excludeNames = identifiers.excludeNames, excludeTags = identifiers.excludeTags, type2 = identifiers.type;
  var names = /* @__PURE__ */ new Set();
  var acceptableNames = type2 === "mark" ? markNames : type2 === "node" ? nodeNames : [...markNames, ...nodeNames];
  var isNameValid = (name) => acceptableNames.includes(name) && !(excludeNames !== null && excludeNames !== void 0 && excludeNames.includes(name));
  var _iterator8 = _createForOfIteratorHelper(extensionNames), _step8;
  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
      var _name2 = _step8.value;
      if (isNameValid(_name2)) {
        names.add(_name2);
      }
    }
  } catch (err2) {
    _iterator8.e(err2);
  } finally {
    _iterator8.f();
  }
  var taggedNamesMap = /* @__PURE__ */ new Map();
  var _iterator9 = _createForOfIteratorHelper(extensionTags), _step9;
  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
      var tag = _step9.value;
      if (excludeTags !== null && excludeTags !== void 0 && excludeTags.includes(tag)) {
        continue;
      }
      var _iterator11 = _createForOfIteratorHelper(tags[tag]), _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
          var _taggedNamesMap$get;
          var _name3 = _step11.value;
          if (!isNameValid(_name3)) {
            continue;
          }
          if (behavior === "any") {
            names.add(_name3);
            continue;
          }
          var tagSet = (_taggedNamesMap$get = taggedNamesMap.get(_name3)) !== null && _taggedNamesMap$get !== void 0 ? _taggedNamesMap$get : /* @__PURE__ */ new Set();
          tagSet.add(tag);
          taggedNamesMap.set(_name3, tagSet);
        }
      } catch (err2) {
        _iterator11.e(err2);
      } finally {
        _iterator11.f();
      }
    }
  } catch (err2) {
    _iterator9.e(err2);
  } finally {
    _iterator9.f();
  }
  var _iterator10 = _createForOfIteratorHelper(taggedNamesMap), _step10;
  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
      var _step10$value = _slicedToArray(_step10.value, 2), _name4 = _step10$value[0], _tagSet = _step10$value[1];
      if (_tagSet.size === extensionTags.length) {
        names.add(_name4);
      }
    }
  } catch (err2) {
    _iterator10.e(err2);
  } finally {
    _iterator10.f();
  }
  return [...names];
}
function createSpec(props) {
  var _spec$group$split, _spec$group;
  var createExtensionSpec = props.createExtensionSpec, extraAttributes = props.extraAttributes, ignoreExtraAttributes = props.ignoreExtraAttributes, name = props.name, tags = props.tags, override = props.override;
  var dynamic = object();
  function addDynamic(attributeName, creator) {
    dynamic[attributeName] = creator;
  }
  var defaultsCalled = false;
  function onDefaultsCalled() {
    defaultsCalled = true;
  }
  var defaults = createDefaults(extraAttributes, ignoreExtraAttributes, onDefaultsCalled, addDynamic);
  var parse3 = createParseDOM(extraAttributes, ignoreExtraAttributes);
  var dom = createToDOM(extraAttributes, ignoreExtraAttributes);
  var spec = createExtensionSpec({
    defaults,
    parse: parse3,
    dom
  }, override);
  !(ignoreExtraAttributes || defaultsCalled) ? invariant(false, {
    code: ErrorConstant.EXTENSION_SPEC,
    message: "When creating a node specification you must call the 'defaults', and parse, and 'dom' methods. To avoid this error you can set the static property 'disableExtraAttributes' of '".concat(name, "' to 'true'.")
  }) : void 0;
  spec.group = [...(_spec$group$split = (_spec$group = spec.group) === null || _spec$group === void 0 ? void 0 : _spec$group.split(" ")) !== null && _spec$group$split !== void 0 ? _spec$group$split : [], ...tags].join(" ") || void 0;
  return {
    spec,
    dynamic
  };
}
function getExtraAttributesObject(value) {
  if (isString$1(value) || isFunction$1(value)) {
    return {
      default: value
    };
  }
  !value ? invariant(false, {
    message: "".concat(toString(value), " is not supported"),
    code: ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES
  }) : void 0;
  return value;
}
function createDefaults(extraAttributes, shouldIgnore, onCalled, addDynamicCreator) {
  return () => {
    onCalled();
    var attributes = object();
    if (shouldIgnore) {
      return attributes;
    }
    var _iterator12 = _createForOfIteratorHelper(entries(extraAttributes)), _step12;
    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
        var _step12$value = _slicedToArray(_step12.value, 2), _name5 = _step12$value[0], config2 = _step12$value[1];
        var attributesObject = getExtraAttributesObject(config2);
        var defaultValue = attributesObject.default;
        if (isFunction$1(defaultValue)) {
          addDynamicCreator(_name5, defaultValue);
          defaultValue = null;
        }
        attributes[_name5] = defaultValue === void 0 ? {} : {
          default: defaultValue
        };
      }
    } catch (err2) {
      _iterator12.e(err2);
    } finally {
      _iterator12.f();
    }
    return attributes;
  };
}
function createParseDOM(extraAttributes, shouldIgnore) {
  return (domNode) => {
    var attributes = object();
    if (shouldIgnore) {
      return attributes;
    }
    var _iterator13 = _createForOfIteratorHelper(entries(extraAttributes)), _step13;
    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done; ) {
        var _domNode$getAttribute2;
        var _step13$value = _slicedToArray(_step13.value, 2), _name6 = _step13$value[0], config2 = _step13$value[1];
        var _getExtraAttributesOb = getExtraAttributesObject(config2), parseDOM = _getExtraAttributesOb.parseDOM, other = _objectWithoutProperties(_getExtraAttributesOb, _excluded$c);
        if (!isElementDomNode(domNode)) {
          continue;
        }
        if (isNullOrUndefined(parseDOM)) {
          var _domNode$getAttribute;
          attributes[_name6] = (_domNode$getAttribute = domNode.getAttribute(_name6)) !== null && _domNode$getAttribute !== void 0 ? _domNode$getAttribute : other.default;
          continue;
        }
        if (isFunction$1(parseDOM)) {
          var _parseDOM;
          attributes[_name6] = (_parseDOM = parseDOM(domNode)) !== null && _parseDOM !== void 0 ? _parseDOM : other.default;
          continue;
        }
        attributes[_name6] = (_domNode$getAttribute2 = domNode.getAttribute(parseDOM)) !== null && _domNode$getAttribute2 !== void 0 ? _domNode$getAttribute2 : other.default;
      }
    } catch (err2) {
      _iterator13.e(err2);
    } finally {
      _iterator13.f();
    }
    return attributes;
  };
}
function createToDOM(extraAttributes, shouldIgnore) {
  return (item) => {
    var domAttributes = object();
    if (shouldIgnore) {
      return domAttributes;
    }
    function updateDomAttributes(value, name) {
      if (!value) {
        return;
      }
      if (isString$1(value)) {
        domAttributes[name] = value;
        return;
      }
      if (isArray(value)) {
        var _value = _slicedToArray(value, 2), attr = _value[0], val = _value[1];
        domAttributes[attr] = val !== null && val !== void 0 ? val : item.attrs[name];
        return;
      }
      var _iterator14 = _createForOfIteratorHelper(entries(value)), _step14;
      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done; ) {
          var _step14$value = _slicedToArray(_step14.value, 2), _attr = _step14$value[0], _val = _step14$value[1];
          domAttributes[_attr] = _val;
        }
      } catch (err2) {
        _iterator14.e(err2);
      } finally {
        _iterator14.f();
      }
    }
    var _iterator15 = _createForOfIteratorHelper(entries(extraAttributes)), _step15;
    try {
      for (_iterator15.s(); !(_step15 = _iterator15.n()).done; ) {
        var _step15$value = _slicedToArray(_step15.value, 2), _name7 = _step15$value[0], config2 = _step15$value[1];
        var _getExtraAttributesOb2 = getExtraAttributesObject(config2), toDOM = _getExtraAttributesOb2.toDOM, parseDOM = _getExtraAttributesOb2.parseDOM;
        if (isNullOrUndefined(toDOM)) {
          var key = isString$1(parseDOM) ? parseDOM : _name7;
          domAttributes[key] = item.attrs[_name7];
          continue;
        }
        if (isFunction$1(toDOM)) {
          updateDomAttributes(toDOM(item.attrs, getNodeMarkOptions(item)), _name7);
          continue;
        }
        updateDomAttributes(toDOM, _name7);
      }
    } catch (err2) {
      _iterator15.e(err2);
    } finally {
      _iterator15.f();
    }
    return domAttributes;
  };
}
function getNodeMarkOptions(item) {
  if (isProsemirrorNode(item)) {
    return {
      node: item
    };
  }
  if (isProsemirrorMark(item)) {
    return {
      mark: item
    };
  }
  return {};
}
function getSpecFromSchema(schema) {
  var nodes = object();
  var marks2 = object();
  for (var _i3 = 0, _Object$entries = Object.entries(schema.nodes); _i3 < _Object$entries.length; _i3++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2), _name8 = _Object$entries$_i[0], type2 = _Object$entries$_i[1];
    nodes[_name8] = type2.spec;
  }
  for (var _i4 = 0, _Object$entries2 = Object.entries(schema.marks); _i4 < _Object$entries2.length; _i4++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2), _name9 = _Object$entries2$_i[0], _type = _Object$entries2$_i[1];
    marks2[_name9] = _type.spec;
  }
  return {
    nodes,
    marks: marks2
  };
}
var _dec$2$2, _dec2$g, _dec3$a, _dec4$5, _class$2$2, _class2$e;
var SuggestExtension = (_dec$2$2 = extension({
  customHandlerKeys: ["suggester"]
}), _dec2$g = helper(), _dec3$a = helper(), _dec4$5 = helper(), _dec$2$2(_class$2$2 = (_class2$e = class SuggestExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "onAddCustomHandler", (_ref) => {
      var _this$store$managerSe;
      var suggester = _ref.suggester;
      if (!suggester || (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.suggesters) {
        return;
      }
      return addSuggester(this.store.getState(), suggester);
    });
  }
  get name() {
    return "suggest";
  }
  onCreate() {
    this.store.setExtensionStore("addSuggester", (suggester) => addSuggester(this.store.getState(), suggester));
    this.store.setExtensionStore("removeSuggester", (suggester) => removeSuggester(this.store.getState(), suggester));
  }
  createExternalPlugins() {
    var suggesters = [];
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _this$store$managerSe2, _extension$options$ex;
        var _extension = _step.value;
        if ((_this$store$managerSe2 = this.store.managerSettings.exclude) !== null && _this$store$managerSe2 !== void 0 && _this$store$managerSe2.suggesters) {
          break;
        }
        if (!_extension.createSuggesters || (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.suggesters) {
          continue;
        }
        var _suggester = _extension.createSuggesters();
        var suggesterList = isArray(_suggester) ? _suggester : [_suggester];
        suggesters.push(...suggesterList);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    return [suggest(...suggesters)];
  }
  getSuggestState(state) {
    return getSuggestPluginState(state !== null && state !== void 0 ? state : this.store.getState());
  }
  getSuggestMethods() {
    var _this$getSuggestState = this.getSuggestState(), addIgnored = _this$getSuggestState.addIgnored, clearIgnored = _this$getSuggestState.clearIgnored, removeIgnored = _this$getSuggestState.removeIgnored, ignoreNextExit = _this$getSuggestState.ignoreNextExit, setMarkRemoved = _this$getSuggestState.setMarkRemoved, findMatchAtPosition = _this$getSuggestState.findMatchAtPosition, findNextTextSelection = _this$getSuggestState.findNextTextSelection, setLastChangeFromAppend = _this$getSuggestState.setLastChangeFromAppend;
    return {
      addIgnored,
      clearIgnored,
      removeIgnored,
      ignoreNextExit,
      setMarkRemoved,
      findMatchAtPosition,
      findNextTextSelection,
      setLastChangeFromAppend
    };
  }
  isSuggesterActive(name) {
    var _this$getSuggestState2;
    return includes(isArray(name) ? name : [name], (_this$getSuggestState2 = this.getSuggestState().match) === null || _this$getSuggestState2 === void 0 ? void 0 : _this$getSuggestState2.suggester.name);
  }
}, _applyDecoratedDescriptor(_class2$e.prototype, "getSuggestState", [_dec2$g], Object.getOwnPropertyDescriptor(_class2$e.prototype, "getSuggestState"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "getSuggestMethods", [_dec3$a], Object.getOwnPropertyDescriptor(_class2$e.prototype, "getSuggestMethods"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "isSuggesterActive", [_dec4$5], Object.getOwnPropertyDescriptor(_class2$e.prototype, "isSuggesterActive"), _class2$e.prototype), _class2$e)) || _class$2$2);
var _dec$1$2, _class$1$2;
var TagsExtension = (_dec$1$2 = extension({
  defaultPriority: ExtensionPriority.Highest
}), _dec$1$2(_class$1$2 = class TagsExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "allTags", object());
    _defineProperty$3(this, "plainTags", object());
    _defineProperty$3(this, "markTags", object());
    _defineProperty$3(this, "nodeTags", object());
  }
  get name() {
    return "tags";
  }
  onCreate() {
    this.resetTags();
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _extension = _step.value;
        this.updateTagForExtension(_extension);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    this.store.setStoreKey("tags", this.allTags);
    this.store.setExtensionStore("tags", this.allTags);
    this.store.setStoreKey("plainTags", this.plainTags);
    this.store.setExtensionStore("plainTags", this.plainTags);
    this.store.setStoreKey("markTags", this.markTags);
    this.store.setExtensionStore("markTags", this.markTags);
    this.store.setStoreKey("nodeTags", this.nodeTags);
    this.store.setExtensionStore("nodeTags", this.nodeTags);
  }
  resetTags() {
    var allTags = object();
    var plainTags = object();
    var markTags = object();
    var nodeTags = object();
    var _iterator2 = _createForOfIteratorHelper(values(ExtensionTag)), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var tagName = _step2.value;
        allTags[tagName] = [];
        plainTags[tagName] = [];
        markTags[tagName] = [];
        nodeTags[tagName] = [];
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
    this.allTags = allTags;
    this.plainTags = plainTags;
    this.markTags = markTags;
    this.nodeTags = nodeTags;
  }
  updateTagForExtension(extension2) {
    var _extension$tags, _extension$createTags, _extension$createTags2, _extension$options$ex, _this$store$managerSe, _this$store$managerSe2;
    var allTags = /* @__PURE__ */ new Set([
      ...(_extension$tags = extension2.tags) !== null && _extension$tags !== void 0 ? _extension$tags : [],
      ...(_extension$createTags = (_extension$createTags2 = extension2.createTags) === null || _extension$createTags2 === void 0 ? void 0 : _extension$createTags2.call(extension2)) !== null && _extension$createTags !== void 0 ? _extension$createTags : [],
      ...(_extension$options$ex = extension2.options.extraTags) !== null && _extension$options$ex !== void 0 ? _extension$options$ex : [],
      ...(_this$store$managerSe = (_this$store$managerSe2 = this.store.managerSettings.extraTags) === null || _this$store$managerSe2 === void 0 ? void 0 : _this$store$managerSe2[extension2.name]) !== null && _this$store$managerSe !== void 0 ? _this$store$managerSe : []
    ]);
    var _iterator3 = _createForOfIteratorHelper(allTags), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var tag = _step3.value;
        !isExtensionTag(tag) ? true ? invariant(false, {
          code: ErrorConstant.EXTENSION,
          message: "The tag provided by the extension: ".concat(extension2.constructorName, " is not supported by the editor. To add custom tags you can use the 'mutateTag' method.")
        }) : invariant(false) : void 0;
        this.allTags[tag].push(extension2.name);
        if (isPlainExtension(extension2)) {
          this.plainTags[tag].push(extension2.name);
        }
        if (isMarkExtension(extension2)) {
          this.markTags[tag].push(extension2.name);
        }
        if (isNodeExtension(extension2)) {
          this.nodeTags[tag].push(extension2.name);
        }
      }
    } catch (err2) {
      _iterator3.e(err2);
    } finally {
      _iterator3.f();
    }
    extension2.tags = [...allTags];
  }
}) || _class$1$2);
function isExtensionTag(value) {
  return includes(values(ExtensionTag), value);
}
var ActionType;
(function(ActionType2) {
  ActionType2[ActionType2["ADD_PLACEHOLDER"] = 0] = "ADD_PLACEHOLDER";
  ActionType2[ActionType2["REMOVE_PLACEHOLDER"] = 1] = "REMOVE_PLACEHOLDER";
})(ActionType || (ActionType = {}));
var key$1 = new PluginKey("remirroFilePlaceholderPlugin");
function createUploadPlaceholderPlugin() {
  return new Plugin({
    key: key$1,
    state: {
      init() {
        return {
          set: DecorationSet.empty,
          payloads: /* @__PURE__ */ new Map()
        };
      },
      apply(tr, _ref) {
        var set2 = _ref.set, payloads = _ref.payloads;
        set2 = set2.map(tr.mapping, tr.doc);
        var action2 = tr.getMeta(this);
        if (action2) {
          if (action2.type === ActionType.ADD_PLACEHOLDER) {
            var widget2 = document.createElement("placeholder");
            var deco = Decoration.widget(action2.pos, widget2, {
              id: action2.id
            });
            set2 = set2.add(tr.doc, [deco]);
            payloads.set(action2.id, action2.payload);
          } else if (action2.type === ActionType.REMOVE_PLACEHOLDER) {
            set2 = set2.remove(set2.find(void 0, void 0, (spec) => spec.id === action2.id));
            payloads.delete(action2.id);
          }
        }
        return {
          set: set2,
          payloads
        };
      }
    },
    props: {
      decorations(state) {
        return this.getState(state).set;
      }
    }
  });
}
class UploadExtension extends PlainExtension {
  get name() {
    return "upload";
  }
  createExternalPlugins() {
    return [createUploadPlaceholderPlugin()];
  }
}
function builtinPreset() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var defaultOptions2 = {
    exitMarksOnArrowPress: KeymapExtension.defaultOptions.exitMarksOnArrowPress,
    excludeBaseKeymap: KeymapExtension.defaultOptions.excludeBaseKeymap,
    selectParentNodeOnEscape: KeymapExtension.defaultOptions.selectParentNodeOnEscape,
    undoInputRuleOnBackspace: KeymapExtension.defaultOptions.undoInputRuleOnBackspace,
    persistentSelectionClass: DecorationsExtension.defaultOptions.persistentSelectionClass
  };
  options = _objectSpread2$3(_objectSpread2$3({}, defaultOptions2), options);
  var keymapOptions = object_pick(options, ["excludeBaseKeymap", "selectParentNodeOnEscape", "undoInputRuleOnBackspace"]);
  var decorationsOptions = object_pick(options, ["persistentSelectionClass"]);
  return [
    new TagsExtension(),
    new SchemaExtension(),
    new AttributesExtension(),
    new PluginsExtension(),
    new InputRulesExtension(),
    new PasteRulesExtension(),
    new NodeViewsExtension(),
    new SuggestExtension(),
    new CommandsExtension(),
    new HelpersExtension(),
    new KeymapExtension(keymapOptions),
    new UploadExtension(),
    new DecorationsExtension(decorationsOptions)
  ];
}
var _dec$n, _class$n;
_dec$n = extension({
  defaultOptions: {
    capture: false
  },
  staticKeys: ["capture"],
  defaultPriority: ExtensionPriority.Highest
}), _dec$n(_class$n = class MetaExtension extends PlainExtension {
  get name() {
    return "meta";
  }
  onCreate() {
    this.store.setStoreKey("getCommandMeta", this.getCommandMeta.bind(this));
    if (!this.options.capture) {
      return;
    }
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _extension = _step.value;
        this.captureCommands(_extension);
        this.captureKeybindings(_extension);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
  }
  createPlugin() {
    return {};
  }
  captureCommands(extension2) {
    var _extension$decoratedC, _this = this;
    var decoratedCommands = (_extension$decoratedC = extension2.decoratedCommands) !== null && _extension$decoratedC !== void 0 ? _extension$decoratedC : {};
    var createCommands = extension2.createCommands;
    var _loop = function _loop2() {
      var name = _Object$keys[_i];
      var command2 = extension2[name];
      extension2[name] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (props) => {
          var value = command2(...args)(props);
          if (props.dispatch && value) {
            var _props$view;
            _this.setCommandMeta(props.tr, {
              type: "command",
              chain: props.dispatch !== ((_props$view = props.view) === null || _props$view === void 0 ? void 0 : _props$view.dispatch),
              name,
              extension: extension2.name,
              decorated: true
            });
          }
          return value;
        };
      };
    };
    for (var _i = 0, _Object$keys = Object.keys(decoratedCommands); _i < _Object$keys.length; _i++) {
      _loop();
    }
    if (createCommands) {
      extension2.createCommands = () => {
        var commandsObject = createCommands();
        var _loop2 = function _loop22() {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), name = _Object$entries$_i[0], command2 = _Object$entries$_i[1];
          commandsObject[name] = function() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return (props) => {
              var value = command2(...args)(props);
              if (props.dispatch && value) {
                var _props$view2;
                _this.setCommandMeta(props.tr, {
                  type: "command",
                  chain: props.dispatch !== ((_props$view2 = props.view) === null || _props$view2 === void 0 ? void 0 : _props$view2.dispatch),
                  name,
                  extension: extension2.name,
                  decorated: false
                });
              }
              return value;
            };
          };
        };
        for (var _i2 = 0, _Object$entries = Object.entries(commandsObject); _i2 < _Object$entries.length; _i2++) {
          _loop2();
        }
        return commandsObject;
      };
    }
  }
  captureKeybindings(_2) {
  }
  getCommandMeta(tr) {
    var _tr$getMeta;
    return (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : [];
  }
  setCommandMeta(tr, update2) {
    var meta = this.getCommandMeta(tr);
    tr.setMeta(this.pluginKey, [...meta, update2]);
  }
}) || _class$n;
function _checkPrivateRedeclaration$4(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec$4(obj, privateMap, value) {
  _checkPrivateRedeclaration$4(obj, privateMap);
  privateMap.set(obj, value);
}
var _uid = /* @__PURE__ */ new WeakMap();
var _getProps = /* @__PURE__ */ new WeakMap();
var _previousState = /* @__PURE__ */ new WeakMap();
var _firstRender = /* @__PURE__ */ new WeakMap();
var _events$1 = /* @__PURE__ */ new WeakMap();
var _addHandler = /* @__PURE__ */ new WeakMap();
var _initialEditorState = /* @__PURE__ */ new WeakMap();
class Framework {
  get addHandler() {
    var _classPrivateFieldGet2;
    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _addHandler)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldSet(this, _addHandler, _classPrivateFieldGet(this, _events$1).on.bind(_classPrivateFieldGet(this, _events$1)));
  }
  get updatableViewProps() {
    return {
      attributes: () => this.getAttributes(),
      editable: () => {
        var _this$props$editable;
        return (_this$props$editable = this.props.editable) !== null && _this$props$editable !== void 0 ? _this$props$editable : true;
      }
    };
  }
  get firstRender() {
    return _classPrivateFieldGet(this, _firstRender);
  }
  get props() {
    return _classPrivateFieldGet(this, _getProps).call(this);
  }
  get previousState() {
    var _ref, _this$previousStateOv;
    return (_ref = (_this$previousStateOv = this.previousStateOverride) !== null && _this$previousStateOv !== void 0 ? _this$previousStateOv : _classPrivateFieldGet(this, _previousState)) !== null && _ref !== void 0 ? _ref : this.initialEditorState;
  }
  get manager() {
    return this.props.manager;
  }
  get view() {
    return this.manager.view;
  }
  get uid() {
    return _classPrivateFieldGet(this, _uid);
  }
  get initialEditorState() {
    return _classPrivateFieldGet(this, _initialEditorState);
  }
  constructor(options) {
    var _this = this;
    _classPrivateFieldInitSpec$4(this, _uid, {
      writable: true,
      value: uniqueId()
    });
    _classPrivateFieldInitSpec$4(this, _getProps, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$4(this, _previousState, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$4(this, _firstRender, {
      writable: true,
      value: true
    });
    _classPrivateFieldInitSpec$4(this, _events$1, {
      writable: true,
      value: createNanoEvents()
    });
    _classPrivateFieldInitSpec$4(this, _addHandler, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$4(this, _initialEditorState, {
      writable: true,
      value: void 0
    });
    _defineProperty$3(this, "getState", () => {
      var _this$view$state;
      return (_this$view$state = this.view.state) !== null && _this$view$state !== void 0 ? _this$view$state : this.initialEditorState;
    });
    _defineProperty$3(this, "getPreviousState", () => this.previousState);
    _defineProperty$3(this, "dispatchTransaction", (tr) => {
      var _this$props$onDispatc, _this$props$onDispatc2, _this$props;
      !!this.manager.destroyed ? invariant(false, {
        code: ErrorConstant.MANAGER_PHASE_ERROR,
        message: "A transaction was dispatched to a manager that has already been destroyed. Please check your set up, or open an issue."
      }) : void 0;
      tr = (_this$props$onDispatc = (_this$props$onDispatc2 = (_this$props = this.props).onDispatchTransaction) === null || _this$props$onDispatc2 === void 0 ? void 0 : _this$props$onDispatc2.call(_this$props, tr, this.getState())) !== null && _this$props$onDispatc !== void 0 ? _this$props$onDispatc : tr;
      var previousState = this.getState();
      var _previousState$applyT = previousState.applyTransaction(tr), state = _previousState$applyT.state, transactions = _previousState$applyT.transactions;
      _classPrivateFieldSet(this, _previousState, previousState);
      this.updateState({
        state,
        tr,
        transactions
      });
      var forcedUpdates = this.manager.store.getForcedUpdates(tr);
      if (!isEmptyArray(forcedUpdates)) {
        this.updateViewProps(...forcedUpdates);
      }
    });
    _defineProperty$3(this, "onChange", function() {
      var _this$props$onChange, _this$props2;
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : object();
      var onChangeProps = _this.eventListenerProps(props);
      if (_classPrivateFieldGet(_this, _firstRender)) {
        _classPrivateFieldSet(_this, _firstRender, false);
      }
      (_this$props$onChange = (_this$props2 = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props2, onChangeProps);
    });
    _defineProperty$3(this, "onBlur", (event) => {
      var _this$props$onBlur, _this$props3;
      var props = this.eventListenerProps();
      (_this$props$onBlur = (_this$props3 = this.props).onBlur) === null || _this$props$onBlur === void 0 ? void 0 : _this$props$onBlur.call(_this$props3, props, event);
      _classPrivateFieldGet(this, _events$1).emit("blur", props, event);
    });
    _defineProperty$3(this, "onFocus", (event) => {
      var _this$props$onFocus, _this$props4;
      var props = this.eventListenerProps();
      (_this$props$onFocus = (_this$props4 = this.props).onFocus) === null || _this$props$onFocus === void 0 ? void 0 : _this$props$onFocus.call(_this$props4, props, event);
      _classPrivateFieldGet(this, _events$1).emit("focus", props, event);
    });
    _defineProperty$3(this, "setContent", function(content2) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$triggerChange = _ref2.triggerChange, triggerChange = _ref2$triggerChange === void 0 ? false : _ref2$triggerChange;
      var _this$manager$createS = _this.manager.createState({
        content: content2
      }), doc2 = _this$manager$createS.doc;
      var previousState = _this.getState();
      var _this$getState$applyT = _this.getState().applyTransaction(previousState.tr.replaceRangeWith(0, previousState.doc.nodeSize - 2, doc2)), state = _this$getState$applyT.state;
      if (triggerChange) {
        return _this.updateState({
          state,
          triggerChange
        });
      }
      _this.view.updateState(state);
    });
    _defineProperty$3(this, "clearContent", function() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$triggerChange = _ref3.triggerChange, triggerChange = _ref3$triggerChange === void 0 ? false : _ref3$triggerChange;
      _this.setContent(_this.manager.createEmptyDoc(), {
        triggerChange
      });
    });
    _defineProperty$3(this, "createStateFromContent", (content2, selection) => {
      return this.manager.createState({
        content: content2,
        selection
      });
    });
    _defineProperty$3(this, "focus", (position) => {
      this.manager.store.commands.focus(position);
    });
    _defineProperty$3(this, "blur", (position) => {
      this.manager.store.commands.blur(position);
    });
    var getProps = options.getProps, initialEditorState = options.initialEditorState, element = options.element;
    _classPrivateFieldSet(this, _getProps, getProps);
    _classPrivateFieldSet(this, _initialEditorState, initialEditorState);
    this.manager.attachFramework(this, this.updateListener.bind(this));
    if (this.manager.view) {
      return;
    }
    var view = this.createView(initialEditorState, element);
    this.manager.addView(view);
  }
  updateListener(props) {
    var state = props.state, tr = props.tr;
    return _classPrivateFieldGet(this, _events$1).emit("updated", this.eventListenerProps({
      state,
      tr
    }));
  }
  update(options) {
    var getProps = options.getProps;
    _classPrivateFieldSet(this, _getProps, getProps);
    return this;
  }
  updateViewProps() {
    for (var _len = arguments.length, keys2 = new Array(_len), _key = 0; _key < _len; _key++) {
      keys2[_key] = arguments[_key];
    }
    var props = object_pick(this.updatableViewProps, keys2);
    this.view.setProps(_objectSpread2$3(_objectSpread2$3({}, this.view.props), props));
  }
  getAttributes(ssr) {
    var _this$manager$store;
    var _this$props5 = this.props, attributes = _this$props5.attributes, autoFocus = _this$props5.autoFocus, _this$props5$classNam = _this$props5.classNames, classNames = _this$props5$classNam === void 0 ? [] : _this$props5$classNam, label = _this$props5.label, editable = _this$props5.editable;
    var managerAttributes = (_this$manager$store = this.manager.store) === null || _this$manager$store === void 0 ? void 0 : _this$manager$store.attributes;
    var propAttributes = isFunction$1(attributes) ? attributes(this.eventListenerProps()) : attributes;
    var focus2 = {};
    if (autoFocus || isNumber(autoFocus)) {
      focus2 = ssr ? {
        autoFocus: true
      } : {
        autofocus: "true"
      };
    }
    var uniqueClasses = uniqueArray(cx2(ssr && "Prosemirror", "remirror-editor", managerAttributes === null || managerAttributes === void 0 ? void 0 : managerAttributes.class, ...classNames).split(" ")).join(" ");
    var defaultAttributes = _objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({
      role: "textbox"
    }, focus2), {}, {
      "aria-multiline": "true"
    }, !(editable !== null && editable !== void 0 ? editable : true) ? {
      "aria-readonly": "true"
    } : {}), {}, {
      "aria-label": label !== null && label !== void 0 ? label : ""
    }, managerAttributes), {}, {
      class: uniqueClasses
    });
    return omitUndefined(_objectSpread2$3(_objectSpread2$3({}, defaultAttributes), propAttributes));
  }
  addFocusListeners() {
    this.view.dom.addEventListener("blur", this.onBlur);
    this.view.dom.addEventListener("focus", this.onFocus);
  }
  removeFocusListeners() {
    this.view.dom.removeEventListener("blur", this.onBlur);
    this.view.dom.removeEventListener("focus", this.onFocus);
  }
  destroy() {
    _classPrivateFieldGet(this, _events$1).emit("destroy");
    if (this.view) {
      this.removeFocusListeners();
    }
  }
  eventListenerProps() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : object();
    var state = props.state, tr = props.tr, transactions = props.transactions;
    return {
      tr,
      transactions,
      internalUpdate: !tr,
      view: this.view,
      firstRender: _classPrivateFieldGet(this, _firstRender),
      state: state !== null && state !== void 0 ? state : this.getState(),
      createStateFromContent: this.createStateFromContent,
      previousState: this.previousState,
      helpers: this.manager.store.helpers
    };
  }
  get baseOutput() {
    return _objectSpread2$3(_objectSpread2$3({
      manager: this.manager
    }, this.manager.store), {}, {
      addHandler: this.addHandler,
      focus: this.focus,
      blur: this.blur,
      uid: _classPrivateFieldGet(this, _uid),
      view: this.view,
      getState: this.getState,
      getPreviousState: this.getPreviousState,
      getExtension: this.manager.getExtension.bind(this.manager),
      clearContent: this.clearContent,
      setContent: this.setContent
    });
  }
}
function transformExtensions(initialExtensions, settings) {
  var extensions = [];
  var extensionMap = /* @__PURE__ */ new WeakMap();
  var parentExtensions = [];
  var duplicateMap = /* @__PURE__ */ new WeakMap();
  var gatheredExtensions = [];
  var gatherRawExtensionConfig = {
    duplicateMap,
    parentExtensions,
    gatheredExtensions,
    settings
  };
  var _iterator = _createForOfIteratorHelper(initialExtensions), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _extension = _step.value;
      gatherRawExtensions(gatherRawExtensionConfig, {
        extension: _extension
      });
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  gatheredExtensions = sort(gatheredExtensions, (a2, z2) => z2.priority - a2.priority);
  var found2 = /* @__PURE__ */ new WeakSet();
  var names = /* @__PURE__ */ new Set();
  var _iterator2 = _createForOfIteratorHelper(gatheredExtensions), _step2;
  try {
    var _loop = function _loop2() {
      var extension3 = _step2.value;
      var key = extension3.constructor;
      var name = extension3.name;
      var duplicates = duplicateMap.get(key);
      !duplicates ? true ? invariant(false, {
        message: "No entries were found for the ExtensionConstructor ".concat(extension3.name),
        code: ErrorConstant.INTERNAL
      }) : invariant(false) : void 0;
      if (found2.has(key) || names.has(name)) {
        return "continue";
      }
      found2.add(key);
      names.add(name);
      extensions.push(extension3);
      extensionMap.set(key, extension3);
      duplicates.forEach((parent) => parent === null || parent === void 0 ? void 0 : parent.replaceChildExtension(key, extension3));
    };
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var _ret = _loop();
      if (_ret === "continue")
        continue;
    }
  } catch (err2) {
    _iterator2.e(err2);
  } finally {
    _iterator2.f();
  }
  var missing = [];
  for (var _i = 0, _extensions2 = extensions; _i < _extensions2.length; _i++) {
    var extension2 = _extensions2[_i];
    findMissingExtensions({
      extension: extension2,
      found: found2,
      missing
    });
  }
  !isEmptyArray(missing) ? invariant(false, {
    code: ErrorConstant.MISSING_REQUIRED_EXTENSION,
    message: missing.map((_ref) => {
      var Constructor = _ref.Constructor, extension3 = _ref.extension;
      return "The extension '".concat(extension3.name, "' requires '").concat(Constructor.name, " in order to run correctly.");
    }).join("\n")
  }) : void 0;
  return {
    extensions,
    extensionMap
  };
}
function gatherRawExtensions(config2, props) {
  var _settings$priority;
  var gatheredExtensions = config2.gatheredExtensions, duplicateMap = config2.duplicateMap, parentExtensions = config2.parentExtensions, settings = config2.settings;
  var extension2 = props.extension, parentExtension = props.parentExtension;
  var _props$names = props.names, names = _props$names === void 0 ? [] : _props$names;
  !isExtension(extension2) ? invariant(false, {
    code: ErrorConstant.INVALID_MANAGER_EXTENSION,
    message: "An invalid extension: ".concat(extension2, " was provided to the [[`RemirrorManager`]].")
  }) : void 0;
  var childExtensions = extension2.extensions;
  extension2.setPriority((_settings$priority = settings.priority) === null || _settings$priority === void 0 ? void 0 : _settings$priority[extension2.name]);
  gatheredExtensions.push(extension2);
  updateExtensionDuplicates({
    duplicateMap,
    extension: extension2,
    parentExtension
  });
  if (childExtensions.length === 0) {
    return;
  }
  if (names.includes(extension2.name)) {
    warning$1(false, "Circular dependency encountered when loading extensions: ".concat(names.join(" > "), " > ").concat(extension2.name));
    return;
  }
  names = [...names, extension2.name];
  parentExtensions.push(extension2);
  var _iterator3 = _createForOfIteratorHelper(childExtensions), _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var child3 = _step3.value;
      gatherRawExtensions(config2, {
        names,
        extension: child3,
        parentExtension: extension2
      });
    }
  } catch (err2) {
    _iterator3.e(err2);
  } finally {
    _iterator3.f();
  }
}
function findMissingExtensions(props) {
  var _extension$requiredEx;
  var extension2 = props.extension, found2 = props.found, missing = props.missing;
  if (!extension2.requiredExtensions) {
    return;
  }
  var _iterator4 = _createForOfIteratorHelper((_extension$requiredEx = extension2.requiredExtensions) !== null && _extension$requiredEx !== void 0 ? _extension$requiredEx : []), _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
      var Constructor = _step4.value;
      if (found2.has(Constructor)) {
        continue;
      }
      missing.push({
        Constructor,
        extension: extension2
      });
    }
  } catch (err2) {
    _iterator4.e(err2);
  } finally {
    _iterator4.f();
  }
}
function updateExtensionDuplicates(props) {
  var duplicateMap = props.duplicateMap, extension2 = props.extension, parentExtension = props.parentExtension;
  var key = extension2.constructor;
  var duplicate = duplicateMap.get(key);
  var parentToAdd = parentExtension ? [parentExtension] : [];
  duplicateMap.set(key, duplicate ? [...duplicate, ...parentToAdd] : parentToAdd);
}
function extractLifecycleMethods(props) {
  var _extension$onCreate, _extension$onView, _extension$onStateUpd, _extension$onDestroy;
  var extension2 = props.extension, nodeNames = props.nodeNames, markNames = props.markNames, plainNames = props.plainNames, store2 = props.store, handlers2 = props.handlers;
  extension2.setStore(store2);
  var createHandler = (_extension$onCreate = extension2.onCreate) === null || _extension$onCreate === void 0 ? void 0 : _extension$onCreate.bind(extension2);
  var viewHandler = (_extension$onView = extension2.onView) === null || _extension$onView === void 0 ? void 0 : _extension$onView.bind(extension2);
  var stateUpdateHandler = (_extension$onStateUpd = extension2.onStateUpdate) === null || _extension$onStateUpd === void 0 ? void 0 : _extension$onStateUpd.bind(extension2);
  var destroyHandler = (_extension$onDestroy = extension2.onDestroy) === null || _extension$onDestroy === void 0 ? void 0 : _extension$onDestroy.bind(extension2);
  if (createHandler) {
    handlers2.create.push(createHandler);
  }
  if (viewHandler) {
    handlers2.view.push(viewHandler);
  }
  if (stateUpdateHandler) {
    handlers2.update.push(stateUpdateHandler);
  }
  if (destroyHandler) {
    handlers2.destroy.push(destroyHandler);
  }
  if (isMarkExtension(extension2)) {
    markNames.push(extension2.name);
  }
  if (isNodeExtension(extension2) && extension2.name !== "doc") {
    nodeNames.push(extension2.name);
  }
  if (isPlainExtension(extension2)) {
    plainNames.push(extension2.name);
  }
}
var _extensionStore = /* @__PURE__ */ new WeakMap();
var _stringHandlers = /* @__PURE__ */ new WeakMap();
var _store = /* @__PURE__ */ new WeakMap();
var _extensions = /* @__PURE__ */ new WeakMap();
var _extensionMap = /* @__PURE__ */ new WeakMap();
var _phase = /* @__PURE__ */ new WeakMap();
var _settings = /* @__PURE__ */ new WeakMap();
var _firstStateUpdate = /* @__PURE__ */ new WeakMap();
var _handlers = /* @__PURE__ */ new WeakMap();
var _disposers = /* @__PURE__ */ new WeakMap();
var _events$2 = /* @__PURE__ */ new WeakMap();
var _framework = /* @__PURE__ */ new WeakMap();
var _disposeFramework = /* @__PURE__ */ new WeakMap();
class RemirrorManager {
  static create(extensions) {
    var settings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return new RemirrorManager([...getLazyArray(extensions), ...builtinPreset(settings.builtin)], settings);
  }
  get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.Manager;
  }
  get destroyed() {
    return _classPrivateFieldGet(this, _phase) === ManagerPhase.Destroy;
  }
  get mounted() {
    return _classPrivateFieldGet(this, _phase) >= ManagerPhase.EditorView && _classPrivateFieldGet(this, _phase) < ManagerPhase.Destroy;
  }
  get output() {
    var _classPrivateFieldGet2;
    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.frameworkOutput;
  }
  get frameworkAttached() {
    return !!_classPrivateFieldGet(this, _framework);
  }
  get extensions() {
    return _classPrivateFieldGet(this, _extensions);
  }
  get stringHandlers() {
    return _classPrivateFieldGet(this, _stringHandlers);
  }
  get store() {
    return freeze(_classPrivateFieldGet(this, _store));
  }
  get extensionStore() {
    return freeze(_classPrivateFieldGet(this, _extensionStore));
  }
  get tr() {
    return this.getExtension(CommandsExtension).transaction;
  }
  get nodes() {
    return _classPrivateFieldGet(this, _store).nodes;
  }
  get marks() {
    return _classPrivateFieldGet(this, _store).marks;
  }
  get schema() {
    return _classPrivateFieldGet(this, _store).schema;
  }
  get extensionTags() {
    return _classPrivateFieldGet(this, _store).tags;
  }
  get view() {
    return _classPrivateFieldGet(this, _store).view;
  }
  get settings() {
    return _classPrivateFieldGet(this, _settings);
  }
  get document() {
    var _classPrivateFieldGet3;
    return (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _settings).document) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : getDocument$1(_classPrivateFieldGet(this, _settings).forceEnvironment);
  }
  constructor(initialExtension) {
    var settings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classPrivateFieldInitSpec$4(this, _extensionStore, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$4(this, _stringHandlers, {
      writable: true,
      value: object()
    });
    _classPrivateFieldInitSpec$4(this, _store, {
      writable: true,
      value: object()
    });
    _classPrivateFieldInitSpec$4(this, _extensions, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$4(this, _extensionMap, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$4(this, _phase, {
      writable: true,
      value: ManagerPhase.None
    });
    _classPrivateFieldInitSpec$4(this, _settings, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$4(this, _firstStateUpdate, {
      writable: true,
      value: true
    });
    _classPrivateFieldInitSpec$4(this, _handlers, {
      writable: true,
      value: {
        create: [],
        view: [],
        update: [],
        destroy: []
      }
    });
    _classPrivateFieldInitSpec$4(this, _disposers, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec$4(this, _events$2, {
      writable: true,
      value: createNanoEvents()
    });
    _classPrivateFieldInitSpec$4(this, _framework, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$4(this, _disposeFramework, {
      writable: true,
      value: void 0
    });
    _defineProperty$3(this, "getState", () => {
      var _classPrivateFieldGet4;
      if (_classPrivateFieldGet(this, _phase) >= ManagerPhase.EditorView) {
        return this.view.state;
      }
      !_classPrivateFieldGet(this, _framework) ? invariant(false, {
        code: ErrorConstant.MANAGER_PHASE_ERROR,
        message: "`getState` can only be called after the `Framework` or the `EditorView` has been added to the manager`. Check your plugins to make sure that the decorations callback uses the state argument."
      }) : void 0;
      return (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.initialEditorState;
    });
    _defineProperty$3(this, "updateState", (state) => {
      var previousState = this.getState();
      this.view.updateState(state);
      this.onStateUpdate({
        previousState,
        state
      });
    });
    var _transformExtensions = transformExtensions(initialExtension, settings), extensions = _transformExtensions.extensions, extensionMap = _transformExtensions.extensionMap;
    _classPrivateFieldSet(this, _settings, settings);
    _classPrivateFieldSet(this, _extensions, freeze(extensions));
    _classPrivateFieldSet(this, _extensionMap, extensionMap);
    _classPrivateFieldSet(this, _extensionStore, this.createExtensionStore());
    _classPrivateFieldSet(this, _phase, ManagerPhase.Create);
    this.setupLifecycleHandlers();
    var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).create), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _handler2 = _step.value;
        var disposer = _handler2();
        if (disposer) {
          _classPrivateFieldGet(this, _disposers).push(disposer);
        }
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
  }
  setupLifecycleHandlers() {
    var store2 = _classPrivateFieldGet(this, _extensionStore);
    var handlers2 = _classPrivateFieldGet(this, _handlers);
    var nodeNames = [];
    var markNames = [];
    var plainNames = [];
    store2.nodeNames = nodeNames;
    store2.markNames = markNames;
    store2.plainNames = plainNames;
    var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _extensions)), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _extension = _step2.value;
        extractLifecycleMethods({
          extension: _extension,
          nodeNames,
          markNames,
          plainNames,
          handlers: handlers2,
          store: store2
        });
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
  }
  setStringHandler(name, handler) {
    _classPrivateFieldGet(this, _stringHandlers)[name] = handler;
  }
  setStoreKey(key, value) {
    _classPrivateFieldGet(this, _store)[key] = value;
  }
  getStoreKey(key) {
    var value = _classPrivateFieldGet(this, _store)[key];
    !!isNullOrUndefined(value) ? invariant(false, {
      code: ErrorConstant.MANAGER_PHASE_ERROR,
      message: "`getStoreKey` should not be called before the values are available."
    }) : void 0;
    return value;
  }
  setExtensionStore(key, value) {
    !(_classPrivateFieldGet(this, _phase) <= ManagerPhase.EditorView) ? invariant(false, {
      code: ErrorConstant.MANAGER_PHASE_ERROR,
      message: "`setExtensionStore` should only be called during the `onCreate` lifecycle hook. Make sure to only call it within the returned methods."
    }) : void 0;
    _classPrivateFieldGet(this, _extensionStore)[key] = value;
  }
  createExtensionStore() {
    var store2 = object();
    var enumerable = true;
    var currentState;
    var previousState;
    Object.defineProperties(store2, {
      extensions: {
        get: () => _classPrivateFieldGet(this, _extensions),
        enumerable
      },
      phase: {
        get: () => _classPrivateFieldGet(this, _phase),
        enumerable
      },
      view: {
        get: () => this.view,
        enumerable
      },
      managerSettings: {
        get: () => freeze(_classPrivateFieldGet(this, _settings)),
        enumerable
      },
      getState: {
        value: this.getState,
        enumerable
      },
      updateState: {
        value: this.updateState,
        enumerable
      },
      isMounted: {
        value: () => this.mounted,
        enumerable
      },
      getExtension: {
        value: this.getExtension.bind(this),
        enumerable
      },
      manager: {
        get: () => this,
        enumerable
      },
      document: {
        get: () => this.document,
        enumerable
      },
      stringHandlers: {
        get: () => _classPrivateFieldGet(this, _stringHandlers),
        enumerable
      },
      currentState: {
        get: () => {
          var _currentState;
          return (_currentState = currentState) !== null && _currentState !== void 0 ? _currentState : currentState = this.getState();
        },
        set: (state) => {
          currentState = state;
        },
        enumerable
      },
      previousState: {
        get: () => previousState,
        set: (state) => {
          previousState = state;
        },
        enumerable
      }
    });
    store2.getStoreKey = this.getStoreKey.bind(this);
    store2.setStoreKey = this.setStoreKey.bind(this);
    store2.setExtensionStore = this.setExtensionStore.bind(this);
    store2.setStringHandler = this.setStringHandler.bind(this);
    return store2;
  }
  addView(view) {
    if (_classPrivateFieldGet(this, _phase) >= ManagerPhase.EditorView) {
      return this;
    }
    _classPrivateFieldSet(this, _firstStateUpdate, true);
    _classPrivateFieldSet(this, _phase, ManagerPhase.EditorView);
    _classPrivateFieldGet(this, _store).view = view;
    var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).view), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var _handler2 = _step3.value;
        var disposer = _handler2(view);
        if (disposer) {
          _classPrivateFieldGet(this, _disposers).push(disposer);
        }
      }
    } catch (err2) {
      _iterator3.e(err2);
    } finally {
      _iterator3.f();
    }
    return this;
  }
  attachFramework(framework, updateHandler) {
    if (_classPrivateFieldGet(this, _framework) === framework) {
      return;
    }
    if (_classPrivateFieldGet(this, _framework)) {
      var _classPrivateFieldGet5;
      _classPrivateFieldGet(this, _framework).destroy();
      (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _disposeFramework)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.call(this);
    }
    _classPrivateFieldSet(this, _framework, framework);
    _classPrivateFieldSet(this, _disposeFramework, this.addHandler("stateUpdate", updateHandler));
  }
  createEmptyDoc() {
    var _this$schema$nodes$do;
    var doc2 = (_this$schema$nodes$do = this.schema.nodes.doc) === null || _this$schema$nodes$do === void 0 ? void 0 : _this$schema$nodes$do.createAndFill();
    !doc2 ? invariant(false, {
      code: ErrorConstant.INVALID_CONTENT,
      message: "An empty node could not be created due to an invalid schema."
    }) : void 0;
    return doc2;
  }
  createState() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _this$settings = this.settings, onError = _this$settings.onError, _this$settings$defaul = _this$settings.defaultSelection, defaultSelection = _this$settings$defaul === void 0 ? "end" : _this$settings$defaul;
    var _props$content = props.content, content2 = _props$content === void 0 ? this.createEmptyDoc() : _props$content, _props$selection = props.selection, selection = _props$selection === void 0 ? defaultSelection : _props$selection, _props$stringHandler = props.stringHandler, stringHandler2 = _props$stringHandler === void 0 ? this.settings.stringHandler : _props$stringHandler;
    var _this$store = this.store, schema = _this$store.schema, plugins = _this$store.plugins;
    var doc2 = createDocumentNode({
      stringHandler: isString$1(stringHandler2) ? this.stringHandlers[stringHandler2] : stringHandler2,
      document: this.document,
      content: content2,
      onError,
      schema,
      selection
    });
    return EditorState.create({
      schema,
      doc: doc2,
      plugins,
      selection: getTextSelection(selection, doc2)
    });
  }
  addHandler(event, cb) {
    return _classPrivateFieldGet(this, _events$2).on(event, cb);
  }
  onStateUpdate(props) {
    var firstUpdate = _classPrivateFieldGet(this, _firstStateUpdate);
    _classPrivateFieldGet(this, _extensionStore).currentState = props.state;
    _classPrivateFieldGet(this, _extensionStore).previousState = props.previousState;
    if (firstUpdate) {
      _classPrivateFieldSet(this, _phase, ManagerPhase.Runtime);
      _classPrivateFieldSet(this, _firstStateUpdate, false);
    }
    var propsWithUpdate = _objectSpread2$3(_objectSpread2$3({}, props), {}, {
      firstUpdate
    });
    var _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).update), _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
        var _handler3 = _step4.value;
        _handler3(propsWithUpdate);
      }
    } catch (err2) {
      _iterator4.e(err2);
    } finally {
      _iterator4.f();
    }
    _classPrivateFieldGet(this, _events$2).emit("stateUpdate", propsWithUpdate);
  }
  getExtension(Constructor) {
    var extension2 = _classPrivateFieldGet(this, _extensionMap).get(Constructor);
    !extension2 ? invariant(false, {
      code: ErrorConstant.INVALID_MANAGER_EXTENSION,
      message: "'".concat(Constructor.name, "' doesn't exist within this manager. Make sure it is properly added before attempting to use it.")
    }) : void 0;
    return extension2;
  }
  clone() {
    var extensions = _classPrivateFieldGet(this, _extensions).map((e2) => e2.clone(e2.options));
    var manager = RemirrorManager.create(() => extensions, _classPrivateFieldGet(this, _settings));
    _classPrivateFieldGet(this, _events$2).emit("clone", manager);
    return manager;
  }
  recreate() {
    var extensions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var settings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var currentExtensions = _classPrivateFieldGet(this, _extensions).map((e2) => e2.clone(e2.initialOptions));
    var manager = RemirrorManager.create(() => [...currentExtensions, ...extensions], settings);
    _classPrivateFieldGet(this, _events$2).emit("recreate", manager);
    return manager;
  }
  destroy() {
    var _classPrivateFieldGet6, _classPrivateFieldGet7, _this$view, _this$view$state$plug, _this$view2;
    _classPrivateFieldSet(this, _phase, ManagerPhase.Destroy);
    var _iterator5 = _createForOfIteratorHelper((_this$view$state$plug = (_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.state.plugins) !== null && _this$view$state$plug !== void 0 ? _this$view$state$plug : []), _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
        var _plugin$getState, _plugin$getState$dest;
        var plugin = _step5.value;
        (_plugin$getState = plugin.getState(this.view.state)) === null || _plugin$getState === void 0 ? void 0 : (_plugin$getState$dest = _plugin$getState.destroy) === null || _plugin$getState$dest === void 0 ? void 0 : _plugin$getState$dest.call(_plugin$getState);
      }
    } catch (err2) {
      _iterator5.e(err2);
    } finally {
      _iterator5.f();
    }
    (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.destroy();
    (_classPrivateFieldGet7 = _classPrivateFieldGet(this, _disposeFramework)) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.call(this);
    var _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _disposers)), _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
        var dispose = _step6.value;
        dispose();
      }
    } catch (err2) {
      _iterator6.e(err2);
    } finally {
      _iterator6.f();
    }
    var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).destroy), _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
        var onDestroy = _step7.value;
        onDestroy();
      }
    } catch (err2) {
      _iterator7.e(err2);
    } finally {
      _iterator7.f();
    }
    (_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.destroy();
    _classPrivateFieldGet(this, _events$2).emit("destroy");
  }
  includes(mustIncludeList) {
    var names = [];
    var extensionsAndPresets = [];
    var _iterator8 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _extensions)), _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
        var item = _step8.value;
        names.push(item.name, item.constructorName);
        extensionsAndPresets.push(item.constructor);
      }
    } catch (err2) {
      _iterator8.e(err2);
    } finally {
      _iterator8.f();
    }
    return mustIncludeList.every((item2) => isString$1(item2) ? includes(names, item2) : includes(extensionsAndPresets, item2));
  }
}
function isRemirrorManager(value, mustIncludeList) {
  if (!isRemirrorType(value) || !isIdentifierOfType(value, RemirrorIdentifier.Manager)) {
    return false;
  }
  if (!mustIncludeList) {
    return true;
  }
  return value.includes(mustIncludeList);
}
function _checkPrivateRedeclaration$3(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec$3(obj, privateMap, value) {
  _checkPrivateRedeclaration$3(obj, privateMap);
  privateMap.set(obj, value);
}
var _events = /* @__PURE__ */ new WeakMap();
class PortalContainer {
  constructor() {
    _defineProperty$3(this, "portals", /* @__PURE__ */ new Map());
    _classPrivateFieldInitSpec$3(this, _events, {
      writable: true,
      value: createNanoEvents()
    });
    _defineProperty$3(this, "on", (callback) => {
      return _classPrivateFieldGet(this, _events).on("update", callback);
    });
    _defineProperty$3(this, "once", (callback) => {
      var unbind = _classPrivateFieldGet(this, _events).on("update", (portals) => {
        unbind();
        callback(portals);
      });
      return unbind;
    });
  }
  update() {
    _classPrivateFieldGet(this, _events).emit("update", this.portals);
  }
  render(_ref) {
    var _portal$key;
    var Component2 = _ref.Component, container = _ref.container;
    var portal = this.portals.get(container);
    this.portals.set(container, {
      Component: Component2,
      key: (_portal$key = portal === null || portal === void 0 ? void 0 : portal.key) !== null && _portal$key !== void 0 ? _portal$key : uniqueId()
    });
    this.update();
  }
  forceUpdate() {
    var _iterator = _createForOfIteratorHelper(this.portals), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), container = _step$value[0], Component2 = _step$value[1].Component;
        this.portals.set(container, {
          Component: Component2,
          key: uniqueId()
        });
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
  }
  remove(container) {
    this.portals.delete(container);
    this.update();
  }
}
var RemirrorPortals = (props) => {
  var portals = props.portals;
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: portals.map((_ref) => {
      var _ref2 = _slicedToArray(_ref, 2), container = _ref2[0], _ref2$ = _ref2[1], Component2 = _ref2$.Component, key = _ref2$.key;
      return /* @__PURE__ */ reactDom.exports.createPortal(/* @__PURE__ */ jsx(Component2, {}), container, key);
    })
  });
};
function usePortals(portalContainer) {
  var _useState = react$1.exports.useState(() => [...portalContainer.portals.entries()]), _useState2 = _slicedToArray(_useState, 2), portals = _useState2[0], setPortals = _useState2[1];
  react$1.exports.useEffect(() => {
    return portalContainer.on((portalMap) => {
      setPortals([...portalMap.entries()]);
    });
  }, [portalContainer]);
  return react$1.exports.useMemo(() => portals, [portals]);
}
var _node = /* @__PURE__ */ new WeakMap();
var _decorations = /* @__PURE__ */ new WeakMap();
var _view$1 = /* @__PURE__ */ new WeakMap();
var _portalContainer = /* @__PURE__ */ new WeakMap();
var _Component = /* @__PURE__ */ new WeakMap();
var _getPosition$1 = /* @__PURE__ */ new WeakMap();
var _options = /* @__PURE__ */ new WeakMap();
var _selected = /* @__PURE__ */ new WeakMap();
var _contentDOM = /* @__PURE__ */ new WeakMap();
var _contentDOMWrapper = /* @__PURE__ */ new WeakMap();
var _dom = /* @__PURE__ */ new WeakMap();
var _forwardRef = /* @__PURE__ */ new WeakMap();
class ReactNodeView {
  static create(props) {
    var portalContainer = props.portalContainer, ReactComponent = props.ReactComponent, options = props.options;
    return (node4, view, getPosition) => new ReactNodeView({
      options,
      node: node4,
      view,
      getPosition,
      portalContainer,
      ReactComponent
    });
  }
  get selected() {
    return _classPrivateFieldGet(this, _selected);
  }
  get contentDOM() {
    return _classPrivateFieldGet(this, _contentDOM);
  }
  get dom() {
    return _classPrivateFieldGet(this, _dom);
  }
  constructor(_ref) {
    var _this$createContentDo;
    var getPosition = _ref.getPosition, _node2 = _ref.node, portalContainer = _ref.portalContainer, view = _ref.view, _ReactComponent = _ref.ReactComponent, options = _ref.options;
    _classPrivateFieldInitSpec$3(this, _node, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$3(this, _decorations, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec$3(this, _view$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$3(this, _portalContainer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$3(this, _Component, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$3(this, _getPosition$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$3(this, _options, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$3(this, _selected, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec$3(this, _contentDOM, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$3(this, _contentDOMWrapper, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$3(this, _dom, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$3(this, _forwardRef, {
      writable: true,
      value: (node4) => {
        if (!node4) {
          return;
        }
        !_classPrivateFieldGet(this, _contentDOMWrapper) ? invariant(false, {
          code: ErrorConstant.REACT_NODE_VIEW,
          message: "You have applied a ref to a node view provided for '".concat(_classPrivateFieldGet(this, _node).type.name, "' which doesn't support content.")
        }) : void 0;
        node4.append(_classPrivateFieldGet(this, _contentDOMWrapper));
      }
    });
    _defineProperty$3(this, "Component", () => {
      var ReactComponent = _classPrivateFieldGet(this, _Component);
      !ReactComponent ? invariant(false, {
        code: ErrorConstant.REACT_NODE_VIEW,
        message: "The custom react node view provided for ".concat(_classPrivateFieldGet(this, _node).type.name, " doesn't have a valid ReactComponent")
      }) : void 0;
      return /* @__PURE__ */ jsx(ReactComponent, {
        environment: "dom",
        updateAttributes: this.updateAttributes,
        selected: this.selected,
        view: _classPrivateFieldGet(this, _view$1),
        getPosition: _classPrivateFieldGet(this, _getPosition$1),
        node: _classPrivateFieldGet(this, _node),
        forwardRef: _classPrivateFieldGet(this, _forwardRef),
        decorations: _classPrivateFieldGet(this, _decorations)
      });
    });
    _defineProperty$3(this, "updateAttributes", (attrs) => {
      if (!_classPrivateFieldGet(this, _view$1).editable) {
        return;
      }
      var tr = _classPrivateFieldGet(this, _view$1).state.tr.setNodeMarkup(_classPrivateFieldGet(this, _getPosition$1).call(this), void 0, _objectSpread2$3(_objectSpread2$3({}, _classPrivateFieldGet(this, _node).attrs), attrs));
      _classPrivateFieldGet(this, _view$1).dispatch(tr);
    });
    !isFunction$1(getPosition) ? invariant(false, {
      message: "You are attempting to use a node view for a mark type. This is not supported yet. Please check your configuration."
    }) : void 0;
    _classPrivateFieldSet(this, _node, _node2);
    _classPrivateFieldSet(this, _view$1, view);
    _classPrivateFieldSet(this, _portalContainer, portalContainer);
    _classPrivateFieldSet(this, _Component, _ReactComponent);
    _classPrivateFieldSet(this, _getPosition$1, getPosition);
    _classPrivateFieldSet(this, _options, options);
    _classPrivateFieldSet(this, _dom, this.createDom());
    var _ref2 = (_this$createContentDo = this.createContentDom()) !== null && _this$createContentDo !== void 0 ? _this$createContentDo : {}, contentDOM = _ref2.contentDOM, wrapper = _ref2.wrapper;
    _classPrivateFieldSet(this, _contentDOM, contentDOM !== null && contentDOM !== void 0 ? contentDOM : void 0);
    _classPrivateFieldSet(this, _contentDOMWrapper, wrapper);
    if (_classPrivateFieldGet(this, _contentDOMWrapper)) {
      _classPrivateFieldGet(this, _dom).append(_classPrivateFieldGet(this, _contentDOMWrapper));
    }
    this.setDomAttributes(_classPrivateFieldGet(this, _node), _classPrivateFieldGet(this, _dom));
    this.Component.displayName = pascalCase("".concat(_classPrivateFieldGet(this, _node).type.name, "NodeView"));
    this.renderComponent();
  }
  renderComponent() {
    _classPrivateFieldGet(this, _portalContainer).render({
      Component: this.Component,
      container: _classPrivateFieldGet(this, _dom)
    });
  }
  createDom() {
    var _classPrivateFieldGet2 = _classPrivateFieldGet(this, _options), defaultBlockNode = _classPrivateFieldGet2.defaultBlockNode, defaultInlineNode = _classPrivateFieldGet2.defaultInlineNode;
    var element = _classPrivateFieldGet(this, _node).isInline ? document.createElement(defaultInlineNode) : document.createElement(defaultBlockNode);
    element.classList.add("".concat(kebabCase(_classPrivateFieldGet(this, _node).type.name), "-node-view-wrapper"));
    return element;
  }
  createContentDom() {
    var _classPrivateFieldGet3, _classPrivateFieldGet4;
    if (_classPrivateFieldGet(this, _node).isLeaf) {
      return;
    }
    var domSpec = (_classPrivateFieldGet3 = (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _node).type.spec).toDOM) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.call(_classPrivateFieldGet4, _classPrivateFieldGet(this, _node));
    if (!domSpec) {
      return;
    }
    var _DOMSerializer$render = DOMSerializer.renderSpec(document, domSpec), contentDOM = _DOMSerializer$render.contentDOM, dom = _DOMSerializer$render.dom;
    var wrapper;
    if (!isElementDomNode(dom)) {
      return;
    }
    wrapper = dom;
    if (dom === contentDOM) {
      wrapper = document.createElement("span");
      wrapper.classList.add("".concat(kebabCase(_classPrivateFieldGet(this, _node).type.name), "-node-view-content-wrapper"));
      wrapper.append(contentDOM);
    }
    if (isElementDomNode(contentDOM))
      ;
    return {
      wrapper,
      contentDOM
    };
  }
  update(node4, decorations) {
    if (!isNodeOfType({
      types: _classPrivateFieldGet(this, _node).type,
      node: node4
    })) {
      return false;
    }
    if (_classPrivateFieldGet(this, _node) === node4 && _classPrivateFieldGet(this, _decorations) === decorations) {
      return true;
    }
    if (!_classPrivateFieldGet(this, _node).sameMarkup(node4)) {
      this.setDomAttributes(node4, _classPrivateFieldGet(this, _dom));
    }
    _classPrivateFieldSet(this, _node, node4);
    _classPrivateFieldSet(this, _decorations, decorations);
    this.renderComponent();
    return true;
  }
  setDomAttributes(node4, element) {
    var toDOM = _classPrivateFieldGet(this, _node).type.spec.toDOM;
    var attributes = node4.attrs;
    if (toDOM) {
      var domSpec = toDOM(node4);
      if (isString$1(domSpec) || isDomNodeOutputSpec(domSpec)) {
        return;
      }
      if (isPlainObject$1(domSpec[1])) {
        attributes = domSpec[1];
      }
    }
    var _iterator = _createForOfIteratorHelper(entries(attributes)), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), attribute = _step$value[0], value = _step$value[1];
        element.setAttribute(attribute, value);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
  }
  selectNode() {
    _classPrivateFieldSet(this, _selected, true);
    if (_classPrivateFieldGet(this, _dom)) {
      _classPrivateFieldGet(this, _dom).classList.add(SELECTED_NODE_CLASS_NAME);
    }
    this.renderComponent();
  }
  deselectNode() {
    _classPrivateFieldSet(this, _selected, false);
    if (_classPrivateFieldGet(this, _dom)) {
      _classPrivateFieldGet(this, _dom).classList.remove(SELECTED_NODE_CLASS_NAME);
    }
    this.renderComponent();
  }
  destroy() {
    _classPrivateFieldGet(this, _portalContainer).remove(_classPrivateFieldGet(this, _dom));
  }
  ignoreMutation(mutation) {
    if (mutation.type === "selection") {
      return !_classPrivateFieldGet(this, _node).type.spec.selectable;
    }
    if (!_classPrivateFieldGet(this, _contentDOMWrapper)) {
      return true;
    }
    return !_classPrivateFieldGet(this, _contentDOMWrapper).contains(mutation.target);
  }
  stopEvent(event) {
    var _this$contentDOM;
    if (!_classPrivateFieldGet(this, _dom)) {
      return false;
    }
    if (isFunction$1(_classPrivateFieldGet(this, _options).stopEvent)) {
      return _classPrivateFieldGet(this, _options).stopEvent({
        event
      });
    }
    var target = event.target;
    var isInElement = _classPrivateFieldGet(this, _dom).contains(target) && !((_this$contentDOM = this.contentDOM) !== null && _this$contentDOM !== void 0 && _this$contentDOM.contains(target));
    if (!isInElement) {
      return false;
    }
    var isDropEvent = event.type === "drop";
    var isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
    if (isInput && !isDropEvent) {
      return true;
    }
    var isDraggable = !!_classPrivateFieldGet(this, _node).type.spec.draggable;
    var isSelectable = NodeSelection.isSelectable(_classPrivateFieldGet(this, _node));
    var isCopyEvent = event.type === "copy";
    var isPasteEvent = event.type === "paste";
    var isCutEvent = event.type === "cut";
    var isClickEvent = event.type === "mousedown";
    var isDragEvent = event.type.startsWith("drag");
    if (!isDraggable && isSelectable && isDragEvent) {
      event.preventDefault();
    }
    if (isDragEvent || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
      return false;
    }
    return true;
  }
}
function isDomNodeOutputSpec(value) {
  return isDomNode(value) || isPlainObject$1(value) && isDomNode(value.dom);
}
var _dec$m, _class$m;
var ReactComponentExtension = (_dec$m = extension({
  defaultOptions: {
    defaultBlockNode: "div",
    defaultInlineNode: "span",
    defaultContentNode: "span",
    defaultEnvironment: "both",
    nodeViewComponents: {},
    stopEvent: null
  },
  staticKeys: ["defaultBlockNode", "defaultInlineNode", "defaultContentNode", "defaultEnvironment"]
}), _dec$m(_class$m = class ReactComponentExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "portalContainer", new PortalContainer());
  }
  get name() {
    return "reactComponent";
  }
  onCreate() {
    this.store.setStoreKey("portalContainer", this.portalContainer);
  }
  createNodeViews() {
    var _this$store$managerSe;
    var nodeViews = object();
    var managerComponents = (_this$store$managerSe = this.store.managerSettings.nodeViewComponents) !== null && _this$store$managerSe !== void 0 ? _this$store$managerSe : {};
    var _iterator = _createForOfIteratorHelper(this.store.extensions), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _extension = _step.value;
        if (!_extension.ReactComponent || !isNodeExtension(_extension) || _extension.reactComponentEnvironment === "ssr") {
          continue;
        }
        nodeViews[_extension.name] = ReactNodeView.create({
          options: this.options,
          ReactComponent: _extension.ReactComponent,
          portalContainer: this.portalContainer
        });
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    var namedComponents = entries(_objectSpread2$3(_objectSpread2$3({}, this.options.nodeViewComponents), managerComponents));
    var _iterator2 = _createForOfIteratorHelper(namedComponents), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _step2$value = _slicedToArray(_step2.value, 2), name = _step2$value[0], ReactComponent = _step2$value[1];
        nodeViews[name] = ReactNodeView.create({
          options: this.options,
          ReactComponent,
          portalContainer: this.portalContainer
        });
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
    return nodeViews;
  }
}) || _class$m);
function isValidElement(value) {
  return isObject$1(value) && /* @__PURE__ */ react$1.exports.isValidElement(value);
}
function isReactDOMElement(value) {
  return isValidElement(value) && isString$1(value.type);
}
function isReactFragment(value) {
  return isObject$1(value) && isValidElement(value) && value.type === react$1.exports.Fragment;
}
function getElementProps(element) {
  return isValidElement(element) ? element.props : {};
}
function addKeyToElement(element, key) {
  if (!isValidElement(element)) {
    return element;
  }
  return /* @__PURE__ */ react$1.exports.cloneElement(element, _objectSpread2$3(_objectSpread2$3({}, element.props), {}, {
    key
  }));
}
var _dec$l, _class$l;
var ReactSsrExtension = (_dec$l = extension({
  defaultOptions: {
    transformers: [injectBrIntoEmptyParagraphs]
  },
  defaultPriority: ExtensionPriority.High,
  staticKeys: ["transformers"]
}), _dec$l(_class$l = class ReactSsrExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "createSSRTransformer", () => (initialElement) => {
      var element = initialElement;
      var _iterator = _createForOfIteratorHelper(this.options.transformers), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var transformer = _step.value;
          element = transformer(element);
        }
      } catch (err2) {
        _iterator.e(err2);
      } finally {
        _iterator.f();
      }
      return element;
    });
  }
  get name() {
    return "reactSsr";
  }
  onCreate() {
    var components2 = object();
    var ssrTransformers = [];
    var ssrTransformer = (initialElement, state) => {
      var element = initialElement;
      var _iterator2 = _createForOfIteratorHelper(ssrTransformers), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var transformer = _step2.value;
          element = transformer()(element, state);
        }
      } catch (err2) {
        _iterator2.e(err2);
      } finally {
        _iterator2.f();
      }
      return element;
    };
    var _iterator3 = _createForOfIteratorHelper(this.store.extensions), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var _this$store$managerSe, _extension$options$ex, _extension$options$ex2;
        var _extension = _step3.value;
        if (!((_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.reactSSR) && _extension.ReactComponent && _extension.reactComponentEnvironment !== "dom" && !((_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.reactSSR)) {
          components2[_extension.name] = {
            Component: _extension.ReactComponent,
            props: {
              decorations: [],
              environment: "ssr",
              forwardRef: () => {
              },
              getPosition: () => 0,
              selected: false,
              updateAttributes: () => {
              }
            }
          };
        }
        if (_extension.createSSRTransformer && !((_extension$options$ex2 = _extension.options.exclude) !== null && _extension$options$ex2 !== void 0 && _extension$options$ex2.reactSSR)) {
          ssrTransformers.push(_extension.createSSRTransformer.bind(_extension));
        }
      }
    } catch (err2) {
      _iterator3.e(err2);
    } finally {
      _iterator3.f();
    }
    this.store.setStoreKey("components", components2);
    this.store.setStoreKey("ssrTransformer", ssrTransformer);
  }
}) || _class$l);
function cloneSSRElement(element, transformChildElements) {
  if (!isReactFragment(element)) {
    throw new Error("Invalid element passed. The top level element must be a fragment");
  }
  var _getElementProps = getElementProps(element), children = _getElementProps.children;
  var childrenProperties = getElementProps(children);
  return /* @__PURE__ */ react$1.exports.cloneElement(element, {}, transformChildElements(children, childrenProperties));
}
function elementIsEmpty(element) {
  return react$1.exports.Children.count(element.props.children) === 0;
}
function elementIsOfType(element, type2) {
  return element.type === type2;
}
function injectBrIntoEmptyParagraphs(element) {
  return cloneSSRElement(element, (children) => {
    if (!isArray(children)) {
      return children;
    }
    return react$1.exports.Children.map(children, (child3) => {
      if (!(isReactDOMElement(child3) && elementIsEmpty(child3) && elementIsOfType(child3, "p"))) {
        return child3;
      }
      var properties = getElementProps(child3);
      return /* @__PURE__ */ react$1.exports.cloneElement(child3, properties, /* @__PURE__ */ react$1.exports.createElement("br"));
    });
  });
}
var composeRefs$1 = {};
Object.defineProperty(composeRefs$1, "__esModule", { value: true });
function composeRefs() {
  var refs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    refs[_i] = arguments[_i];
  }
  if (refs.length === 2) {
    return composeTwoRefs(refs[0], refs[1]) || null;
  }
  var composedRef = refs.slice(1).reduce(function(semiCombinedRef, refToInclude) {
    return composeTwoRefs(semiCombinedRef, refToInclude);
  }, refs[0]);
  return composedRef || null;
}
var _default$2 = composeRefs$1.default = composeRefs;
var composedRefCache = /* @__PURE__ */ new WeakMap();
function composeTwoRefs(ref1, ref2) {
  if (ref1 && ref2) {
    var ref1Cache = composedRefCache.get(ref1) || /* @__PURE__ */ new WeakMap();
    composedRefCache.set(ref1, ref1Cache);
    var composedRef = ref1Cache.get(ref2) || function(instance) {
      updateRef(ref1, instance);
      updateRef(ref2, instance);
    };
    ref1Cache.set(ref2, composedRef);
    return composedRef;
  }
  if (!ref1) {
    return ref2;
  } else {
    return ref1;
  }
}
function updateRef(ref2, instance) {
  if (typeof ref2 === "function") {
    ref2(instance);
  } else {
    ref2.current = instance;
  }
}
var removeAccents$2 = { exports: {} };
var characterMap = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\u1EA4": "A",
  "\u1EAE": "A",
  "\u1EB2": "A",
  "\u1EB4": "A",
  "\u1EB6": "A",
  "\xC6": "AE",
  "\u1EA6": "A",
  "\u1EB0": "A",
  "\u0202": "A",
  "\xC7": "C",
  "\u1E08": "C",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\u1EBE": "E",
  "\u1E16": "E",
  "\u1EC0": "E",
  "\u1E14": "E",
  "\u1E1C": "E",
  "\u0206": "E",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\u1E2E": "I",
  "\u020A": "I",
  "\xD0": "D",
  "\xD1": "N",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\u1ED0": "O",
  "\u1E4C": "O",
  "\u1E52": "O",
  "\u020E": "O",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xDD": "Y",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\u1EA5": "a",
  "\u1EAF": "a",
  "\u1EB3": "a",
  "\u1EB5": "a",
  "\u1EB7": "a",
  "\xE6": "ae",
  "\u1EA7": "a",
  "\u1EB1": "a",
  "\u0203": "a",
  "\xE7": "c",
  "\u1E09": "c",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\u1EBF": "e",
  "\u1E17": "e",
  "\u1EC1": "e",
  "\u1E15": "e",
  "\u1E1D": "e",
  "\u0207": "e",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\u1E2F": "i",
  "\u020B": "i",
  "\xF0": "d",
  "\xF1": "n",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\u1ED1": "o",
  "\u1E4D": "o",
  "\u1E53": "o",
  "\u020F": "o",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xFD": "y",
  "\xFF": "y",
  "\u0100": "A",
  "\u0101": "a",
  "\u0102": "A",
  "\u0103": "a",
  "\u0104": "A",
  "\u0105": "a",
  "\u0106": "C",
  "\u0107": "c",
  "\u0108": "C",
  "\u0109": "c",
  "\u010A": "C",
  "\u010B": "c",
  "\u010C": "C",
  "\u010D": "c",
  "C\u0306": "C",
  "c\u0306": "c",
  "\u010E": "D",
  "\u010F": "d",
  "\u0110": "D",
  "\u0111": "d",
  "\u0112": "E",
  "\u0113": "e",
  "\u0114": "E",
  "\u0115": "e",
  "\u0116": "E",
  "\u0117": "e",
  "\u0118": "E",
  "\u0119": "e",
  "\u011A": "E",
  "\u011B": "e",
  "\u011C": "G",
  "\u01F4": "G",
  "\u011D": "g",
  "\u01F5": "g",
  "\u011E": "G",
  "\u011F": "g",
  "\u0120": "G",
  "\u0121": "g",
  "\u0122": "G",
  "\u0123": "g",
  "\u0124": "H",
  "\u0125": "h",
  "\u0126": "H",
  "\u0127": "h",
  "\u1E2A": "H",
  "\u1E2B": "h",
  "\u0128": "I",
  "\u0129": "i",
  "\u012A": "I",
  "\u012B": "i",
  "\u012C": "I",
  "\u012D": "i",
  "\u012E": "I",
  "\u012F": "i",
  "\u0130": "I",
  "\u0131": "i",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u1E30": "K",
  "\u1E31": "k",
  "K\u0306": "K",
  "k\u0306": "k",
  "\u0139": "L",
  "\u013A": "l",
  "\u013B": "L",
  "\u013C": "l",
  "\u013D": "L",
  "\u013E": "l",
  "\u013F": "L",
  "\u0140": "l",
  "\u0141": "l",
  "\u0142": "l",
  "\u1E3E": "M",
  "\u1E3F": "m",
  "M\u0306": "M",
  "m\u0306": "m",
  "\u0143": "N",
  "\u0144": "n",
  "\u0145": "N",
  "\u0146": "n",
  "\u0147": "N",
  "\u0148": "n",
  "\u0149": "n",
  "N\u0306": "N",
  "n\u0306": "n",
  "\u014C": "O",
  "\u014D": "o",
  "\u014E": "O",
  "\u014F": "o",
  "\u0150": "O",
  "\u0151": "o",
  "\u0152": "OE",
  "\u0153": "oe",
  "P\u0306": "P",
  "p\u0306": "p",
  "\u0154": "R",
  "\u0155": "r",
  "\u0156": "R",
  "\u0157": "r",
  "\u0158": "R",
  "\u0159": "r",
  "R\u0306": "R",
  "r\u0306": "r",
  "\u0212": "R",
  "\u0213": "r",
  "\u015A": "S",
  "\u015B": "s",
  "\u015C": "S",
  "\u015D": "s",
  "\u015E": "S",
  "\u0218": "S",
  "\u0219": "s",
  "\u015F": "s",
  "\u0160": "S",
  "\u0161": "s",
  "\u0162": "T",
  "\u0163": "t",
  "\u021B": "t",
  "\u021A": "T",
  "\u0164": "T",
  "\u0165": "t",
  "\u0166": "T",
  "\u0167": "t",
  "T\u0306": "T",
  "t\u0306": "t",
  "\u0168": "U",
  "\u0169": "u",
  "\u016A": "U",
  "\u016B": "u",
  "\u016C": "U",
  "\u016D": "u",
  "\u016E": "U",
  "\u016F": "u",
  "\u0170": "U",
  "\u0171": "u",
  "\u0172": "U",
  "\u0173": "u",
  "\u0216": "U",
  "\u0217": "u",
  "V\u0306": "V",
  "v\u0306": "v",
  "\u0174": "W",
  "\u0175": "w",
  "\u1E82": "W",
  "\u1E83": "w",
  "X\u0306": "X",
  "x\u0306": "x",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "Y\u0306": "Y",
  "y\u0306": "y",
  "\u0179": "Z",
  "\u017A": "z",
  "\u017B": "Z",
  "\u017C": "z",
  "\u017D": "Z",
  "\u017E": "z",
  "\u017F": "s",
  "\u0192": "f",
  "\u01A0": "O",
  "\u01A1": "o",
  "\u01AF": "U",
  "\u01B0": "u",
  "\u01CD": "A",
  "\u01CE": "a",
  "\u01CF": "I",
  "\u01D0": "i",
  "\u01D1": "O",
  "\u01D2": "o",
  "\u01D3": "U",
  "\u01D4": "u",
  "\u01D5": "U",
  "\u01D6": "u",
  "\u01D7": "U",
  "\u01D8": "u",
  "\u01D9": "U",
  "\u01DA": "u",
  "\u01DB": "U",
  "\u01DC": "u",
  "\u1EE8": "U",
  "\u1EE9": "u",
  "\u1E78": "U",
  "\u1E79": "u",
  "\u01FA": "A",
  "\u01FB": "a",
  "\u01FC": "AE",
  "\u01FD": "ae",
  "\u01FE": "O",
  "\u01FF": "o",
  "\xDE": "TH",
  "\xFE": "th",
  "\u1E54": "P",
  "\u1E55": "p",
  "\u1E64": "S",
  "\u1E65": "s",
  "X\u0301": "X",
  "x\u0301": "x",
  "\u0403": "\u0413",
  "\u0453": "\u0433",
  "\u040C": "\u041A",
  "\u045C": "\u043A",
  "A\u030B": "A",
  "a\u030B": "a",
  "E\u030B": "E",
  "e\u030B": "e",
  "I\u030B": "I",
  "i\u030B": "i",
  "\u01F8": "N",
  "\u01F9": "n",
  "\u1ED2": "O",
  "\u1ED3": "o",
  "\u1E50": "O",
  "\u1E51": "o",
  "\u1EEA": "U",
  "\u1EEB": "u",
  "\u1E80": "W",
  "\u1E81": "w",
  "\u1EF2": "Y",
  "\u1EF3": "y",
  "\u0200": "A",
  "\u0201": "a",
  "\u0204": "E",
  "\u0205": "e",
  "\u0208": "I",
  "\u0209": "i",
  "\u020C": "O",
  "\u020D": "o",
  "\u0210": "R",
  "\u0211": "r",
  "\u0214": "U",
  "\u0215": "u",
  "B\u030C": "B",
  "b\u030C": "b",
  "\u010C\u0323": "C",
  "\u010D\u0323": "c",
  "\xCA\u030C": "E",
  "\xEA\u030C": "e",
  "F\u030C": "F",
  "f\u030C": "f",
  "\u01E6": "G",
  "\u01E7": "g",
  "\u021E": "H",
  "\u021F": "h",
  "J\u030C": "J",
  "\u01F0": "j",
  "\u01E8": "K",
  "\u01E9": "k",
  "M\u030C": "M",
  "m\u030C": "m",
  "P\u030C": "P",
  "p\u030C": "p",
  "Q\u030C": "Q",
  "q\u030C": "q",
  "\u0158\u0329": "R",
  "\u0159\u0329": "r",
  "\u1E66": "S",
  "\u1E67": "s",
  "V\u030C": "V",
  "v\u030C": "v",
  "W\u030C": "W",
  "w\u030C": "w",
  "X\u030C": "X",
  "x\u030C": "x",
  "Y\u030C": "Y",
  "y\u030C": "y",
  "A\u0327": "A",
  "a\u0327": "a",
  "B\u0327": "B",
  "b\u0327": "b",
  "\u1E10": "D",
  "\u1E11": "d",
  "\u0228": "E",
  "\u0229": "e",
  "\u0190\u0327": "E",
  "\u025B\u0327": "e",
  "\u1E28": "H",
  "\u1E29": "h",
  "I\u0327": "I",
  "i\u0327": "i",
  "\u0197\u0327": "I",
  "\u0268\u0327": "i",
  "M\u0327": "M",
  "m\u0327": "m",
  "O\u0327": "O",
  "o\u0327": "o",
  "Q\u0327": "Q",
  "q\u0327": "q",
  "U\u0327": "U",
  "u\u0327": "u",
  "X\u0327": "X",
  "x\u0327": "x",
  "Z\u0327": "Z",
  "z\u0327": "z"
};
var chars = Object.keys(characterMap).join("|");
var allAccents = new RegExp(chars, "g");
var firstAccent = new RegExp(chars, "");
var removeAccents = function(string) {
  return string.replace(allAccents, function(match) {
    return characterMap[match];
  });
};
var hasAccents = function(string) {
  return !!string.match(firstAccent);
};
removeAccents$2.exports = removeAccents;
removeAccents$2.exports.has = hasAccents;
removeAccents$2.exports.remove = removeAccents;
var removeAccents$1 = removeAccents$2.exports;
var rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
matchSorter.rankings = rankings;
var defaultBaseSortFn = function defaultBaseSortFn2(a2, b) {
  return String(a2.rankedValue).localeCompare(String(b.rankedValue));
};
function matchSorter(items, value, options) {
  if (options === void 0) {
    options = {};
  }
  var _options2 = options, keys2 = _options2.keys, _options$threshold = _options2.threshold, threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold, _options$baseSort = _options2.baseSort, baseSort = _options$baseSort === void 0 ? defaultBaseSortFn : _options$baseSort, _options$sorter = _options2.sorter, sorter = _options$sorter === void 0 ? function(matchedItems2) {
    return matchedItems2.sort(function(a2, b) {
      return sortRankedValues(a2, b, baseSort);
    });
  } : _options$sorter;
  var matchedItems = items.reduce(reduceItemsToRanked, []);
  return sorter(matchedItems).map(function(_ref) {
    var item = _ref.item;
    return item;
  });
  function reduceItemsToRanked(matches2, item, index3) {
    var rankingInfo = getHighestRanking(item, keys2, value, options);
    var rank = rankingInfo.rank, _rankingInfo$keyThres = rankingInfo.keyThreshold, keyThreshold = _rankingInfo$keyThres === void 0 ? threshold : _rankingInfo$keyThres;
    if (rank >= keyThreshold) {
      matches2.push(_extends({}, rankingInfo, {
        item,
        index: index3
      }));
    }
    return matches2;
  }
}
function getHighestRanking(item, keys2, value, options) {
  if (!keys2) {
    var stringItem = item;
    return {
      rankedValue: stringItem,
      rank: getMatchRanking(stringItem, value, options),
      keyIndex: -1,
      keyThreshold: options.threshold
    };
  }
  var valuesToRank = getAllValuesToRank(item, keys2);
  return valuesToRank.reduce(function(_ref2, _ref3, i2) {
    var rank = _ref2.rank, rankedValue = _ref2.rankedValue, keyIndex = _ref2.keyIndex, keyThreshold = _ref2.keyThreshold;
    var itemValue = _ref3.itemValue, attributes = _ref3.attributes;
    var newRank = getMatchRanking(itemValue, value, options);
    var newRankedValue = rankedValue;
    var minRanking = attributes.minRanking, maxRanking = attributes.maxRanking, threshold = attributes.threshold;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    if (newRank > rank) {
      rank = newRank;
      keyIndex = i2;
      keyThreshold = threshold;
      newRankedValue = itemValue;
    }
    return {
      rankedValue: newRankedValue,
      rank,
      keyIndex,
      keyThreshold
    };
  }, {
    rankedValue: item,
    rank: rankings.NO_MATCH,
    keyIndex: -1,
    keyThreshold: options.threshold
  });
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(" " + stringToRank)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string) {
  var acronym = "";
  var wordsInString = string.split(" ");
  wordsInString.forEach(function(wordInString) {
    var splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach(function(splitByHyphenWord) {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getClosenessRanking(testString, stringToRank) {
  var matchingInOrderCharCount = 0;
  var charNumber = 0;
  function findMatchingCharacter(matchChar2, string, index3) {
    for (var j = index3, J = string.length; j < J; j++) {
      var stringChar = string[j];
      if (stringChar === matchChar2) {
        matchingInOrderCharCount += 1;
        return j + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    var spreadPercentage = 1 / spread2;
    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    var ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return ranking;
  }
  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (var i2 = 1, I = stringToRank.length; i2 < I; i2++) {
    var matchChar = stringToRank[i2];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    var found2 = charNumber > -1;
    if (!found2) {
      return rankings.NO_MATCH;
    }
  }
  var spread = charNumber - firstIndex;
  return getRanking(spread);
}
function sortRankedValues(a2, b, baseSort) {
  var aFirst = -1;
  var bFirst = 1;
  var aRank = a2.rank, aKeyIndex = a2.keyIndex;
  var bRank = b.rank, bKeyIndex = b.keyIndex;
  var same = aRank === bRank;
  if (same) {
    if (aKeyIndex === bKeyIndex) {
      return baseSort(a2, b);
    } else {
      return aKeyIndex < bKeyIndex ? aFirst : bFirst;
    }
  } else {
    return aRank > bRank ? aFirst : bFirst;
  }
}
function prepareValueForComparison(value, _ref4) {
  var keepDiacritics = _ref4.keepDiacritics;
  value = "" + value;
  if (!keepDiacritics) {
    value = removeAccents$1(value);
  }
  return value;
}
function getItemValues(item, key) {
  if (typeof key === "object") {
    key = key.key;
  }
  var value;
  if (typeof key === "function") {
    value = key(item);
  } else if (item == null) {
    value = null;
  } else if (Object.hasOwnProperty.call(item, key)) {
    value = item[key];
  } else if (key.includes(".")) {
    return getNestedValues(key, item);
  } else {
    value = null;
  }
  if (value == null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value;
  }
  return [String(value)];
}
function getNestedValues(path, item) {
  var keys2 = path.split(".");
  var values2 = [item];
  for (var i2 = 0, I = keys2.length; i2 < I; i2++) {
    var nestedKey = keys2[i2];
    var nestedValues = [];
    for (var j = 0, J = values2.length; j < J; j++) {
      var nestedItem = values2[j];
      if (nestedItem == null)
        continue;
      if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {
        var nestedValue = nestedItem[nestedKey];
        if (nestedValue != null) {
          nestedValues.push(nestedValue);
        }
      } else if (nestedKey === "*") {
        nestedValues = nestedValues.concat(nestedItem);
      }
    }
    values2 = nestedValues;
  }
  if (Array.isArray(values2[0])) {
    var result2 = [];
    return result2.concat.apply(result2, values2);
  }
  return values2;
}
function getAllValuesToRank(item, keys2) {
  var allValues = [];
  for (var j = 0, J = keys2.length; j < J; j++) {
    var key = keys2[j];
    var attributes = getKeyAttributes(key);
    var itemValues = getItemValues(item, key);
    for (var i2 = 0, I = itemValues.length; i2 < I; i2++) {
      allValues.push({
        itemValue: itemValues[i2],
        attributes
      });
    }
  }
  return allValues;
}
var defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity
};
function getKeyAttributes(key) {
  if (typeof key === "string") {
    return defaultKeyAttributes;
  }
  return _extends({}, defaultKeyAttributes, key);
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$2(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray$2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o2, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _createForOfIteratorHelperLoose$2(o2, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray$2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      return function() {
        if (i2 >= o2.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o2[i2++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o2[Symbol.iterator]();
  return it.next.bind(it);
}
var SystemContext = /* @__PURE__ */ react$1.exports.createContext({});
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$1(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o2, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _createForOfIteratorHelperLoose$1(o2, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray$1(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      return function() {
        if (i2 >= o2.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o2[i2++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o2[Symbol.iterator]();
  return it.next.bind(it);
}
function isRenderProp(children) {
  return typeof children === "function";
}
var useCreateElement = function useCreateElement2(type2, props, children) {
  if (children === void 0) {
    children = props.children;
  }
  var context2 = react$1.exports.useContext(SystemContext);
  if (context2.useCreateElement) {
    return context2.useCreateElement(type2, props, children);
  }
  if (typeof type2 === "string" && isRenderProp(children)) {
    props.children;
    var rest = _objectWithoutPropertiesLoose$1(props, ["children"]);
    return children(rest);
  }
  return /* @__PURE__ */ react$1.exports.createElement(type2, props, children);
};
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      return function() {
        if (i2 >= o2.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o2[i2++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o2[Symbol.iterator]();
  return it.next.bind(it);
}
function isObject2(arg) {
  return typeof arg === "object" && arg != null;
}
function isPlainObject2(arg) {
  var _proto$constructor;
  if (!isObject2(arg))
    return false;
  var proto = Object.getPrototypeOf(arg);
  if (proto == null)
    return true;
  return ((_proto$constructor = proto.constructor) === null || _proto$constructor === void 0 ? void 0 : _proto$constructor.toString()) === Object.toString();
}
function __deprecatedSplitProps(props, keys2) {
  var propsKeys = Object.keys(props);
  var picked = {};
  var omitted = {};
  for (var _i = 0, _propsKeys = propsKeys; _i < _propsKeys.length; _i++) {
    var key = _propsKeys[_i];
    if (keys2.indexOf(key) >= 0) {
      picked[key] = props[key];
    } else {
      omitted[key] = props[key];
    }
  }
  return [picked, omitted];
}
function splitProps(props, keys2) {
  if (keys2 === void 0) {
    keys2 = [];
  }
  if (!isPlainObject2(props.state)) {
    return __deprecatedSplitProps(props, keys2);
  }
  var _deprecatedSplitProp = __deprecatedSplitProps(props, [].concat(keys2, ["state"])), picked = _deprecatedSplitProp[0], omitted = _deprecatedSplitProp[1];
  var state = picked.state, restPicked = _objectWithoutPropertiesLoose(picked, ["state"]);
  return [_objectSpread2(_objectSpread2({}, state), restPicked), omitted];
}
function shallowEqual(objA, objB) {
  if (objA === objB)
    return true;
  if (!objA)
    return false;
  if (!objB)
    return false;
  if (typeof objA !== "object")
    return false;
  if (typeof objB !== "object")
    return false;
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var length = aKeys.length;
  if (bKeys.length !== length)
    return false;
  for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {
    var key = _aKeys[_i];
    if (objA[key] !== objB[key]) {
      return false;
    }
  }
  return true;
}
function normalizePropsAreEqual(propsAreEqual6) {
  if (propsAreEqual6.name === "normalizePropsAreEqualInner") {
    return propsAreEqual6;
  }
  return function normalizePropsAreEqualInner(prev, next) {
    if (!isPlainObject2(prev.state) || !isPlainObject2(next.state)) {
      return propsAreEqual6(prev, next);
    }
    return propsAreEqual6(_objectSpread2(_objectSpread2({}, prev.state), prev), _objectSpread2(_objectSpread2({}, next.state), next));
  };
}
function forwardRef(component) {
  return /* @__PURE__ */ react$1.exports.forwardRef(component);
}
function memo(component, propsAreEqual6) {
  return /* @__PURE__ */ react$1.exports.memo(component, propsAreEqual6);
}
function createComponent(_ref) {
  var type2 = _ref.as, useHook = _ref.useHook, shouldMemo = _ref.memo, _ref$propsAreEqual = _ref.propsAreEqual, propsAreEqual6 = _ref$propsAreEqual === void 0 ? useHook === null || useHook === void 0 ? void 0 : useHook.unstable_propsAreEqual : _ref$propsAreEqual, _ref$keys = _ref.keys, keys2 = _ref$keys === void 0 ? (useHook === null || useHook === void 0 ? void 0 : useHook.__keys) || [] : _ref$keys, _ref$useCreateElement = _ref.useCreateElement, useCreateElement$17 = _ref$useCreateElement === void 0 ? useCreateElement : _ref$useCreateElement;
  var Comp = function Comp2(_ref2, ref2) {
    var _ref2$as = _ref2.as, as = _ref2$as === void 0 ? type2 : _ref2$as, props = _objectWithoutPropertiesLoose$1(_ref2, ["as"]);
    if (useHook) {
      var _as$render;
      var _splitProps = splitProps(props, keys2), _options2 = _splitProps[0], htmlProps = _splitProps[1];
      var _useHook = useHook(_options2, _objectSpread2$1({
        ref: ref2
      }, htmlProps)), wrapElement = _useHook.wrapElement, elementProps = _objectWithoutPropertiesLoose$1(_useHook, ["wrapElement"]);
      var asKeys = ((_as$render = as.render) === null || _as$render === void 0 ? void 0 : _as$render.__keys) || as.__keys;
      var asOptions = asKeys && splitProps(props, asKeys)[0];
      var allProps = asOptions ? _objectSpread2$1(_objectSpread2$1({}, elementProps), asOptions) : elementProps;
      var _element = useCreateElement$17(as, allProps);
      if (wrapElement) {
        return wrapElement(_element);
      }
      return _element;
    }
    return useCreateElement$17(as, _objectSpread2$1({
      ref: ref2
    }, props));
  };
  if (useHook) {
    Comp.displayName = useHook.name.replace(/^(unstable_)?use/, "");
  }
  Comp = forwardRef(Comp);
  if (shouldMemo) {
    Comp = memo(Comp, propsAreEqual6 && normalizePropsAreEqual(propsAreEqual6));
  }
  Comp.__keys = keys2;
  Comp.unstable_propsAreEqual = normalizePropsAreEqual(propsAreEqual6 || shallowEqual);
  return Comp;
}
function useToken(token, defaultValue) {
  react$1.exports.useDebugValue(token);
  var context2 = react$1.exports.useContext(SystemContext);
  return context2[token] != null ? context2[token] : defaultValue;
}
function useProps(name, options, htmlProps) {
  if (options === void 0) {
    options = {};
  }
  if (htmlProps === void 0) {
    htmlProps = {};
  }
  var hookName = "use" + name + "Props";
  react$1.exports.useDebugValue(hookName);
  var useHook = useToken(hookName);
  if (useHook) {
    return useHook(options, htmlProps);
  }
  return htmlProps;
}
function useOptions(name, options, htmlProps) {
  if (options === void 0) {
    options = {};
  }
  if (htmlProps === void 0) {
    htmlProps = {};
  }
  var hookName = "use" + name + "Options";
  react$1.exports.useDebugValue(hookName);
  var useHook = useToken(hookName);
  if (useHook) {
    return _objectSpread2$1(_objectSpread2$1({}, options), useHook(options, htmlProps));
  }
  return options;
}
function toArray(arg) {
  if (Array.isArray(arg)) {
    return arg;
  }
  return typeof arg !== "undefined" ? [arg] : [];
}
function createHook(options) {
  var _options$useState, _composedHooks$;
  var composedHooks = toArray(options.compose);
  var __useOptions = function __useOptions2(hookOptions, htmlProps) {
    if (options.useOptions) {
      hookOptions = options.useOptions(hookOptions, htmlProps);
    }
    if (options.name) {
      hookOptions = useOptions(options.name, hookOptions, htmlProps);
    }
    if (options.compose) {
      for (var _iterator = _createForOfIteratorHelperLoose$1(composedHooks), _step; !(_step = _iterator()).done; ) {
        var hook = _step.value;
        hookOptions = hook.__useOptions(hookOptions, htmlProps);
      }
    }
    return hookOptions;
  };
  var useHook = function useHook2(hookOptions, htmlProps, unstable_ignoreUseOptions) {
    if (hookOptions === void 0) {
      hookOptions = {};
    }
    if (htmlProps === void 0) {
      htmlProps = {};
    }
    if (unstable_ignoreUseOptions === void 0) {
      unstable_ignoreUseOptions = false;
    }
    if (!unstable_ignoreUseOptions) {
      hookOptions = __useOptions(hookOptions, htmlProps);
    }
    if (options.useProps) {
      htmlProps = options.useProps(hookOptions, htmlProps);
    }
    if (options.name) {
      htmlProps = useProps(options.name, hookOptions, htmlProps);
    }
    if (options.compose) {
      if (options.useComposeOptions) {
        hookOptions = options.useComposeOptions(hookOptions, htmlProps);
      }
      if (options.useComposeProps) {
        htmlProps = options.useComposeProps(hookOptions, htmlProps);
      } else {
        for (var _iterator2 = _createForOfIteratorHelperLoose$1(composedHooks), _step2; !(_step2 = _iterator2()).done; ) {
          var hook = _step2.value;
          htmlProps = hook(hookOptions, htmlProps, true);
        }
      }
    }
    var finalHTMLProps = {};
    var definedHTMLProps = htmlProps || {};
    for (var prop in definedHTMLProps) {
      if (definedHTMLProps[prop] !== void 0) {
        finalHTMLProps[prop] = definedHTMLProps[prop];
      }
    }
    return finalHTMLProps;
  };
  useHook.__useOptions = __useOptions;
  var composedKeys = composedHooks.reduce(function(keys2, hook) {
    keys2.push.apply(keys2, hook.__keys || []);
    return keys2;
  }, []);
  useHook.__keys = [].concat(composedKeys, ((_options$useState = options.useState) === null || _options$useState === void 0 ? void 0 : _options$useState.__keys) || [], options.keys || []);
  useHook.unstable_propsAreEqual = options.propsAreEqual || ((_composedHooks$ = composedHooks[0]) === null || _composedHooks$ === void 0 ? void 0 : _composedHooks$.unstable_propsAreEqual) || shallowEqual;
  if (options.name) {
    Object.defineProperty(useHook, "name", {
      value: "use" + options.name
    });
  }
  return useHook;
}
function setRef(ref2, value) {
  if (value === void 0) {
    value = null;
  }
  if (!ref2)
    return;
  if (typeof ref2 === "function") {
    ref2(value);
  } else {
    ref2.current = value;
  }
}
function useForkRef(refA, refB) {
  return react$1.exports.useMemo(function() {
    if (refA == null && refB == null) {
      return null;
    }
    return function(value) {
      setRef(refA, value);
      setRef(refB, value);
    };
  }, [refA, refB]);
}
var buttonInputTypes = ["button", "color", "file", "image", "reset", "submit"];
function isButton(element) {
  if (element.tagName === "BUTTON")
    return true;
  if (element.tagName === "INPUT") {
    var input = element;
    return buttonInputTypes.indexOf(input.type) !== -1;
  }
  return false;
}
function flatten$1(array) {
  var flat = [];
  for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done; ) {
    var maybeArray = _step.value;
    if (Array.isArray(maybeArray)) {
      flat.push.apply(flat, flatten$1(maybeArray));
    } else {
      flat.push(maybeArray);
    }
  }
  return flat;
}
function warning(condition) {
  {
    var _console;
    if (!condition)
      return;
    for (var _len = arguments.length, messages2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      messages2[_key - 1] = arguments[_key];
    }
    var warns = flatten$1(messages2.map(function(message) {
      return [message, "\n"];
    }));
    (_console = console).warn.apply(_console, warns.slice(0, -1));
    try {
      throw Error(warns.join(""));
    } catch (x) {
    }
  }
}
function isRefObject(ref2) {
  return isObject2(ref2) && "current" in ref2;
}
function useWarning(condition) {
  for (var _len = arguments.length, messages2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    messages2[_key - 1] = arguments[_key];
  }
  {
    react$1.exports.useEffect(function() {
      warning.apply(void 0, [condition].concat(messages2.map(function(message) {
        return isRefObject(message) ? message.current : message;
      })));
    }, [condition]);
  }
}
function getDocument(element) {
  return element ? element.ownerDocument || element : document;
}
var _window;
try {
  _window = window;
} catch (e2) {
}
function getWindow$1(element) {
  if (!element) {
    return _window;
  }
  return getDocument(element).defaultView || _window;
}
function checkIsBrowser() {
  var _window2 = getWindow$1();
  return Boolean(typeof _window2 !== "undefined" && _window2.document && _window2.document.createElement);
}
var canUseDOM = checkIsBrowser();
var useIsomorphicEffect = !canUseDOM ? react$1.exports.useEffect : react$1.exports.useLayoutEffect;
function useLiveRef(value) {
  var ref2 = react$1.exports.useRef(value);
  useIsomorphicEffect(function() {
    ref2.current = value;
  });
  return ref2;
}
function isSelfTarget(event) {
  return event.target === event.currentTarget;
}
function getActiveElement(element) {
  var _getDocument = getDocument(element), activeElement = _getDocument.activeElement;
  if (!(activeElement !== null && activeElement !== void 0 && activeElement.nodeName)) {
    return null;
  }
  return activeElement;
}
function contains$1(parent, child3) {
  return parent === child3 || parent.contains(child3);
}
function hasFocusWithin(element) {
  var activeElement = getActiveElement(element);
  if (!activeElement)
    return false;
  if (contains$1(element, activeElement))
    return true;
  var activeDescendant = activeElement.getAttribute("aria-activedescendant");
  if (!activeDescendant)
    return false;
  if (activeDescendant === element.id)
    return true;
  return !!element.querySelector("#" + activeDescendant);
}
function isPortalEvent(event) {
  return !contains$1(event.currentTarget, event.target);
}
function isUA(string) {
  if (!canUseDOM)
    return false;
  return window.navigator.userAgent.indexOf(string) !== -1;
}
function matches(element, selectors) {
  if ("matches" in element) {
    return element.matches(selectors);
  }
  if ("msMatchesSelector" in element) {
    return element.msMatchesSelector(selectors);
  }
  return element.webkitMatchesSelector(selectors);
}
function closest(element, selectors) {
  if ("closest" in element)
    return element.closest(selectors);
  do {
    if (matches(element, selectors))
      return element;
    element = element.parentElement || element.parentNode;
  } while (element !== null && element.nodeType === 1);
  return null;
}
var selector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false'])";
function isVisible(element) {
  var htmlElement = element;
  return htmlElement.offsetWidth > 0 || htmlElement.offsetHeight > 0 || element.getClientRects().length > 0;
}
function hasNegativeTabIndex(element) {
  var tabIndex = parseInt(element.getAttribute("tabindex") || "0", 10);
  return tabIndex < 0;
}
function isFocusable(element) {
  return matches(element, selector) && isVisible(element);
}
function isTabbable(element) {
  return isFocusable(element) && !hasNegativeTabIndex(element);
}
function getAllTabbableIn(container, fallbackToFocusable) {
  var allFocusable = Array.from(container.querySelectorAll(selector));
  var allTabbable = allFocusable.filter(isTabbable);
  if (isTabbable(container)) {
    allTabbable.unshift(container);
  }
  if (!allTabbable.length && fallbackToFocusable) {
    return allFocusable;
  }
  return allTabbable;
}
function getFirstTabbableIn(container, fallbackToFocusable) {
  var _getAllTabbableIn = getAllTabbableIn(container, fallbackToFocusable), first = _getAllTabbableIn[0];
  return first || null;
}
function getLastTabbableIn(container, fallbackToFocusable) {
  var allTabbable = getAllTabbableIn(container, fallbackToFocusable);
  return allTabbable[allTabbable.length - 1] || null;
}
var ROLE_KEYS = ["unstable_system"];
var useRole = createHook({
  name: "Role",
  keys: ROLE_KEYS,
  propsAreEqual: function propsAreEqual(prev, next) {
    var prevSystem = prev.unstable_system, prevProps = _objectWithoutPropertiesLoose$2(prev, ["unstable_system"]);
    var nextSystem = next.unstable_system, nextProps = _objectWithoutPropertiesLoose$2(next, ["unstable_system"]);
    if (prevSystem !== nextSystem && !shallowEqual(prevSystem, nextSystem)) {
      return false;
    }
    return shallowEqual(prevProps, nextProps);
  }
});
createComponent({
  as: "div",
  useHook: useRole
});
var TABBABLE_KEYS = ["disabled", "focusable"];
var isSafariOrFirefoxOnMac = isUA("Mac") && !isUA("Chrome") && (isUA("Safari") || isUA("Firefox"));
function focusIfNeeded(element) {
  if (!hasFocusWithin(element) && isFocusable(element)) {
    element.focus();
  }
}
function isNativeTabbable(element) {
  return ["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"].includes(element.tagName);
}
function supportsDisabledAttribute(element) {
  return ["BUTTON", "INPUT", "SELECT", "TEXTAREA"].includes(element.tagName);
}
function getTabIndex(trulyDisabled, nativeTabbable, supportsDisabled, htmlTabIndex) {
  if (trulyDisabled) {
    if (nativeTabbable && !supportsDisabled) {
      return -1;
    }
    return void 0;
  }
  if (nativeTabbable) {
    return htmlTabIndex;
  }
  return htmlTabIndex || 0;
}
function useDisableEvent(htmlEventRef, disabled) {
  return react$1.exports.useCallback(function(event) {
    var _htmlEventRef$current;
    (_htmlEventRef$current = htmlEventRef.current) === null || _htmlEventRef$current === void 0 ? void 0 : _htmlEventRef$current.call(htmlEventRef, event);
    if (event.defaultPrevented)
      return;
    if (disabled) {
      event.stopPropagation();
      event.preventDefault();
    }
  }, [htmlEventRef, disabled]);
}
var useTabbable = createHook({
  name: "Tabbable",
  compose: useRole,
  keys: TABBABLE_KEYS,
  useOptions: function useOptions2(options, _ref) {
    var disabled = _ref.disabled;
    return _objectSpread2$2({
      disabled
    }, options);
  },
  useProps: function useProps2(options, _ref2) {
    var htmlRef = _ref2.ref, htmlTabIndex = _ref2.tabIndex, htmlOnClickCapture = _ref2.onClickCapture, htmlOnMouseDownCapture = _ref2.onMouseDownCapture, htmlOnMouseDown = _ref2.onMouseDown, htmlOnKeyPressCapture = _ref2.onKeyPressCapture, htmlStyle = _ref2.style, htmlProps = _objectWithoutPropertiesLoose$2(_ref2, ["ref", "tabIndex", "onClickCapture", "onMouseDownCapture", "onMouseDown", "onKeyPressCapture", "style"]);
    var ref2 = react$1.exports.useRef(null);
    var onClickCaptureRef = useLiveRef(htmlOnClickCapture);
    var onMouseDownCaptureRef = useLiveRef(htmlOnMouseDownCapture);
    var onMouseDownRef = useLiveRef(htmlOnMouseDown);
    var onKeyPressCaptureRef = useLiveRef(htmlOnKeyPressCapture);
    var trulyDisabled = !!options.disabled && !options.focusable;
    var _React$useState = react$1.exports.useState(true), nativeTabbable = _React$useState[0], setNativeTabbable = _React$useState[1];
    var _React$useState2 = react$1.exports.useState(true), supportsDisabled = _React$useState2[0], setSupportsDisabled = _React$useState2[1];
    var style = options.disabled ? _objectSpread2$2({
      pointerEvents: "none"
    }, htmlStyle) : htmlStyle;
    useIsomorphicEffect(function() {
      var tabbable = ref2.current;
      if (!tabbable) {
        warning(true, "Can't determine if the element is a native tabbable element because `ref` wasn't passed to the component.", "See https://reakit.io/docs/tabbable");
        return;
      }
      if (!isNativeTabbable(tabbable)) {
        setNativeTabbable(false);
      }
      if (!supportsDisabledAttribute(tabbable)) {
        setSupportsDisabled(false);
      }
    }, []);
    var onClickCapture = useDisableEvent(onClickCaptureRef, options.disabled);
    var onMouseDownCapture = useDisableEvent(onMouseDownCaptureRef, options.disabled);
    var onKeyPressCapture = useDisableEvent(onKeyPressCaptureRef, options.disabled);
    var onMouseDown = react$1.exports.useCallback(function(event) {
      var _onMouseDownRef$curre;
      (_onMouseDownRef$curre = onMouseDownRef.current) === null || _onMouseDownRef$curre === void 0 ? void 0 : _onMouseDownRef$curre.call(onMouseDownRef, event);
      var element = event.currentTarget;
      if (event.defaultPrevented)
        return;
      if (!isSafariOrFirefoxOnMac)
        return;
      if (isPortalEvent(event))
        return;
      if (!isButton(element))
        return;
      var raf = requestAnimationFrame(function() {
        element.removeEventListener("mouseup", focusImmediately, true);
        focusIfNeeded(element);
      });
      var focusImmediately = function focusImmediately2() {
        cancelAnimationFrame(raf);
        focusIfNeeded(element);
      };
      element.addEventListener("mouseup", focusImmediately, {
        once: true,
        capture: true
      });
    }, []);
    return _objectSpread2$2({
      ref: useForkRef(ref2, htmlRef),
      style,
      tabIndex: getTabIndex(trulyDisabled, nativeTabbable, supportsDisabled, htmlTabIndex),
      disabled: trulyDisabled && supportsDisabled ? true : void 0,
      "aria-disabled": options.disabled ? true : void 0,
      onClickCapture,
      onMouseDownCapture,
      onMouseDown,
      onKeyPressCapture
    }, htmlProps);
  }
});
createComponent({
  as: "div",
  useHook: useTabbable
});
var CLICKABLE_KEYS = ["unstable_clickOnEnter", "unstable_clickOnSpace"];
function isNativeClick(event) {
  var element = event.currentTarget;
  if (!event.isTrusted)
    return false;
  return isButton(element) || element.tagName === "INPUT" || element.tagName === "TEXTAREA" || element.tagName === "A" || element.tagName === "SELECT";
}
var useClickable = createHook({
  name: "Clickable",
  compose: useTabbable,
  keys: CLICKABLE_KEYS,
  useOptions: function useOptions3(_ref) {
    var _ref$unstable_clickOn = _ref.unstable_clickOnEnter, unstable_clickOnEnter = _ref$unstable_clickOn === void 0 ? true : _ref$unstable_clickOn, _ref$unstable_clickOn2 = _ref.unstable_clickOnSpace, unstable_clickOnSpace = _ref$unstable_clickOn2 === void 0 ? true : _ref$unstable_clickOn2, options = _objectWithoutPropertiesLoose$2(_ref, ["unstable_clickOnEnter", "unstable_clickOnSpace"]);
    return _objectSpread2$2({
      unstable_clickOnEnter,
      unstable_clickOnSpace
    }, options);
  },
  useProps: function useProps3(options, _ref2) {
    var htmlOnKeyDown = _ref2.onKeyDown, htmlOnKeyUp = _ref2.onKeyUp, htmlProps = _objectWithoutPropertiesLoose$2(_ref2, ["onKeyDown", "onKeyUp"]);
    var _React$useState = react$1.exports.useState(false), active = _React$useState[0], setActive = _React$useState[1];
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var onKeyUpRef = useLiveRef(htmlOnKeyUp);
    var onKeyDown = react$1.exports.useCallback(function(event) {
      var _onKeyDownRef$current;
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented)
        return;
      if (options.disabled)
        return;
      if (event.metaKey)
        return;
      if (!isSelfTarget(event))
        return;
      var isEnter = options.unstable_clickOnEnter && event.key === "Enter";
      var isSpace = options.unstable_clickOnSpace && event.key === " ";
      if (isEnter || isSpace) {
        if (isNativeClick(event))
          return;
        event.preventDefault();
        if (isEnter) {
          event.currentTarget.click();
        } else if (isSpace) {
          setActive(true);
        }
      }
    }, [options.disabled, options.unstable_clickOnEnter, options.unstable_clickOnSpace]);
    var onKeyUp = react$1.exports.useCallback(function(event) {
      var _onKeyUpRef$current;
      (_onKeyUpRef$current = onKeyUpRef.current) === null || _onKeyUpRef$current === void 0 ? void 0 : _onKeyUpRef$current.call(onKeyUpRef, event);
      if (event.defaultPrevented)
        return;
      if (options.disabled)
        return;
      if (event.metaKey)
        return;
      var isSpace = options.unstable_clickOnSpace && event.key === " ";
      if (active && isSpace) {
        setActive(false);
        event.currentTarget.click();
      }
    }, [options.disabled, options.unstable_clickOnSpace, active]);
    return _objectSpread2$2({
      "data-active": active || void 0,
      onKeyDown,
      onKeyUp
    }, htmlProps);
  }
});
createComponent({
  as: "button",
  memo: true,
  useHook: useClickable
});
var BUTTON_KEYS = [];
var useButton = createHook({
  name: "Button",
  compose: useClickable,
  keys: BUTTON_KEYS,
  useProps: function useProps4(_2, _ref) {
    var htmlRef = _ref.ref, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["ref"]);
    var ref2 = react$1.exports.useRef(null);
    var _React$useState = react$1.exports.useState(void 0), role = _React$useState[0], setRole = _React$useState[1];
    var _React$useState2 = react$1.exports.useState("button"), type2 = _React$useState2[0], setType = _React$useState2[1];
    react$1.exports.useEffect(function() {
      var element = ref2.current;
      if (!element) {
        warning(true, "Can't determine whether the element is a native button because `ref` wasn't passed to the component", "See https://reakit.io/docs/button");
        return;
      }
      if (!isButton(element)) {
        if (element.tagName !== "A") {
          setRole("button");
        }
        setType(void 0);
      }
    }, []);
    return _objectSpread2$2({
      ref: useForkRef(ref2, htmlRef),
      role,
      type: type2
    }, htmlProps);
  }
});
var Button = createComponent({
  as: "button",
  memo: true,
  useHook: useButton
});
function removeIndexFromArray(array, index3) {
  if (index3 === -1)
    return array;
  return [].concat(array.slice(0, index3), array.slice(index3 + 1));
}
function createEvent(element, type2, eventInit) {
  if (typeof Event === "function") {
    return new Event(type2, eventInit);
  }
  var event = getDocument(element).createEvent("Event");
  event.initEvent(type2, eventInit === null || eventInit === void 0 ? void 0 : eventInit.bubbles, eventInit === null || eventInit === void 0 ? void 0 : eventInit.cancelable);
  return event;
}
function useSealedState(initialState2) {
  var _React$useState = react$1.exports.useState(initialState2), sealed = _React$useState[0];
  return sealed;
}
function useUpdateEffect(effect2, deps) {
  var mounted = react$1.exports.useRef(false);
  react$1.exports.useEffect(function() {
    if (mounted.current) {
      return effect2();
    }
    mounted.current = true;
    return void 0;
  }, deps);
}
function createFocusEvent(element, type2, eventInit) {
  if (eventInit === void 0) {
    eventInit = {};
  }
  if (typeof FocusEvent === "function") {
    return new FocusEvent(type2, eventInit);
  }
  return createEvent(element, type2, eventInit);
}
function fireBlurEvent(element, eventInit) {
  var event = createFocusEvent(element, "blur", eventInit);
  var defaultAllowed = element.dispatchEvent(event);
  var bubbleInit = _objectSpread2(_objectSpread2({}, eventInit), {}, {
    bubbles: true
  });
  element.dispatchEvent(createFocusEvent(element, "focusout", bubbleInit));
  return defaultAllowed;
}
function createKeyboardEvent(element, type2, eventInit) {
  if (eventInit === void 0) {
    eventInit = {};
  }
  if (typeof KeyboardEvent === "function") {
    return new KeyboardEvent(type2, eventInit);
  }
  var event = getDocument(element).createEvent("KeyboardEvent");
  event.initKeyboardEvent(type2, eventInit.bubbles, eventInit.cancelable, getWindow$1(element), eventInit.key, eventInit.location, eventInit.ctrlKey, eventInit.altKey, eventInit.shiftKey, eventInit.metaKey);
  return event;
}
function fireKeyboardEvent(element, type2, eventInit) {
  return element.dispatchEvent(createKeyboardEvent(element, type2, eventInit));
}
var isIE11$1 = canUseDOM && "msCrypto" in window;
function getNextActiveElementOnBlur(event) {
  if (isIE11$1) {
    var activeElement = getActiveElement(event.currentTarget);
    return activeElement;
  }
  return event.relatedTarget;
}
function groupItems(items) {
  var groups = [[]];
  var _loop = function _loop2() {
    var item = _step.value;
    var group = groups.find(function(g) {
      return !g[0] || g[0].groupId === item.groupId;
    });
    if (group) {
      group.push(item);
    } else {
      groups.push([item]);
    }
  };
  for (var _iterator = _createForOfIteratorHelperLoose$2(items), _step; !(_step = _iterator()).done; ) {
    _loop();
  }
  return groups;
}
function flatten(grid) {
  var flattened = [];
  for (var _iterator = _createForOfIteratorHelperLoose$2(grid), _step; !(_step = _iterator()).done; ) {
    var row = _step.value;
    flattened.push.apply(flattened, row);
  }
  return flattened;
}
function reverse(array) {
  return array.slice().reverse();
}
function findFirstEnabledItem(items, excludeId) {
  if (excludeId) {
    return items.find(function(item) {
      return !item.disabled && item.id !== excludeId;
    });
  }
  return items.find(function(item) {
    return !item.disabled;
  });
}
function getCurrentId(options, passedId) {
  var _findFirstEnabledItem;
  if (passedId || passedId === null) {
    return passedId;
  }
  if (options.currentId || options.currentId === null) {
    return options.currentId;
  }
  return (_findFirstEnabledItem = findFirstEnabledItem(options.items || [])) === null || _findFirstEnabledItem === void 0 ? void 0 : _findFirstEnabledItem.id;
}
function findEnabledItemById(items, id) {
  if (!id)
    return void 0;
  return items === null || items === void 0 ? void 0 : items.find(function(item) {
    return item.id === id && !item.disabled;
  });
}
var COMPOSITE_STATE_KEYS = ["baseId", "unstable_idCountRef", "setBaseId", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget"];
var COMPOSITE_KEYS = COMPOSITE_STATE_KEYS;
var COMPOSITE_GROUP_KEYS = COMPOSITE_KEYS;
var COMPOSITE_ITEM_KEYS = COMPOSITE_GROUP_KEYS;
function userFocus(element) {
  element.userFocus = true;
  element.focus();
  element.userFocus = false;
}
function hasUserFocus(element) {
  return !!element.userFocus;
}
function setUserFocus(element, value) {
  element.userFocus = value;
}
var isIE11 = canUseDOM && "msCrypto" in window;
function canProxyKeyboardEvent(event) {
  if (!isSelfTarget(event))
    return false;
  if (event.metaKey)
    return false;
  if (event.key === "Tab")
    return false;
  return true;
}
function useKeyboardEventProxy(virtual, currentItem, htmlEventHandler) {
  var eventHandlerRef = useLiveRef(htmlEventHandler);
  return react$1.exports.useCallback(function(event) {
    var _eventHandlerRef$curr;
    (_eventHandlerRef$curr = eventHandlerRef.current) === null || _eventHandlerRef$curr === void 0 ? void 0 : _eventHandlerRef$curr.call(eventHandlerRef, event);
    if (event.defaultPrevented)
      return;
    if (virtual && canProxyKeyboardEvent(event)) {
      var currentElement = currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current;
      if (currentElement) {
        if (!fireKeyboardEvent(currentElement, event.type, event)) {
          event.preventDefault();
        }
        if (event.currentTarget.contains(currentElement)) {
          event.stopPropagation();
        }
      }
    }
  }, [virtual, currentItem]);
}
function useActiveElementRef(elementRef) {
  var activeElementRef = react$1.exports.useRef(null);
  react$1.exports.useEffect(function() {
    var document2 = getDocument(elementRef.current);
    var onFocus = function onFocus2(event) {
      var target = event.target;
      activeElementRef.current = target;
    };
    document2.addEventListener("focus", onFocus, true);
    return function() {
      document2.removeEventListener("focus", onFocus, true);
    };
  }, []);
  return activeElementRef;
}
function findFirstEnabledItemInTheLastRow(items) {
  return findFirstEnabledItem(flatten(reverse(groupItems(items))));
}
function isItem(items, element) {
  return items === null || items === void 0 ? void 0 : items.some(function(item) {
    return !!element && item.ref.current === element;
  });
}
function useScheduleUserFocus(currentItem) {
  var currentItemRef = useLiveRef(currentItem);
  var _React$useReducer = react$1.exports.useReducer(function(n2) {
    return n2 + 1;
  }, 0), scheduled = _React$useReducer[0], schedule = _React$useReducer[1];
  react$1.exports.useEffect(function() {
    var _currentItemRef$curre;
    var currentElement = (_currentItemRef$curre = currentItemRef.current) === null || _currentItemRef$curre === void 0 ? void 0 : _currentItemRef$curre.ref.current;
    if (scheduled && currentElement) {
      userFocus(currentElement);
    }
  }, [scheduled]);
  return schedule;
}
var useComposite = createHook({
  name: "Composite",
  compose: [useTabbable],
  keys: COMPOSITE_KEYS,
  useOptions: function useOptions4(options) {
    return _objectSpread2$2(_objectSpread2$2({}, options), {}, {
      currentId: getCurrentId(options)
    });
  },
  useProps: function useProps5(options, _ref) {
    var htmlRef = _ref.ref, htmlOnFocusCapture = _ref.onFocusCapture, htmlOnFocus = _ref.onFocus, htmlOnBlurCapture = _ref.onBlurCapture, htmlOnKeyDown = _ref.onKeyDown, htmlOnKeyDownCapture = _ref.onKeyDownCapture, htmlOnKeyUpCapture = _ref.onKeyUpCapture, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["ref", "onFocusCapture", "onFocus", "onBlurCapture", "onKeyDown", "onKeyDownCapture", "onKeyUpCapture"]);
    var ref2 = react$1.exports.useRef(null);
    var currentItem = findEnabledItemById(options.items, options.currentId);
    var previousElementRef = react$1.exports.useRef(null);
    var onFocusCaptureRef = useLiveRef(htmlOnFocusCapture);
    var onFocusRef = useLiveRef(htmlOnFocus);
    var onBlurCaptureRef = useLiveRef(htmlOnBlurCapture);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var scheduleUserFocus = useScheduleUserFocus(currentItem);
    var activeElementRef = isIE11 ? useActiveElementRef(ref2) : void 0;
    react$1.exports.useEffect(function() {
      var element = ref2.current;
      if (options.unstable_moves && !currentItem) {
        warning(!element, "Can't focus composite component because `ref` wasn't passed to component.", "See https://reakit.io/docs/composite");
        element === null || element === void 0 ? void 0 : element.focus();
      }
    }, [options.unstable_moves, currentItem]);
    var onKeyDownCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyDownCapture);
    var onKeyUpCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyUpCapture);
    var onFocusCapture = react$1.exports.useCallback(function(event) {
      var _onFocusCaptureRef$cu;
      (_onFocusCaptureRef$cu = onFocusCaptureRef.current) === null || _onFocusCaptureRef$cu === void 0 ? void 0 : _onFocusCaptureRef$cu.call(onFocusCaptureRef, event);
      if (event.defaultPrevented)
        return;
      if (!options.unstable_virtual)
        return;
      var previousActiveElement = (activeElementRef === null || activeElementRef === void 0 ? void 0 : activeElementRef.current) || event.relatedTarget;
      var previousActiveElementWasItem = isItem(options.items, previousActiveElement);
      if (isSelfTarget(event) && previousActiveElementWasItem) {
        event.stopPropagation();
        previousElementRef.current = previousActiveElement;
      }
    }, [options.unstable_virtual, options.items]);
    var onFocus = react$1.exports.useCallback(function(event) {
      var _onFocusRef$current;
      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
      if (event.defaultPrevented)
        return;
      if (options.unstable_virtual) {
        if (isSelfTarget(event)) {
          scheduleUserFocus();
        }
      } else if (isSelfTarget(event)) {
        var _options$setCurrentId;
        (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, null);
      }
    }, [options.unstable_virtual, options.setCurrentId]);
    var onBlurCapture = react$1.exports.useCallback(function(event) {
      var _onBlurCaptureRef$cur;
      (_onBlurCaptureRef$cur = onBlurCaptureRef.current) === null || _onBlurCaptureRef$cur === void 0 ? void 0 : _onBlurCaptureRef$cur.call(onBlurCaptureRef, event);
      if (event.defaultPrevented)
        return;
      if (!options.unstable_virtual)
        return;
      var currentElement = (currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current) || null;
      var nextActiveElement = getNextActiveElementOnBlur(event);
      var nextActiveElementIsItem = isItem(options.items, nextActiveElement);
      if (isSelfTarget(event) && nextActiveElementIsItem) {
        if (nextActiveElement === currentElement) {
          if (previousElementRef.current && previousElementRef.current !== nextActiveElement) {
            fireBlurEvent(previousElementRef.current, event);
          }
        } else if (currentElement) {
          fireBlurEvent(currentElement, event);
        }
        event.stopPropagation();
      } else {
        var targetIsItem = isItem(options.items, event.target);
        if (!targetIsItem && currentElement) {
          fireBlurEvent(currentElement, event);
        }
      }
    }, [options.unstable_virtual, options.items, currentItem]);
    var onKeyDown = react$1.exports.useCallback(function(event) {
      var _onKeyDownRef$current, _options$groups;
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented)
        return;
      if (options.currentId !== null)
        return;
      if (!isSelfTarget(event))
        return;
      var isVertical = options.orientation !== "horizontal";
      var isHorizontal = options.orientation !== "vertical";
      var isGrid = !!((_options$groups = options.groups) !== null && _options$groups !== void 0 && _options$groups.length);
      var up2 = function up3() {
        if (isGrid) {
          var item = findFirstEnabledItemInTheLastRow(options.items);
          if (item !== null && item !== void 0 && item.id) {
            var _options$move;
            (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, item.id);
          }
        } else {
          var _options$last;
          (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);
        }
      };
      var keyMap = {
        ArrowUp: (isGrid || isVertical) && up2,
        ArrowRight: (isGrid || isHorizontal) && options.first,
        ArrowDown: (isGrid || isVertical) && options.first,
        ArrowLeft: (isGrid || isHorizontal) && options.last,
        Home: options.first,
        End: options.last,
        PageUp: options.first,
        PageDown: options.last
      };
      var action2 = keyMap[event.key];
      if (action2) {
        event.preventDefault();
        action2();
      }
    }, [options.currentId, options.orientation, options.groups, options.items, options.move, options.last, options.first]);
    return _objectSpread2$2({
      ref: useForkRef(ref2, htmlRef),
      id: options.baseId,
      onFocus,
      onFocusCapture,
      onBlurCapture,
      onKeyDownCapture,
      onKeyDown,
      onKeyUpCapture,
      "aria-activedescendant": options.unstable_virtual ? (currentItem === null || currentItem === void 0 ? void 0 : currentItem.id) || void 0 : void 0
    }, htmlProps);
  },
  useComposeProps: function useComposeProps(options, htmlProps) {
    htmlProps = useRole(options, htmlProps, true);
    var tabbableHTMLProps = useTabbable(options, htmlProps, true);
    if (options.unstable_virtual || options.currentId === null) {
      return _objectSpread2$2({
        tabIndex: 0
      }, tabbableHTMLProps);
    }
    return _objectSpread2$2(_objectSpread2$2({}, htmlProps), {}, {
      ref: tabbableHTMLProps.ref
    });
  }
});
createComponent({
  as: "div",
  useHook: useComposite,
  useCreateElement: function useCreateElement$1(type2, props, children) {
    useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/composite");
    return useCreateElement(type2, props, children);
  }
});
function isTextField(element) {
  try {
    var isTextInput = element instanceof HTMLInputElement && element.selectionStart !== null;
    var isTextArea = element.tagName === "TEXTAREA";
    var isContentEditable = element.contentEditable === "true";
    return isTextInput || isTextArea || isContentEditable || false;
  } catch (error) {
    return false;
  }
}
function hasFocus2(element) {
  var activeElement = getActiveElement(element);
  if (!activeElement)
    return false;
  if (activeElement === element)
    return true;
  var activeDescendant = activeElement.getAttribute("aria-activedescendant");
  if (!activeDescendant)
    return false;
  return activeDescendant === element.id;
}
function ensureFocus(element, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, preventScroll = _ref.preventScroll, _ref$isActive = _ref.isActive, isActive = _ref$isActive === void 0 ? hasFocus2 : _ref$isActive;
  if (isActive(element))
    return -1;
  element.focus({
    preventScroll
  });
  if (isActive(element))
    return -1;
  return requestAnimationFrame(function() {
    element.focus({
      preventScroll
    });
  });
}
var defaultPrefix = "id";
function generateRandomString(prefix) {
  if (prefix === void 0) {
    prefix = defaultPrefix;
  }
  return (prefix ? prefix + "-" : "") + Math.random().toString(32).substr(2, 6);
}
var unstable_IdContext = /* @__PURE__ */ react$1.exports.createContext(generateRandomString);
function unstable_IdProvider(_ref) {
  var children = _ref.children, _ref$prefix = _ref.prefix, prefix = _ref$prefix === void 0 ? defaultPrefix : _ref$prefix;
  var count = react$1.exports.useRef(0);
  var generateId = react$1.exports.useCallback(function(localPrefix) {
    if (localPrefix === void 0) {
      localPrefix = prefix;
    }
    return (localPrefix ? localPrefix + "-" : "") + ++count.current;
  }, [prefix]);
  return /* @__PURE__ */ react$1.exports.createElement(unstable_IdContext.Provider, {
    value: generateId
  }, children);
}
var ID_STATE_KEYS = ["baseId", "unstable_idCountRef", "setBaseId"];
var ID_KEYS = [].concat(ID_STATE_KEYS, ["id"]);
var unstable_useId = createHook({
  keys: ID_KEYS,
  useOptions: function useOptions5(options, htmlProps) {
    var generateId = react$1.exports.useContext(unstable_IdContext);
    var _React$useState = react$1.exports.useState(function() {
      if (options.unstable_idCountRef) {
        options.unstable_idCountRef.current += 1;
        return "-" + options.unstable_idCountRef.current;
      }
      if (options.baseId) {
        return "-" + generateId("");
      }
      return "";
    }), suffix = _React$useState[0];
    var baseId = react$1.exports.useMemo(function() {
      return options.baseId || generateId();
    }, [options.baseId, generateId]);
    var id = htmlProps.id || options.id || "" + baseId + suffix;
    return _objectSpread2$2(_objectSpread2$2({}, options), {}, {
      id
    });
  },
  useProps: function useProps6(options, htmlProps) {
    return _objectSpread2$2({
      id: options.id
    }, htmlProps);
  }
});
createComponent({
  as: "div",
  useHook: unstable_useId
});
function fireEvent(element, type2, eventInit) {
  return element.dispatchEvent(createEvent(element, type2, eventInit));
}
function setTextFieldValue(element, value) {
  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
    var _Object$getOwnPropert;
    var proto = Object.getPrototypeOf(element);
    var setValue = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(proto, "value")) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.set;
    if (setValue) {
      setValue.call(element, value);
      fireEvent(element, "input", {
        bubbles: true
      });
    }
  }
}
function getWidget(itemElement) {
  return itemElement.querySelector("[data-composite-item-widget]");
}
function useItem(options) {
  return react$1.exports.useMemo(function() {
    var _options$items;
    return (_options$items = options.items) === null || _options$items === void 0 ? void 0 : _options$items.find(function(item) {
      return options.id && item.id === options.id;
    });
  }, [options.items, options.id]);
}
function targetIsAnotherItem(event, items) {
  if (isSelfTarget(event))
    return false;
  for (var _iterator = _createForOfIteratorHelperLoose$2(items), _step; !(_step = _iterator()).done; ) {
    var item = _step.value;
    if (item.ref.current === event.target) {
      return true;
    }
  }
  return false;
}
var useCompositeItem = createHook({
  name: "CompositeItem",
  compose: [useClickable, unstable_useId],
  keys: COMPOSITE_ITEM_KEYS,
  propsAreEqual: function propsAreEqual2(prev, next) {
    if (!next.id || prev.id !== next.id) {
      return useClickable.unstable_propsAreEqual(prev, next);
    }
    var prevCurrentId = prev.currentId, prevMoves = prev.unstable_moves, prevProps = _objectWithoutPropertiesLoose$2(prev, ["currentId", "unstable_moves"]);
    var nextCurrentId = next.currentId, nextMoves = next.unstable_moves, nextProps = _objectWithoutPropertiesLoose$2(next, ["currentId", "unstable_moves"]);
    if (nextCurrentId !== prevCurrentId) {
      if (next.id === nextCurrentId || next.id === prevCurrentId) {
        return false;
      }
    } else if (prevMoves !== nextMoves) {
      return false;
    }
    return useClickable.unstable_propsAreEqual(prevProps, nextProps);
  },
  useOptions: function useOptions6(options) {
    return _objectSpread2$2(_objectSpread2$2({}, options), {}, {
      id: options.id,
      currentId: getCurrentId(options),
      unstable_clickOnSpace: options.unstable_hasActiveWidget ? false : options.unstable_clickOnSpace
    });
  },
  useProps: function useProps7(options, _ref) {
    var _options$items2;
    var htmlRef = _ref.ref, _ref$tabIndex = _ref.tabIndex, htmlTabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, htmlOnMouseDown = _ref.onMouseDown, htmlOnFocus = _ref.onFocus, htmlOnBlurCapture = _ref.onBlurCapture, htmlOnKeyDown = _ref.onKeyDown, htmlOnClick = _ref.onClick, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["ref", "tabIndex", "onMouseDown", "onFocus", "onBlurCapture", "onKeyDown", "onClick"]);
    var ref2 = react$1.exports.useRef(null);
    var id = options.id;
    var trulyDisabled = options.disabled && !options.focusable;
    var isCurrentItem = options.currentId === id;
    var isCurrentItemRef = useLiveRef(isCurrentItem);
    var hasFocusedComposite = react$1.exports.useRef(false);
    var item = useItem(options);
    var onMouseDownRef = useLiveRef(htmlOnMouseDown);
    var onFocusRef = useLiveRef(htmlOnFocus);
    var onBlurCaptureRef = useLiveRef(htmlOnBlurCapture);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var onClickRef = useLiveRef(htmlOnClick);
    var shouldTabIndex = !options.unstable_virtual && !options.unstable_hasActiveWidget && isCurrentItem || !((_options$items2 = options.items) !== null && _options$items2 !== void 0 && _options$items2.length);
    react$1.exports.useEffect(function() {
      var _options$registerItem;
      if (!id)
        return void 0;
      (_options$registerItem = options.registerItem) === null || _options$registerItem === void 0 ? void 0 : _options$registerItem.call(options, {
        id,
        ref: ref2,
        disabled: !!trulyDisabled
      });
      return function() {
        var _options$unregisterIt;
        (_options$unregisterIt = options.unregisterItem) === null || _options$unregisterIt === void 0 ? void 0 : _options$unregisterIt.call(options, id);
      };
    }, [id, trulyDisabled, options.registerItem, options.unregisterItem]);
    react$1.exports.useEffect(function() {
      var element = ref2.current;
      if (!element) {
        warning(true, "Can't focus composite item component because `ref` wasn't passed to component.", "See https://reakit.io/docs/composite");
        return;
      }
      if (options.unstable_moves && isCurrentItemRef.current) {
        userFocus(element);
      }
    }, [options.unstable_moves]);
    var onMouseDown = react$1.exports.useCallback(function(event) {
      var _onMouseDownRef$curre;
      (_onMouseDownRef$curre = onMouseDownRef.current) === null || _onMouseDownRef$curre === void 0 ? void 0 : _onMouseDownRef$curre.call(onMouseDownRef, event);
      setUserFocus(event.currentTarget, true);
    }, []);
    var onFocus = react$1.exports.useCallback(function(event) {
      var _onFocusRef$current, _options$setCurrentId;
      var shouldFocusComposite = hasUserFocus(event.currentTarget);
      setUserFocus(event.currentTarget, false);
      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
      if (event.defaultPrevented)
        return;
      if (isPortalEvent(event))
        return;
      if (!id)
        return;
      if (targetIsAnotherItem(event, options.items))
        return;
      (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, id);
      if (shouldFocusComposite && options.unstable_virtual && options.baseId && isSelfTarget(event)) {
        var target = event.target;
        var composite = getDocument(target).getElementById(options.baseId);
        if (composite) {
          hasFocusedComposite.current = true;
          ensureFocus(composite);
        }
      }
    }, [id, options.items, options.setCurrentId, options.unstable_virtual, options.baseId]);
    var onBlurCapture = react$1.exports.useCallback(function(event) {
      var _onBlurCaptureRef$cur;
      (_onBlurCaptureRef$cur = onBlurCaptureRef.current) === null || _onBlurCaptureRef$cur === void 0 ? void 0 : _onBlurCaptureRef$cur.call(onBlurCaptureRef, event);
      if (event.defaultPrevented)
        return;
      if (options.unstable_virtual && hasFocusedComposite.current) {
        hasFocusedComposite.current = false;
        event.preventDefault();
        event.stopPropagation();
      }
    }, [options.unstable_virtual]);
    var onKeyDown = react$1.exports.useCallback(function(event) {
      var _onKeyDownRef$current;
      if (!isSelfTarget(event))
        return;
      var isVertical = options.orientation !== "horizontal";
      var isHorizontal = options.orientation !== "vertical";
      var isGrid = !!(item !== null && item !== void 0 && item.groupId);
      var keyMap = {
        ArrowUp: (isGrid || isVertical) && options.up,
        ArrowRight: (isGrid || isHorizontal) && options.next,
        ArrowDown: (isGrid || isVertical) && options.down,
        ArrowLeft: (isGrid || isHorizontal) && options.previous,
        Home: function Home() {
          if (!isGrid || event.ctrlKey) {
            var _options$first;
            (_options$first = options.first) === null || _options$first === void 0 ? void 0 : _options$first.call(options);
          } else {
            var _options$previous;
            (_options$previous = options.previous) === null || _options$previous === void 0 ? void 0 : _options$previous.call(options, true);
          }
        },
        End: function End() {
          if (!isGrid || event.ctrlKey) {
            var _options$last;
            (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);
          } else {
            var _options$next;
            (_options$next = options.next) === null || _options$next === void 0 ? void 0 : _options$next.call(options, true);
          }
        },
        PageUp: function PageUp() {
          if (isGrid) {
            var _options$up;
            (_options$up = options.up) === null || _options$up === void 0 ? void 0 : _options$up.call(options, true);
          } else {
            var _options$first2;
            (_options$first2 = options.first) === null || _options$first2 === void 0 ? void 0 : _options$first2.call(options);
          }
        },
        PageDown: function PageDown() {
          if (isGrid) {
            var _options$down;
            (_options$down = options.down) === null || _options$down === void 0 ? void 0 : _options$down.call(options, true);
          } else {
            var _options$last2;
            (_options$last2 = options.last) === null || _options$last2 === void 0 ? void 0 : _options$last2.call(options);
          }
        }
      };
      var action2 = keyMap[event.key];
      if (action2) {
        event.preventDefault();
        action2();
        return;
      }
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented)
        return;
      if (event.key.length === 1 && event.key !== " ") {
        var widget2 = getWidget(event.currentTarget);
        if (widget2 && isTextField(widget2)) {
          widget2.focus();
          setTextFieldValue(widget2, "");
        }
      } else if (event.key === "Delete" || event.key === "Backspace") {
        var _widget = getWidget(event.currentTarget);
        if (_widget && isTextField(_widget)) {
          event.preventDefault();
          setTextFieldValue(_widget, "");
        }
      }
    }, [options.orientation, item, options.up, options.next, options.down, options.previous, options.first, options.last]);
    var onClick = react$1.exports.useCallback(function(event) {
      var _onClickRef$current;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented)
        return;
      var element = event.currentTarget;
      var widget2 = getWidget(element);
      if (widget2 && !hasFocusWithin(widget2)) {
        widget2.focus();
      }
    }, []);
    return _objectSpread2$2({
      ref: useForkRef(ref2, htmlRef),
      id,
      tabIndex: shouldTabIndex ? htmlTabIndex : -1,
      "aria-selected": options.unstable_virtual && isCurrentItem ? true : void 0,
      onMouseDown,
      onFocus,
      onBlurCapture,
      onKeyDown,
      onClick
    }, htmlProps);
  }
});
createComponent({
  as: "button",
  memo: true,
  useHook: useCompositeItem
});
function isUpdater(argument) {
  return typeof argument === "function";
}
function applyState$1(argument, currentValue) {
  if (isUpdater(argument)) {
    return argument(currentValue);
  }
  return argument;
}
function unstable_useIdState(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var _useSealedState = useSealedState(initialState2), initialBaseId = _useSealedState.baseId;
  var generateId = react$1.exports.useContext(unstable_IdContext);
  var idCountRef = react$1.exports.useRef(0);
  var _React$useState = react$1.exports.useState(function() {
    return initialBaseId || generateId();
  }), baseId = _React$useState[0], setBaseId = _React$useState[1];
  return {
    baseId,
    setBaseId,
    unstable_idCountRef: idCountRef
  };
}
function isElementPreceding(element1, element2) {
  return Boolean(element2.compareDocumentPosition(element1) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, item) {
  return items.findIndex(function(currentItem) {
    if (!currentItem.ref.current || !item.ref.current) {
      return false;
    }
    return isElementPreceding(item.ref.current, currentItem.ref.current);
  });
}
function getMaxLength(rows) {
  var maxLength = 0;
  for (var _iterator = _createForOfIteratorHelperLoose$2(rows), _step; !(_step = _iterator()).done; ) {
    var length = _step.value.length;
    if (length > maxLength) {
      maxLength = length;
    }
  }
  return maxLength;
}
function verticalizeItems(items) {
  var groups = groupItems(items);
  var maxLength = getMaxLength(groups);
  var verticalized = [];
  for (var i2 = 0; i2 < maxLength; i2 += 1) {
    for (var _iterator = _createForOfIteratorHelperLoose$2(groups), _step; !(_step = _iterator()).done; ) {
      var group = _step.value;
      if (group[i2]) {
        verticalized.push(_objectSpread2$2(_objectSpread2$2({}, group[i2]), {}, {
          groupId: group[i2].groupId ? "" + i2 : void 0
        }));
      }
    }
  }
  return verticalized;
}
function createEmptyItem(groupId) {
  return {
    id: "__EMPTY_ITEM__",
    disabled: true,
    ref: {
      current: null
    },
    groupId
  };
}
function fillGroups(groups, currentId, shift2) {
  var maxLength = getMaxLength(groups);
  for (var _iterator = _createForOfIteratorHelperLoose$2(groups), _step; !(_step = _iterator()).done; ) {
    var group = _step.value;
    for (var i2 = 0; i2 < maxLength; i2 += 1) {
      var item = group[i2];
      if (!item || shift2 && item.disabled) {
        var isFrist = i2 === 0;
        var previousItem = isFrist && shift2 ? findFirstEnabledItem(group) : group[i2 - 1];
        group[i2] = previousItem && currentId !== (previousItem === null || previousItem === void 0 ? void 0 : previousItem.id) && shift2 ? previousItem : createEmptyItem(previousItem === null || previousItem === void 0 ? void 0 : previousItem.groupId);
      }
    }
  }
  return groups;
}
var nullItem = {
  id: null,
  ref: {
    current: null
  }
};
function placeItemsAfter(items, id, shouldInsertNullItem) {
  var index3 = items.findIndex(function(item) {
    return item.id === id;
  });
  return [].concat(items.slice(index3 + 1), shouldInsertNullItem ? [nullItem] : [], items.slice(0, index3));
}
function getItemsInGroup(items, groupId) {
  return items.filter(function(item) {
    return item.groupId === groupId;
  });
}
var map$1 = {
  horizontal: "vertical",
  vertical: "horizontal"
};
function getOppositeOrientation(orientation) {
  return orientation && map$1[orientation];
}
function addItemAtIndex(array, item, index3) {
  if (!(index3 in array)) {
    return [].concat(array, [item]);
  }
  return [].concat(array.slice(0, index3), [item], array.slice(index3));
}
function sortBasedOnDOMPosition(items) {
  var pairs = items.map(function(item, index3) {
    return [index3, item];
  });
  var isOrderDifferent = false;
  pairs.sort(function(_ref, _ref2) {
    var indexA = _ref[0], a2 = _ref[1];
    var indexB = _ref2[0], b = _ref2[1];
    var elementA = a2.ref.current;
    var elementB = b.ref.current;
    if (!elementA || !elementB)
      return 0;
    if (isElementPreceding(elementA, elementB)) {
      if (indexA > indexB) {
        isOrderDifferent = true;
      }
      return -1;
    }
    if (indexA < indexB) {
      isOrderDifferent = true;
    }
    return 1;
  });
  if (isOrderDifferent) {
    return pairs.map(function(_ref3) {
      _ref3[0];
      var item = _ref3[1];
      return item;
    });
  }
  return items;
}
function setItemsBasedOnDOMPosition(items, setItems) {
  var sortedItems = sortBasedOnDOMPosition(items);
  if (items !== sortedItems) {
    setItems(sortedItems);
  }
}
function getCommonParent(items) {
  var _firstItem$ref$curren;
  var firstItem = items[0], nextItems = items.slice(1);
  var parentElement = firstItem === null || firstItem === void 0 ? void 0 : (_firstItem$ref$curren = firstItem.ref.current) === null || _firstItem$ref$curren === void 0 ? void 0 : _firstItem$ref$curren.parentElement;
  var _loop = function _loop2() {
    var parent = parentElement;
    if (nextItems.every(function(item) {
      return parent.contains(item.ref.current);
    })) {
      return {
        v: parentElement
      };
    }
    parentElement = parentElement.parentElement;
  };
  while (parentElement) {
    var _ret = _loop();
    if (typeof _ret === "object")
      return _ret.v;
  }
  return getDocument(parentElement).body;
}
function useIntersectionObserver(items, setItems) {
  var previousItems = react$1.exports.useRef([]);
  react$1.exports.useEffect(function() {
    var callback = function callback2() {
      var hasPreviousItems = !!previousItems.current.length;
      if (hasPreviousItems) {
        setItemsBasedOnDOMPosition(items, setItems);
      }
      previousItems.current = items;
    };
    var root = getCommonParent(items);
    var observer = new IntersectionObserver(callback, {
      root
    });
    for (var _iterator = _createForOfIteratorHelperLoose$2(items), _step; !(_step = _iterator()).done; ) {
      var item = _step.value;
      if (item.ref.current) {
        observer.observe(item.ref.current);
      }
    }
    return function() {
      observer.disconnect();
    };
  }, [items]);
}
function useTimeoutObserver(items, setItems) {
  react$1.exports.useEffect(function() {
    var callback = function callback2() {
      return setItemsBasedOnDOMPosition(items, setItems);
    };
    var timeout = setTimeout(callback, 250);
    return function() {
      return clearTimeout(timeout);
    };
  });
}
function useSortBasedOnDOMPosition(items, setItems) {
  if (typeof IntersectionObserver === "function") {
    useIntersectionObserver(items, setItems);
  } else {
    useTimeoutObserver(items, setItems);
  }
}
function reducer(state, action2) {
  var virtual = state.unstable_virtual, rtl = state.rtl, orientation = state.orientation, items = state.items, groups = state.groups, currentId = state.currentId, loop = state.loop, wrap = state.wrap, pastIds = state.pastIds, shift2 = state.shift, moves = state.unstable_moves, includesBaseElement = state.unstable_includesBaseElement, initialVirtual = state.initialVirtual, initialRTL = state.initialRTL, initialOrientation = state.initialOrientation, initialCurrentId = state.initialCurrentId, initialLoop = state.initialLoop, initialWrap = state.initialWrap, initialShift = state.initialShift, hasSetCurrentId = state.hasSetCurrentId;
  switch (action2.type) {
    case "registerGroup": {
      var _group = action2.group;
      if (groups.length === 0) {
        return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
          groups: [_group]
        });
      }
      var index3 = findDOMIndex(groups, _group);
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        groups: addItemAtIndex(groups, _group, index3)
      });
    }
    case "unregisterGroup": {
      var _id = action2.id;
      var nextGroups = groups.filter(function(group) {
        return group.id !== _id;
      });
      if (nextGroups.length === groups.length) {
        return state;
      }
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        groups: nextGroups
      });
    }
    case "registerItem": {
      var _item = action2.item;
      var _group2 = groups.find(function(r2) {
        var _r$ref$current;
        return (_r$ref$current = r2.ref.current) === null || _r$ref$current === void 0 ? void 0 : _r$ref$current.contains(_item.ref.current);
      });
      var nextItem = _objectSpread2$2({
        groupId: _group2 === null || _group2 === void 0 ? void 0 : _group2.id
      }, _item);
      var _index = findDOMIndex(items, nextItem);
      var nextState = _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        items: addItemAtIndex(items, nextItem, _index)
      });
      if (!hasSetCurrentId && !moves && initialCurrentId === void 0) {
        var _findFirstEnabledItem;
        return _objectSpread2$2(_objectSpread2$2({}, nextState), {}, {
          currentId: (_findFirstEnabledItem = findFirstEnabledItem(nextState.items)) === null || _findFirstEnabledItem === void 0 ? void 0 : _findFirstEnabledItem.id
        });
      }
      return nextState;
    }
    case "unregisterItem": {
      var _id2 = action2.id;
      var nextItems = items.filter(function(item) {
        return item.id !== _id2;
      });
      if (nextItems.length === items.length) {
        return state;
      }
      var nextPastIds = pastIds.filter(function(pastId) {
        return pastId !== _id2;
      });
      var _nextState = _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        pastIds: nextPastIds,
        items: nextItems
      });
      if (currentId && currentId === _id2) {
        var nextId = includesBaseElement ? null : getCurrentId(_objectSpread2$2(_objectSpread2$2({}, _nextState), {}, {
          currentId: nextPastIds[0]
        }));
        return _objectSpread2$2(_objectSpread2$2({}, _nextState), {}, {
          currentId: nextId
        });
      }
      return _nextState;
    }
    case "move": {
      var _id3 = action2.id;
      if (_id3 === void 0) {
        return state;
      }
      var filteredPastIds = pastIds.filter(function(pastId) {
        return pastId !== currentId && pastId !== _id3;
      });
      var _nextPastIds = currentId ? [currentId].concat(filteredPastIds) : filteredPastIds;
      var _nextState2 = _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        pastIds: _nextPastIds
      });
      if (_id3 === null) {
        return _objectSpread2$2(_objectSpread2$2({}, _nextState2), {}, {
          unstable_moves: moves + 1,
          currentId: getCurrentId(_nextState2, _id3)
        });
      }
      var _item2 = findEnabledItemById(items, _id3);
      return _objectSpread2$2(_objectSpread2$2({}, _nextState2), {}, {
        unstable_moves: _item2 ? moves + 1 : moves,
        currentId: getCurrentId(_nextState2, _item2 === null || _item2 === void 0 ? void 0 : _item2.id)
      });
    }
    case "next": {
      if (currentId == null) {
        return reducer(state, _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
          type: "first"
        }));
      }
      var isHorizontal = orientation !== "vertical";
      var isRTL = rtl && isHorizontal;
      var allItems = isRTL ? reverse(items) : items;
      var currentItem = allItems.find(function(item) {
        return item.id === currentId;
      });
      if (!currentItem) {
        return reducer(state, _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
          type: "first"
        }));
      }
      var isGrid = !!currentItem.groupId;
      var currentIndex = allItems.indexOf(currentItem);
      var _nextItems = allItems.slice(currentIndex + 1);
      var nextItemsInGroup = getItemsInGroup(_nextItems, currentItem.groupId);
      if (action2.allTheWay) {
        var _nextItem2 = findFirstEnabledItem(isRTL ? getItemsInGroup(allItems, currentItem.groupId) : reverse(nextItemsInGroup));
        return reducer(state, _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
          type: "move",
          id: _nextItem2 === null || _nextItem2 === void 0 ? void 0 : _nextItem2.id
        }));
      }
      var oppositeOrientation = getOppositeOrientation(isGrid ? orientation || "horizontal" : orientation);
      var canLoop = loop && loop !== oppositeOrientation;
      var canWrap = isGrid && wrap && wrap !== oppositeOrientation;
      var hasNullItem = action2.hasNullItem || !isGrid && canLoop && includesBaseElement;
      if (canLoop) {
        var loopItems = canWrap && !hasNullItem ? allItems : getItemsInGroup(allItems, currentItem.groupId);
        var sortedItems = placeItemsAfter(loopItems, currentId, hasNullItem);
        var _nextItem3 = findFirstEnabledItem(sortedItems, currentId);
        return reducer(state, _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
          type: "move",
          id: _nextItem3 === null || _nextItem3 === void 0 ? void 0 : _nextItem3.id
        }));
      }
      if (canWrap) {
        var _nextItem4 = findFirstEnabledItem(hasNullItem ? nextItemsInGroup : _nextItems, currentId);
        var _nextId = hasNullItem ? (_nextItem4 === null || _nextItem4 === void 0 ? void 0 : _nextItem4.id) || null : _nextItem4 === null || _nextItem4 === void 0 ? void 0 : _nextItem4.id;
        return reducer(state, _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
          type: "move",
          id: _nextId
        }));
      }
      var _nextItem = findFirstEnabledItem(nextItemsInGroup, currentId);
      if (!_nextItem && hasNullItem) {
        return reducer(state, _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
          type: "move",
          id: null
        }));
      }
      return reducer(state, _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
        type: "move",
        id: _nextItem === null || _nextItem === void 0 ? void 0 : _nextItem.id
      }));
    }
    case "previous": {
      var _isGrid = !!groups.length;
      var _hasNullItem = !_isGrid && includesBaseElement;
      var _nextState3 = reducer(_objectSpread2$2(_objectSpread2$2({}, state), {}, {
        items: reverse(items)
      }), _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
        type: "next",
        hasNullItem: _hasNullItem
      }));
      return _objectSpread2$2(_objectSpread2$2({}, _nextState3), {}, {
        items
      });
    }
    case "down": {
      var shouldShift = shift2 && !action2.allTheWay;
      var verticalItems = verticalizeItems(flatten(fillGroups(groupItems(items), currentId, shouldShift)));
      var _canLoop = loop && loop !== "horizontal";
      var _hasNullItem2 = _canLoop && includesBaseElement;
      var _nextState4 = reducer(_objectSpread2$2(_objectSpread2$2({}, state), {}, {
        orientation: "vertical",
        items: verticalItems
      }), _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
        type: "next",
        hasNullItem: _hasNullItem2
      }));
      return _objectSpread2$2(_objectSpread2$2({}, _nextState4), {}, {
        orientation,
        items
      });
    }
    case "up": {
      var _shouldShift = shift2 && !action2.allTheWay;
      var _verticalItems = verticalizeItems(reverse(flatten(fillGroups(groupItems(items), currentId, _shouldShift))));
      var _hasNullItem3 = includesBaseElement;
      var _nextState5 = reducer(_objectSpread2$2(_objectSpread2$2({}, state), {}, {
        orientation: "vertical",
        items: _verticalItems
      }), _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
        type: "next",
        hasNullItem: _hasNullItem3
      }));
      return _objectSpread2$2(_objectSpread2$2({}, _nextState5), {}, {
        orientation,
        items
      });
    }
    case "first": {
      var firstItem = findFirstEnabledItem(items);
      return reducer(state, _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
        type: "move",
        id: firstItem === null || firstItem === void 0 ? void 0 : firstItem.id
      }));
    }
    case "last": {
      var _nextState6 = reducer(_objectSpread2$2(_objectSpread2$2({}, state), {}, {
        items: reverse(items)
      }), _objectSpread2$2(_objectSpread2$2({}, action2), {}, {
        type: "first"
      }));
      return _objectSpread2$2(_objectSpread2$2({}, _nextState6), {}, {
        items
      });
    }
    case "sort": {
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        items: sortBasedOnDOMPosition(items),
        groups: sortBasedOnDOMPosition(groups)
      });
    }
    case "setVirtual":
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        unstable_virtual: applyState$1(action2.virtual, virtual)
      });
    case "setRTL":
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        rtl: applyState$1(action2.rtl, rtl)
      });
    case "setOrientation":
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        orientation: applyState$1(action2.orientation, orientation)
      });
    case "setCurrentId": {
      var nextCurrentId = getCurrentId(_objectSpread2$2(_objectSpread2$2({}, state), {}, {
        currentId: applyState$1(action2.currentId, currentId)
      }));
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        currentId: nextCurrentId,
        hasSetCurrentId: true
      });
    }
    case "setLoop":
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        loop: applyState$1(action2.loop, loop)
      });
    case "setWrap":
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        wrap: applyState$1(action2.wrap, wrap)
      });
    case "setShift":
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        shift: applyState$1(action2.shift, shift2)
      });
    case "setIncludesBaseElement": {
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        unstable_includesBaseElement: applyState$1(action2.includesBaseElement, includesBaseElement)
      });
    }
    case "reset":
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        unstable_virtual: initialVirtual,
        rtl: initialRTL,
        orientation: initialOrientation,
        currentId: getCurrentId(_objectSpread2$2(_objectSpread2$2({}, state), {}, {
          currentId: initialCurrentId
        })),
        loop: initialLoop,
        wrap: initialWrap,
        shift: initialShift,
        unstable_moves: 0,
        pastIds: []
      });
    case "setItems": {
      return _objectSpread2$2(_objectSpread2$2({}, state), {}, {
        items: action2.items
      });
    }
    default:
      throw new Error();
  }
}
function useAction(fn2) {
  return react$1.exports.useCallback(fn2, []);
}
function useIsUnmountedRef() {
  var isUnmountedRef = react$1.exports.useRef(false);
  useIsomorphicEffect(function() {
    return function() {
      isUnmountedRef.current = true;
    };
  }, []);
  return isUnmountedRef;
}
function useCompositeState(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var _useSealedState = useSealedState(initialState2), _useSealedState$unsta = _useSealedState.unstable_virtual, virtual = _useSealedState$unsta === void 0 ? false : _useSealedState$unsta, _useSealedState$rtl = _useSealedState.rtl, rtl = _useSealedState$rtl === void 0 ? false : _useSealedState$rtl, orientation = _useSealedState.orientation, currentId = _useSealedState.currentId, _useSealedState$loop = _useSealedState.loop, loop = _useSealedState$loop === void 0 ? false : _useSealedState$loop, _useSealedState$wrap = _useSealedState.wrap, wrap = _useSealedState$wrap === void 0 ? false : _useSealedState$wrap, _useSealedState$shift = _useSealedState.shift, shift2 = _useSealedState$shift === void 0 ? false : _useSealedState$shift, unstable_includesBaseElement = _useSealedState.unstable_includesBaseElement, sealed = _objectWithoutPropertiesLoose$2(_useSealedState, ["unstable_virtual", "rtl", "orientation", "currentId", "loop", "wrap", "shift", "unstable_includesBaseElement"]);
  var idState = unstable_useIdState(sealed);
  var _React$useReducer = react$1.exports.useReducer(reducer, {
    unstable_virtual: virtual,
    rtl,
    orientation,
    items: [],
    groups: [],
    currentId,
    loop,
    wrap,
    shift: shift2,
    unstable_moves: 0,
    pastIds: [],
    unstable_includesBaseElement: unstable_includesBaseElement != null ? unstable_includesBaseElement : currentId === null,
    initialVirtual: virtual,
    initialRTL: rtl,
    initialOrientation: orientation,
    initialCurrentId: currentId,
    initialLoop: loop,
    initialWrap: wrap,
    initialShift: shift2
  }), _React$useReducer$ = _React$useReducer[0];
  _React$useReducer$.pastIds;
  _React$useReducer$.initialVirtual;
  _React$useReducer$.initialRTL;
  _React$useReducer$.initialOrientation;
  _React$useReducer$.initialCurrentId;
  _React$useReducer$.initialLoop;
  _React$useReducer$.initialWrap;
  _React$useReducer$.initialShift;
  _React$useReducer$.hasSetCurrentId;
  var state = _objectWithoutPropertiesLoose$2(_React$useReducer$, ["pastIds", "initialVirtual", "initialRTL", "initialOrientation", "initialCurrentId", "initialLoop", "initialWrap", "initialShift", "hasSetCurrentId"]), dispatch2 = _React$useReducer[1];
  var _React$useState = react$1.exports.useState(false), hasActiveWidget = _React$useState[0], setHasActiveWidget = _React$useState[1];
  var isUnmountedRef = useIsUnmountedRef();
  var setItems = react$1.exports.useCallback(function(items) {
    return dispatch2({
      type: "setItems",
      items
    });
  }, []);
  useSortBasedOnDOMPosition(state.items, setItems);
  return _objectSpread2$2(_objectSpread2$2(_objectSpread2$2({}, idState), state), {}, {
    unstable_hasActiveWidget: hasActiveWidget,
    unstable_setHasActiveWidget: setHasActiveWidget,
    registerItem: useAction(function(item) {
      if (isUnmountedRef.current)
        return;
      dispatch2({
        type: "registerItem",
        item
      });
    }),
    unregisterItem: useAction(function(id) {
      if (isUnmountedRef.current)
        return;
      dispatch2({
        type: "unregisterItem",
        id
      });
    }),
    registerGroup: useAction(function(group) {
      if (isUnmountedRef.current)
        return;
      dispatch2({
        type: "registerGroup",
        group
      });
    }),
    unregisterGroup: useAction(function(id) {
      if (isUnmountedRef.current)
        return;
      dispatch2({
        type: "unregisterGroup",
        id
      });
    }),
    move: useAction(function(id) {
      return dispatch2({
        type: "move",
        id
      });
    }),
    next: useAction(function(allTheWay) {
      return dispatch2({
        type: "next",
        allTheWay
      });
    }),
    previous: useAction(function(allTheWay) {
      return dispatch2({
        type: "previous",
        allTheWay
      });
    }),
    up: useAction(function(allTheWay) {
      return dispatch2({
        type: "up",
        allTheWay
      });
    }),
    down: useAction(function(allTheWay) {
      return dispatch2({
        type: "down",
        allTheWay
      });
    }),
    first: useAction(function() {
      return dispatch2({
        type: "first"
      });
    }),
    last: useAction(function() {
      return dispatch2({
        type: "last"
      });
    }),
    sort: useAction(function() {
      return dispatch2({
        type: "sort"
      });
    }),
    unstable_setVirtual: useAction(function(value) {
      return dispatch2({
        type: "setVirtual",
        virtual: value
      });
    }),
    setRTL: useAction(function(value) {
      return dispatch2({
        type: "setRTL",
        rtl: value
      });
    }),
    setOrientation: useAction(function(value) {
      return dispatch2({
        type: "setOrientation",
        orientation: value
      });
    }),
    setCurrentId: useAction(function(value) {
      return dispatch2({
        type: "setCurrentId",
        currentId: value
      });
    }),
    setLoop: useAction(function(value) {
      return dispatch2({
        type: "setLoop",
        loop: value
      });
    }),
    setWrap: useAction(function(value) {
      return dispatch2({
        type: "setWrap",
        wrap: value
      });
    }),
    setShift: useAction(function(value) {
      return dispatch2({
        type: "setShift",
        shift: value
      });
    }),
    unstable_setIncludesBaseElement: useAction(function(value) {
      return dispatch2({
        type: "setIncludesBaseElement",
        includesBaseElement: value
      });
    }),
    reset: useAction(function() {
      return dispatch2({
        type: "reset"
      });
    })
  });
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start3 = "start";
var end2 = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start3, placement + "-" + end2]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start3, placement + "-" + end2]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main$1 = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main$1, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node4) {
  if (node4 == null) {
    return window;
  }
  if (node4.toString() !== "[object Window]") {
    var ownerDocument = node4.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node4;
}
function isElement(node4) {
  var OwnElement = getWindow(node4).Element;
  return node4 instanceof OwnElement || node4 instanceof Element;
}
function isHTMLElement(node4) {
  var OwnElement = getWindow(node4).HTMLElement;
  return node4 instanceof OwnElement || node4 instanceof HTMLElement;
}
function isShadowRoot(node4) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node4).ShadowRoot;
  return node4 instanceof OwnElement || node4 instanceof ShadowRoot;
}
function applyStyles$2(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$3 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles$2,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max2 = Math.max;
var min2 = Math.min;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child3) {
  var rootNode = child3.getRootNode && child3.getRootNode();
  if (parent.contains(child3)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child3;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max2(min$1, min2(value, max$1));
}
function withinMaxClamp(min3, value, max3) {
  var v2 = within(min3, value, max3);
  return v2 > max3 ? max3 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow$1(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min3 = paddingObject[minProp];
  var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset3 = within(min3, center, max3);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$2 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow$1,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end2) {
      sideY = bottom;
      var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end2) {
      sideX = right;
      var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  {
    var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node4) {
  var win = getWindow(node4);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node4) {
  if (["html", "body", "#document"].indexOf(getNodeName(node4)) >= 0) {
    return node4.ownerDocument.body;
  }
  if (isHTMLElement(node4) && isScrollParent(node4)) {
    return node4;
  }
  return getScrollParent(getParentNode(node4));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start3:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end2:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options2 = options, _options$placement = _options2.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options2.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options2.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options2.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options2.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options2.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset3 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset3[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options2 = options, placement = _options2.placement, boundary = _options2.boundary, rootBoundary = _options2.rootBoundary, padding = _options2.padding, flipVariations = _options2.flipVariations, _options$allowedAutoP = _options2.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
    {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b) {
    return overflows[a2] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start3;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset3) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
    placement
  })) : offset3, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset2(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset2
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset3 = popperOffsets2[mainAxis];
    var min$1 = offset3 + overflow[mainSide];
    var max$1 = offset3 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start3 ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start3 ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset3 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min2(min$1, tetherMin) : min$1, offset3, tether ? max2(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset3;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node4) {
  if (node4 === getWindow(node4) || !isHTMLElement(node4)) {
    return getWindowScroll(node4);
  } else {
    return getHTMLElementScroll(node4);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers2) {
  var map16 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result2 = [];
  modifiers2.forEach(function(modifier) {
    map16.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map16.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result2.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result2;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve7) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve7(fn2());
        });
      });
    }
    return pending;
  };
}
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p2, c2) {
    return p2.replace(/%s/, c2);
  }, str);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers2) {
  modifiers2.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index3, self) {
      return self.indexOf(value) === index3;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s2) {
            return '"' + s2 + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers2.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS$2 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$2 : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS$2, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        {
          var modifiers2 = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers2);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle$1(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index3 = 0; index3 < state.orderedModifiers.length; index3++) {
          {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index3 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index3], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options2 = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options2,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve7) {
          instance.forceUpdate();
          resolve7(state);
        });
      }),
      destroy: function destroy4() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$3, offset$1, flip$1, preventOverflow$1, arrow$2, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function useLastValue(value) {
  var lastValue = react$1.exports.useRef(null);
  useIsomorphicEffect(function() {
    lastValue.current = value;
  }, [value]);
  return lastValue;
}
function useDisclosureState(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var _useSealedState = useSealedState(initialState2), _useSealedState$visib = _useSealedState.visible, initialVisible = _useSealedState$visib === void 0 ? false : _useSealedState$visib, _useSealedState$anima = _useSealedState.animated, initialAnimated = _useSealedState$anima === void 0 ? false : _useSealedState$anima, sealed = _objectWithoutPropertiesLoose$2(_useSealedState, ["visible", "animated"]);
  var id = unstable_useIdState(sealed);
  var _React$useState = react$1.exports.useState(initialVisible), visible = _React$useState[0], setVisible = _React$useState[1];
  var _React$useState2 = react$1.exports.useState(initialAnimated), animated2 = _React$useState2[0], setAnimated = _React$useState2[1];
  var _React$useState3 = react$1.exports.useState(false), animating = _React$useState3[0], setAnimating = _React$useState3[1];
  var lastVisible = useLastValue(visible);
  var visibleHasChanged = lastVisible.current != null && lastVisible.current !== visible;
  if (animated2 && !animating && visibleHasChanged) {
    setAnimating(true);
  }
  react$1.exports.useEffect(function() {
    if (typeof animated2 === "number" && animating) {
      var timeout = setTimeout(function() {
        return setAnimating(false);
      }, animated2);
      return function() {
        clearTimeout(timeout);
      };
    }
    if (animated2 && animating && false) {
      var _timeout = setTimeout(function() {
        warning(animating, "It's been 8 seconds but stopAnimation has not been called. Does the disclousure element have a CSS transition?");
      }, 8e3);
      return function() {
        clearTimeout(_timeout);
      };
    }
    return function() {
    };
  }, [animated2, animating]);
  var show2 = react$1.exports.useCallback(function() {
    return setVisible(true);
  }, []);
  var hide3 = react$1.exports.useCallback(function() {
    return setVisible(false);
  }, []);
  var toggle = react$1.exports.useCallback(function() {
    return setVisible(function(v2) {
      return !v2;
    });
  }, []);
  var stopAnimation = react$1.exports.useCallback(function() {
    return setAnimating(false);
  }, []);
  return _objectSpread2$2(_objectSpread2$2({}, id), {}, {
    visible,
    animated: animated2,
    animating,
    show: show2,
    hide: hide3,
    toggle,
    setVisible,
    setAnimated,
    stopAnimation
  });
}
function useDialogState(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var _useSealedState = useSealedState(initialState2), _useSealedState$modal = _useSealedState.modal, initialModal = _useSealedState$modal === void 0 ? true : _useSealedState$modal, sealed = _objectWithoutPropertiesLoose$2(_useSealedState, ["modal"]);
  var disclosure = useDisclosureState(sealed);
  var _React$useState = react$1.exports.useState(initialModal), modal = _React$useState[0], setModal2 = _React$useState[1];
  var disclosureRef = react$1.exports.useRef(null);
  return _objectSpread2$2(_objectSpread2$2({}, disclosure), {}, {
    modal,
    setModal: setModal2,
    unstable_disclosureRef: disclosureRef
  });
}
var isSafari$1 = isUA("Mac") && !isUA("Chrome") && isUA("Safari");
function applyStyles$1(styles2) {
  return function(prevStyles) {
    if (styles2 && !shallowEqual(prevStyles, styles2)) {
      return styles2;
    }
    return prevStyles;
  };
}
function usePopoverState(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var _useSealedState = useSealedState(initialState2), _useSealedState$gutte = _useSealedState.gutter, gutter = _useSealedState$gutte === void 0 ? 12 : _useSealedState$gutte, _useSealedState$place = _useSealedState.placement, sealedPlacement = _useSealedState$place === void 0 ? "bottom" : _useSealedState$place, _useSealedState$unsta = _useSealedState.unstable_flip, flip2 = _useSealedState$unsta === void 0 ? true : _useSealedState$unsta, sealedOffset = _useSealedState.unstable_offset, _useSealedState$unsta2 = _useSealedState.unstable_preventOverflow, preventOverflow2 = _useSealedState$unsta2 === void 0 ? true : _useSealedState$unsta2, _useSealedState$unsta3 = _useSealedState.unstable_fixed, fixed = _useSealedState$unsta3 === void 0 ? false : _useSealedState$unsta3, _useSealedState$modal = _useSealedState.modal, modal = _useSealedState$modal === void 0 ? false : _useSealedState$modal, sealed = _objectWithoutPropertiesLoose$2(_useSealedState, ["gutter", "placement", "unstable_flip", "unstable_offset", "unstable_preventOverflow", "unstable_fixed", "modal"]);
  var popper2 = react$1.exports.useRef(null);
  var referenceRef = react$1.exports.useRef(null);
  var popoverRef = react$1.exports.useRef(null);
  var arrowRef = react$1.exports.useRef(null);
  var _React$useState = react$1.exports.useState(sealedPlacement), originalPlacement = _React$useState[0], place = _React$useState[1];
  var _React$useState2 = react$1.exports.useState(sealedPlacement), placement = _React$useState2[0], setPlacement = _React$useState2[1];
  var _React$useState3 = react$1.exports.useState(sealedOffset || [0, gutter]), offset3 = _React$useState3[0];
  var _React$useState4 = react$1.exports.useState({
    position: "fixed",
    left: "100%",
    top: "100%"
  }), popoverStyles = _React$useState4[0], setPopoverStyles = _React$useState4[1];
  var _React$useState5 = react$1.exports.useState({}), arrowStyles = _React$useState5[0], setArrowStyles = _React$useState5[1];
  var dialog = useDialogState(_objectSpread2$2({
    modal
  }, sealed));
  var update2 = react$1.exports.useCallback(function() {
    if (popper2.current) {
      popper2.current.forceUpdate();
      return true;
    }
    return false;
  }, []);
  var updateState2 = react$1.exports.useCallback(function(state) {
    if (state.placement) {
      setPlacement(state.placement);
    }
    if (state.styles) {
      setPopoverStyles(applyStyles$1(state.styles.popper));
      if (arrowRef.current) {
        setArrowStyles(applyStyles$1(state.styles.arrow));
      }
    }
  }, []);
  useIsomorphicEffect(function() {
    if (referenceRef.current && popoverRef.current) {
      popper2.current = createPopper(referenceRef.current, popoverRef.current, {
        placement: originalPlacement,
        strategy: fixed ? "fixed" : "absolute",
        onFirstUpdate: isSafari$1 ? updateState2 : void 0,
        modifiers: [{
          name: "eventListeners",
          enabled: dialog.visible
        }, {
          name: "applyStyles",
          enabled: false
        }, {
          name: "flip",
          enabled: flip2,
          options: {
            padding: 8
          }
        }, {
          name: "offset",
          options: {
            offset: offset3
          }
        }, {
          name: "preventOverflow",
          enabled: preventOverflow2,
          options: {
            tetherOffset: function tetherOffset() {
              var _arrowRef$current;
              return ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.clientWidth) || 0;
            }
          }
        }, {
          name: "arrow",
          enabled: !!arrowRef.current,
          options: {
            element: arrowRef.current
          }
        }, {
          name: "updateState",
          phase: "write",
          requires: ["computeStyles"],
          enabled: dialog.visible && true,
          fn: function fn2(_ref) {
            var state = _ref.state;
            return updateState2(state);
          }
        }]
      });
    }
    return function() {
      if (popper2.current) {
        popper2.current.destroy();
        popper2.current = null;
      }
    };
  }, [originalPlacement, fixed, dialog.visible, flip2, offset3, preventOverflow2]);
  react$1.exports.useEffect(function() {
    if (!dialog.visible)
      return void 0;
    var id = window.requestAnimationFrame(function() {
      var _popper$current;
      (_popper$current = popper2.current) === null || _popper$current === void 0 ? void 0 : _popper$current.forceUpdate();
    });
    return function() {
      window.cancelAnimationFrame(id);
    };
  }, [dialog.visible]);
  return _objectSpread2$2(_objectSpread2$2({}, dialog), {}, {
    unstable_referenceRef: referenceRef,
    unstable_popoverRef: popoverRef,
    unstable_arrowRef: arrowRef,
    unstable_popoverStyles: popoverStyles,
    unstable_arrowStyles: arrowStyles,
    unstable_update: update2,
    unstable_originalPlacement: originalPlacement,
    placement,
    place
  });
}
var DISCLOSURE_STATE_KEYS = ["baseId", "unstable_idCountRef", "visible", "animated", "animating", "setBaseId", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation"];
var DISCLOSURE_KEYS = DISCLOSURE_STATE_KEYS;
var DISCLOSURE_CONTENT_KEYS = DISCLOSURE_KEYS;
var useDisclosureContent = createHook({
  name: "DisclosureContent",
  compose: useRole,
  keys: DISCLOSURE_CONTENT_KEYS,
  useProps: function useProps8(options, _ref) {
    var htmlOnTransitionEnd = _ref.onTransitionEnd, htmlOnAnimationEnd = _ref.onAnimationEnd, htmlStyle = _ref.style, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["onTransitionEnd", "onAnimationEnd", "style"]);
    var animating = options.animated && options.animating;
    var _React$useState = react$1.exports.useState(null), transition = _React$useState[0], setTransition = _React$useState[1];
    var hidden = !options.visible && !animating;
    var style = hidden ? _objectSpread2$2({
      display: "none"
    }, htmlStyle) : htmlStyle;
    var onTransitionEndRef = useLiveRef(htmlOnTransitionEnd);
    var onAnimationEndRef = useLiveRef(htmlOnAnimationEnd);
    var raf = react$1.exports.useRef(0);
    react$1.exports.useEffect(function() {
      if (!options.animated)
        return void 0;
      raf.current = window.requestAnimationFrame(function() {
        raf.current = window.requestAnimationFrame(function() {
          if (options.visible) {
            setTransition("enter");
          } else if (animating) {
            setTransition("leave");
          } else {
            setTransition(null);
          }
        });
      });
      return function() {
        return window.cancelAnimationFrame(raf.current);
      };
    }, [options.animated, options.visible, animating]);
    var onEnd = react$1.exports.useCallback(function(event) {
      if (!isSelfTarget(event))
        return;
      if (!animating)
        return;
      if (options.animated === true) {
        var _options$stopAnimatio;
        (_options$stopAnimatio = options.stopAnimation) === null || _options$stopAnimatio === void 0 ? void 0 : _options$stopAnimatio.call(options);
      }
    }, [options.animated, animating, options.stopAnimation]);
    var onTransitionEnd = react$1.exports.useCallback(function(event) {
      var _onTransitionEndRef$c;
      (_onTransitionEndRef$c = onTransitionEndRef.current) === null || _onTransitionEndRef$c === void 0 ? void 0 : _onTransitionEndRef$c.call(onTransitionEndRef, event);
      onEnd(event);
    }, [onEnd]);
    var onAnimationEnd = react$1.exports.useCallback(function(event) {
      var _onAnimationEndRef$cu;
      (_onAnimationEndRef$cu = onAnimationEndRef.current) === null || _onAnimationEndRef$cu === void 0 ? void 0 : _onAnimationEndRef$cu.call(onAnimationEndRef, event);
      onEnd(event);
    }, [onEnd]);
    return _objectSpread2$2({
      id: options.baseId,
      "data-enter": transition === "enter" ? "" : void 0,
      "data-leave": transition === "leave" ? "" : void 0,
      onTransitionEnd,
      onAnimationEnd,
      hidden,
      style
    }, htmlProps);
  }
});
createComponent({
  as: "div",
  useHook: useDisclosureContent
});
function getBodyElement() {
  return canUseDOM ? document.body : null;
}
var PortalContext = /* @__PURE__ */ react$1.exports.createContext(getBodyElement());
function Portal(_ref) {
  var children = _ref.children;
  var context2 = react$1.exports.useContext(PortalContext) || getBodyElement();
  var _React$useState = react$1.exports.useState(function() {
    if (canUseDOM) {
      var element = document.createElement("div");
      element.className = Portal.__className;
      return element;
    }
    return null;
  }), hostNode = _React$useState[0];
  useIsomorphicEffect(function() {
    if (!hostNode || !context2)
      return void 0;
    context2.appendChild(hostNode);
    return function() {
      context2.removeChild(hostNode);
    };
  }, [hostNode, context2]);
  if (hostNode) {
    return /* @__PURE__ */ reactDom.exports.createPortal(/* @__PURE__ */ react$1.exports.createElement(PortalContext.Provider, {
      value: hostNode
    }, children), hostNode);
  }
  return null;
}
Portal.__className = "__reakit-portal";
Portal.__selector = "." + Portal.__className;
function removeItemFromArray(array, item) {
  var index3 = array.indexOf(item);
  return removeIndexFromArray(array, index3);
}
var MenuContext = /* @__PURE__ */ react$1.exports.createContext(null);
function useMenuContext(menuRef, role, options) {
  var orphan = "unstable_orphan" in options && options.unstable_orphan;
  var parent = react$1.exports.useContext(MenuContext);
  var _React$useState = react$1.exports.useState([]), children = _React$useState[0], setChildren = _React$useState[1];
  var _ref = parent || {}, addChildToParent = _ref.addChild, removeChildFromParent = _ref.removeChild;
  var addChild = react$1.exports.useCallback(function(ref2) {
    return setChildren(function(refs) {
      return [].concat(refs, [ref2]);
    });
  }, []);
  var removeChild = react$1.exports.useCallback(function(ref2) {
    return setChildren(function(refs) {
      return removeItemFromArray(refs, ref2);
    });
  }, []);
  react$1.exports.useEffect(function() {
    if (!addChildToParent || orphan)
      return void 0;
    addChildToParent(menuRef);
    return function() {
      removeChildFromParent === null || removeChildFromParent === void 0 ? void 0 : removeChildFromParent(menuRef);
    };
  }, [menuRef, addChildToParent, removeChildFromParent, orphan]);
  var providerValue = react$1.exports.useMemo(function() {
    return {
      orientation: options.orientation,
      next: options.next,
      previous: options.previous,
      ref: menuRef,
      role,
      parent,
      children,
      addChild,
      removeChild
    };
  }, [options.orientation, options.next, options.previous, menuRef, role, parent, children, addChild, removeChild]);
  var wrapElement = react$1.exports.useCallback(function(element) {
    return /* @__PURE__ */ react$1.exports.createElement(MenuContext.Provider, {
      value: providerValue
    }, element);
  }, [providerValue]);
  return wrapElement;
}
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var hasPassiveEvents = false;
if (typeof window !== "undefined") {
  var passiveTestOptions = {
    get passive() {
      hasPassiveEvents = true;
      return void 0;
    }
  };
  window.addEventListener("testPassive", null, passiveTestOptions);
  window.removeEventListener("testPassive", null, passiveTestOptions);
}
var isIosDevice = typeof window !== "undefined" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
var locks = [];
var documentListenerAdded = false;
var initialClientY = -1;
var previousBodyOverflowSetting = void 0;
var previousBodyPaddingRight = void 0;
var allowTouchMove = function allowTouchMove2(el) {
  return locks.some(function(lock) {
    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
      return true;
    }
    return false;
  });
};
var preventDefault = function preventDefault2(rawEvent) {
  var e2 = rawEvent || window.event;
  if (allowTouchMove(e2.target)) {
    return true;
  }
  if (e2.touches.length > 1)
    return true;
  if (e2.preventDefault)
    e2.preventDefault();
  return false;
};
var setOverflowHidden = function setOverflowHidden2(options) {
  if (previousBodyPaddingRight === void 0) {
    var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;
    var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
    if (_reserveScrollBarGap && scrollBarGap > 0) {
      previousBodyPaddingRight = document.body.style.paddingRight;
      document.body.style.paddingRight = scrollBarGap + "px";
    }
  }
  if (previousBodyOverflowSetting === void 0) {
    previousBodyOverflowSetting = document.body.style.overflow;
    document.body.style.overflow = "hidden";
  }
};
var restoreOverflowSetting = function restoreOverflowSetting2() {
  if (previousBodyPaddingRight !== void 0) {
    document.body.style.paddingRight = previousBodyPaddingRight;
    previousBodyPaddingRight = void 0;
  }
  if (previousBodyOverflowSetting !== void 0) {
    document.body.style.overflow = previousBodyOverflowSetting;
    previousBodyOverflowSetting = void 0;
  }
};
var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled2(targetElement) {
  return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
};
var handleScroll = function handleScroll2(event, targetElement) {
  var clientY = event.targetTouches[0].clientY - initialClientY;
  if (allowTouchMove(event.target)) {
    return false;
  }
  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
    return preventDefault(event);
  }
  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
    return preventDefault(event);
  }
  event.stopPropagation();
  return true;
};
var disableBodyScroll = function disableBodyScroll2(targetElement, options) {
  if (!targetElement) {
    console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
    return;
  }
  if (locks.some(function(lock2) {
    return lock2.targetElement === targetElement;
  })) {
    return;
  }
  var lock = {
    targetElement,
    options: options || {}
  };
  locks = [].concat(_toConsumableArray(locks), [lock]);
  if (isIosDevice) {
    targetElement.ontouchstart = function(event) {
      if (event.targetTouches.length === 1) {
        initialClientY = event.targetTouches[0].clientY;
      }
    };
    targetElement.ontouchmove = function(event) {
      if (event.targetTouches.length === 1) {
        handleScroll(event, targetElement);
      }
    };
    if (!documentListenerAdded) {
      document.addEventListener("touchmove", preventDefault, hasPassiveEvents ? { passive: false } : void 0);
      documentListenerAdded = true;
    }
  } else {
    setOverflowHidden(options);
  }
};
var enableBodyScroll = function enableBodyScroll2(targetElement) {
  if (!targetElement) {
    console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
    return;
  }
  locks = locks.filter(function(lock) {
    return lock.targetElement !== targetElement;
  });
  if (isIosDevice) {
    targetElement.ontouchstart = null;
    targetElement.ontouchmove = null;
    if (documentListenerAdded && locks.length === 0) {
      document.removeEventListener("touchmove", preventDefault, hasPassiveEvents ? { passive: false } : void 0);
      documentListenerAdded = false;
    }
  } else if (!locks.length) {
    restoreOverflowSetting();
  }
};
var DialogBackdropContext = /* @__PURE__ */ react$1.exports.createContext(void 0);
function isEmpty(arg) {
  if (Array.isArray(arg))
    return !arg.length;
  if (isObject2(arg))
    return !Object.keys(arg).length;
  if (arg == null)
    return true;
  if (arg === "")
    return true;
  return false;
}
var DIALOG_STATE_KEYS = ["baseId", "unstable_idCountRef", "visible", "animated", "animating", "setBaseId", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation", "modal", "unstable_disclosureRef", "setModal"];
var DIALOG_KEYS = [].concat(DIALOG_STATE_KEYS, ["hideOnEsc", "hideOnClickOutside", "preventBodyScroll", "unstable_initialFocusRef", "unstable_finalFocusRef", "unstable_orphan", "unstable_autoFocusOnShow", "unstable_autoFocusOnHide"]);
var DIALOG_BACKDROP_KEYS = DIALOG_STATE_KEYS;
var DIALOG_DISCLOSURE_KEYS = DIALOG_BACKDROP_KEYS;
function useDisclosureRef(dialogRef, options) {
  var ref2 = react$1.exports.useRef(null);
  var animating = !!(options.animated && options.animating);
  react$1.exports.useEffect(function() {
    if (options.visible || animating)
      return void 0;
    var onFocus = function onFocus2(event) {
      var target = event.target;
      if ("focus" in target) {
        ref2.current = target;
        if (options.unstable_disclosureRef) {
          options.unstable_disclosureRef.current = target;
        }
      }
    };
    var document2 = getDocument(dialogRef.current);
    document2.addEventListener("focusin", onFocus);
    return function() {
      return document2.removeEventListener("focusin", onFocus);
    };
  }, [options.visible, animating, options.unstable_disclosureRef, dialogRef]);
  react$1.exports.useEffect(function() {
    var _options$unstable_dis;
    if (!options.visible || animating)
      return void 0;
    var onMouseDown = function onMouseDown2(event) {
      var element = event.currentTarget;
      if (!isButton(element))
        return;
      event.preventDefault();
      element.focus();
    };
    var disclosure = ((_options$unstable_dis = options.unstable_disclosureRef) === null || _options$unstable_dis === void 0 ? void 0 : _options$unstable_dis.current) || ref2.current;
    disclosure === null || disclosure === void 0 ? void 0 : disclosure.addEventListener("mousedown", onMouseDown);
    return function() {
      return disclosure === null || disclosure === void 0 ? void 0 : disclosure.removeEventListener("mousedown", onMouseDown);
    };
  }, [options.visible, animating, options.unstable_disclosureRef]);
  return options.unstable_disclosureRef || ref2;
}
function usePreventBodyScroll(targetRef, options) {
  var shouldPrevent = Boolean(options.preventBodyScroll && options.visible);
  react$1.exports.useEffect(function() {
    var element = targetRef.current;
    if (!element || !shouldPrevent)
      return void 0;
    disableBodyScroll(element, {
      reserveScrollBarGap: true
    });
    return function() {
      return enableBodyScroll(element);
    };
  }, [targetRef, shouldPrevent]);
}
function useFocusOnShow(dialogRef, nestedDialogs, options) {
  var initialFocusRef = options.unstable_initialFocusRef;
  var shouldFocus = options.visible && options.unstable_autoFocusOnShow;
  var animating = !!(options.animated && options.animating);
  useUpdateEffect(function() {
    var dialog = dialogRef.current;
    warning(!!shouldFocus && !dialog, "[reakit/Dialog]", "Can't set initial focus on dialog because `ref` wasn't passed to the dialog element.", "See https://reakit.io/docs/dialog");
    if (!shouldFocus)
      return;
    if (!dialog)
      return;
    if (animating)
      return;
    if (nestedDialogs.some(function(child3) {
      return child3.current && !child3.current.hidden;
    })) {
      return;
    }
    if (initialFocusRef !== null && initialFocusRef !== void 0 && initialFocusRef.current) {
      initialFocusRef.current.focus({
        preventScroll: true
      });
    } else {
      var tabbable = getFirstTabbableIn(dialog, true);
      var isActive = function isActive2() {
        return hasFocusWithin(dialog);
      };
      if (tabbable) {
        ensureFocus(tabbable, {
          preventScroll: true,
          isActive
        });
      } else {
        ensureFocus(dialog, {
          preventScroll: true,
          isActive
        });
        warning(dialog.tabIndex === void 0 || dialog.tabIndex < 0, "It's recommended to have at least one tabbable element inside dialog. The dialog element has been automatically focused.", "If this is the intended behavior, pass `tabIndex={0}` to the dialog element to disable this warning.", "See https://reakit.io/docs/dialog/#initial-focus", dialog);
      }
    }
  }, [dialogRef, shouldFocus, animating, nestedDialogs, initialFocusRef]);
}
function usePortalRef(dialogRef, options) {
  var portalRef = react$1.exports.useRef(null);
  react$1.exports.useEffect(function() {
    var dialog = dialogRef.current;
    if (!dialog || !options.visible)
      return;
    portalRef.current = closest(dialog, Portal.__selector);
  }, [dialogRef, options.visible]);
  return portalRef;
}
function removeFromDOM(element) {
  if (element.parentNode == null)
    return;
  element.parentNode.removeChild(element);
}
var focusTrapClassName = "__reakit-focus-trap";
function isFocusTrap(element) {
  var _element$classList;
  return (_element$classList = element.classList) === null || _element$classList === void 0 ? void 0 : _element$classList.contains(focusTrapClassName);
}
function useFocusTrap(dialogRef, visibleModals, options) {
  var portalRef = usePortalRef(dialogRef, options);
  var shouldTrap = options.visible && options.modal;
  var beforeElement = react$1.exports.useRef(null);
  var afterElement = react$1.exports.useRef(null);
  react$1.exports.useEffect(function() {
    if (!shouldTrap)
      return void 0;
    var portal = portalRef.current;
    if (!portal) {
      warning(true, "Can't trap focus within modal dialog because either `ref` wasn't passed to component or the component wasn't rendered within a portal", "See https://reakit.io/docs/dialog");
      return void 0;
    }
    if (!beforeElement.current) {
      var document2 = getDocument(portal);
      beforeElement.current = document2.createElement("div");
      beforeElement.current.className = focusTrapClassName;
      beforeElement.current.tabIndex = 0;
      beforeElement.current.style.position = "fixed";
      beforeElement.current.setAttribute("aria-hidden", "true");
    }
    if (!afterElement.current) {
      afterElement.current = beforeElement.current.cloneNode();
    }
    portal.insertAdjacentElement("beforebegin", beforeElement.current);
    portal.insertAdjacentElement("afterend", afterElement.current);
    return function() {
      if (beforeElement.current)
        removeFromDOM(beforeElement.current);
      if (afterElement.current)
        removeFromDOM(afterElement.current);
    };
  }, [portalRef, shouldTrap]);
  react$1.exports.useEffect(function() {
    var before2 = beforeElement.current;
    var after2 = afterElement.current;
    if (!shouldTrap || !before2 || !after2)
      return void 0;
    var handleFocus = function handleFocus2(event) {
      var dialog = dialogRef.current;
      if (!dialog || visibleModals.length)
        return;
      event.preventDefault();
      var isAfter = event.target === after2;
      var tabbable = isAfter ? getFirstTabbableIn(dialog) : getLastTabbableIn(dialog);
      if (tabbable) {
        tabbable.focus();
      } else {
        dialog.focus();
      }
    };
    before2.addEventListener("focus", handleFocus);
    after2.addEventListener("focus", handleFocus);
    return function() {
      before2.removeEventListener("focus", handleFocus);
      after2.removeEventListener("focus", handleFocus);
    };
  }, [dialogRef, visibleModals, shouldTrap]);
}
function hidByFocusingAnotherElement(dialogRef) {
  var dialog = dialogRef.current;
  if (!dialog)
    return false;
  var activeElement = getActiveElement(dialog);
  if (!activeElement)
    return false;
  if (contains$1(dialog, activeElement))
    return false;
  if (isTabbable(activeElement))
    return true;
  if (activeElement.getAttribute("data-dialog") === "true")
    return true;
  return false;
}
function useFocusOnHide(dialogRef, disclosureRef, options) {
  var shouldFocus = options.unstable_autoFocusOnHide && !options.visible;
  var animating = !!(options.animated && options.animating);
  useUpdateEffect(function() {
    var _options$unstable_fin;
    if (!shouldFocus)
      return;
    if (animating)
      return;
    if (hidByFocusingAnotherElement(dialogRef)) {
      return;
    }
    var finalFocusEl = ((_options$unstable_fin = options.unstable_finalFocusRef) === null || _options$unstable_fin === void 0 ? void 0 : _options$unstable_fin.current) || disclosureRef.current;
    if (finalFocusEl) {
      if (finalFocusEl.id) {
        var document2 = getDocument(finalFocusEl);
        var compositeElement = document2.querySelector("[aria-activedescendant='" + finalFocusEl.id + "']");
        if (compositeElement) {
          ensureFocus(compositeElement);
          return;
        }
      }
      ensureFocus(finalFocusEl);
      return;
    }
    warning(true, "Can't return focus after closing dialog. Either render a disclosure component or provide a `unstable_finalFocusRef` prop.", "See https://reakit.io/docs/dialog", dialogRef.current);
  }, [shouldFocus, animating, dialogRef, disclosureRef]);
}
var DialogContext = /* @__PURE__ */ react$1.exports.createContext({});
function useNestedDialogs(dialogRef, options) {
  var context2 = react$1.exports.useContext(DialogContext);
  var _React$useState = react$1.exports.useState([]), dialogs = _React$useState[0], setDialogs = _React$useState[1];
  var _React$useState2 = react$1.exports.useState(dialogs), visibleModals = _React$useState2[0], setVisibleModals = _React$useState2[1];
  var addDialog = react$1.exports.useCallback(function(ref2) {
    var _context$addDialog;
    (_context$addDialog = context2.addDialog) === null || _context$addDialog === void 0 ? void 0 : _context$addDialog.call(context2, ref2);
    setDialogs(function(prevDialogs) {
      return [].concat(prevDialogs, [ref2]);
    });
  }, [context2.addDialog]);
  var removeDialog = react$1.exports.useCallback(function(ref2) {
    var _context$removeDialog;
    (_context$removeDialog = context2.removeDialog) === null || _context$removeDialog === void 0 ? void 0 : _context$removeDialog.call(context2, ref2);
    setDialogs(function(prevDialogs) {
      return removeItemFromArray(prevDialogs, ref2);
    });
  }, [context2.removeDialog]);
  var showDialog = react$1.exports.useCallback(function(ref2) {
    var _context$showDialog;
    (_context$showDialog = context2.showDialog) === null || _context$showDialog === void 0 ? void 0 : _context$showDialog.call(context2, ref2);
    setVisibleModals(function(prevDialogs) {
      return [].concat(prevDialogs, [ref2]);
    });
  }, [context2.showDialog]);
  var hideDialog = react$1.exports.useCallback(function(ref2) {
    var _context$hideDialog;
    (_context$hideDialog = context2.hideDialog) === null || _context$hideDialog === void 0 ? void 0 : _context$hideDialog.call(context2, ref2);
    setVisibleModals(function(prevDialogs) {
      return removeItemFromArray(prevDialogs, ref2);
    });
  }, [context2.hideDialog]);
  react$1.exports.useEffect(function() {
    var _context$addDialog2;
    if (options.unstable_orphan)
      return void 0;
    (_context$addDialog2 = context2.addDialog) === null || _context$addDialog2 === void 0 ? void 0 : _context$addDialog2.call(context2, dialogRef);
    return function() {
      var _context$removeDialog2;
      (_context$removeDialog2 = context2.removeDialog) === null || _context$removeDialog2 === void 0 ? void 0 : _context$removeDialog2.call(context2, dialogRef);
    };
  }, [options.unstable_orphan, context2.addDialog, dialogRef, context2.removeDialog]);
  react$1.exports.useEffect(function() {
    var _context$showDialog2;
    if (options.unstable_orphan)
      return void 0;
    if (!options.modal)
      return void 0;
    if (!options.visible)
      return void 0;
    (_context$showDialog2 = context2.showDialog) === null || _context$showDialog2 === void 0 ? void 0 : _context$showDialog2.call(context2, dialogRef);
    return function() {
      var _context$hideDialog2;
      (_context$hideDialog2 = context2.hideDialog) === null || _context$hideDialog2 === void 0 ? void 0 : _context$hideDialog2.call(context2, dialogRef);
    };
  }, [options.unstable_orphan, options.modal, options.visible, context2.showDialog, dialogRef, context2.hideDialog]);
  react$1.exports.useEffect(function() {
    if (context2.visible === false && options.visible && !options.unstable_orphan) {
      var _options$hide;
      (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
    }
  }, [context2.visible, options.visible, options.hide, options.unstable_orphan]);
  var providerValue = react$1.exports.useMemo(function() {
    return {
      visible: options.visible,
      addDialog,
      removeDialog,
      showDialog,
      hideDialog
    };
  }, [options.visible, addDialog, removeDialog, showDialog, hideDialog]);
  var wrap = react$1.exports.useCallback(function(element) {
    return /* @__PURE__ */ react$1.exports.createElement(DialogContext.Provider, {
      value: providerValue
    }, element);
  }, [providerValue]);
  return {
    dialogs,
    visibleModals,
    wrap
  };
}
function dialogContains(target) {
  return function(dialogRef) {
    var dialog = dialogRef.current;
    if (!dialog)
      return false;
    if (contains$1(dialog, target))
      return true;
    var document2 = getDocument(dialog);
    var backdrop = document2.querySelector('[data-dialog-ref="' + dialog.id + '"]');
    if (backdrop) {
      return contains$1(backdrop, target);
    }
    return false;
  };
}
function isDisclosure(target, disclosure) {
  return contains$1(disclosure, target);
}
function isInDocument(target) {
  var document2 = getDocument(target);
  if (target.tagName === "HTML") {
    return true;
  }
  return contains$1(document2.body, target);
}
function useEventListenerOutside(containerRef, disclosureRef, nestedDialogs, eventType, listener, shouldListen, capture) {
  var listenerRef = useLiveRef(listener);
  react$1.exports.useEffect(function() {
    if (!shouldListen)
      return void 0;
    var onEvent = function onEvent2(event) {
      if (!listenerRef.current)
        return;
      var container = containerRef.current;
      var disclosure = disclosureRef.current;
      var target = event.target;
      if (!container) {
        warning(true, "Can't detect events outside dialog because `ref` wasn't passed to component.", "See https://reakit.io/docs/dialog");
        return;
      }
      if (!isInDocument(target))
        return;
      if (contains$1(container, target))
        return;
      if (disclosure && isDisclosure(target, disclosure))
        return;
      if (isFocusTrap(target) || nestedDialogs.some(dialogContains(target))) {
        return;
      }
      listenerRef.current(event);
    };
    var document2 = getDocument(containerRef.current);
    document2.addEventListener(eventType, onEvent, capture);
    return function() {
      return document2.removeEventListener(eventType, onEvent, capture);
    };
  }, [containerRef, disclosureRef, nestedDialogs, eventType, shouldListen, listenerRef]);
}
function useMouseDownRef(dialogRef, options) {
  var mouseDownRef = react$1.exports.useRef();
  react$1.exports.useEffect(function() {
    if (!options.visible)
      return void 0;
    if (!options.hideOnClickOutside)
      return void 0;
    var document2 = getDocument(dialogRef.current);
    var onMouseDown = function onMouseDown2(event) {
      mouseDownRef.current = event.target;
    };
    document2.addEventListener("mousedown", onMouseDown);
    return function() {
      return document2.removeEventListener("mousedown", onMouseDown);
    };
  }, [options.visible, options.hideOnClickOutside, dialogRef]);
  return mouseDownRef;
}
function useHideOnClickOutside(dialogRef, disclosureRef, nestedDialogs, options) {
  var mouseDownRef = useMouseDownRef(dialogRef, options);
  useEventListenerOutside(dialogRef, disclosureRef, nestedDialogs, "click", function(event) {
    if (mouseDownRef.current === event.target) {
      var _options$hide;
      (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
    }
  }, options.visible && options.hideOnClickOutside);
  useEventListenerOutside(dialogRef, disclosureRef, nestedDialogs, "focusin", function(event) {
    var document2 = getDocument(dialogRef.current);
    if (event.target !== document2 && event.target !== document2.body) {
      var _options$hide2;
      (_options$hide2 = options.hide) === null || _options$hide2 === void 0 ? void 0 : _options$hide2.call(options);
    }
  }, options.visible && options.hideOnClickOutside);
}
function useDisableHoverOutside(portalRef, nestedDialogs, options) {
  var useEvent2 = function useEvent3(eventType) {
    return useEventListenerOutside(portalRef, {
      current: null
    }, nestedDialogs, eventType, function(event) {
      event.stopPropagation();
      event.preventDefault();
    }, options.visible && options.modal, true);
  };
  useEvent2("mouseover");
  useEvent2("mousemove");
  useEvent2("mouseout");
}
function useFocusOnChildUnmount(dialogRef, options) {
  react$1.exports.useEffect(function() {
    var dialog = dialogRef.current;
    if (!options.visible || !dialog)
      return void 0;
    var observer = new MutationObserver(function(mutations) {
      var target = mutations[0].target;
      if (target !== dialog)
        return;
      var document2 = getDocument(dialog);
      var activeElement = getActiveElement(dialog);
      if (activeElement === document2.body || isEmpty(activeElement)) {
        dialog.focus();
      }
    });
    observer.observe(dialog, {
      childList: true,
      subtree: true
    });
    return function() {
      observer.disconnect();
    };
  }, [options.visible, dialogRef]);
}
function isActualElement(element) {
  return element && element.tagName && element.tagName !== "HTML" && element !== getDocument(element).body;
}
function useFocusOnBlur(dialogRef, options) {
  var _React$useReducer = react$1.exports.useReducer(function(n2) {
    return n2 + 1;
  }, 0), blurred = _React$useReducer[0], scheduleFocus = _React$useReducer[1];
  useIsomorphicEffect(function() {
    var dialog = dialogRef.current;
    if (!options.visible)
      return;
    if (!blurred)
      return;
    if (!isActualElement(getActiveElement(dialog))) {
      warning(!dialog, "Can't focus dialog after a nested element got blurred because `ref` wasn't passed to the component", "See https://reakit.io/docs/dialog");
      dialog === null || dialog === void 0 ? void 0 : dialog.focus();
    }
  }, [blurred, dialogRef]);
  var onBlur = react$1.exports.useCallback(function(event) {
    if (!options.visible)
      return;
    var nextActiveElement = getNextActiveElementOnBlur(event);
    if (!isActualElement(nextActiveElement)) {
      scheduleFocus();
    }
  }, [options.visible]);
  return onBlur;
}
var useDialog = createHook({
  name: "Dialog",
  compose: useDisclosureContent,
  keys: DIALOG_KEYS,
  useOptions: function useOptions7(_ref) {
    var _ref$modal = _ref.modal, modal = _ref$modal === void 0 ? true : _ref$modal, _ref$hideOnEsc = _ref.hideOnEsc, hideOnEsc = _ref$hideOnEsc === void 0 ? true : _ref$hideOnEsc, _ref$hideOnClickOutsi = _ref.hideOnClickOutside, hideOnClickOutside = _ref$hideOnClickOutsi === void 0 ? true : _ref$hideOnClickOutsi, _ref$preventBodyScrol = _ref.preventBodyScroll, preventBodyScroll = _ref$preventBodyScrol === void 0 ? modal : _ref$preventBodyScrol, _ref$unstable_autoFoc = _ref.unstable_autoFocusOnShow, unstable_autoFocusOnShow = _ref$unstable_autoFoc === void 0 ? true : _ref$unstable_autoFoc, _ref$unstable_autoFoc2 = _ref.unstable_autoFocusOnHide, unstable_autoFocusOnHide = _ref$unstable_autoFoc2 === void 0 ? true : _ref$unstable_autoFoc2, unstable_orphan = _ref.unstable_orphan, options = _objectWithoutPropertiesLoose$2(_ref, ["modal", "hideOnEsc", "hideOnClickOutside", "preventBodyScroll", "unstable_autoFocusOnShow", "unstable_autoFocusOnHide", "unstable_orphan"]);
    return _objectSpread2$2({
      modal,
      hideOnEsc,
      hideOnClickOutside,
      preventBodyScroll: modal && preventBodyScroll,
      unstable_autoFocusOnShow,
      unstable_autoFocusOnHide,
      unstable_orphan: modal && unstable_orphan
    }, options);
  },
  useProps: function useProps9(options, _ref2) {
    var htmlRef = _ref2.ref, htmlOnKeyDown = _ref2.onKeyDown, htmlOnBlur = _ref2.onBlur, htmlWrapElement = _ref2.wrapElement, tabIndex = _ref2.tabIndex, htmlProps = _objectWithoutPropertiesLoose$2(_ref2, ["ref", "onKeyDown", "onBlur", "wrapElement", "tabIndex"]);
    var dialog = react$1.exports.useRef(null);
    var backdrop = react$1.exports.useContext(DialogBackdropContext);
    var hasBackdrop = backdrop && backdrop === options.baseId;
    var disclosure = useDisclosureRef(dialog, options);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var onBlurRef = useLiveRef(htmlOnBlur);
    var focusOnBlur = useFocusOnBlur(dialog, options);
    var _useNestedDialogs = useNestedDialogs(dialog, options), dialogs = _useNestedDialogs.dialogs, visibleModals = _useNestedDialogs.visibleModals, wrap = _useNestedDialogs.wrap;
    var modal = options.modal && !visibleModals.length ? true : void 0;
    usePreventBodyScroll(dialog, options);
    useFocusTrap(dialog, visibleModals, options);
    useFocusOnChildUnmount(dialog, options);
    useFocusOnShow(dialog, dialogs, options);
    useFocusOnHide(dialog, disclosure, options);
    useHideOnClickOutside(dialog, disclosure, dialogs, options);
    useDisableHoverOutside(dialog, dialogs, options);
    var onKeyDown = react$1.exports.useCallback(function(event) {
      var _onKeyDownRef$current;
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented)
        return;
      if (event.key !== "Escape")
        return;
      if (!options.hideOnEsc)
        return;
      if (!options.hide) {
        warning(true, "`hideOnEsc` prop is truthy, but `hide` prop wasn't provided.", "See https://reakit.io/docs/dialog", dialog.current);
        return;
      }
      event.stopPropagation();
      options.hide();
    }, [options.hideOnEsc, options.hide]);
    var onBlur = react$1.exports.useCallback(function(event) {
      var _onBlurRef$current;
      (_onBlurRef$current = onBlurRef.current) === null || _onBlurRef$current === void 0 ? void 0 : _onBlurRef$current.call(onBlurRef, event);
      focusOnBlur(event);
    }, [focusOnBlur]);
    var wrapElement = react$1.exports.useCallback(function(element) {
      element = wrap(element);
      if (options.modal && !hasBackdrop) {
        element = /* @__PURE__ */ react$1.exports.createElement(Portal, null, element);
      }
      if (htmlWrapElement) {
        element = htmlWrapElement(element);
      }
      return /* @__PURE__ */ react$1.exports.createElement(MenuContext.Provider, {
        value: null
      }, element);
    }, [wrap, options.modal, hasBackdrop, htmlWrapElement]);
    return _objectSpread2$2({
      ref: useForkRef(dialog, htmlRef),
      role: "dialog",
      tabIndex: tabIndex != null ? tabIndex : -1,
      "aria-modal": modal,
      "data-dialog": true,
      onKeyDown,
      onBlur,
      wrapElement
    }, htmlProps);
  }
});
createComponent({
  as: "div",
  useHook: useDialog,
  useCreateElement: function useCreateElement$12(type2, props, children) {
    useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/dialog");
    return useCreateElement(type2, props, children);
  }
});
var POPOVER_STATE_KEYS = ["baseId", "unstable_idCountRef", "visible", "animated", "animating", "setBaseId", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation", "modal", "unstable_disclosureRef", "setModal", "unstable_referenceRef", "unstable_popoverRef", "unstable_arrowRef", "unstable_popoverStyles", "unstable_arrowStyles", "unstable_originalPlacement", "unstable_update", "placement", "place"];
var POPOVER_KEYS = POPOVER_STATE_KEYS;
var POPOVER_BACKDROP_KEYS = POPOVER_KEYS;
var POPOVER_DISCLOSURE_KEYS = POPOVER_BACKDROP_KEYS;
var usePopover = createHook({
  name: "Popover",
  compose: useDialog,
  keys: POPOVER_KEYS,
  useOptions: function useOptions8(_ref) {
    var _ref$modal = _ref.modal, modal = _ref$modal === void 0 ? false : _ref$modal, options = _objectWithoutPropertiesLoose$2(_ref, ["modal"]);
    return _objectSpread2$2({
      modal
    }, options);
  },
  useProps: function useProps10(options, _ref2) {
    var htmlRef = _ref2.ref, htmlStyle = _ref2.style, htmlProps = _objectWithoutPropertiesLoose$2(_ref2, ["ref", "style"]);
    return _objectSpread2$2({
      ref: useForkRef(options.unstable_popoverRef, htmlRef),
      style: _objectSpread2$2(_objectSpread2$2({}, options.unstable_popoverStyles), htmlStyle)
    }, htmlProps);
  }
});
createComponent({
  as: "div",
  useHook: usePopover,
  useCreateElement: function useCreateElement$13(type2, props, children) {
    useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/popover");
    return useCreateElement(type2, props, children);
  }
});
var useDisclosure = createHook({
  name: "Disclosure",
  compose: useButton,
  keys: DISCLOSURE_KEYS,
  useProps: function useProps11(options, _ref) {
    var htmlOnClick = _ref.onClick, ariaControls = _ref["aria-controls"], htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["onClick", "aria-controls"]);
    var onClickRef = useLiveRef(htmlOnClick);
    var controls = ariaControls ? ariaControls + " " + options.baseId : options.baseId;
    var onClick = react$1.exports.useCallback(function(event) {
      var _onClickRef$current, _options$toggle;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented)
        return;
      (_options$toggle = options.toggle) === null || _options$toggle === void 0 ? void 0 : _options$toggle.call(options);
    }, [options.toggle]);
    return _objectSpread2$2({
      "aria-expanded": !!options.visible,
      "aria-controls": controls,
      onClick
    }, htmlProps);
  }
});
createComponent({
  as: "button",
  memo: true,
  useHook: useDisclosure
});
var useDialogDisclosure = createHook({
  name: "DialogDisclosure",
  compose: useDisclosure,
  keys: DIALOG_DISCLOSURE_KEYS,
  useProps: function useProps12(options, _ref) {
    var htmlRef = _ref.ref, htmlOnClick = _ref.onClick, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["ref", "onClick"]);
    var ref2 = react$1.exports.useRef(null);
    var onClickRef = useLiveRef(htmlOnClick);
    var _React$useState = react$1.exports.useState(false), expanded = _React$useState[0], setExpanded = _React$useState[1];
    var disclosureRef = options.unstable_disclosureRef;
    useIsomorphicEffect(function() {
      var element = ref2.current;
      warning(!element, "Can't determine whether the element is the current disclosure because `ref` wasn't passed to the component", "See https://reakit.io/docs/dialog");
      if (disclosureRef && !disclosureRef.current) {
        disclosureRef.current = element;
      }
      var isCurrentDisclosure = !(disclosureRef !== null && disclosureRef !== void 0 && disclosureRef.current) || disclosureRef.current === element;
      setExpanded(!!options.visible && isCurrentDisclosure);
    }, [options.visible, disclosureRef]);
    var onClick = react$1.exports.useCallback(function(event) {
      var _onClickRef$current;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented)
        return;
      if (disclosureRef) {
        disclosureRef.current = event.currentTarget;
      }
    }, [disclosureRef]);
    return _objectSpread2$2({
      ref: useForkRef(ref2, htmlRef),
      "aria-haspopup": "dialog",
      "aria-expanded": expanded,
      onClick
    }, htmlProps);
  }
});
createComponent({
  as: "button",
  memo: true,
  useHook: useDialogDisclosure
});
var MENU_BAR_STATE_KEYS = ["baseId", "unstable_idCountRef", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "unstable_values", "setBaseId", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget", "unstable_setValue"];
var MENU_STATE_KEYS = [].concat(MENU_BAR_STATE_KEYS, ["visible", "animated", "animating", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation", "modal", "unstable_disclosureRef", "setModal", "unstable_referenceRef", "unstable_popoverRef", "unstable_arrowRef", "unstable_popoverStyles", "unstable_arrowStyles", "unstable_originalPlacement", "unstable_update", "placement", "place"]);
var MENU_KEYS = MENU_STATE_KEYS;
var MENU_ARROW_KEYS = MENU_KEYS;
var MENU_BAR_KEYS = MENU_ARROW_KEYS;
var MENU_BUTTON_KEYS = MENU_BAR_KEYS;
var MENU_DISCLOSURE_KEYS = MENU_BUTTON_KEYS;
var MENU_GROUP_KEYS = MENU_DISCLOSURE_KEYS;
var MENU_ITEM_KEYS = MENU_GROUP_KEYS;
var MENU_SEPARATOR_KEYS = MENU_ITEM_KEYS;
function useShortcuts(menuRef, _ref, timeout) {
  var _ref$items = _ref.items, items = _ref$items === void 0 ? [] : _ref$items, move2 = _ref.move;
  if (timeout === void 0) {
    timeout = 500;
  }
  var _React$useState = react$1.exports.useState(""), keys2 = _React$useState[0], setKeys = _React$useState[1];
  react$1.exports.useEffect(function() {
    if (!keys2)
      return void 0;
    var timeoutId = setTimeout(function() {
      return setKeys("");
    }, timeout);
    var stop2 = items.find(function(s2) {
      return Boolean(s2.ref.current && s2.ref.current.textContent && s2.ref.current.textContent.toLowerCase().startsWith(keys2));
    });
    if (stop2) {
      move2(stop2.id);
    }
    return function() {
      return clearTimeout(timeoutId);
    };
  }, [keys2, items, move2, timeout]);
  react$1.exports.useEffect(function() {
    var menu = menuRef.current;
    if (!menu)
      return void 0;
    var onKeyDown = function onKeyDown2(event) {
      var _target$getAttribute;
      if (event.key.length > 1)
        return;
      if (event.shiftKey)
        return;
      if (event.metaKey)
        return;
      if (event.ctrlKey)
        return;
      if (event.altKey)
        return;
      var target = event.target;
      var role = (_target$getAttribute = target.getAttribute) === null || _target$getAttribute === void 0 ? void 0 : _target$getAttribute.call(target, "role");
      var targetIsMenu = target === menu;
      var targetIsMenuItem = role && role.indexOf("menuitem") !== -1 && closest(target, "[role=menu],[role=menubar]") === menu;
      if (!targetIsMenu && !targetIsMenuItem)
        return;
      if (/^[a-z0-9_-]$/i.test(event.key)) {
        event.stopPropagation();
        event.preventDefault();
        setKeys(function(k) {
          return "" + k + event.key;
        });
      }
    };
    menu.addEventListener("keydown", onKeyDown);
    return function() {
      return menu.removeEventListener("keydown", onKeyDown);
    };
  }, [menuRef, setKeys]);
}
var useMenuBar = createHook({
  name: "MenuBar",
  compose: useComposite,
  keys: MENU_BAR_KEYS,
  useProps: function useProps13(options, _ref) {
    var htmlRef = _ref.ref, htmlWrapElement = _ref.wrapElement, _ref$role = _ref.role, role = _ref$role === void 0 ? "menubar" : _ref$role, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["ref", "wrapElement", "role"]);
    var ref2 = react$1.exports.useRef(null);
    var wrap = useMenuContext(ref2, role, options);
    useShortcuts(ref2, options);
    var wrapElement = react$1.exports.useCallback(function(element) {
      element = wrap(element);
      if (htmlWrapElement) {
        return htmlWrapElement(element);
      }
      return element;
    }, [wrap, htmlWrapElement]);
    return _objectSpread2$2({
      ref: useForkRef(ref2, htmlRef),
      role,
      "aria-orientation": options.orientation,
      wrapElement
    }, htmlProps);
  }
});
createComponent({
  as: "div",
  useHook: useMenuBar,
  useCreateElement: function useCreateElement$14(type2, props, children) {
    useWarning(!props["aria-label"] && !props["aria-labelledby"] && props.role !== "menubar", "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/menu");
    return useCreateElement(type2, props, children);
  }
});
function usePlacementDir(placement) {
  return react$1.exports.useMemo(function() {
    var _placement$split;
    return placement === null || placement === void 0 ? void 0 : (_placement$split = placement.split("-")) === null || _placement$split === void 0 ? void 0 : _placement$split[0];
  }, [placement]);
}
var useMenu = createHook({
  name: "Menu",
  compose: [useMenuBar, usePopover],
  keys: MENU_KEYS,
  useOptions: function useOptions9(options) {
    var parent = react$1.exports.useContext(MenuContext);
    var parentIsMenuBar = (parent === null || parent === void 0 ? void 0 : parent.role) === "menubar";
    return _objectSpread2$2(_objectSpread2$2({
      unstable_autoFocusOnHide: !parentIsMenuBar,
      modal: false
    }, options), {}, {
      unstable_autoFocusOnShow: false,
      hideOnEsc: false
    });
  },
  useProps: function useProps14(options, _ref) {
    var htmlOnKeyDown = _ref.onKeyDown, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["onKeyDown"]);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var parent = react$1.exports.useContext(MenuContext);
    var hasParent = !!parent;
    var ancestorMenuBar = parent;
    while (ancestorMenuBar && ancestorMenuBar.role !== "menubar") {
      ancestorMenuBar = ancestorMenuBar.parent;
    }
    var _ref2 = ancestorMenuBar || {}, next = _ref2.next, previous = _ref2.previous, orientation = _ref2.orientation;
    var ancestorIsHorizontal = orientation === "horizontal";
    var dir = usePlacementDir(options.placement);
    var onKeyDown = react$1.exports.useCallback(function(event) {
      var _onKeyDownRef$current;
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
      if (event.defaultPrevented)
        return;
      if (event.key === "Escape") {
        var _options$hide;
        if (!hasParent) {
          event.stopPropagation();
        }
        (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
      } else if (hasParent && !isPortalEvent(event)) {
        var ArrowRight = ancestorIsHorizontal && dir !== "left" ? next : dir === "left" && options.hide;
        var ArrowLeft = ancestorIsHorizontal && dir !== "right" ? previous : dir === "right" && options.hide;
        var keyMap = {
          ArrowRight,
          ArrowLeft
        };
        var action2 = keyMap[event.key];
        if (action2) {
          event.preventDefault();
          if (hasParent) {
            event.stopPropagation();
          }
          action2();
        }
      }
    }, [hasParent, ancestorIsHorizontal, next, previous, dir, options.hide]);
    return _objectSpread2$2({
      role: "menu",
      onKeyDown
    }, htmlProps);
  }
});
var Menu = createComponent({
  as: "div",
  useHook: useMenu,
  useCreateElement: function useCreateElement$15(type2, props, children) {
    useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/menu");
    return useCreateElement(type2, props, children);
  }
});
function useMenuBarState(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var _useSealedState = useSealedState(initialState2), _useSealedState$orien = _useSealedState.orientation, orientation = _useSealedState$orien === void 0 ? "horizontal" : _useSealedState$orien, _useSealedState$unsta = _useSealedState.unstable_values, initialValues = _useSealedState$unsta === void 0 ? {} : _useSealedState$unsta, sealed = _objectWithoutPropertiesLoose$2(_useSealedState, ["orientation", "unstable_values"]);
  var _React$useState = react$1.exports.useState(initialValues), values2 = _React$useState[0], setValues = _React$useState[1];
  var composite = useCompositeState(_objectSpread2$2(_objectSpread2$2({}, sealed), {}, {
    orientation
  }));
  return _objectSpread2$2(_objectSpread2$2({}, composite), {}, {
    unstable_values: values2,
    unstable_setValue: react$1.exports.useCallback(function(name, value) {
      setValues(function(vals) {
        var _objectSpread2$12;
        return _objectSpread2$2(_objectSpread2$2({}, vals), {}, (_objectSpread2$12 = {}, _objectSpread2$12[name] = typeof value === "function" ? value(vals) : value, _objectSpread2$12));
      });
    }, [])
  });
}
var usePopoverDisclosure = createHook({
  name: "PopoverDisclosure",
  compose: useDialogDisclosure,
  keys: POPOVER_DISCLOSURE_KEYS,
  useProps: function useProps15(options, _ref) {
    var htmlRef = _ref.ref, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["ref"]);
    return _objectSpread2$2({
      ref: useForkRef(options.unstable_referenceRef, htmlRef)
    }, htmlProps);
  }
});
createComponent({
  as: "button",
  memo: true,
  useHook: usePopoverDisclosure
});
function findVisibleSubmenu(submenus) {
  var visibleSubmenu = submenus === null || submenus === void 0 ? void 0 : submenus.find(function(submenu) {
    return submenu.current && !submenu.current.hidden;
  });
  return visibleSubmenu === null || visibleSubmenu === void 0 ? void 0 : visibleSubmenu.current;
}
var noop = function noop2() {
};
var useMenuButton = createHook({
  name: "MenuButton",
  compose: usePopoverDisclosure,
  keys: MENU_BUTTON_KEYS,
  propsAreEqual: function propsAreEqual3(prev, next) {
    prev.unstable_popoverStyles;
    prev.unstable_arrowStyles;
    prev.currentId;
    prev.unstable_moves;
    var prevProps = _objectWithoutPropertiesLoose$2(prev, ["unstable_popoverStyles", "unstable_arrowStyles", "currentId", "unstable_moves"]);
    next.unstable_popoverStyles;
    next.unstable_arrowStyles;
    next.currentId;
    next.unstable_moves;
    var nextProps = _objectWithoutPropertiesLoose$2(next, ["unstable_popoverStyles", "unstable_arrowStyles", "currentId", "unstable_moves"]);
    return usePopoverDisclosure.unstable_propsAreEqual(prevProps, nextProps);
  },
  useProps: function useProps16(options, _ref) {
    var htmlRef = _ref.ref, htmlOnClick = _ref.onClick, htmlOnKeyDown = _ref.onKeyDown, htmlOnFocus = _ref.onFocus, htmlOnMouseEnter = _ref.onMouseEnter, htmlOnMouseDown = _ref.onMouseDown, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["ref", "onClick", "onKeyDown", "onFocus", "onMouseEnter", "onMouseDown"]);
    var parent = react$1.exports.useContext(MenuContext);
    var ref2 = react$1.exports.useRef(null);
    var hasPressedMouse = react$1.exports.useRef(false);
    var _options$placement$sp = options.placement.split("-"), dir = _options$placement$sp[0];
    var hasParent = !!parent;
    var parentIsMenuBar = (parent === null || parent === void 0 ? void 0 : parent.role) === "menubar";
    var disabled = options.disabled || htmlProps["aria-disabled"];
    var onClickRef = useLiveRef(htmlOnClick);
    var onKeyDownRef = useLiveRef(htmlOnKeyDown);
    var onFocusRef = useLiveRef(htmlOnFocus);
    var onMouseEnterRef = useLiveRef(htmlOnMouseEnter);
    var onMouseDownRef = useLiveRef(htmlOnMouseDown);
    var onKeyDown = react$1.exports.useCallback(function(event) {
      var _onKeyDownRef$current;
      if (event.key === "Escape") {
        var _options$hide;
        (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
      } else if (!disabled) {
        var first = options.first && function() {
          return setTimeout(options.first);
        };
        var last = options.last && function() {
          return setTimeout(options.last);
        };
        var keyMap = {
          Enter: first,
          " ": first,
          ArrowUp: (dir === "top" || dir === "bottom") && last,
          ArrowRight: dir === "right" && first,
          ArrowDown: (dir === "bottom" || dir === "top") && first,
          ArrowLeft: dir === "left" && first
        };
        var action2 = keyMap[event.key];
        if (action2) {
          var _options$show;
          event.preventDefault();
          event.stopPropagation();
          (_options$show = options.show) === null || _options$show === void 0 ? void 0 : _options$show.call(options);
          action2();
          return;
        }
      }
      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
    }, [disabled, options.hide, options.first, options.last, dir, options.show]);
    var onMouseEnter = react$1.exports.useCallback(function(event) {
      var _onMouseEnterRef$curr;
      (_onMouseEnterRef$curr = onMouseEnterRef.current) === null || _onMouseEnterRef$curr === void 0 ? void 0 : _onMouseEnterRef$curr.call(onMouseEnterRef, event);
      if (event.defaultPrevented)
        return;
      if (!parent)
        return;
      var element = event.currentTarget;
      if (parentIsMenuBar) {
        if (findVisibleSubmenu(parent.children)) {
          element.focus();
        }
      } else {
        setTimeout(function() {
          if (hasFocusWithin(element)) {
            var _options$show2;
            (_options$show2 = options.show) === null || _options$show2 === void 0 ? void 0 : _options$show2.call(options);
          }
        }, 200);
      }
    }, [parent, parentIsMenuBar, options.show]);
    var onMouseDown = react$1.exports.useCallback(function(event) {
      var _onMouseDownRef$curre;
      hasPressedMouse.current = true;
      (_onMouseDownRef$curre = onMouseDownRef.current) === null || _onMouseDownRef$curre === void 0 ? void 0 : _onMouseDownRef$curre.call(onMouseDownRef, event);
    }, []);
    var onFocus = react$1.exports.useCallback(function(event) {
      var _onFocusRef$current;
      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
      if (event.defaultPrevented)
        return;
      if (disabled)
        return;
      if (parentIsMenuBar && !hasPressedMouse.current) {
        var _options$show3;
        (_options$show3 = options.show) === null || _options$show3 === void 0 ? void 0 : _options$show3.call(options);
      }
    }, [parentIsMenuBar, disabled, options.show]);
    var onClick = react$1.exports.useCallback(function(event) {
      var _onClickRef$current;
      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented)
        return;
      if (hasParent && !parentIsMenuBar) {
        var _options$show4;
        (_options$show4 = options.show) === null || _options$show4 === void 0 ? void 0 : _options$show4.call(options);
      } else {
        var _options$toggle;
        (_options$toggle = options.toggle) === null || _options$toggle === void 0 ? void 0 : _options$toggle.call(options);
        if (hasPressedMouse.current && !parentIsMenuBar && !options.visible) {
          var _options$move;
          (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, null);
        }
      }
      hasPressedMouse.current = false;
    }, [hasParent, parentIsMenuBar, options.show, options.toggle, options.visible, options.move]);
    return _objectSpread2$2({
      ref: useForkRef(ref2, htmlRef),
      "aria-haspopup": "menu",
      onKeyDown,
      onMouseEnter,
      onMouseDown,
      onFocus,
      onClick
    }, htmlProps);
  },
  useComposeOptions: function useComposeOptions(options) {
    return _objectSpread2$2(_objectSpread2$2({}, options), {}, {
      toggle: noop
    });
  }
});
var MenuButton = createComponent({
  as: "button",
  memo: true,
  useHook: useMenuButton
});
var useMenuGroup = createHook({
  name: "MenuGroup",
  compose: useRole,
  keys: MENU_GROUP_KEYS,
  useProps: function useProps17(_2, htmlProps) {
    return _objectSpread2$2({
      role: "group"
    }, htmlProps);
  }
});
var MenuGroup$1 = createComponent({
  as: "div",
  useHook: useMenuGroup
});
function getTriangleArea(a2, b, c2) {
  return Math.abs((a2.x * (b.y - c2.y) + b.x * (c2.y - a2.y) + c2.x * (a2.y - b.y)) / 2);
}
function isPointInTriangle(point, a2, b, c2) {
  var A = getTriangleArea(a2, b, c2);
  var A1 = getTriangleArea(point, b, c2);
  var A2 = getTriangleArea(a2, point, c2);
  var A3 = getTriangleArea(a2, b, point);
  return A === A1 + A2 + A3;
}
function getSubmenuAnchorPoints(event, visibleSubmenu) {
  var _visibleSubmenu$getBo = visibleSubmenu.getBoundingClientRect(), top2 = _visibleSubmenu$getBo.top, right2 = _visibleSubmenu$getBo.right, bottom2 = _visibleSubmenu$getBo.bottom, left2 = _visibleSubmenu$getBo.left;
  var x = left2 > event.clientX ? left2 : right2;
  return [{
    x,
    y: top2
  }, {
    x,
    y: bottom2
  }];
}
function useTransitToSubmenu(menu, htmlOnMouseEnter) {
  var onMouseEnterRef = useLiveRef(htmlOnMouseEnter);
  var enterPointRef = react$1.exports.useRef(null);
  var submenuTopPointRef = react$1.exports.useRef(null);
  var submenuBottomPointRef = react$1.exports.useRef(null);
  var previousClientX = react$1.exports.useRef(0);
  var previousClientY = react$1.exports.useRef(0);
  var assignSubmenuAnchorPoints = react$1.exports.useCallback(function(event) {
    if (!(menu !== null && menu !== void 0 && menu.children.length))
      return;
    submenuTopPointRef.current = null;
    submenuBottomPointRef.current = null;
    var visibleSubmenu = findVisibleSubmenu(menu.children);
    if (!visibleSubmenu)
      return;
    var _getSubmenuAnchorPoin = getSubmenuAnchorPoints(event, visibleSubmenu);
    submenuTopPointRef.current = _getSubmenuAnchorPoin[0];
    submenuBottomPointRef.current = _getSubmenuAnchorPoin[1];
  }, [menu === null || menu === void 0 ? void 0 : menu.children]);
  var isMouseInTransitToSubmenu = react$1.exports.useCallback(function(event) {
    var isMoving = previousClientX.current !== event.clientX || previousClientY.current !== event.clientY;
    if (event.isTrusted && !isMoving) {
      return true;
    }
    var movementX = Math.abs(previousClientX.current - event.clientX);
    previousClientX.current = event.clientX;
    previousClientY.current = event.clientY;
    var hasAnchorPoints = function hasAnchorPoints2() {
      return submenuTopPointRef.current && submenuBottomPointRef.current;
    };
    if (event.type === "mouseleave" && !hasAnchorPoints()) {
      assignSubmenuAnchorPoints(event);
    }
    if (!hasAnchorPoints())
      return false;
    return movementX && enterPointRef.current && isPointInTriangle({
      x: event.clientX,
      y: event.clientY
    }, enterPointRef.current, submenuTopPointRef.current, submenuBottomPointRef.current);
  }, [assignSubmenuAnchorPoints]);
  var onMouseEnter = react$1.exports.useCallback(function(event) {
    var _onMouseEnterRef$curr;
    (_onMouseEnterRef$curr = onMouseEnterRef.current) === null || _onMouseEnterRef$curr === void 0 ? void 0 : _onMouseEnterRef$curr.call(onMouseEnterRef, event);
    if (event.defaultPrevented)
      return;
    if ((menu === null || menu === void 0 ? void 0 : menu.role) === "menubar")
      return;
    enterPointRef.current = {
      x: event.clientX,
      y: event.clientY
    };
    assignSubmenuAnchorPoints(event);
  }, [menu === null || menu === void 0 ? void 0 : menu.role, assignSubmenuAnchorPoints]);
  return {
    onMouseEnter,
    isMouseInTransitToSubmenu
  };
}
function getMouseDestination(event) {
  var relatedTarget = event.relatedTarget;
  if ((relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.nodeType) === Node.ELEMENT_NODE) {
    return event.relatedTarget;
  }
  return event.toElement || null;
}
function hoveringInside(event) {
  var nextElement = getMouseDestination(event);
  if (!nextElement)
    return false;
  return contains$1(event.currentTarget, nextElement);
}
function hoveringExpandedMenu(event, children) {
  if (!(children !== null && children !== void 0 && children.length))
    return false;
  var nextElement = getMouseDestination(event);
  if (!nextElement)
    return false;
  var visibleSubmenu = findVisibleSubmenu(children);
  return visibleSubmenu && contains$1(visibleSubmenu, nextElement);
}
function hoveringAnotherMenuItem(event, items) {
  var nextElement = getMouseDestination(event);
  if (!nextElement)
    return false;
  return items === null || items === void 0 ? void 0 : items.some(function(item) {
    return item.ref.current && contains$1(item.ref.current, nextElement);
  });
}
var useMenuItem = createHook({
  name: "MenuItem",
  compose: useCompositeItem,
  keys: MENU_ITEM_KEYS,
  propsAreEqual: function propsAreEqual4(prev, next) {
    prev.unstable_popoverStyles;
    prev.unstable_arrowStyles;
    prev.visible;
    var prevProps = _objectWithoutPropertiesLoose$2(prev, ["unstable_popoverStyles", "unstable_arrowStyles", "visible"]);
    next.unstable_popoverStyles;
    next.unstable_arrowStyles;
    next.visible;
    var nextProps = _objectWithoutPropertiesLoose$2(next, ["unstable_popoverStyles", "unstable_arrowStyles", "visible"]);
    return useCompositeItem.unstable_propsAreEqual(prevProps, nextProps);
  },
  useProps: function useProps18(options, _ref) {
    var htmlOnMouseEnter = _ref.onMouseEnter, htmlOnMouseMove = _ref.onMouseMove, htmlOnMouseLeave = _ref.onMouseLeave, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["onMouseEnter", "onMouseMove", "onMouseLeave"]);
    var menu = react$1.exports.useContext(MenuContext);
    var onMouseMoveRef = useLiveRef(htmlOnMouseMove);
    var onMouseLeaveRef = useLiveRef(htmlOnMouseLeave);
    var _useTransitToSubmenu = useTransitToSubmenu(menu, htmlOnMouseEnter), onMouseEnter = _useTransitToSubmenu.onMouseEnter, isMouseInTransitToSubmenu = _useTransitToSubmenu.isMouseInTransitToSubmenu;
    var onMouseMove = react$1.exports.useCallback(function(event) {
      var _onMouseMoveRef$curre, _options$move;
      (_onMouseMoveRef$curre = onMouseMoveRef.current) === null || _onMouseMoveRef$curre === void 0 ? void 0 : _onMouseMoveRef$curre.call(onMouseMoveRef, event);
      if (event.defaultPrevented)
        return;
      if ((menu === null || menu === void 0 ? void 0 : menu.role) === "menubar")
        return;
      if (isMouseInTransitToSubmenu(event))
        return;
      if (hasFocusWithin(event.currentTarget))
        return;
      (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, event.currentTarget.id);
    }, [options.move]);
    var onMouseLeave = react$1.exports.useCallback(function(event) {
      var _onMouseLeaveRef$curr;
      (_onMouseLeaveRef$curr = onMouseLeaveRef.current) === null || _onMouseLeaveRef$curr === void 0 ? void 0 : _onMouseLeaveRef$curr.call(onMouseLeaveRef, event);
      if (event.defaultPrevented)
        return;
      if ((menu === null || menu === void 0 ? void 0 : menu.role) === "menubar")
        return;
      if (hoveringInside(event))
        return;
      if (hoveringExpandedMenu(event, menu === null || menu === void 0 ? void 0 : menu.children))
        return;
      if (!hoveringAnotherMenuItem(event, options.items)) {
        var _options$move2;
        if (isMouseInTransitToSubmenu(event))
          return;
        (_options$move2 = options.move) === null || _options$move2 === void 0 ? void 0 : _options$move2.call(options, null);
      }
    }, [menu === null || menu === void 0 ? void 0 : menu.role, menu === null || menu === void 0 ? void 0 : menu.children, options.items, options.move]);
    return _objectSpread2$2({
      role: "menuitem",
      onMouseEnter,
      onMouseMove,
      onMouseLeave
    }, htmlProps);
  }
});
var MenuItem = createComponent({
  as: "button",
  memo: true,
  useHook: useMenuItem
});
var SEPARATOR_KEYS = ["orientation"];
var useSeparator = createHook({
  name: "Separator",
  compose: useRole,
  keys: SEPARATOR_KEYS,
  useOptions: function useOptions10(_ref) {
    var _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? "horizontal" : _ref$orientation, options = _objectWithoutPropertiesLoose$2(_ref, ["orientation"]);
    return _objectSpread2$2({
      orientation
    }, options);
  },
  useProps: function useProps19(options, htmlProps) {
    return _objectSpread2$2({
      role: "separator",
      "aria-orientation": options.orientation
    }, htmlProps);
  }
});
createComponent({
  as: "hr",
  memo: true,
  useHook: useSeparator
});
var useMenuSeparator = createHook({
  name: "MenuSeparator",
  compose: useSeparator,
  keys: MENU_SEPARATOR_KEYS,
  useOptions: function useOptions11(_ref) {
    var _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? "vertical" : _ref$orientation, options = _objectWithoutPropertiesLoose$2(_ref, ["orientation"]);
    return _objectSpread2$2({
      orientation: orientation === "vertical" ? "horizontal" : "vertical"
    }, options);
  }
});
var MenuSeparator = createComponent({
  as: "hr",
  memo: true,
  useHook: useMenuSeparator
});
function useMenuState(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var parent = react$1.exports.useContext(MenuContext);
  var _useSealedState = useSealedState(initialState2), _useSealedState$orien = _useSealedState.orientation, orientation = _useSealedState$orien === void 0 ? "vertical" : _useSealedState$orien, _useSealedState$gutte = _useSealedState.gutter, gutter = _useSealedState$gutte === void 0 ? 0 : _useSealedState$gutte, sealed = _objectWithoutPropertiesLoose$2(_useSealedState, ["orientation", "gutter"]);
  var placement = sealed.placement || (parent && parent.orientation === "vertical" ? "right-start" : "bottom-start");
  var menuBar = useMenuBarState(_objectSpread2$2(_objectSpread2$2({}, sealed), {}, {
    orientation
  }));
  var popover = usePopoverState(_objectSpread2$2(_objectSpread2$2({}, sealed), {}, {
    placement,
    gutter
  }));
  react$1.exports.useEffect(function() {
    if (!popover.visible) {
      menuBar.reset();
    }
  }, [popover.visible, menuBar.reset]);
  return _objectSpread2$2(_objectSpread2$2({}, menuBar), popover);
}
var index2 = react$1.exports.useLayoutEffect;
function t(t2, n2, r2) {
  return Math.min(Math.max(t2, r2), n2);
}
class n extends Error {
  constructor(t2) {
    super(`Failed to parse color: "${t2}"`);
  }
}
function r(r2) {
  if (typeof r2 != "string")
    throw new n(r2);
  if (r2.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let e2 = r2.trim();
  e2 = u.test(r2) ? function(t2) {
    const r3 = t2.toLowerCase().trim(), e3 = o[function(t3) {
      let n2 = 5381, r4 = t3.length;
      for (; r4; )
        n2 = 33 * n2 ^ t3.charCodeAt(--r4);
      return (n2 >>> 0) % 2341;
    }(r3)];
    if (!e3)
      throw new n(t2);
    return `#${e3}`;
  }(r2) : r2;
  const f2 = s.exec(e2);
  if (f2) {
    const t2 = Array.from(f2).slice(1);
    return [...t2.slice(0, 3).map((t3) => parseInt(_(t3, 2), 16)), parseInt(_(t2[3] || "f", 2), 16) / 255];
  }
  const p2 = i.exec(e2);
  if (p2) {
    const t2 = Array.from(p2).slice(1);
    return [...t2.slice(0, 3).map((t3) => parseInt(t3, 16)), parseInt(t2[3] || "ff", 16) / 255];
  }
  const z2 = a.exec(e2);
  if (z2) {
    const t2 = Array.from(z2).slice(1);
    return [...t2.slice(0, 3).map((t3) => parseInt(t3, 10)), parseFloat(t2[3] || "1")];
  }
  const h = c.exec(e2);
  if (h) {
    const [e3, o2, _2, s2] = Array.from(h).slice(1).map(parseFloat);
    if (t(0, 100, o2) !== o2)
      throw new n(r2);
    if (t(0, 100, _2) !== _2)
      throw new n(r2);
    return [...l(e3, o2, _2), s2 || 1];
  }
  throw new n(r2);
}
const e = (t2) => parseInt(t2.replace(/_/g, ""), 36), o = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((t2, n2) => {
  const r2 = e(n2.substring(0, 3)), o2 = e(n2.substring(3)).toString(16);
  let _2 = "";
  for (let t3 = 0; t3 < 6 - o2.length; t3++)
    _2 += "0";
  return t2[r2] = `${_2}${o2}`, t2;
}, {}), _ = (t2, n2) => Array.from(Array(n2)).map(() => t2).join(""), s = new RegExp(`^#${_("([a-f0-9])", 3)}([a-f0-9])?$`, "i"), i = new RegExp(`^#${_("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i"), a = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${_(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i"), c = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i, u = /^[a-z]+$/i, f = (t2) => Math.round(255 * t2), l = (t2, n2, r2) => {
  let e2 = r2 / 100;
  if (n2 === 0)
    return [e2, e2, e2].map(f);
  const o2 = (t2 % 360 + 360) % 360 / 60, _2 = (1 - Math.abs(2 * e2 - 1)) * (n2 / 100), s2 = _2 * (1 - Math.abs(o2 % 2 - 1));
  let i2 = 0, a2 = 0, c2 = 0;
  o2 >= 0 && o2 < 1 ? (i2 = _2, a2 = s2) : o2 >= 1 && o2 < 2 ? (i2 = s2, a2 = _2) : o2 >= 2 && o2 < 3 ? (a2 = _2, c2 = s2) : o2 >= 3 && o2 < 4 ? (a2 = s2, c2 = _2) : o2 >= 4 && o2 < 5 ? (i2 = s2, c2 = _2) : o2 >= 5 && o2 < 6 && (i2 = _2, c2 = s2);
  const u2 = e2 - _2 / 2;
  return [i2 + u2, a2 + u2, c2 + u2].map(f);
};
function p(t2) {
  const [n2, e2, o2, _2] = r(t2).map((t3, n3) => n3 === 3 ? t3 : t3 / 255), s2 = Math.max(n2, e2, o2), i2 = Math.min(n2, e2, o2), a2 = (s2 + i2) / 2;
  if (s2 === i2)
    return [0, 0, a2, _2];
  const c2 = s2 - i2;
  return [60 * (n2 === s2 ? (e2 - o2) / c2 + (e2 < o2 ? 6 : 0) : e2 === s2 ? (o2 - n2) / c2 + 2 : (n2 - e2) / c2 + 4), a2 > 0.5 ? c2 / (2 - s2 - i2) : c2 / (s2 + i2), a2, _2];
}
function z(n2, r2, e2, o2) {
  return `hsla(${(n2 % 360).toFixed()}, ${t(0, 100, 100 * r2).toFixed()}%, ${t(0, 100, 100 * e2).toFixed()}%, ${parseFloat(t(0, 1, o2).toFixed(3))})`;
}
function d(t2, n2) {
  const [r2, e2, o2, _2] = p(t2);
  return z(r2, e2, o2 - n2, _2);
}
function w(t2) {
  if (t2 === "transparent")
    return 0;
  function n2(t3) {
    const n3 = t3 / 255;
    return n3 <= 0.03928 ? n3 / 12.92 : Math.pow((n3 + 0.055) / 1.055, 2.4);
  }
  const [e2, o2, _2] = r(t2);
  return 0.2126 * n2(e2) + 0.7152 * n2(o2) + 0.0722 * n2(_2);
}
function m(n2, r2, e2, o2) {
  return `rgba(${t(0, 255, n2).toFixed()}, ${t(0, 255, r2).toFixed()}, ${t(0, 255, e2).toFixed()}, ${parseFloat(t(0, 1, o2).toFixed(3))})`;
}
function $(t2, n2) {
  return d(t2, -n2);
}
function v(t2, n2) {
  const [e2, o2, _2, s2] = r(t2);
  return m(e2, o2, _2, s2 - n2);
}
function F(t2) {
  return w(t2) > 0.179;
}
function M(t2) {
  return F(t2) ? "#000" : "#fff";
}
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
function createThemeVariables() {
  var theme2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var cssVariableString = [];
  var cssVariableObject = {};
  function addCssVariable(keys2, value2) {
    if (typeof value2 === "string" || typeof value2 === "number") {
      cssVariableString.push("".concat(getCustomPropertyName(keys2), ": ").concat(value2, ";"));
      cssVariableObject[getCustomPropertyName(keys2)] = value2;
      return;
    }
    if (typeof value2 !== "object" || !value2) {
      return;
    }
    for (var _i = 0, _Object$entries = Object.entries(value2); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), _key = _Object$entries$_i[0], v2 = _Object$entries$_i[1];
      addCssVariable([...keys2, _key], v2);
    }
    return;
  }
  for (var _i2 = 0, _Object$entries2 = Object.entries(theme2); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2), _key2 = _Object$entries2$_i[0], value = _Object$entries2$_i[1];
    addCssVariable([_key2], value);
  }
  return {
    css: cssVariableString.join("\n"),
    styles: cssVariableObject
  };
}
function getCustomPropertyName(keys2) {
  return "--rmr-".concat(keys2.map(kebabCase).join("-"));
}
function getVar(keys2) {
  return "var(".concat(getCustomPropertyName(keys2), ")");
}
function getThemeVar() {
  for (var _len = arguments.length, args = new Array(_len), _key3 = 0; _key3 < _len; _key3++) {
    args[_key3] = arguments[_key3];
  }
  return getVar(args.map((p2) => p2.toString()));
}
var defaultRemirrorThemeHue = {
  gray: ["#f8f9fa", "#f1f3f5", "#e9ecef", "#dee2e6", "#ced4da", "#adb5bd", "#868e96", "#495057", "#343a40", "#212529"],
  red: ["#fff5f5", "#ffe3e3", "#ffc9c9", "#ffa8a8", "#ff8787", "#ff6b6b", "#fa5252", "#f03e3e", "#e03131", "#c92a2a"],
  pink: ["#fff0f6", "#ffdeeb", "#fcc2d7", "#faa2c1", "#f783ac", "#f06595", "#e64980", "#d6336c", "#c2255c", "#a61e4d"],
  grape: ["#f8f0fc", "#f3d9fa", "#eebefa", "#e599f7", "#da77f2", "#cc5de8", "#be4bdb", "#ae3ec9", "#9c36b5", "#862e9c"],
  violet: ["#f3f0ff", "#e5dbff", "#d0bfff", "#b197fc", "#9775fa", "#845ef7", "#7950f2", "#7048e8", "#6741d9", "#5f3dc4"],
  indigo: ["#edf2ff", "#dbe4ff", "#bac8ff", "#91a7ff", "#748ffc", "#5c7cfa", "#4c6ef5", "#4263eb", "#3b5bdb", "#364fc7"],
  blue: ["#e7f5ff", "#d0ebff", "#a5d8ff", "#74c0fc", "#4dabf7", "#339af0", "#228be6", "#1c7ed6", "#1971c2", "#1864ab"],
  cyan: ["#e3fafc", "#c5f6fa", "#99e9f2", "#66d9e8", "#3bc9db", "#22b8cf", "#15aabf", "#1098ad", "#0c8599", "#0b7285"],
  teal: ["#e6fcf5", "#c3fae8", "#96f2d7", "#63e6be", "#38d9a9", "#20c997", "#12b886", "#0ca678", "#099268", "#087f5b"],
  green: ["#ebfbee", "#d3f9d8", "#b2f2bb", "#8ce99a", "#69db7c", "#51cf66", "#40c057", "#37b24d", "#2f9e44", "#2b8a3e"],
  lime: ["#f4fce3", "#e9fac8", "#d8f5a2", "#c0eb75", "#a9e34b", "#94d82d", "#82c91e", "#74b816", "#66a80f", "#5c940d"],
  yellow: ["#fff9db", "#fff3bf", "#ffec99", "#ffe066", "#ffd43b", "#fcc419", "#fab005", "#f59f00", "#f08c00", "#e67700"],
  orange: ["#fff4e6", "#ffe8cc", "#ffd8a8", "#ffc078", "#ffa94d", "#ff922b", "#fd7e14", "#f76707", "#e8590c", "#d9480f"]
};
var foreground = "#000000";
var background = "#ffffff";
var text$1 = "#252103";
var border = v(foreground, 0.75);
var primary = "#7963d2";
var secondary = "#bcd263";
var primaryText = "#fff";
var secondaryText = "#fff";
var muted = defaultRemirrorThemeHue.gray[1];
var shadow1 = "rgba(10,31,68,0.08)";
var shadow2 = "rgba(10,31,68,0.10)";
var shadow3 = "rgba(10,31,68,0.12)";
var faded = $(v(foreground, 0.1), 0.13);
var baseColorTheme = {
  background,
  border,
  foreground,
  muted,
  primary,
  secondary,
  primaryText,
  secondaryText,
  text: text$1,
  faded
};
var activeColorTheme = _objectSpread2$3(_objectSpread2$3({}, baseColorTheme), {}, {
  background: d(background, 0.15),
  border: d(border, 0.15),
  foreground: d(foreground, 0.15),
  muted: d(muted, 0.15),
  primary: d(primary, 0.15),
  secondary: d(secondary, 0.15),
  get text() {
    return M(this.background);
  },
  get primaryText() {
    return M(this.primary);
  },
  get secondaryText() {
    return M(this.secondary);
  }
});
var hoverColorTheme = _objectSpread2$3(_objectSpread2$3({}, baseColorTheme), {}, {
  background: d(background, 0.075),
  border: d(border, 0.075),
  foreground: d(foreground, 0.075),
  muted: d(muted, 0.075),
  primary: d(primary, 0.075),
  secondary: d(secondary, 0.075),
  get text() {
    return M(this.background);
  },
  get primaryText() {
    return M(this.primary);
  },
  get secondaryText() {
    return M(this.secondary);
  }
});
({
  color: _objectSpread2$3(_objectSpread2$3({}, baseColorTheme), {}, {
    active: activeColorTheme,
    hover: hoverColorTheme,
    shadow1,
    shadow2,
    shadow3,
    backdrop: v(foreground, 0.1),
    outline: v(primary, 0.6),
    selection: {
      background: "Highlight",
      shadow: "inherit",
      text: "HighlightText",
      caret: "inherit"
    },
    table: {
      default: {
        border: $(foreground, 0.8),
        cell: $(foreground, 0.4),
        controller: defaultRemirrorThemeHue.gray[3]
      },
      selected: {
        border: defaultRemirrorThemeHue.blue[7],
        cell: defaultRemirrorThemeHue.blue[1],
        controller: defaultRemirrorThemeHue.blue[5]
      },
      preselect: {
        border: defaultRemirrorThemeHue.blue[7],
        cell: $(foreground, 0.4),
        controller: defaultRemirrorThemeHue.blue[5]
      },
      predelete: {
        border: defaultRemirrorThemeHue.red[7],
        cell: defaultRemirrorThemeHue.red[1],
        controller: defaultRemirrorThemeHue.red[5]
      },
      mark: "#91919196"
    }
  }),
  hue: defaultRemirrorThemeHue,
  radius: {
    border: "0.25rem",
    extra: "0.5rem",
    circle: "50%"
  },
  fontFamily: {
    default: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif',
    heading: "inherit",
    mono: "Menlo, monospace"
  },
  fontSize: {
    0: "12px",
    1: "14px",
    2: "16px",
    3: "20px",
    4: "24px",
    5: "32px",
    6: "48px",
    7: "64px",
    8: "96px",
    default: "16px"
  },
  space: {
    1: "4px",
    2: "8px",
    3: "16px",
    4: "32px",
    5: "64px",
    6: "128px",
    7: "256px",
    8: "512px"
  },
  fontWeight: {
    bold: "700",
    default: "400",
    heading: "700"
  },
  letterSpacing: {
    tight: "-1px",
    default: "normal",
    loose: "1px",
    wide: "3px"
  },
  lineHeight: {
    heading: "1.25em",
    default: "1.5em"
  },
  boxShadow: {
    1: "0 1px 1px ".concat(shadow1),
    2: "0 1px 1px ".concat(shadow2),
    3: "0 1px 1px ".concat(shadow3)
  }
});
getThemeVar("color", "foreground");
getThemeVar("color", "text");
getThemeVar("color", "background");
getThemeVar("color", "backdrop");
getThemeVar("color", "border");
getThemeVar("color", "shadow1");
getThemeVar("color", "hover", "border");
getThemeVar("color", "active", "border");
getThemeVar("color", "primary");
getThemeVar("color", "primaryText");
getThemeVar("color", "hover", "primary");
getThemeVar("color", "hover", "primaryText");
getThemeVar("color", "active", "primary");
getThemeVar("color", "active", "primaryText");
var EDITOR_WRAPPER = "remirror-editor-wrapper";
var BUTTON_ACTIVE = "remirror-button-active";
var BUTTON = "remirror-button";
var COMPOSITE = "remirror-composite";
var DIALOG = "remirror-dialog";
var DIALOG_BACKDROP = "remirror-dialog-backdrop";
var FORM = "remirror-form";
var FORM_MESSAGE = "remirror-form-message";
var FORM_LABEL = "remirror-form-label";
var FORM_GROUP = "remirror-form-group";
var GROUP = "remirror-group";
var INPUT = "remirror-input";
var MENU = "remirror-menu";
var MENU_PANE = "remirror-menu-pane";
var MENU_PANE_ACTIVE = "remirror-menu-pane-active";
var MENU_DROPDOWN_LABEL = "remirror-menu-dropdown-label";
var MENU_PANE_ICON = "remirror-menu-pane-icon";
var MENU_PANE_LABEL = "remirror-menu-pane-label";
var MENU_PANE_SHORTCUT = "remirror-menu-pane-shortcut";
var MENU_BUTTON_LEFT = "remirror-menu-button-left";
var MENU_BUTTON_RIGHT = "remirror-menu-button-right";
var MENU_BUTTON_NESTED_LEFT = "remirror-menu-button-nested-left";
var MENU_BUTTON_NESTED_RIGHT = "remirror-menu-button-nested-right";
var MENU_BUTTON = "remirror-menu-button";
var MENU_BAR = "remirror-menu-bar";
var FLEX_COLUMN = "remirror-flex-column";
var FLEX_ROW = "remirror-flex-row";
var MENU_ITEM = "remirror-menu-item";
var MENU_ITEM_ROW = "remirror-menu-item-row";
var MENU_ITEM_COLUMN = "remirror-menu-item-column";
var MENU_ITEM_CHECKBOX = "remirror-menu-item-checkbox";
var MENU_ITEM_RADIO = "remirror-menu-item-radio";
var MENU_GROUP = "remirror-menu-group";
var FLOATING_POPOVER = "remirror-floating-popover";
var POPOVER = "remirror-popover";
var ANIMATED_POPOVER = "remirror-animated-popover";
var ROLE = "remirror-role";
var SEPARATOR = "remirror-separator";
var TAB = "remirror-tab";
var TAB_LIST = "remirror-tab-list";
var TABBABLE = "remirror-tabbable";
var TOOLBAR = "remirror-toolbar";
var TOOLTIP = "remirror-tooltip";
var TABLE_SIZE_EDITOR = "remirror-table-size-editor";
var TABLE_SIZE_EDITOR_BODY = "remirror-table-size-editor-body";
var TABLE_SIZE_EDITOR_CELL = "remirror-table-size-editor-cell";
var TABLE_SIZE_EDITOR_CELL_SELECTED = "remirror-table-size-editor-cell-selected";
var TABLE_SIZE_EDITOR_FOOTER = "remirror-table-size-editor-footer";
var COLOR_PICKER = "remirror-color-picker";
var COLOR_PICKER_CELL = "remirror-color-picker-cell";
var COLOR_PICKER_CELL_SELECTED = "remirror-color-picker-cell-selected";
var componentsTheme = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EDITOR_WRAPPER,
  BUTTON_ACTIVE,
  BUTTON,
  COMPOSITE,
  DIALOG,
  DIALOG_BACKDROP,
  FORM,
  FORM_MESSAGE,
  FORM_LABEL,
  FORM_GROUP,
  GROUP,
  INPUT,
  MENU,
  MENU_PANE,
  MENU_PANE_ACTIVE,
  MENU_DROPDOWN_LABEL,
  MENU_PANE_ICON,
  MENU_PANE_LABEL,
  MENU_PANE_SHORTCUT,
  MENU_BUTTON_LEFT,
  MENU_BUTTON_RIGHT,
  MENU_BUTTON_NESTED_LEFT,
  MENU_BUTTON_NESTED_RIGHT,
  MENU_BUTTON,
  MENU_BAR,
  FLEX_COLUMN,
  FLEX_ROW,
  MENU_ITEM,
  MENU_ITEM_ROW,
  MENU_ITEM_COLUMN,
  MENU_ITEM_CHECKBOX,
  MENU_ITEM_RADIO,
  MENU_GROUP,
  FLOATING_POPOVER,
  POPOVER,
  ANIMATED_POPOVER,
  ROLE,
  SEPARATOR,
  TAB,
  TAB_LIST,
  TABBABLE,
  TOOLBAR,
  TOOLTIP,
  TABLE_SIZE_EDITOR,
  TABLE_SIZE_EDITOR_BODY,
  TABLE_SIZE_EDITOR_CELL,
  TABLE_SIZE_EDITOR_CELL_SELECTED,
  TABLE_SIZE_EDITOR_FOOTER,
  COLOR_PICKER,
  COLOR_PICKER_CELL,
  COLOR_PICKER_CELL_SELECTED
});
var LIST_ITEM_WITH_CUSTOM_MARKER = "remirror-list-item-with-custom-mark";
var UL_LIST_CONTENT = "remirror-ul-list-content";
var EDITOR$3 = "remirror-editor";
var LIST_ITEM_MARKER_CONTAINER = "remirror-list-item-marker-container";
var LIST_ITEM_CHECKBOX = "remirror-list-item-checkbox";
var COLLAPSIBLE_LIST_ITEM_CLOSED = "remirror-collapsible-list-item-closed";
var COLLAPSIBLE_LIST_ITEM_BUTTON = "remirror-collapsible-list-item-button";
var LIST_SPINE = "remirror-list-spine";
var extensionListTheme = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LIST_ITEM_WITH_CUSTOM_MARKER,
  UL_LIST_CONTENT,
  EDITOR: EDITOR$3,
  LIST_ITEM_MARKER_CONTAINER,
  LIST_ITEM_CHECKBOX,
  COLLAPSIBLE_LIST_ITEM_CLOSED,
  COLLAPSIBLE_LIST_ITEM_BUTTON,
  LIST_SPINE
});
var IS_EMPTY = "remirror-is-empty";
var extensionPlaceholderTheme = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  IS_EMPTY
});
var EDITOR$2 = "remirror-editor";
var POSITIONER = "remirror-positioner";
var POSITIONER_WIDGET = "remirror-positioner-widget";
var extensionPositionerTheme = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EDITOR: EDITOR$2,
  POSITIONER,
  POSITIONER_WIDGET
});
var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9;
var controllerSize = 12;
var markRadius = 2;
var TABLE_CONTROLLER_WRAPPER = "remirror-table-controller-wrapper";
var TABLE_CONTROLLER_TRIGGER_AREA = "remirror-table-controller-trigger-area";
var TABLE_CONTROLLER_MARK_ROW_CORNER = "remirror-table-controller-mark-row-corner";
var TABLE_CONTROLLER_MARK_COLUMN_CORNER = "remirror-table-controller-mark-column-corner";
(() => {
  var css = String.raw;
  var tableController = css(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    overflow: visible;\n    padding: 0;\n    cursor: pointer;\n    z-index: 15;\n    position: relative;\n  "])));
  var tableControllerTriggerArea = css(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n    flex: 1;\n    position: relative;\n    z-index: 10;\n\n    /* Style for debug. Use linear-gradient as background so that we can differentiate two neighbor areas. */\n    /* background: linear-gradient(to left top, rgba(0, 255, 100, 0.2), rgba(200, 100, 255, 0.2)); */\n  "])));
  var tableControllerWrapper = css(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n    overflow: visible;\n    display: flex;\n    justify-content: flex-end;\n    align-items: flex-end;\n  "])));
  var tableControllerMark = css(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n    position: absolute;\n    width: 0px;\n    height: 0px;\n    border-radius: 50%;\n    border-style: solid;\n    border-color: ", ";\n    border-width: ", "px;\n  "])), getThemeVar("color", "table", "mark"), markRadius);
  var tableControllerMarkRowCorner = css(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n    bottom: -", "px;\n    left: -12px;\n\n    ", "\n  "])), markRadius, tableControllerMark);
  var tableControllerMarkColumnCorner = css(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n    ", "\n\n    right: -", "px;\n    top: -12px;\n  "])), tableControllerMark, markRadius);
  var tableCornerController = css(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["\n    ", "\n\n    height: ", "px;\n    width: ", "px;\n\n    & div.", " {\n      ", "\n\n      width: ", "px;\n      height: ", "px;\n    }\n\n    & div.", " {\n      ", "\n\n      display: none;\n    }\n\n    & div.", " {\n      ", "\n    }\n    & div.", " {\n      ", "\n    }\n  "])), tableController, controllerSize, controllerSize, TABLE_CONTROLLER_WRAPPER, tableControllerWrapper, controllerSize, controllerSize, TABLE_CONTROLLER_TRIGGER_AREA, tableControllerTriggerArea, TABLE_CONTROLLER_MARK_ROW_CORNER, tableControllerMarkRowCorner, TABLE_CONTROLLER_MARK_COLUMN_CORNER, tableControllerMarkColumnCorner);
  var tableColumnController = css(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["\n    ", "\n\n    height: ", "px;\n\n    & div.", " {\n      ", "\n\n      width: 100%;\n      height: ", "px;\n      flex-direction: row;\n    }\n\n    & div.", " {\n      ", "\n\n      height: 36px;\n    }\n\n    & div.", " {\n      display: none;\n    }\n    & div.", " {\n      ", "\n    }\n  "])), tableController, controllerSize, TABLE_CONTROLLER_WRAPPER, tableControllerWrapper, controllerSize, TABLE_CONTROLLER_TRIGGER_AREA, tableControllerTriggerArea, TABLE_CONTROLLER_MARK_ROW_CORNER, TABLE_CONTROLLER_MARK_COLUMN_CORNER, tableControllerMarkColumnCorner);
  var tableRowController = css(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["\n    ", "\n\n    width: ", "px;\n\n    & div.", " {\n      ", "\n\n      height: 100%;\n      width: ", "px;\n      flex-direction: column;\n    }\n\n    & div.", " {\n      ", "\n\n      width: 36px;\n    }\n\n    & div.", " {\n      ", "\n    }\n    & div.", " {\n      display: none;\n    }\n  "])), tableController, controllerSize, TABLE_CONTROLLER_WRAPPER, tableControllerWrapper, controllerSize, TABLE_CONTROLLER_TRIGGER_AREA, tableControllerTriggerArea, TABLE_CONTROLLER_MARK_ROW_CORNER, tableControllerMarkRowCorner, TABLE_CONTROLLER_MARK_COLUMN_CORNER);
  return {
    tableCornerController,
    tableColumnController,
    tableRowController
  };
})();
var THEME = "remirror-theme";
function _checkPrivateRedeclaration$2(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec$2(obj, privateMap, value) {
  _checkPrivateRedeclaration$2(obj, privateMap);
  privateMap.set(obj, value);
}
var _handler = /* @__PURE__ */ new WeakMap();
var _active = /* @__PURE__ */ new WeakMap();
var _props = /* @__PURE__ */ new WeakMap();
var _ids = /* @__PURE__ */ new WeakMap();
var _updated = /* @__PURE__ */ new WeakMap();
var _constructorProps = /* @__PURE__ */ new WeakMap();
var _getActive = /* @__PURE__ */ new WeakMap();
var _getID = /* @__PURE__ */ new WeakMap();
var _getPosition = /* @__PURE__ */ new WeakMap();
class Positioner {
  static create(props) {
    return new Positioner(props);
  }
  static fromPositioner(positioner, base2) {
    return Positioner.create(_objectSpread2$3(_objectSpread2$3({}, positioner.basePositioner), base2));
  }
  get basePositioner() {
    return {
      getActive: _classPrivateFieldGet(this, _getActive),
      getPosition: _classPrivateFieldGet(this, _getPosition),
      hasChanged: this.hasChanged,
      events: this.events,
      getID: _classPrivateFieldGet(this, _getID)
    };
  }
  constructor(props) {
    var _props$events;
    _classPrivateFieldInitSpec$2(this, _handler, {
      writable: true,
      value: createNanoEvents()
    });
    _classPrivateFieldInitSpec$2(this, _active, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec$2(this, _props, {
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    _classPrivateFieldInitSpec$2(this, _ids, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec$2(this, _updated, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec$2(this, _constructorProps, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$2(this, _getActive, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$2(this, _getID, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$2(this, _getPosition, {
      writable: true,
      value: void 0
    });
    _defineProperty$3(this, "addListener", (event, cb) => {
      return _classPrivateFieldGet(this, _handler).on(event, cb);
    });
    _classPrivateFieldSet(this, _constructorProps, props);
    _classPrivateFieldSet(this, _getActive, props.getActive);
    _classPrivateFieldSet(this, _getPosition, props.getPosition);
    _classPrivateFieldSet(this, _getID, props.getID);
    this.hasChanged = props.hasChanged;
    this.events = (_props$events = props.events) !== null && _props$events !== void 0 ? _props$events : ["state", "scroll"];
  }
  onActiveChanged(props) {
    var _this = this;
    this.recentUpdate = props;
    var active = _classPrivateFieldGet(this, _getActive).call(this, props);
    _classPrivateFieldSet(this, _active, active);
    _classPrivateFieldSet(this, _props, /* @__PURE__ */ new Map());
    _classPrivateFieldSet(this, _updated, false);
    _classPrivateFieldSet(this, _ids, []);
    var elementSetters = [];
    var _iterator = _createForOfIteratorHelper(active.entries()), _step;
    try {
      var _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), index3 = _step$value[0], data = _step$value[1];
        var id = _this.getID(data, index3);
        _classPrivateFieldGet(_this, _ids).push(id);
        elementSetters.push({
          setElement: (element) => {
            return _this.addProps(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
              data,
              element
            }), index3);
          },
          id
        });
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    _classPrivateFieldGet(this, _handler).emit("update", elementSetters);
  }
  getID(data, index3) {
    var _classPrivateFieldGet2, _classPrivateFieldGet3;
    return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _getID)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.call(this, data, index3)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : index3.toString();
  }
  addProps(props, index3) {
    if (_classPrivateFieldGet(this, _updated)) {
      return;
    }
    _classPrivateFieldGet(this, _props).set(index3, props);
    if (_classPrivateFieldGet(this, _props).size < _classPrivateFieldGet(this, _active).length) {
      return;
    }
    var doneProps = [];
    var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _active).keys()), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _index = _step2.value;
        var item = _classPrivateFieldGet(this, _props).get(_index);
        !item ? true ? invariant(false, {
          code: ErrorConstant.INTERNAL,
          message: "Something went wrong when retrieving the parameters"
        }) : invariant(false) : void 0;
        var id = _classPrivateFieldGet(this, _ids)[_index];
        if (!id) {
          return;
        }
        doneProps.push({
          position: _classPrivateFieldGet(this, _getPosition).call(this, item),
          element: item.element,
          id
        });
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
    _classPrivateFieldGet(this, _handler).emit("done", doneProps);
  }
  clone(props) {
    return Positioner.create(_objectSpread2$3(_objectSpread2$3({}, _classPrivateFieldGet(this, _constructorProps)), isFunction$1(props) ? props(_classPrivateFieldGet(this, _constructorProps)) : props));
  }
  active(isActive) {
    var filterFunction = isFunction$1(isActive) ? isActive : () => isActive;
    return this.clone((original) => ({
      getActive: (props) => original.getActive(props).filter(filterFunction)
    }));
  }
}
_defineProperty$3(Positioner, "EMPTY", []);
function isPositionerUpdateTransaction(tr) {
  var _tr$getMeta;
  var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : POSITIONER_UPDATE_ALL;
  var _ref = (_tr$getMeta = tr === null || tr === void 0 ? void 0 : tr.getMeta(POSITIONER_UPDATE_KEY)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : {}, trKey = _ref.key;
  return trKey === key;
}
function hasStateChanged(props) {
  var tr = props.tr, state = props.state, previousState = props.previousState;
  if (!previousState) {
    return true;
  }
  if (tr && isPositionerUpdateTransaction(tr)) {
    return true;
  }
  if (tr) {
    return hasTransactionChanged(tr);
  }
  return !state.doc.eq(previousState.doc) || !state.selection.eq(previousState.selection);
}
function isPositionVisible(rect, element) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var elementRect = element.getBoundingClientRect();
  var _options$accountForPa = options.accountForPadding, accountForPadding = _options$accountForPa === void 0 ? false : _options$accountForPa;
  var leftDelta = 0;
  var rightDelta = 0;
  var topDelta = 0;
  var bottomDelta = 0;
  if (isElementDomNode(element) && accountForPadding) {
    var paddingLeft = Number.parseFloat(getStyle(element, "padding-left").replace("px", ""));
    var paddingRight = Number.parseFloat(getStyle(element, "padding-right").replace("px", ""));
    var paddingTop = Number.parseFloat(getStyle(element, "padding-top").replace("px", ""));
    var paddingBottom = Number.parseFloat(getStyle(element, "padding-bottom").replace("px", ""));
    var borderLeft = Number.parseFloat(getStyle(element, "border-left").replace("px", ""));
    var borderRight = Number.parseFloat(getStyle(element, "border-right").replace("px", ""));
    var borderTop = Number.parseFloat(getStyle(element, "border-top").replace("px", ""));
    var borderBottom = Number.parseFloat(getStyle(element, "border-bottom").replace("px", ""));
    var verticalScrollBarWidth = element.offsetWidth - element.clientWidth;
    var horizontalScrollBarHeight = element.offsetHeight - element.clientHeight;
    leftDelta += paddingLeft + borderLeft + (element.dir === "rtl" ? verticalScrollBarWidth : 0);
    rightDelta += paddingRight + borderRight + (element.dir === "rtl" ? 0 : verticalScrollBarWidth);
    topDelta += paddingTop + borderTop;
    bottomDelta += paddingBottom + borderBottom + horizontalScrollBarHeight;
  }
  var containerRect = new DOMRect(elementRect.left + leftDelta, elementRect.top + topDelta, elementRect.width - rightDelta, elementRect.height - bottomDelta);
  var _iterator = _createForOfIteratorHelper([[rect.top, rect.left], [rect.top, rect.right], [rect.bottom, rect.left], [rect.bottom, rect.right]]), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _slicedToArray(_step.value, 2), top2 = _step$value[0], left2 = _step$value[1];
      if (within$1(top2, containerRect.top, containerRect.bottom) && within$1(left2, containerRect.left, containerRect.right)) {
        return true;
      }
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  return false;
}
var POSITIONER_WIDGET_KEY = "remirror-positioner-widget";
var POSITIONER_UPDATE_KEY = "positionerUpdate";
var POSITIONER_UPDATE_ALL = "__all_positioners__";
var basePosition = {
  y: -999999,
  x: -999999,
  width: 0,
  height: 0
};
var baseRect = _objectSpread2$3(_objectSpread2$3({}, basePosition), {}, {
  left: -999999,
  top: -999999,
  bottom: -999999,
  right: -999999
});
var defaultAbsolutePosition = _objectSpread2$3(_objectSpread2$3({}, basePosition), {}, {
  rect: _objectSpread2$3(_objectSpread2$3({}, baseRect), {}, {
    toJSON: () => baseRect
  }),
  visible: false
});
var blockNodePositioner = Positioner.create({
  hasChanged: hasStateChanged,
  getActive(props) {
    var state = props.state;
    if (!isSelectionEmpty(state) || state.selection.$anchor.depth > 2) {
      return Positioner.EMPTY;
    }
    var parentNode2 = findParentNode({
      predicate: (node4) => node4.type.isBlock,
      selection: state
    });
    return parentNode2 ? [parentNode2] : Positioner.EMPTY;
  },
  getPosition(props) {
    var view = props.view, data = props.data;
    var node4 = view.nodeDOM(data.pos);
    if (!isElementDomNode(node4)) {
      return defaultAbsolutePosition;
    }
    var rect = node4.getBoundingClientRect();
    var editorRect = view.dom.getBoundingClientRect();
    var height = rect.height;
    var width = rect.width;
    var left2 = view.dom.scrollLeft + rect.left - editorRect.left;
    var top2 = view.dom.scrollTop + rect.top - editorRect.top;
    var visible = isPositionVisible(rect, view.dom);
    return {
      y: top2,
      x: left2,
      height,
      width,
      rect,
      visible
    };
  }
});
var emptyBlockNodePositioner = blockNodePositioner.clone((_ref) => {
  var _getActive2 = _ref.getActive;
  return {
    getActive: (props) => {
      var _getActive22 = _getActive2(props), _getActive3 = _slicedToArray(_getActive22, 1), parentNode2 = _getActive3[0];
      return parentNode2 && isEmptyBlockNode(parentNode2.node) && parentNode2.node.type === getDefaultBlockNode(props.state.schema) ? [parentNode2] : Positioner.EMPTY;
    }
  };
});
var emptyBlockNodeStartPositioner = emptyBlockNodePositioner.clone((_ref2) => {
  var _getPosition2 = _ref2.getPosition;
  return {
    getPosition: (props) => _objectSpread2$3(_objectSpread2$3({}, _getPosition2(props)), {}, {
      width: 1
    })
  };
});
var emptyBlockNodeEndPositioner = emptyBlockNodePositioner.clone((_ref3) => {
  var _getPosition2 = _ref3.getPosition;
  return {
    getPosition: (props) => {
      var _getPosition3 = _getPosition2(props), width = _getPosition3.width, left2 = _getPosition3.x, top2 = _getPosition3.y, height = _getPosition3.height;
      return _objectSpread2$3(_objectSpread2$3({}, _getPosition2(props)), {}, {
        width: 1,
        x: width + left2,
        rect: new DOMRect(width + left2, top2, 1, height)
      });
    }
  };
});
function createSelectionPositioner(isActive) {
  return Positioner.create({
    hasChanged: hasStateChanged,
    getActive: (props) => {
      var state = props.state, view = props.view;
      if (!isActive(state) || !isTextSelection(state.selection)) {
        return Positioner.EMPTY;
      }
      try {
        var _state$selection = state.selection, head = _state$selection.head, anchor = _state$selection.anchor;
        return [{
          from: view.coordsAtPos(anchor),
          to: view.coordsAtPos(head)
        }];
      } catch (_unused) {
        return Positioner.EMPTY;
      }
    },
    getPosition(props) {
      var _element$offsetParent;
      var element = props.element, data = props.data, view = props.view;
      var from4 = data.from, to = data.to;
      var parent = (_element$offsetParent = element.offsetParent) !== null && _element$offsetParent !== void 0 ? _element$offsetParent : view.dom;
      var parentRect = parent.getBoundingClientRect();
      var height = Math.abs(to.bottom - from4.top);
      var spansMultipleLines = height > from4.bottom - from4.top;
      var leftmost = Math.min(from4.left, to.left);
      var topmost = Math.min(from4.top, to.top);
      var left2 = parent.scrollLeft + (spansMultipleLines ? to.left - parentRect.left : leftmost - parentRect.left);
      var top2 = parent.scrollTop + topmost - parentRect.top;
      var width = spansMultipleLines ? 1 : Math.abs(from4.left - to.right);
      var rect = new DOMRect(spansMultipleLines ? to.left : leftmost, topmost, width, height);
      var visible = isPositionVisible(rect, view.dom);
      return {
        rect,
        y: top2,
        x: left2,
        height,
        width,
        visible
      };
    }
  });
}
var selectionPositioner = createSelectionPositioner((state) => !state.selection.empty);
var cursorPositioner = createSelectionPositioner((state) => state.selection.empty);
var alwaysPositioner = createSelectionPositioner(() => true);
var nearestWordPositioner = selectionPositioner.clone(() => ({
  getActive: (props) => {
    var state = props.state, view = props.view;
    if (!state.selection.empty) {
      return Positioner.EMPTY;
    }
    var word = getSelectedWord(state);
    if (!word) {
      return Positioner.EMPTY;
    }
    try {
      return [{
        from: view.coordsAtPos(word.from),
        to: view.coordsAtPos(word.to)
      }];
    } catch (_unused2) {
      return Positioner.EMPTY;
    }
  }
}));
var _dec$k, _dec2$f, _dec3$9, _class$k, _class2$d;
var PositionerExtension = (_dec$k = extension({
  defaultOptions: {
    scrollDebounce: 100
  },
  customHandlerKeys: ["positioner"],
  staticKeys: ["scrollDebounce"]
}), _dec2$f = command(), _dec3$9 = helper(), _dec$k(_class$k = (_class2$d = class PositionerExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "positioners", []);
    _defineProperty$3(this, "onAddCustomHandler", (_ref) => {
      var positioner = _ref.positioner;
      if (!positioner) {
        return;
      }
      this.positioners = [...this.positioners, positioner];
      this.store.commands.forceUpdate();
      return () => {
        this.positioners = this.positioners.filter((handler) => handler !== positioner);
      };
    });
  }
  get name() {
    return "positioner";
  }
  createAttributes() {
    return {
      class: extensionPositionerTheme.EDITOR
    };
  }
  init() {
    this.onScroll = debounce$1(this.options.scrollDebounce, this.onScroll.bind(this));
  }
  createEventHandlers() {
    return {
      scroll: () => {
        this.onScroll();
        return false;
      },
      hover: (_hover) => {
        this.positioner(this.getBaseProps("hover", {
          hover: _hover
        }));
        return false;
      },
      contextmenu: (_contextmenu) => {
        this.positioner(this.getBaseProps("contextmenu", {
          contextmenu: _contextmenu
        }));
        return false;
      }
    };
  }
  onStateUpdate(update2) {
    this.positioner(_objectSpread2$3(_objectSpread2$3({}, update2), {}, {
      previousState: update2.firstUpdate ? void 0 : update2.previousState,
      event: "state",
      helpers: this.store.helpers
    }));
  }
  createDecorations(state) {
    var _this$element;
    (_this$element = this.element) !== null && _this$element !== void 0 ? _this$element : this.element = this.createElement();
    if (!this.element.hasChildNodes()) {
      return DecorationSet.empty;
    }
    var decoration = Decoration.widget(0, this.element, {
      key: "positioner-widget",
      side: -1,
      stopEvent: () => true
    });
    return DecorationSet.create(state.doc, [decoration]);
  }
  forceUpdatePositioners() {
    var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : POSITIONER_UPDATE_ALL;
    return (_ref2) => {
      var tr = _ref2.tr, dispatch2 = _ref2.dispatch;
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.setMeta(POSITIONER_UPDATE_KEY, {
        key
      }));
      return true;
    };
  }
  getPositionerWidget() {
    var _this$element2;
    return (_this$element2 = this.element) !== null && _this$element2 !== void 0 ? _this$element2 : this.element = this.createElement();
  }
  createElement() {
    var element = document.createElement("span");
    element.dataset.id = POSITIONER_WIDGET_KEY;
    element.setAttribute("role", "presentation");
    return element;
  }
  triggerPositioner(positioner, update2) {
    if (!positioner.hasChanged(update2)) {
      return;
    }
    positioner.onActiveChanged(_objectSpread2$3(_objectSpread2$3({}, update2), {}, {
      view: this.store.view
    }));
  }
  positioner(update2) {
    var _iterator = _createForOfIteratorHelper(this.positioners), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var positioner = _step.value;
        var eventIsNotSupported = !positioner.events.includes(update2.event);
        if (eventIsNotSupported) {
          continue;
        }
        this.triggerPositioner(positioner, update2);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
  }
  getBaseProps(event, extra) {
    var state = this.store.getState();
    var previousState = this.store.previousState;
    return _objectSpread2$3({
      helpers: this.store.helpers,
      event,
      firstUpdate: false,
      previousState,
      state
    }, extra);
  }
  onScroll() {
    this.positioner(this.getBaseProps("scroll", {
      scroll: {
        scrollTop: this.store.view.dom.scrollTop
      }
    }));
  }
}, _applyDecoratedDescriptor(_class2$d.prototype, "forceUpdatePositioners", [_dec2$f], Object.getOwnPropertyDescriptor(_class2$d.prototype, "forceUpdatePositioners"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "getPositionerWidget", [_dec3$9], Object.getOwnPropertyDescriptor(_class2$d.prototype, "getPositionerWidget"), _class2$d.prototype), _class2$d)) || _class$k);
var positioners = {
  selection: selectionPositioner,
  cursor: cursorPositioner,
  always: alwaysPositioner,
  block: blockNodePositioner,
  emptyBlock: emptyBlockNodePositioner,
  emptyBlockStart: emptyBlockNodeStartPositioner,
  emptyBlockEnd: emptyBlockNodeEndPositioner,
  nearestWord: nearestWordPositioner
};
function getPositioner(positioner) {
  if (isString$1(positioner)) {
    return positioners[positioner].clone();
  }
  if (isFunction$1(positioner)) {
    return positioner().clone();
  }
  return positioner.clone();
}
var _dec$j, _dec2$e, _class$j, _class2$c;
var DocExtension = (_dec$j = extension({
  defaultOptions: {
    content: "block+",
    docAttributes: []
  },
  defaultPriority: ExtensionPriority.Medium,
  staticKeys: ["content", "docAttributes"],
  disableExtraAttributes: true
}), _dec2$e = command(), _dec$j(_class$j = (_class2$c = class DocExtension2 extends NodeExtension {
  get name() {
    return "doc";
  }
  createNodeSpec(_2, override) {
    var _this$options = this.options, docAttributes = _this$options.docAttributes, content2 = _this$options.content;
    var attrs = object();
    if (isPlainObject$1(docAttributes)) {
      var _iterator = _createForOfIteratorHelper(entries(docAttributes)), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1];
          attrs[key] = {
            default: value
          };
        }
      } catch (err2) {
        _iterator.e(err2);
      } finally {
        _iterator.f();
      }
    } else {
      var _iterator2 = _createForOfIteratorHelper(docAttributes), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _key = _step2.value;
          attrs[_key] = {
            default: null
          };
        }
      } catch (err2) {
        _iterator2.e(err2);
      } finally {
        _iterator2.f();
      }
    }
    return _objectSpread2$3({
      attrs,
      content: content2
    }, override);
  }
  setDocAttributes(attrs) {
    return (_ref) => {
      var tr = _ref.tr, dispatch2 = _ref.dispatch;
      if (dispatch2) {
        for (var _i = 0, _Object$entries = Object.entries(attrs); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
          tr.step(new SetDocAttributeStep(key, value));
        }
        dispatch2(tr);
      }
      return true;
    };
  }
}, _applyDecoratedDescriptor(_class2$c.prototype, "setDocAttributes", [_dec2$e], Object.getOwnPropertyDescriptor(_class2$c.prototype, "setDocAttributes"), _class2$c.prototype), _class2$c)) || _class$j);
var STEP_TYPE = "SetDocAttribute";
var REVERT_STEP_TYPE = "RevertSetDocAttribute";
class SetDocAttributeStep extends Step {
  static fromJSON(_2, json) {
    return new SetDocAttributeStep(json.key, json.value, json.stepType);
  }
  constructor(key, value) {
    var stepType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : STEP_TYPE;
    super();
    this.stepType = stepType;
    this.key = key;
    this.value = value;
  }
  apply(doc2) {
    this.previous = doc2.attrs[this.key];
    var attrs = _objectSpread2$3(_objectSpread2$3({}, doc2.attrs), {}, {
      [this.key]: this.value
    });
    return StepResult.ok(doc2.type.create(attrs, doc2.content, doc2.marks));
  }
  invert() {
    return new SetDocAttributeStep(this.key, this.previous, REVERT_STEP_TYPE);
  }
  map() {
    return this;
  }
  toJSON() {
    return {
      stepType: this.stepType,
      key: this.key,
      value: this.value
    };
  }
}
try {
  Step.jsonID(STEP_TYPE, SetDocAttributeStep);
  Step.jsonID(REVERT_STEP_TYPE, SetDocAttributeStep);
} catch (error) {
  if (!error.message.startsWith("Duplicate use of step JSON ID")) {
    throw error;
  }
}
function posAtDOM2(view, node4, offset3, bias) {
  return view.docView.posFromDOM(node4, offset3, bias);
}
function getPositionFromEvent(view, event) {
  var _view$posAtCoords;
  var target = event.target;
  if (target) {
    var pos = posAtDOM2(view, target, 0);
    if (pos !== null) {
      var $pos = view.state.doc.resolve(pos);
      var border2 = $pos.node().isLeaf ? 0 : 1;
      var inside = $pos.start() - border2;
      return {
        pos,
        inside
      };
    }
  }
  return (_view$posAtCoords = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  })) !== null && _view$posAtCoords !== void 0 ? _view$posAtCoords : void 0;
}
var _dec$i, _dec2$d, _class$i, _class2$b;
var EventsExtension = (_dec$i = extension({
  handlerKeys: ["blur", "focus", "mousedown", "mouseup", "mouseenter", "mouseleave", "textInput", "keypress", "keyup", "keydown", "click", "clickMark", "contextmenu", "hover", "scroll", "copy", "paste"],
  handlerKeyOptions: {
    blur: {
      earlyReturnValue: true
    },
    focus: {
      earlyReturnValue: true
    },
    mousedown: {
      earlyReturnValue: true
    },
    mouseleave: {
      earlyReturnValue: true
    },
    mouseup: {
      earlyReturnValue: true
    },
    click: {
      earlyReturnValue: true
    },
    hover: {
      earlyReturnValue: true
    },
    contextmenu: {
      earlyReturnValue: true
    },
    scroll: {
      earlyReturnValue: true
    },
    copy: {
      earlyReturnValue: true
    },
    paste: {
      earlyReturnValue: true
    }
  },
  defaultPriority: ExtensionPriority.High
}), _dec2$d = helper(), _dec$i(_class$i = (_class2$b = class EventsExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "mousedown", false);
    _defineProperty$3(this, "mouseover", false);
    _defineProperty$3(this, "createMouseEventHandler", (fn2) => {
      return (view, event) => {
        var eventPosition = getPositionFromEvent(view, event);
        if (!eventPosition) {
          return false;
        }
        var nodes = [];
        var marks2 = [];
        var inside = eventPosition.inside;
        if (inside === -1) {
          return false;
        }
        var $pos = view.state.doc.resolve(inside);
        var currentNodeDepth = $pos.depth + 1;
        var _iterator = _createForOfIteratorHelper(range(currentNodeDepth, 1)), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var index3 = _step.value;
            nodes.push({
              node: index3 > $pos.depth && $pos.nodeAfter ? $pos.nodeAfter : $pos.node(index3),
              pos: $pos.before(index3)
            });
          }
        } catch (err2) {
          _iterator.e(err2);
        } finally {
          _iterator.f();
        }
        var _iterator2 = _createForOfIteratorHelper($pos.marks()), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var type2 = _step2.value.type;
            var _range = getMarkRange($pos, type2);
            if (_range) {
              marks2.push(_range);
            }
          }
        } catch (err2) {
          _iterator2.e(err2);
        } finally {
          _iterator2.f();
        }
        return fn2({
          event,
          view,
          nodes,
          marks: marks2,
          getMark: (markType) => {
            var type3 = isString$1(markType) ? view.state.schema.marks[markType] : markType;
            !type3 ? invariant(false, {
              code: ErrorConstant.EXTENSION,
              message: "The mark ".concat(markType, " being checked does not exist within the editor schema.")
            }) : void 0;
            return marks2.find((range2) => range2.mark.type === type3);
          },
          getNode: (nodeType2) => {
            var _nodes$;
            var type3 = isString$1(nodeType2) ? view.state.schema.nodes[nodeType2] : nodeType2;
            !type3 ? invariant(false, {
              code: ErrorConstant.EXTENSION,
              message: "The node being checked does not exist"
            }) : void 0;
            var nodeWithPos = nodes.find((_ref) => {
              var node4 = _ref.node;
              return node4.type === type3;
            });
            if (!nodeWithPos) {
              return;
            }
            return _objectSpread2$3(_objectSpread2$3({}, nodeWithPos), {}, {
              isRoot: !!((_nodes$ = nodes[0]) !== null && _nodes$ !== void 0 && _nodes$.node.eq(nodeWithPos.node))
            });
          }
        });
      };
    });
  }
  get name() {
    return "events";
  }
  onView() {
    var _this$store$managerSe;
    if ((_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.clickHandler) {
      return;
    }
    var _iterator3 = _createForOfIteratorHelper(this.store.extensions), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var _extension$options$ex;
        var _extension = _step3.value;
        if (!_extension.createEventHandlers || (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.clickHandler) {
          continue;
        }
        var eventHandlers = _extension.createEventHandlers();
        var _iterator4 = _createForOfIteratorHelper(entries(eventHandlers)), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var _step4$value = _slicedToArray(_step4.value, 2), key = _step4$value[0], handler = _step4$value[1];
            this.addHandler(key, handler);
          }
        } catch (err2) {
          _iterator4.e(err2);
        } finally {
          _iterator4.f();
        }
      }
    } catch (err2) {
      _iterator3.e(err2);
    } finally {
      _iterator3.f();
    }
  }
  createPlugin() {
    var eventMap = /* @__PURE__ */ new WeakMap();
    return {
      props: {
        handleKeyPress: (_2, event) => {
          return this.options.keypress(event) || false;
        },
        handleKeyDown: (_2, event) => {
          return this.options.keydown(event) || false;
        },
        handleTextInput: (_2, from4, to, text3) => {
          return this.options.textInput({
            from: from4,
            to,
            text: text3
          }) || false;
        },
        handleClickOn: (view, pos, node4, nodePos, event, direct) => {
          var state = this.store.currentState;
          var schema = state.schema, doc2 = state.doc;
          var $pos = doc2.resolve(pos);
          var handled = eventMap.has(event);
          var baseState = createClickMarkState({
            $pos,
            handled,
            view,
            state
          });
          var returnValue = false;
          if (!handled) {
            returnValue = this.options.clickMark(event, baseState) || returnValue;
          }
          var clickState = _objectSpread2$3(_objectSpread2$3({}, baseState), {}, {
            pos,
            direct,
            nodeWithPosition: {
              node: node4,
              pos: nodePos
            },
            getNode: (nodeType2) => {
              var type2 = isString$1(nodeType2) ? schema.nodes[nodeType2] : nodeType2;
              !type2 ? invariant(false, {
                code: ErrorConstant.EXTENSION,
                message: "The node being checked does not exist"
              }) : void 0;
              return type2 === node4.type ? {
                node: node4,
                pos: nodePos
              } : void 0;
            }
          });
          eventMap.set(event, true);
          return this.options.click(event, clickState) || returnValue;
        },
        handleDOMEvents: {
          focus: (_2, event) => {
            return this.options.focus(event) || false;
          },
          blur: (_2, event) => {
            return this.options.blur(event) || false;
          },
          mousedown: (_2, event) => {
            this.startMouseover();
            return this.options.mousedown(event) || false;
          },
          mouseup: (_2, event) => {
            this.endMouseover();
            return this.options.mouseup(event) || false;
          },
          mouseleave: (_2, event) => {
            this.mouseover = false;
            return this.options.mouseleave(event) || false;
          },
          mouseenter: (_2, event) => {
            this.mouseover = true;
            return this.options.mouseenter(event) || false;
          },
          keyup: (_2, event) => {
            return this.options.keyup(event) || false;
          },
          mouseout: this.createMouseEventHandler((props) => this.options.hover(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
            hovering: false
          })) || false),
          mouseover: this.createMouseEventHandler((props) => this.options.hover(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
            hovering: true
          })) || false),
          contextmenu: this.createMouseEventHandler((props) => this.options.contextmenu(props) || false),
          scroll: (_2, event) => {
            return this.options.scroll(event) || false;
          },
          copy: (_2, event) => {
            return this.options.copy(event) || false;
          },
          paste: (_2, event) => {
            return this.options.paste(event) || false;
          }
        }
      }
    };
  }
  isInteracting() {
    return this.mousedown && this.mouseover;
  }
  startMouseover() {
    this.mouseover = true;
    if (this.mousedown) {
      return;
    }
    this.mousedown = true;
    this.store.document.documentElement.addEventListener("mouseup", () => {
      this.endMouseover();
    }, {
      once: true
    });
  }
  endMouseover() {
    if (!this.mousedown) {
      return;
    }
    this.mousedown = false;
    this.store.commands.emptyUpdate();
  }
}, _applyDecoratedDescriptor(_class2$b.prototype, "isInteracting", [_dec2$d], Object.getOwnPropertyDescriptor(_class2$b.prototype, "isInteracting"), _class2$b.prototype), _class2$b)) || _class$i);
function createClickMarkState(props) {
  var handled = props.handled, view = props.view, $pos = props.$pos, state = props.state;
  var clickState = {
    getMark: noop$1,
    markRanges: [],
    view,
    state
  };
  if (handled) {
    return clickState;
  }
  var _iterator5 = _createForOfIteratorHelper($pos.marks()), _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
      var type2 = _step5.value.type;
      var _range2 = getMarkRange($pos, type2);
      if (_range2) {
        clickState.markRanges.push(_range2);
      }
    }
  } catch (err2) {
    _iterator5.e(err2);
  } finally {
    _iterator5.f();
  }
  clickState.getMark = (markType) => {
    var type3 = isString$1(markType) ? state.schema.marks[markType] : markType;
    !type3 ? invariant(false, {
      code: ErrorConstant.EXTENSION,
      message: "The mark ".concat(markType, " being checked does not exist within the editor schema.")
    }) : void 0;
    return clickState.markRanges.find((range2) => range2.mark.type === type3);
  };
  return clickState;
}
var GapCursor = /* @__PURE__ */ function(Selection3) {
  function GapCursor2($pos) {
    Selection3.call(this, $pos, $pos);
  }
  if (Selection3)
    GapCursor2.__proto__ = Selection3;
  GapCursor2.prototype = Object.create(Selection3 && Selection3.prototype);
  GapCursor2.prototype.constructor = GapCursor2;
  GapCursor2.prototype.map = function map16(doc2, mapping) {
    var $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor2.valid($pos) ? new GapCursor2($pos) : Selection3.near($pos);
  };
  GapCursor2.prototype.content = function content2() {
    return Slice.empty;
  };
  GapCursor2.prototype.eq = function eq12(other) {
    return other instanceof GapCursor2 && other.head == this.head;
  };
  GapCursor2.prototype.toJSON = function toJSON7() {
    return { type: "gapcursor", pos: this.head };
  };
  GapCursor2.fromJSON = function fromJSON8(doc2, json) {
    if (typeof json.pos != "number") {
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    }
    return new GapCursor2(doc2.resolve(json.pos));
  };
  GapCursor2.prototype.getBookmark = function getBookmark2() {
    return new GapBookmark(this.anchor);
  };
  GapCursor2.valid = function valid4($pos) {
    var parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) {
      return false;
    }
    var override = parent.type.spec.allowGapCursor;
    if (override != null) {
      return override;
    }
    var deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  };
  GapCursor2.findFrom = function findFrom2($pos, dir, mustMove) {
    search:
      for (; ; ) {
        if (!mustMove && GapCursor2.valid($pos)) {
          return $pos;
        }
        var pos = $pos.pos, next = null;
        for (var d2 = $pos.depth; ; d2--) {
          var parent = $pos.node(d2);
          if (dir > 0 ? $pos.indexAfter(d2) < parent.childCount : $pos.index(d2) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d2) : $pos.index(d2) - 1);
            break;
          } else if (d2 == 0) {
            return null;
          }
          pos += dir;
          var $cur = $pos.doc.resolve(pos);
          if (GapCursor2.valid($cur)) {
            return $cur;
          }
        }
        for (; ; ) {
          var inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          var $cur$1 = $pos.doc.resolve(pos);
          if (GapCursor2.valid($cur$1)) {
            return $cur$1;
          }
        }
        return null;
      }
  };
  return GapCursor2;
}(Selection);
GapCursor.prototype.visible = false;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = function GapBookmark2(pos) {
  this.pos = pos;
};
GapBookmark.prototype.map = function map13(mapping) {
  return new GapBookmark(mapping.map(this.pos));
};
GapBookmark.prototype.resolve = function resolve6(doc2) {
  var $pos = doc2.resolve(this.pos);
  return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
};
function closedBefore($pos) {
  for (var d2 = $pos.depth; d2 >= 0; d2--) {
    var index3 = $pos.index(d2), parent = $pos.node(d2);
    if (index3 == 0) {
      if (parent.type.spec.isolating) {
        return true;
      }
      continue;
    }
    for (var before2 = parent.child(index3 - 1); ; before2 = before2.lastChild) {
      if (before2.childCount == 0 && !before2.inlineContent || before2.isAtom || before2.type.spec.isolating) {
        return true;
      }
      if (before2.inlineContent) {
        return false;
      }
    }
  }
  return true;
}
function closedAfter($pos) {
  for (var d2 = $pos.depth; d2 >= 0; d2--) {
    var index3 = $pos.indexAfter(d2), parent = $pos.node(d2);
    if (index3 == parent.childCount) {
      if (parent.type.spec.isolating) {
        return true;
      }
      continue;
    }
    for (var after2 = parent.child(index3); ; after2 = after2.firstChild) {
      if (after2.childCount == 0 && !after2.inlineContent || after2.isAtom || after2.type.spec.isolating) {
        return true;
      }
      if (after2.inlineContent) {
        return false;
      }
    }
  }
  return true;
}
var gapCursor = function() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween: function createSelectionBetween(_view2, $anchor, $head) {
        if ($anchor.pos == $head.pos && GapCursor.valid($head)) {
          return new GapCursor($head);
        }
      },
      handleClick,
      handleKeyDown
    }
  });
};
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch2, view) {
    var sel = state.selection;
    var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0) {
        return false;
      }
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    var $found = GapCursor.findFrom($start, dir, mustMove);
    if (!$found) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.setSelection(new GapCursor($found)));
    }
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view.editable) {
    return false;
  }
  var $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos)) {
    return false;
  }
  var ref2 = view.posAtCoords({ left: event.clientX, top: event.clientY });
  var inside = ref2.inside;
  if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) {
    return false;
  }
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor)) {
    return null;
  }
  var node4 = document.createElement("div");
  node4.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node4, { key: "gapcursor" })]);
}
var _dec$h, _class$h;
var GapCursorExtension = (_dec$h = extension({}), _dec$h(_class$h = class GapCursorExtension2 extends PlainExtension {
  get name() {
    return "gapCursor";
  }
  createExternalPlugins() {
    return [gapCursor()];
  }
}) || _class$h);
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append2(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice3(from4, to) {
  if (from4 === void 0)
    from4 = 0;
  if (to === void 0)
    to = this.length;
  if (from4 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from4), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get3(i2) {
  if (i2 < 0 || i2 >= this.length) {
    return void 0;
  }
  return this.getInner(i2);
};
RopeSequence.prototype.forEach = function forEach4(f2, from4, to) {
  if (from4 === void 0)
    from4 = 0;
  if (to === void 0)
    to = this.length;
  if (from4 <= to) {
    this.forEachInner(f2, from4, to, 0);
  } else {
    this.forEachInvertedInner(f2, from4, to, 0);
  }
};
RopeSequence.prototype.map = function map14(f2, from4, to) {
  if (from4 === void 0)
    from4 = 0;
  if (to === void 0)
    to = this.length;
  var result2 = [];
  this.forEach(function(elt, i2) {
    return result2.push(f2(elt, i2));
  }, from4, to);
  return result2;
};
RopeSequence.from = function from3(values2) {
  if (values2 instanceof RopeSequence) {
    return values2;
  }
  return values2 && values2.length ? new Leaf(values2) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values2) {
    RopeSequence3.call(this);
    this.values = values2;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors2 = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten2() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from4, to) {
    if (from4 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from4, to));
  };
  Leaf2.prototype.getInner = function getInner(i2) {
    return this.values[i2];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f2, from4, to, start4) {
    for (var i2 = from4; i2 < to; i2++) {
      if (f2(this.values[i2], start4 + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from4, to, start4) {
    for (var i2 = from4 - 1; i2 >= to; i2--) {
      if (f2(this.values[i2], start4 + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors2.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors2.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors2);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten2() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i2) {
    return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f2, from4, to, start4) {
    var leftLen = this.left.length;
    if (from4 < leftLen && this.left.forEachInner(f2, from4, Math.min(to, leftLen), start4) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f2, Math.max(from4 - leftLen, 0), Math.min(this.length, to) - leftLen, start4 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from4, to, start4) {
    var leftLen = this.left.length;
    if (from4 > leftLen && this.right.forEachInvertedInner(f2, from4 - leftLen, Math.max(to, leftLen) - leftLen, start4 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f2, Math.min(from4, leftLen), to, start4) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from4, to) {
    if (from4 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from4, to);
    }
    if (from4 >= leftLen) {
      return this.right.slice(from4 - leftLen, to - leftLen);
    }
    return this.left.slice(from4, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var ropeSequence = RopeSequence;
var max_empty_items = 500;
var Branch = function Branch2(items, eventCount) {
  this.items = items;
  this.eventCount = eventCount;
};
Branch.prototype.popEvent = function popEvent(state, preserveItems) {
  var this$1$1 = this;
  if (this.eventCount == 0) {
    return null;
  }
  var end3 = this.items.length;
  for (; ; end3--) {
    var next = this.items.get(end3 - 1);
    if (next.selection) {
      --end3;
      break;
    }
  }
  var remap, mapFrom;
  if (preserveItems) {
    remap = this.remapping(end3, this.items.length);
    mapFrom = remap.maps.length;
  }
  var transform = state.tr;
  var selection, remaining;
  var addAfter = [], addBefore = [];
  this.items.forEach(function(item, i2) {
    if (!item.step) {
      if (!remap) {
        remap = this$1$1.remapping(end3, i2 + 1);
        mapFrom = remap.maps.length;
      }
      mapFrom--;
      addBefore.push(item);
      return;
    }
    if (remap) {
      addBefore.push(new Item(item.map));
      var step2 = item.step.map(remap.slice(mapFrom)), map16;
      if (step2 && transform.maybeStep(step2).doc) {
        map16 = transform.mapping.maps[transform.mapping.maps.length - 1];
        addAfter.push(new Item(map16, null, null, addAfter.length + addBefore.length));
      }
      mapFrom--;
      if (map16) {
        remap.appendMap(map16, mapFrom);
      }
    } else {
      transform.maybeStep(item.step);
    }
    if (item.selection) {
      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
      remaining = new Branch(this$1$1.items.slice(0, end3).append(addBefore.reverse().concat(addAfter)), this$1$1.eventCount - 1);
      return false;
    }
  }, this.items.length, 0);
  return { remaining, transform, selection };
};
Branch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
  var newItems = [], eventCount = this.eventCount;
  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
  for (var i2 = 0; i2 < transform.steps.length; i2++) {
    var step2 = transform.steps[i2].invert(transform.docs[i2]);
    var item = new Item(transform.mapping.maps[i2], step2, selection), merged = void 0;
    if (merged = lastItem && lastItem.merge(item)) {
      item = merged;
      if (i2) {
        newItems.pop();
      } else {
        oldItems = oldItems.slice(0, oldItems.length - 1);
      }
    }
    newItems.push(item);
    if (selection) {
      eventCount++;
      selection = null;
    }
    if (!preserveItems) {
      lastItem = item;
    }
  }
  var overflow = eventCount - histOptions.depth;
  if (overflow > DEPTH_OVERFLOW) {
    oldItems = cutOffEvents(oldItems, overflow);
    eventCount -= overflow;
  }
  return new Branch(oldItems.append(newItems), eventCount);
};
Branch.prototype.remapping = function remapping(from4, to) {
  var maps = new Mapping();
  this.items.forEach(function(item, i2) {
    var mirrorPos = item.mirrorOffset != null && i2 - item.mirrorOffset >= from4 ? maps.maps.length - item.mirrorOffset : null;
    maps.appendMap(item.map, mirrorPos);
  }, from4, to);
  return maps;
};
Branch.prototype.addMaps = function addMaps(array) {
  if (this.eventCount == 0) {
    return this;
  }
  return new Branch(this.items.append(array.map(function(map16) {
    return new Item(map16);
  })), this.eventCount);
};
Branch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {
  if (!this.eventCount) {
    return this;
  }
  var rebasedItems = [], start4 = Math.max(0, this.items.length - rebasedCount);
  var mapping = rebasedTransform.mapping;
  var newUntil = rebasedTransform.steps.length;
  var eventCount = this.eventCount;
  this.items.forEach(function(item) {
    if (item.selection) {
      eventCount--;
    }
  }, start4);
  var iRebased = rebasedCount;
  this.items.forEach(function(item) {
    var pos = mapping.getMirror(--iRebased);
    if (pos == null) {
      return;
    }
    newUntil = Math.min(newUntil, pos);
    var map16 = mapping.maps[pos];
    if (item.step) {
      var step2 = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
      var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
      if (selection) {
        eventCount++;
      }
      rebasedItems.push(new Item(map16, step2, selection));
    } else {
      rebasedItems.push(new Item(map16));
    }
  }, start4);
  var newMaps = [];
  for (var i2 = rebasedCount; i2 < newUntil; i2++) {
    newMaps.push(new Item(mapping.maps[i2]));
  }
  var items = this.items.slice(0, start4).append(newMaps).append(rebasedItems);
  var branch = new Branch(items, eventCount);
  if (branch.emptyItemCount() > max_empty_items) {
    branch = branch.compress(this.items.length - rebasedItems.length);
  }
  return branch;
};
Branch.prototype.emptyItemCount = function emptyItemCount() {
  var count = 0;
  this.items.forEach(function(item) {
    if (!item.step) {
      count++;
    }
  });
  return count;
};
Branch.prototype.compress = function compress(upto) {
  if (upto === void 0)
    upto = this.items.length;
  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
  var items = [], events2 = 0;
  this.items.forEach(function(item, i2) {
    if (i2 >= upto) {
      items.push(item);
      if (item.selection) {
        events2++;
      }
    } else if (item.step) {
      var step2 = item.step.map(remap.slice(mapFrom)), map16 = step2 && step2.getMap();
      mapFrom--;
      if (map16) {
        remap.appendMap(map16, mapFrom);
      }
      if (step2) {
        var selection = item.selection && item.selection.map(remap.slice(mapFrom));
        if (selection) {
          events2++;
        }
        var newItem = new Item(map16.invert(), step2, selection), merged, last = items.length - 1;
        if (merged = items.length && items[last].merge(newItem)) {
          items[last] = merged;
        } else {
          items.push(newItem);
        }
      }
    } else if (item.map) {
      mapFrom--;
    }
  }, this.items.length, 0);
  return new Branch(ropeSequence.from(items.reverse()), events2);
};
Branch.empty = new Branch(ropeSequence.empty, 0);
function cutOffEvents(items, n2) {
  var cutPoint;
  items.forEach(function(item, i2) {
    if (item.selection && n2-- == 0) {
      cutPoint = i2;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = function Item2(map16, step2, selection, mirrorOffset) {
  this.map = map16;
  this.step = step2;
  this.selection = selection;
  this.mirrorOffset = mirrorOffset;
};
Item.prototype.merge = function merge2(other) {
  if (this.step && other.step && !other.selection) {
    var step2 = other.step.merge(this.step);
    if (step2) {
      return new Item(step2.getMap().invert(), step2, this.selection);
    }
  }
};
var HistoryState = function HistoryState2(done2, undone, prevRanges, prevTime) {
  this.done = done2;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
};
var DEPTH_OVERFLOW = 20;
function applyTransaction2(history2, state, tr, options) {
  var historyTr = tr.getMeta(historyKey), rebased2;
  if (historyTr) {
    return historyTr.historyState;
  }
  if (tr.getMeta(closeHistoryKey)) {
    history2 = new HistoryState(history2.done, history2.undone, null, 0);
  }
  var appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo) {
      return new HistoryState(history2.done.addTransform(tr, null, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime);
    } else {
      return new HistoryState(history2.done, history2.undone.addTransform(tr, null, options, mustPreserveItems(state)), null, history2.prevTime);
    }
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    var newGroup = history2.prevTime == 0 || !appended && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    var prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
  } else if (rebased2 = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased2), history2.undone.rebased(tr, rebased2), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) {
    return false;
  }
  if (!transform.docChanged) {
    return true;
  }
  var adjacent = false;
  transform.mapping.maps[0].forEach(function(start4, end3) {
    for (var i2 = 0; i2 < prevRanges.length; i2 += 2) {
      if (start4 <= prevRanges[i2 + 1] && end3 >= prevRanges[i2]) {
        adjacent = true;
      }
    }
  });
  return adjacent;
}
function rangesFor(map16) {
  var result2 = [];
  map16.forEach(function(_from, _to, from4, to) {
    return result2.push(from4, to);
  });
  return result2;
}
function mapRanges(ranges, mapping) {
  if (!ranges) {
    return null;
  }
  var result2 = [];
  for (var i2 = 0; i2 < ranges.length; i2 += 2) {
    var from4 = mapping.map(ranges[i2], 1), to = mapping.map(ranges[i2 + 1], -1);
    if (from4 <= to) {
      result2.push(from4, to);
    }
  }
  return result2;
}
function histTransaction(history2, state, dispatch2, redo2) {
  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
  var pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop) {
    return;
  }
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);
  dispatch2(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
var cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var i2 = 0; i2 < plugins.length; i2++) {
      if (plugins[i2].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config2) {
  config2 = {
    depth: config2 && config2.depth || 100,
    newGroupDelay: config2 && config2.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init: function init6() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply: function apply8(tr, hist, state) {
        return applyTransaction2(hist, state, tr, config2);
      }
    },
    config: config2,
    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e2) {
          var handled = e2.inputType == "historyUndo" ? undo(view.state, view.dispatch) : e2.inputType == "historyRedo" ? redo(view.state, view.dispatch) : false;
          if (handled) {
            e2.preventDefault();
          }
          return handled;
        }
      }
    }
  });
}
function undo(state, dispatch2) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) {
    return false;
  }
  if (dispatch2) {
    histTransaction(hist, state, dispatch2, false);
  }
  return true;
}
function redo(state, dispatch2) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) {
    return false;
  }
  if (dispatch2) {
    histTransaction(hist, state, dispatch2, true);
  }
  return true;
}
function undoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}
var _dec$g, _dec2$c, _dec3$8, _dec4$3, _dec5$2, _class$g, _class2$a;
var HistoryExtension = (_dec$g = extension({
  defaultOptions: {
    depth: 100,
    newGroupDelay: 500,
    getDispatch: void 0,
    getState: void 0
  },
  staticKeys: ["depth", "newGroupDelay"],
  handlerKeys: ["onUndo", "onRedo"]
}), _dec2$c = keyBinding({
  shortcut: NamedShortcut.Undo,
  command: "undo"
}), _dec3$8 = keyBinding({
  shortcut: NamedShortcut.Redo,
  command: "redo"
}), _dec4$3 = command({
  disableChaining: true,
  description: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionHistoryMessages.UNDO_DESCRIPTION);
  },
  label: (_ref2) => {
    var t2 = _ref2.t;
    return t2(extensionHistoryMessages.UNDO_LABEL);
  },
  icon: "arrowGoBackFill"
}), _dec5$2 = command({
  disableChaining: true,
  description: (_ref3) => {
    var t2 = _ref3.t;
    return t2(extensionHistoryMessages.REDO_DESCRIPTION);
  },
  label: (_ref4) => {
    var t2 = _ref4.t;
    return t2(extensionHistoryMessages.REDO_LABEL);
  },
  icon: "arrowGoForwardFill"
}), _dec$g(_class$g = (_class2$a = class HistoryExtension2 extends PlainExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "wrapMethod", (method, callback) => {
      return (_ref5) => {
        var state = _ref5.state, dispatch2 = _ref5.dispatch, view = _ref5.view;
        var _this$options = this.options, getState4 = _this$options.getState, getDispatch = _this$options.getDispatch;
        var wrappedState = isFunction$1(getState4) ? getState4() : state;
        var wrappedDispatch = isFunction$1(getDispatch) && dispatch2 ? getDispatch() : dispatch2;
        var success = method(wrappedState, wrappedDispatch, view);
        callback === null || callback === void 0 ? void 0 : callback(success);
        return success;
      };
    });
  }
  get name() {
    return "history";
  }
  createKeymap() {
    return {
      "Mod-y": !environment.isMac ? this.wrapMethod(redo, this.options.onRedo) : () => false,
      "Mod-z": this.wrapMethod(undo, this.options.onUndo),
      "Shift-Mod-z": this.wrapMethod(redo, this.options.onRedo)
    };
  }
  undoShortcut(props) {
    return this.wrapMethod(undo, this.options.onUndo)(props);
  }
  redoShortcut(props) {
    return this.wrapMethod(redo, this.options.onRedo)(props);
  }
  createExternalPlugins() {
    var _this$options2 = this.options, depth = _this$options2.depth, newGroupDelay = _this$options2.newGroupDelay;
    return [history({
      depth,
      newGroupDelay
    })];
  }
  undo() {
    return nonChainable(this.wrapMethod(undo, this.options.onUndo));
  }
  redo() {
    return nonChainable(this.wrapMethod(redo, this.options.onRedo));
  }
}, _applyDecoratedDescriptor(_class2$a.prototype, "undoShortcut", [_dec2$c], Object.getOwnPropertyDescriptor(_class2$a.prototype, "undoShortcut"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "redoShortcut", [_dec3$8], Object.getOwnPropertyDescriptor(_class2$a.prototype, "redoShortcut"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "undo", [_dec4$3], Object.getOwnPropertyDescriptor(_class2$a.prototype, "undo"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "redo", [_dec5$2], Object.getOwnPropertyDescriptor(_class2$a.prototype, "redo"), _class2$a.prototype), _class2$a)) || _class$g);
var _dec$f, _dec2$b, _dec3$7, _dec4$2, _class$f, _class2$9;
var insertParagraphOptions = {
  icon: "paragraph",
  label: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionParagraphMessages.INSERT_LABEL);
  },
  description: (_ref2) => {
    var t2 = _ref2.t;
    return t2(extensionParagraphMessages.INSERT_DESCRIPTION);
  }
};
var convertParagraphOptions = {
  icon: "paragraph",
  label: (_ref3) => {
    var t2 = _ref3.t;
    return t2(extensionParagraphMessages.CONVERT_LABEL);
  },
  description: (_ref4) => {
    var t2 = _ref4.t;
    return t2(extensionParagraphMessages.CONVERT_DESCRIPTION);
  }
};
var ParagraphExtension = (_dec$f = extension({
  defaultPriority: ExtensionPriority.Medium
}), _dec2$b = command(convertParagraphOptions), _dec3$7 = command(insertParagraphOptions), _dec4$2 = keyBinding({
  shortcut: NamedShortcut.Paragraph,
  command: "convertParagraph"
}), _dec$f(_class$f = (_class2$9 = class ParagraphExtension2 extends NodeExtension {
  get name() {
    return "paragraph";
  }
  createTags() {
    return [ExtensionTag.LastNodeCompatible, ExtensionTag.TextBlock, ExtensionTag.Block, ExtensionTag.FormattingNode];
  }
  createNodeSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({
      content: "inline*",
      draggable: false
    }, override), {}, {
      attrs: _objectSpread2$3({}, extra.defaults()),
      parseDOM: [{
        tag: "p",
        getAttrs: (node4) => _objectSpread2$3({}, extra.parse(node4))
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => {
        return ["p", extra.dom(node4), 0];
      }
    });
  }
  convertParagraph() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var attrs = options.attrs, selection = options.selection, preserveAttrs = options.preserveAttrs;
    return this.store.commands.setBlockNodeType.original(this.type, attrs, selection, preserveAttrs);
  }
  insertParagraph(content2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var selection = options.selection, attrs = options.attrs;
    return this.store.commands.insertNode.original(this.type, {
      content: content2,
      selection,
      attrs
    });
  }
  shortcut(props) {
    return this.convertParagraph()(props);
  }
}, _applyDecoratedDescriptor(_class2$9.prototype, "convertParagraph", [_dec2$b], Object.getOwnPropertyDescriptor(_class2$9.prototype, "convertParagraph"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "insertParagraph", [_dec3$7], Object.getOwnPropertyDescriptor(_class2$9.prototype, "insertParagraph"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "shortcut", [_dec4$2], Object.getOwnPropertyDescriptor(_class2$9.prototype, "shortcut"), _class2$9.prototype), _class2$9)) || _class$f);
var _dec$e, _class$e;
var TextExtension = (_dec$e = extension({
  disableExtraAttributes: true,
  defaultPriority: ExtensionPriority.Medium
}), _dec$e(_class$e = class TextExtension2 extends NodeExtension {
  get name() {
    return "text";
  }
  createTags() {
    return [ExtensionTag.InlineNode];
  }
  createNodeSpec() {
    return {};
  }
}) || _class$e);
var defaultOptions = _objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, DocExtension.defaultOptions), ParagraphExtension.defaultOptions), HistoryExtension.defaultOptions), {}, {
  excludeExtensions: []
});
function corePreset() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  options = _objectSpread2$3(_objectSpread2$3({}, defaultOptions), options);
  var _options2 = options, content2 = _options2.content, depth = _options2.depth, getDispatch = _options2.getDispatch, getState4 = _options2.getState, newGroupDelay = _options2.newGroupDelay, excludeExtensions = _options2.excludeExtensions;
  var excludeMap = {};
  var _iterator = _createForOfIteratorHelper(excludeExtensions !== null && excludeExtensions !== void 0 ? excludeExtensions : []), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var name = _step.value;
      excludeMap[name] = true;
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  var coreExtensions = [];
  if (!excludeMap["history"]) {
    var historyExtension = new HistoryExtension({
      depth,
      getDispatch,
      getState: getState4,
      newGroupDelay
    });
    coreExtensions.push(historyExtension);
  }
  if (!excludeMap["doc"]) {
    coreExtensions.push(new DocExtension({
      content: content2
    }));
  }
  if (!excludeMap["text"]) {
    coreExtensions.push(new TextExtension());
  }
  if (!excludeMap["paragraph"]) {
    coreExtensions.push(new ParagraphExtension());
  }
  if (!excludeMap["positioner"]) {
    coreExtensions.push(new PositionerExtension());
  }
  if (!excludeMap["gapCursor"]) {
    coreExtensions.push(new GapCursorExtension());
  }
  if (!excludeMap["events"]) {
    coreExtensions.push(new EventsExtension());
  }
  return coreExtensions;
}
var _dec$d, _class$d;
var PlaceholderExtension = (_dec$d = extension({
  defaultOptions: {
    emptyNodeClass: extensionPlaceholderTheme.IS_EMPTY,
    placeholder: ""
  }
}), _dec$d(_class$d = class PlaceholderExtension2 extends PlainExtension {
  get name() {
    return "placeholder";
  }
  createAttributes() {
    return {
      "aria-placeholder": this.options.placeholder
    };
  }
  createPlugin() {
    return {
      state: {
        init: (_2, state) => _objectSpread2$3(_objectSpread2$3({}, this.options), {}, {
          empty: isDefaultDocNode(state.doc, {
            ignoreAttributes: true
          })
        }),
        apply: (tr, pluginState, _2, state) => {
          return applyState({
            pluginState,
            tr,
            extension: this,
            state
          });
        }
      },
      props: {
        decorations: (state) => {
          return createDecorationSet({
            state,
            extension: this
          });
        }
      }
    };
  }
  onSetOptions(props) {
    var changes = props.changes;
    if (changes.placeholder.changed && this.store.phase >= ManagerPhase.EditorView) {
      this.store.updateAttributes();
    }
  }
}) || _class$d);
function applyState(props) {
  var pluginState = props.pluginState, extension2 = props.extension, tr = props.tr, state = props.state;
  if (!tr.docChanged) {
    return pluginState;
  }
  return _objectSpread2$3(_objectSpread2$3({}, extension2.options), {}, {
    empty: isDefaultDocNode(state.doc)
  });
}
function createDecorationSet(props) {
  var extension2 = props.extension, state = props.state;
  var _ref = extension2.pluginKey.getState(state), empty2 = _ref.empty;
  var _extension$options = extension2.options, emptyNodeClass = _extension$options.emptyNodeClass, placeholder = _extension$options.placeholder;
  if (!empty2) {
    return;
  }
  var decorations = [];
  state.doc.descendants((node4, pos) => {
    var decoration = Decoration.node(pos, pos + node4.nodeSize, {
      class: emptyNodeClass,
      "data-placeholder": placeholder
    });
    decorations.push(decoration);
  });
  return DecorationSet.create(state.doc, decorations);
}
class ReactPlaceholderExtension extends PlaceholderExtension {
  get name() {
    return "reactPlaceholder";
  }
  createSSRTransformer() {
    return (element, state) => {
      var _state;
      state = (_state = state) !== null && _state !== void 0 ? _state : this.store.getState();
      var _this$options = this.options, emptyNodeClass = _this$options.emptyNodeClass, placeholder = _this$options.placeholder;
      var _getElementProps = getElementProps(element), children = _getElementProps.children;
      if (react$1.exports.Children.count(children) > 1 || !isDocNodeEmpty(state.doc)) {
        return element;
      }
      var properties = getElementProps(children);
      return /* @__PURE__ */ react$1.exports.cloneElement(element, {}, /* @__PURE__ */ react$1.exports.cloneElement(children, {
        placeholder,
        className: cx2(isString$1(properties.className) && properties.className, emptyNodeClass),
        "data-placeholder": placeholder
      }));
    };
  }
}
var _dec$c, _class$c;
var DEFAULT_OPTIONS$1 = _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, ReactSsrExtension.defaultOptions), ReactPlaceholderExtension.defaultOptions), ReactComponentExtension.defaultOptions);
var STATIC_KEYS = [...ReactSsrExtension.staticKeys, ...ReactPlaceholderExtension.staticKeys, ...ReactComponentExtension.staticKeys];
var ReactExtension = (_dec$c = extension({
  defaultOptions: DEFAULT_OPTIONS$1,
  staticKeys: STATIC_KEYS
}), _dec$c(_class$c = class ReactExtension2 extends PlainExtension {
  get name() {
    return "react";
  }
  onSetOptions(props) {
    var pickChanged = props.pickChanged;
    this.getExtension(ReactPlaceholderExtension).setOptions(pickChanged(["placeholder"]));
  }
  createExtensions() {
    var _this$options = this.options, transformers2 = _this$options.transformers, emptyNodeClass = _this$options.emptyNodeClass, placeholder = _this$options.placeholder, defaultBlockNode = _this$options.defaultBlockNode, defaultContentNode = _this$options.defaultContentNode, defaultEnvironment = _this$options.defaultEnvironment, defaultInlineNode = _this$options.defaultInlineNode, nodeViewComponents = _this$options.nodeViewComponents;
    return [new ReactSsrExtension({
      transformers: transformers2
    }), new ReactPlaceholderExtension({
      emptyNodeClass,
      placeholder,
      priority: ExtensionPriority.Medium
    }), new ReactComponentExtension({
      defaultBlockNode,
      defaultContentNode,
      defaultEnvironment,
      defaultInlineNode,
      nodeViewComponents
    })];
  }
}) || _class$c);
function usePrevious$1(value) {
  var ref2 = react$1.exports.useRef();
  index2(function() {
    ref2.current = value;
  });
  return ref2.current;
}
function _checkPrivateRedeclaration$1(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec$1(obj, privateMap, value) {
  _checkPrivateRedeclaration$1(obj, privateMap);
  privateMap.set(obj, value);
}
var possibleStandardNames = {
  accept: "accept",
  acceptcharset: "acceptCharset",
  "accept-charset": "acceptCharset",
  accesskey: "accessKey",
  action: "action",
  allowfullscreen: "allowFullScreen",
  alt: "alt",
  as: "as",
  async: "async",
  autocapitalize: "autoCapitalize",
  autocomplete: "autoComplete",
  autocorrect: "autoCorrect",
  autofocus: "autoFocus",
  autoplay: "autoPlay",
  autosave: "autoSave",
  capture: "capture",
  cellpadding: "cellPadding",
  cellspacing: "cellSpacing",
  challenge: "challenge",
  charset: "charSet",
  checked: "checked",
  children: "children",
  cite: "cite",
  class: "className",
  classid: "classID",
  classname: "className",
  cols: "cols",
  colspan: "colSpan",
  content: "content",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  controls: "controls",
  controlslist: "controlsList",
  coords: "coords",
  crossorigin: "crossOrigin",
  dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
  data: "data",
  datetime: "dateTime",
  default: "default",
  defaultchecked: "defaultChecked",
  defaultvalue: "defaultValue",
  defer: "defer",
  dir: "dir",
  disabled: "disabled",
  download: "download",
  draggable: "draggable",
  enctype: "encType",
  for: "htmlFor",
  form: "form",
  formmethod: "formMethod",
  formaction: "formAction",
  formenctype: "formEncType",
  formnovalidate: "formNoValidate",
  formtarget: "formTarget",
  frameborder: "frameBorder",
  headers: "headers",
  height: "height",
  hidden: "hidden",
  high: "high",
  href: "href",
  hreflang: "hrefLang",
  htmlfor: "htmlFor",
  httpequiv: "httpEquiv",
  "http-equiv": "httpEquiv",
  icon: "icon",
  id: "id",
  innerhtml: "innerHTML",
  inputmode: "inputMode",
  integrity: "integrity",
  is: "is",
  itemid: "itemID",
  itemprop: "itemProps",
  itemref: "itemRef",
  itemscope: "itemScope",
  itemtype: "itemType",
  keyparams: "keyProps",
  keytype: "keyType",
  kind: "kind",
  label: "label",
  lang: "lang",
  list: "list",
  loop: "loop",
  low: "low",
  manifest: "manifest",
  marginwidth: "marginWidth",
  marginheight: "marginHeight",
  max: "max",
  maxlength: "maxLength",
  media: "media",
  mediagroup: "mediaGroup",
  method: "method",
  min: "min",
  minlength: "minLength",
  multiple: "multiple",
  muted: "muted",
  name: "name",
  nomodule: "noModule",
  nonce: "nonce",
  novalidate: "noValidate",
  open: "open",
  optimum: "optimum",
  pattern: "pattern",
  placeholder: "placeholder",
  playsinline: "playsInline",
  poster: "poster",
  preload: "preload",
  profile: "profile",
  radiogroup: "radioGroup",
  readonly: "readOnly",
  referrerpolicy: "referrerPolicy",
  rel: "rel",
  required: "required",
  reversed: "reversed",
  role: "role",
  rows: "rows",
  rowspan: "rowSpan",
  sandbox: "sandbox",
  scope: "scope",
  scoped: "scoped",
  scrolling: "scrolling",
  seamless: "seamless",
  selected: "selected",
  shape: "shape",
  size: "size",
  sizes: "sizes",
  span: "span",
  spellcheck: "spellCheck",
  src: "src",
  srcdoc: "srcDoc",
  srclang: "srcLang",
  srcset: "srcSet",
  start: "start",
  step: "step",
  style: "style",
  summary: "summary",
  tabindex: "tabIndex",
  target: "target",
  title: "title",
  type: "type",
  usemap: "useMap",
  value: "value",
  width: "width",
  wmode: "wmode",
  wrap: "wrap",
  about: "about",
  accentheight: "accentHeight",
  "accent-height": "accentHeight",
  accumulate: "accumulate",
  additive: "additive",
  alignmentbaseline: "alignmentBaseline",
  "alignment-baseline": "alignmentBaseline",
  allowreorder: "allowReorder",
  alphabetic: "alphabetic",
  amplitude: "amplitude",
  arabicform: "arabicForm",
  "arabic-form": "arabicForm",
  ascent: "ascent",
  attributename: "attributeName",
  attributetype: "attributeType",
  autoreverse: "autoReverse",
  azimuth: "azimuth",
  basefrequency: "baseFrequency",
  baselineshift: "baselineShift",
  "baseline-shift": "baselineShift",
  baseprofile: "baseProfile",
  bbox: "bbox",
  begin: "begin",
  bias: "bias",
  by: "by",
  calcmode: "calcMode",
  capheight: "capHeight",
  "cap-height": "capHeight",
  clip: "clip",
  clippath: "clipPath",
  "clip-path": "clipPath",
  clippathunits: "clipPathUnits",
  cliprule: "clipRule",
  "clip-rule": "clipRule",
  color: "color",
  colorinterpolation: "colorInterpolation",
  "color-interpolation": "colorInterpolation",
  colorinterpolationfilters: "colorInterpolationFilters",
  "color-interpolation-filters": "colorInterpolationFilters",
  colorprofile: "colorProfile",
  "color-profile": "colorProfile",
  colorrendering: "colorRendering",
  "color-rendering": "colorRendering",
  contentscripttype: "contentScriptType",
  contentstyletype: "contentStyleType",
  cursor: "cursor",
  cx: "cx",
  cy: "cy",
  d: "d",
  datatype: "datatype",
  decelerate: "decelerate",
  descent: "descent",
  diffuseconstant: "diffuseConstant",
  direction: "direction",
  display: "display",
  divisor: "divisor",
  dominantbaseline: "dominantBaseline",
  "dominant-baseline": "dominantBaseline",
  dur: "dur",
  dx: "dx",
  dy: "dy",
  edgemode: "edgeMode",
  elevation: "elevation",
  enablebackground: "enableBackground",
  "enable-background": "enableBackground",
  end: "end",
  exponent: "exponent",
  externalresourcesrequired: "externalResourcesRequired",
  fill: "fill",
  fillopacity: "fillOpacity",
  "fill-opacity": "fillOpacity",
  fillrule: "fillRule",
  "fill-rule": "fillRule",
  filter: "filter",
  filterres: "filterRes",
  filterunits: "filterUnits",
  floodopacity: "floodOpacity",
  "flood-opacity": "floodOpacity",
  floodcolor: "floodColor",
  "flood-color": "floodColor",
  focusable: "focusable",
  fontfamily: "fontFamily",
  "font-family": "fontFamily",
  fontsize: "fontSize",
  "font-size": "fontSize",
  fontsizeadjust: "fontSizeAdjust",
  "font-size-adjust": "fontSizeAdjust",
  fontstretch: "fontStretch",
  "font-stretch": "fontStretch",
  fontstyle: "fontStyle",
  "font-style": "fontStyle",
  fontvariant: "fontVariant",
  "font-variant": "fontVariant",
  fontweight: "fontWeight",
  "font-weight": "fontWeight",
  format: "format",
  from: "from",
  fx: "fx",
  fy: "fy",
  g1: "g1",
  g2: "g2",
  glyphname: "glyphName",
  "glyph-name": "glyphName",
  glyphorientationhorizontal: "glyphOrientationHorizontal",
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphorientationvertical: "glyphOrientationVertical",
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphref: "glyphRef",
  gradienttransform: "gradientTransform",
  gradientunits: "gradientUnits",
  hanging: "hanging",
  horizadvx: "horizAdvX",
  "horiz-adv-x": "horizAdvX",
  horizoriginx: "horizOriginX",
  "horiz-origin-x": "horizOriginX",
  ideographic: "ideographic",
  imagerendering: "imageRendering",
  "image-rendering": "imageRendering",
  in2: "in2",
  in: "in",
  inlist: "inlist",
  intercept: "intercept",
  k1: "k1",
  k2: "k2",
  k3: "k3",
  k4: "k4",
  k: "k",
  kernelmatrix: "kernelMatrix",
  kernelunitlength: "kernelUnitLength",
  kerning: "kerning",
  keypoints: "keyPoints",
  keysplines: "keySplines",
  keytimes: "keyTimes",
  lengthadjust: "lengthAdjust",
  letterspacing: "letterSpacing",
  "letter-spacing": "letterSpacing",
  lightingcolor: "lightingColor",
  "lighting-color": "lightingColor",
  limitingconeangle: "limitingConeAngle",
  local: "local",
  markerend: "markerEnd",
  "marker-end": "markerEnd",
  markerheight: "markerHeight",
  markermid: "markerMid",
  "marker-mid": "markerMid",
  markerstart: "markerStart",
  "marker-start": "markerStart",
  markerunits: "markerUnits",
  markerwidth: "markerWidth",
  mask: "mask",
  maskcontentunits: "maskContentUnits",
  maskunits: "maskUnits",
  mathematical: "mathematical",
  mode: "mode",
  numoctaves: "numOctaves",
  offset: "offset",
  opacity: "opacity",
  operator: "operator",
  order: "order",
  orient: "orient",
  orientation: "orientation",
  origin: "origin",
  overflow: "overflow",
  overlineposition: "overlinePosition",
  "overline-position": "overlinePosition",
  overlinethickness: "overlineThickness",
  "overline-thickness": "overlineThickness",
  paintorder: "paintOrder",
  "paint-order": "paintOrder",
  panose1: "panose1",
  "panose-1": "panose1",
  pathlength: "pathLength",
  patterncontentunits: "patternContentUnits",
  patterntransform: "patternTransform",
  patternunits: "patternUnits",
  pointerevents: "pointerEvents",
  "pointer-events": "pointerEvents",
  points: "points",
  pointsatx: "pointsAtX",
  pointsaty: "pointsAtY",
  pointsatz: "pointsAtZ",
  prefix: "prefix",
  preservealpha: "preserveAlpha",
  preserveaspectratio: "preserveAspectRatio",
  primitiveunits: "primitiveUnits",
  property: "property",
  r: "r",
  radius: "radius",
  refx: "refX",
  refy: "refY",
  renderingintent: "renderingIntent",
  "rendering-intent": "renderingIntent",
  repeatcount: "repeatCount",
  repeatdur: "repeatDur",
  requiredextensions: "requiredExtensions",
  requiredfeatures: "requiredFeatures",
  resource: "resource",
  restart: "restart",
  result: "result",
  results: "results",
  rotate: "rotate",
  rx: "rx",
  ry: "ry",
  scale: "scale",
  security: "security",
  seed: "seed",
  shaperendering: "shapeRendering",
  "shape-rendering": "shapeRendering",
  slope: "slope",
  spacing: "spacing",
  specularconstant: "specularConstant",
  specularexponent: "specularExponent",
  speed: "speed",
  spreadmethod: "spreadMethod",
  startoffset: "startOffset",
  stddeviation: "stdDeviation",
  stemh: "stemh",
  stemv: "stemv",
  stitchtiles: "stitchTiles",
  stopcolor: "stopColor",
  "stop-color": "stopColor",
  stopopacity: "stopOpacity",
  "stop-opacity": "stopOpacity",
  strikethroughposition: "strikethroughPosition",
  "strikethrough-position": "strikethroughPosition",
  strikethroughthickness: "strikethroughThickness",
  "strikethrough-thickness": "strikethroughThickness",
  string: "string",
  stroke: "stroke",
  strokedasharray: "strokeDasharray",
  "stroke-dasharray": "strokeDasharray",
  strokedashoffset: "strokeDashoffset",
  "stroke-dashoffset": "strokeDashoffset",
  strokelinecap: "strokeLinecap",
  "stroke-linecap": "strokeLinecap",
  strokelinejoin: "strokeLinejoin",
  "stroke-linejoin": "strokeLinejoin",
  strokemiterlimit: "strokeMiterlimit",
  "stroke-miterlimit": "strokeMiterlimit",
  strokewidth: "strokeWidth",
  "stroke-width": "strokeWidth",
  strokeopacity: "strokeOpacity",
  "stroke-opacity": "strokeOpacity",
  suppresscontenteditablewarning: "suppressContentEditableWarning",
  suppresshydrationwarning: "suppressHydrationWarning",
  surfacescale: "surfaceScale",
  systemlanguage: "systemLanguage",
  tablevalues: "tableValues",
  targetx: "targetX",
  targety: "targetY",
  textanchor: "textAnchor",
  "text-anchor": "textAnchor",
  textdecoration: "textDecoration",
  "text-decoration": "textDecoration",
  textlength: "textLength",
  textrendering: "textRendering",
  "text-rendering": "textRendering",
  to: "to",
  transform: "transform",
  typeof: "typeof",
  u1: "u1",
  u2: "u2",
  underlineposition: "underlinePosition",
  "underline-position": "underlinePosition",
  underlinethickness: "underlineThickness",
  "underline-thickness": "underlineThickness",
  unicode: "unicode",
  unicodebidi: "unicodeBidi",
  "unicode-bidi": "unicodeBidi",
  unicoderange: "unicodeRange",
  "unicode-range": "unicodeRange",
  unitsperem: "unitsPerEm",
  "units-per-em": "unitsPerEm",
  unselectable: "unselectable",
  valphabetic: "vAlphabetic",
  "v-alphabetic": "vAlphabetic",
  values: "values",
  vectoreffect: "vectorEffect",
  "vector-effect": "vectorEffect",
  version: "version",
  vertadvy: "vertAdvY",
  "vert-adv-y": "vertAdvY",
  vertoriginx: "vertOriginX",
  "vert-origin-x": "vertOriginX",
  vertoriginy: "vertOriginY",
  "vert-origin-y": "vertOriginY",
  vhanging: "vHanging",
  "v-hanging": "vHanging",
  videographic: "vIdeographic",
  "v-ideographic": "vIdeographic",
  viewbox: "viewBox",
  viewtarget: "viewTarget",
  visibility: "visibility",
  vmathematical: "vMathematical",
  "v-mathematical": "vMathematical",
  vocab: "vocab",
  widths: "widths",
  wordspacing: "wordSpacing",
  "word-spacing": "wordSpacing",
  writingmode: "writingMode",
  "writing-mode": "writingMode",
  x1: "x1",
  x2: "x2",
  x: "x",
  xchannelselector: "xChannelSelector",
  xheight: "xHeight",
  "x-height": "xHeight",
  xlinkactuate: "xlinkActuate",
  "xlink:actuate": "xlinkActuate",
  xlinkarcrole: "xlinkArcrole",
  "xlink:arcrole": "xlinkArcrole",
  xlinkhref: "xlinkHref",
  "xlink:href": "xlinkHref",
  xlinkrole: "xlinkRole",
  "xlink:role": "xlinkRole",
  xlinkshow: "xlinkShow",
  "xlink:show": "xlinkShow",
  xlinktitle: "xlinkTitle",
  "xlink:title": "xlinkTitle",
  xlinktype: "xlinkType",
  "xlink:type": "xlinkType",
  xmlbase: "xmlBase",
  "xml:base": "xmlBase",
  xmllang: "xmlLang",
  "xml:lang": "xmlLang",
  xmlns: "xmlns",
  "xml:space": "xmlSpace",
  xmlnsxlink: "xmlnsXlink",
  "xmlns:xlink": "xmlnsXlink",
  xmlspace: "xmlSpace",
  y1: "y1",
  y2: "y2",
  y: "y",
  ychannelselector: "yChannelSelector",
  z: "z",
  zoomandpan: "zoomAndPan"
};
function getPossibleStandardName(key) {
  var _possibleStandardName;
  if (!hasOwnProperty$1(possibleStandardNames, key)) {
    return key;
  }
  return (_possibleStandardName = possibleStandardNames[key]) !== null && _possibleStandardName !== void 0 ? _possibleStandardName : key;
}
function mapProps(props) {
  var transformedProps = object();
  var _iterator = _createForOfIteratorHelper(keys$1(props)), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var key = _step.value;
      var name = getPossibleStandardName(key);
      transformedProps[name] = props[key];
      if (name === "contentEditable") {
        transformedProps.suppressContentEditableWarning = true;
      }
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  return transformedProps;
}
function gatherDomMethods(specs) {
  var result2 = object();
  for (var name in specs) {
    var _specs$name;
    if (!hasOwnProperty$1(specs, name)) {
      continue;
    }
    var toDOM = (_specs$name = specs[name]) === null || _specs$name === void 0 ? void 0 : _specs$name.toDOM;
    if (toDOM) {
      result2[name] = toDOM;
    }
  }
  return result2;
}
var _components = /* @__PURE__ */ new WeakMap();
var _view = /* @__PURE__ */ new WeakMap();
class ReactSerializer {
  static renderSpec(structure, wraps) {
    if (isString$1(structure)) {
      return structure;
    }
    var Component2 = structure[0];
    var props = object();
    var attributes = structure[1];
    var children = [];
    var currentIndex = 1;
    if (isPlainObject$1(attributes) && !isArray(attributes)) {
      currentIndex = 2;
      for (var name in attributes) {
        if (attributes[name] != null) {
          props[name] = attributes[name];
        }
      }
    }
    for (var ii = currentIndex; ii < structure.length; ii++) {
      var child3 = structure[ii];
      if (child3 === 0) {
        !!(ii < structure.length - 1 || ii > currentIndex) ? invariant(false, {
          message: "Content hole (0) must be the only child of its parent node",
          code: ErrorConstant.INTERNAL
        }) : void 0;
        return /* @__PURE__ */ react$1.exports.createElement(Component2, mapProps(props), wraps);
      }
      children.push(ReactSerializer.renderSpec(child3, wraps));
    }
    return /* @__PURE__ */ react$1.exports.createElement(Component2, mapProps(props), ...children);
  }
  static fromManager(manager) {
    return new ReactSerializer(this.nodesFromManager(manager), this.marksFromManager(manager), manager);
  }
  static nodesFromManager(manager) {
    var result2 = gatherDomMethods(manager.nodes);
    if (!result2.text) {
      result2.text = (node4) => node4.text ? node4.text : "";
    }
    return result2;
  }
  static marksFromManager(manager) {
    return gatherDomMethods(manager.marks);
  }
  constructor(nodes, marks2, manager) {
    var _manager$store$compon;
    _classPrivateFieldInitSpec$1(this, _components, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$1(this, _view, {
      writable: true,
      value: void 0
    });
    this.nodes = nodes;
    this.marks = marks2;
    _classPrivateFieldSet(this, _components, (_manager$store$compon = manager.store.components) !== null && _manager$store$compon !== void 0 ? _manager$store$compon : object());
    _classPrivateFieldSet(this, _view, manager.view);
  }
  serializeFragment(fragment) {
    var children = [];
    fragment.forEach((node4) => {
      var child3;
      child3 = this.serializeNode(node4);
      node4.marks.reverse().forEach((mark3) => {
        child3 = this.serializeMark(mark3, node4.isInline, child3);
      });
      children.push(child3);
    });
    return /* @__PURE__ */ react$1.exports.createElement(react$1.exports.Fragment, {}, ...children);
  }
  serializeNode(node4) {
    var managerStoreComponent = _classPrivateFieldGet(this, _components)[node4.type.name];
    var toDOM = this.nodes[node4.type.name];
    var children;
    if (node4.content.childCount > 0) {
      children = this.serializeFragment(node4.content);
    }
    if (managerStoreComponent) {
      var Component2 = managerStoreComponent.Component, props = managerStoreComponent.props;
      return /* @__PURE__ */ jsx(Component2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        node: node4,
        view: _classPrivateFieldGet(this, _view),
        children
      }));
    }
    return toDOM && ReactSerializer.renderSpec(toDOM(node4), children);
  }
  serializeMark(mark3, inline2, wrappedElement) {
    var toDOM = this.marks[mark3.type.name];
    return toDOM && ReactSerializer.renderSpec(toDOM(mark3, inline2), wrappedElement);
  }
}
var RemirrorSSR = (props) => {
  var attributes = props.attributes, manager = props.manager, state = props.state, editable = props.editable;
  var outerProperties = mapProps(attributes);
  var ssrElement = ReactSerializer.fromManager(manager).serializeFragment(state.doc.content);
  var transformedElement = manager.store.ssrTransformer(ssrElement, state);
  return /* @__PURE__ */ jsx("div", _objectSpread2$3(_objectSpread2$3({}, outerProperties), {}, {
    suppressContentEditableWarning: true,
    contentEditable: editable,
    children: transformedElement
  }));
};
class EditorViewSSR {
  constructor(_place, props) {
    _defineProperty$3(this, "dragging", null);
    var doc2 = getDocument$1();
    this.root = doc2;
    this.dom = doc2.createElement("div");
    this.state = props.state;
  }
  update(_props2) {
  }
  setProps(_props2) {
  }
  updateState(_state) {
  }
  someProps(_propName, f2) {
    return f2 ? f2(null) : null;
  }
  hasFocus() {
    return false;
  }
  focus() {
  }
  posAtCoords(_coords) {
    return null;
  }
  coordsAtPos(_pos) {
    return {
      bottom: 0,
      left: 0,
      right: 0,
      top: 0
    };
  }
  domAtPos(_pos) {
    return {
      node: this.dom,
      offset: 0
    };
  }
  nodeDOM(_pos) {
    return null;
  }
  posAtDOM(_node2, _offset, _bias) {
    return 0;
  }
  endOfTextblock(_dir, _state) {
    return true;
  }
  destroy() {
  }
  dispatch(_tr) {
  }
}
function createEditorView(place, props, forceEnvironment) {
  var Constructor = shouldUseDomEnvironment(forceEnvironment) ? EditorView : Cast(EditorViewSSR);
  return new Constructor(place, props);
}
function createContextHook(useHook) {
  var DefaultContext2 = /* @__PURE__ */ react$1.exports.createContext(null);
  var useHookContext = contextHookFactory(DefaultContext2);
  var Provider2 = (props) => {
    var context2 = useHook(props);
    return /* @__PURE__ */ jsx(DefaultContext2.Provider, {
      value: context2,
      children: props.children
    });
  };
  return [Provider2, useHookContext, DefaultContext2];
}
function contextHookFactory(DefaultContext2) {
  return (selector2, equalityCheck) => {
    var context2 = react$1.exports.useContext(DefaultContext2);
    var previousContext = usePrevious(context2);
    if (!context2) {
      throw new Error("`useContextHook` must be placed inside the `Provider` returned by the `createContextState` method");
    }
    if (!selector2) {
      return context2;
    }
    if (typeof selector2 !== "function") {
      throw new TypeError("invalid arguments passed to `useContextHook`. This hook must be called with zero arguments, a getter function or a path string.");
    }
    var value = selector2(context2);
    if (!previousContext || !equalityCheck) {
      return value;
    }
    var previousValue = selector2(previousContext);
    return equalityCheck(previousValue, value) ? previousValue : value;
  };
}
function usePrevious(value) {
  var ref2 = react$1.exports.useRef();
  useIsomorphicLayoutEffect(() => {
    ref2.current = value;
  });
  return ref2.current;
}
var useIsomorphicLayoutEffect = react$1.exports.useLayoutEffect;
function createContextState(creator, hook) {
  return createContextHook((props) => {
    var contextRef = react$1.exports.useRef(null);
    var setContextRef = react$1.exports.useRef();
    var state = hook === null || hook === void 0 ? void 0 : hook(props);
    var _useState = react$1.exports.useState(() => {
      return creator({
        get: createGet(contextRef),
        set: createSet(setContextRef),
        previousContext: void 0,
        props,
        state
      });
    }), _useState2 = _slicedToArray(_useState, 2), context2 = _useState2[0], setContext = _useState2[1];
    var dependencies = [...Object.values(props), state];
    react$1.exports.useEffect(() => {
      if (dependencies.length === 0) {
        return;
      }
      setContext((previousContext) => {
        return creator({
          get: createGet(contextRef),
          set: createSet(setContextRef),
          previousContext,
          props,
          state
        });
      });
    }, dependencies);
    contextRef.current = context2;
    setContextRef.current = setContext;
    return context2;
  });
}
function createGet(ref2) {
  return (pathOrSelector) => {
    if (!ref2.current) {
      throw new Error("`get` called outside of function scope. `get` can only be called within a function.");
    }
    if (!pathOrSelector) {
      return ref2.current;
    }
    if (typeof pathOrSelector !== "function") {
      throw new TypeError("Invalid arguments passed to `useContextHook`. The hook must be called with zero arguments, a getter function or a path string.");
    }
    return pathOrSelector(ref2.current);
  };
}
function createSet(ref2) {
  return (partial) => {
    if (!ref2.current) {
      throw new Error("`set` called outside of function scope. `set` can only be called within a function.");
    }
    ref2.current((context2) => _objectSpread2$3(_objectSpread2$3({}, context2), typeof partial === "function" ? partial(context2) : partial));
  };
}
var messages = {
  "components.image.dialog.description.label": "Image description",
  "components.image.dialog.description.placeholder": "Add a short description here.",
  "components.image.dialog.label": "Image",
  "components.image.dialog.source.label": "Image source",
  "components.image.menu.icon.label": "Image",
  "components.italic.menu.icon.label": "Italic",
  "components.underline.menu.icon.label": "Underline",
  "extension.command.add-annotation.label": "Add annotation",
  "extension.command.center-align.label": "Center align",
  "extension.command.convert-paragraph.description": "Convert current block into a paragraph block.",
  "extension.command.convert-paragraph.label": "Convert Paragraph",
  "extension.command.copy.description": "Copy the selected text",
  "extension.command.copy.label": "Copy",
  "extension.command.create-table.description": "Create a table with set number of rows and columns.",
  "extension.command.create-table.label": "Create table",
  "extension.command.cut.description": "Cut the selected text",
  "extension.command.cut.label": "Cut",
  "extension.command.decrease-font-size.description": "Decrease the font size.",
  "extension.command.decrease-font-size.label": "Decrease",
  "extension.command.decrease-indent.label": "Decrease indentation",
  "extension.command.increase-font-size.description": "Increase the font size",
  "extension.command.increase-font-size.label": "Increase",
  "extension.command.increase-indent.label": "Increase indentation",
  "extension.command.insert-emoji.label": "Insert Emoji",
  "extension.command.insert-paragraph.description": "Insert a new paragraph",
  "extension.command.insert-paragraph.label": "Insert Paragraph",
  "extension.command.justify-align.label": "Justify",
  "extension.command.left-align.label": "Left align",
  "extension.command.paste.description": "Paste content into the editor",
  "extension.command.paste.label": "Paste",
  "extension.command.redo.description": "Redo the most recent action",
  "extension.command.redo.label": "Redo",
  "extension.command.remove-annotation.label": "Remove annotation",
  "extension.command.right-align.label": "Right align",
  "extension.command.select-all.description": "Select all content within the editor",
  "extension.command.select-all.label": "Select all",
  "extension.command.set-casing.label": "Set text case",
  "extension.command.set-font-size.description": "Set the font size for the selected text.",
  "extension.command.set-font-size.label": "Font size",
  "extension.command.set-text-color.description": "Set the text color for the selected text.",
  "extension.command.set-text-color.label": "Text color",
  "extension.command.set-text-direction.description": [["dir", "select", {
    ltr: "Set the text direction from left to right",
    rtl: "Set the text direction from right to left",
    other: "Reset text direction"
  }]],
  "extension.command.set-text-direction.label": [["dir", "select", {
    ltr: "Left-To-Right",
    rtl: "Right-To-Left",
    other: "Reset Direction"
  }]],
  "extension.command.set-text-highlight.description": "Set the text highlight color for the selected text.",
  "extension.command.set-text-highlight.label": "Text highlight",
  "extension.command.toggle-blockquote.description": "Add blockquote formatting to the selected text",
  "extension.command.toggle-blockquote.label": "Blockquote",
  "extension.command.toggle-bold.description": "Add bold formatting to the selected text",
  "extension.command.toggle-bold.label": "Bold",
  "extension.command.toggle-bullet-list.description": "Bulleted list",
  "extension.command.toggle-callout.description": [["level", "select", {
    info: "Create an information callout block",
    warning: "Create a warning callout block",
    error: "Create an error callout block",
    success: "Create a success callout block",
    other: "Create a callout block"
  }]],
  "extension.command.toggle-callout.label": [["level", "select", {
    info: "Information Callout",
    warning: "Warning Callout",
    error: "Error Callout",
    success: "Success Callout",
    other: "Callout"
  }]],
  "extension.command.toggle-code-block.description": "Add a code block",
  "extension.command.toggle-code-block.label": "Codeblock",
  "extension.command.toggle-code.description": "Add inline code formatting to the selected text",
  "extension.command.toggle-code.label": "Code",
  "extension.command.toggle-columns.description": [["count", "select", {
    2: "Split the block into two columns",
    3: "Split the current block into three columns",
    4: "Split the current block into four columns",
    other: "Split the current block into multiple columns"
  }]],
  "extension.command.toggle-columns.label": [["count", "select", {
    2: "Two Column Block",
    3: "Three Column Block",
    4: "Four Column Block",
    other: "Multi Column Block"
  }]],
  "extension.command.toggle-heading.label": [["level", "select", {
    1: "Heading 1",
    2: "Heading 2",
    3: "Heading 3",
    4: "Heading 4",
    5: "Heading 5",
    6: "Heading 6",
    other: "Heading"
  }]],
  "extension.command.toggle-italic.description": "Italicize the selected text",
  "extension.command.toggle-italic.label": "Italic",
  "extension.command.toggle-ordered-list.label": "Ordered list",
  "extension.command.toggle-strike.description": "Strikethrough the selected text",
  "extension.command.toggle-strike.label": "Strikethrough",
  "extension.command.toggle-subscript.label": "Subscript",
  "extension.command.toggle-superscript.label": "Superscript",
  "extension.command.toggle-task-list.description": "Tasked list",
  "extension.command.toggle-underline.description": "Underline the selected text",
  "extension.command.toggle-underline.label": "Underline",
  "extension.command.toggle-upper-case.label": [["case", "select", {
    upper: "Uppercase",
    lower: "Lowercase",
    capitalize: "Sentence case",
    smallCaps: "Small caps",
    other: "Text case"
  }]],
  "extension.command.toggle-whitespace.description": "Show hidden whitespace characters in your editor.",
  "extension.command.toggle-whitespace.label": "Toggle Whitespace",
  "extension.command.undo.description": "Undo the most recent action",
  "extension.command.undo.label": "Undo",
  "extension.command.update-annotation.label": "Update annotation",
  "extension.table.column_count": [["count", "plural", {
    one: ["#", " column"],
    other: ["#", " columns"]
  }]],
  "extension.table.row_count": [["count", "plural", {
    one: ["#", " row"],
    other: ["#", " rows"]
  }]],
  "keyboard.shortcut.alt": "Alt",
  "keyboard.shortcut.arrowDown": "Arrow Down",
  "keyboard.shortcut.arrowLeft": "Arrow Left",
  "keyboard.shortcut.arrowRight": "Arrow Right",
  "keyboard.shortcut.arrowUp": "Arrow Up",
  "keyboard.shortcut.backspace": "Backspace",
  "keyboard.shortcut.capsLock": "Caps Lock",
  "keyboard.shortcut.command": "Command",
  "keyboard.shortcut.control": "Control",
  "keyboard.shortcut.delete": "Delete",
  "keyboard.shortcut.end": "End",
  "keyboard.shortcut.enter": "Enter",
  "keyboard.shortcut.escape": "Enter",
  "keyboard.shortcut.home": "Home",
  "keyboard.shortcut.pageDown": "Page Down",
  "keyboard.shortcut.pageUp": "Page Up",
  "keyboard.shortcut.shift": "Shift",
  "keyboard.shortcut.space": "Space",
  "keyboard.shortcut.tab": "Tab",
  "react-components.mention-atom-component.zero-items": "No items available",
  "react-components.top-menu.label": "Static Menu",
  "ui.text-color.black": "Black",
  "ui.text-color.blue": "Blue",
  "ui.text-color.blue.hue": ["Blue ", ["hue"]],
  "ui.text-color.cyan": "Cyan",
  "ui.text-color.cyan.hue": ["Cyan ", ["hue"]],
  "ui.text-color.grape": "Grape",
  "ui.text-color.grape.hue": ["Grape ", ["hue"]],
  "ui.text-color.gray": "Gray",
  "ui.text-color.gray.hue": ["Gray ", ["hue"]],
  "ui.text-color.green": "Green",
  "ui.text-color.green.hue": ["Green ", ["hue"]],
  "ui.text-color.indigo": "Indigo",
  "ui.text-color.indigo.hue": ["Indigo ", ["hue"]],
  "ui.text-color.lime": "Lime",
  "ui.text-color.lime.hue": ["Lime ", ["hue"]],
  "ui.text-color.orange": "Orange",
  "ui.text-color.orange.hue": ["Orange ", ["hue"]],
  "ui.text-color.pink": "Pink",
  "ui.text-color.pink.hue": ["Pink ", ["hue"]],
  "ui.text-color.red": "Red",
  "ui.text-color.red.hue": ["Red ", ["hue"]],
  "ui.text-color.teal": "Teal",
  "ui.text-color.teal.hue": ["Teal ", ["hue"]],
  "ui.text-color.transparent": "Transparent",
  "ui.text-color.violet": "Violet",
  "ui.text-color.violet.hue": ["Violet ", ["hue"]],
  "ui.text-color.white": "White",
  "ui.text-color.yellow": "Yellow",
  "ui.text-color.yellow.hue": ["Yellow ", ["hue"]]
};
function en(n2, ord) {
  var s2 = String(n2).split("."), v0 = !s2[1], t0 = Number(s2[0]) == n2, n10 = t0 && s2[0].slice(-1), n100 = t0 && s2[0].slice(-2);
  if (ord)
    return n10 == 1 && n100 != 11 ? "one" : n10 == 2 && n100 != 12 ? "two" : n10 == 3 && n100 != 13 ? "few" : "other";
  return n2 == 1 && v0 ? "one" : "other";
}
i18n.loadLocaleData("en", {
  plurals: en
});
i18n.load("en", messages);
i18n.activate("en");
var react = function equal2(a2, b) {
  if (a2 === b)
    return true;
  if (a2 && b && typeof a2 == "object" && typeof b == "object") {
    if (a2.constructor !== b.constructor)
      return false;
    var length, i2, keys2;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal2(a2[i2], b[i2]))
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b.source && a2.flags === b.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b.toString();
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys2[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!equal2(a2[key], b[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b !== b;
};
function useForceUpdate() {
  var _useState = react$1.exports.useState(object()), _useState2 = _slicedToArray(_useState, 2), setState = _useState2[1];
  return react$1.exports.useCallback(() => {
    setState(object());
  }, []);
}
var RemirrorContext = /* @__PURE__ */ react$1.exports.createContext(null);
function useRemirrorContext(handler) {
  var context2 = react$1.exports.useContext(RemirrorContext);
  var forceUpdate = react$1.exports.useRef(useForceUpdate());
  !context2 ? invariant(false, {
    code: ErrorConstant.REACT_PROVIDER_CONTEXT
  }) : void 0;
  var addHandler = context2.addHandler;
  react$1.exports.useEffect(() => {
    var updateHandler = handler;
    if (!updateHandler) {
      return;
    }
    if (isPlainObject$1(updateHandler)) {
      var _updateHandler = updateHandler, autoUpdate = _updateHandler.autoUpdate;
      updateHandler = autoUpdate ? () => forceUpdate.current() : void 0;
    }
    if (!isFunction$1(updateHandler)) {
      return;
    }
    return addHandler("updated", updateHandler);
  }, [addHandler, handler]);
  return context2;
}
function useActive() {
  var autoUpdate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  return useRemirrorContext({
    autoUpdate
  }).active;
}
function useChainedCommands() {
  return useRemirrorContext().chain;
}
function useCommands() {
  return useRemirrorContext().commands;
}
var useEffectWithWarning = (effect2, deps) => {
  var firstUpdate = react$1.exports.useRef(true);
  var ref2 = react$1.exports.useRef();
  var unnecessaryChange = react$1.exports.useRef(0);
  react$1.exports.useEffect(() => {
    if (firstUpdate.current) {
      firstUpdate.current = false;
      ref2.current = deps;
      return;
    }
    if (!react(deps, ref2.current)) {
      unnecessaryChange.current = 0;
      ref2.current = deps;
      return;
    }
    unnecessaryChange.current += 1;
  });
  var wrappedEffect = () => {
    if (unnecessaryChange.current > 0) {
      throw new Error("SERIOUS ".concat(unnecessaryChange.current));
    }
    warning$1(unnecessaryChange.current === 0, "The dependencies passed into your useEffect are identical, but an update has been triggered ".concat(unnecessaryChange.current, " time(s). Please consider wrapping the values with `useMemo` or `useCallback` to memoize your dependencies and prevent unnecessary re-renders."));
    return effect2();
  };
  react$1.exports.useEffect(wrappedEffect, deps);
};
function useExtension(Constructor) {
  var optionsOrCallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
  var dependencies = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var _useRemirrorContext = useRemirrorContext(), getExtension = _useRemirrorContext.getExtension;
  var extension2 = react$1.exports.useMemo(() => getExtension(Constructor), [Constructor, getExtension]);
  var deps = isFunction$1(optionsOrCallback) ? [extension2, ...dependencies] : optionsOrCallback ? [extension2, ...Object.values(optionsOrCallback)] : [];
  useEffectWithWarning(() => {
    if (isFunction$1(optionsOrCallback) || !optionsOrCallback) {
      return;
    }
    extension2.setOptions(optionsOrCallback);
  }, deps);
  useEffectWithWarning(() => {
    if (!isFunction$1(optionsOrCallback)) {
      return;
    }
    return optionsOrCallback({
      addHandler: extension2.addHandler.bind(extension2),
      addCustomHandler: extension2.addCustomHandler.bind(extension2),
      extension: extension2
    });
  }, deps);
  if (optionsOrCallback) {
    return;
  }
  return extension2;
}
function useHelpers() {
  var update2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  return useRemirrorContext(update2 ? {
    autoUpdate: true
  } : void 0).helpers;
}
var _createContextState = createContextState((_ref) => {
  var _props$locale, _props$i18n, _props$supportedLocal;
  var props = _ref.props;
  var locale = (_props$locale = props.locale) !== null && _props$locale !== void 0 ? _props$locale : "en";
  var i18n$12 = (_props$i18n = props.i18n) !== null && _props$i18n !== void 0 ? _props$i18n : i18n;
  var supportedLocales = (_props$supportedLocal = props.supportedLocales) !== null && _props$supportedLocal !== void 0 ? _props$supportedLocal : [locale];
  var t2 = function t3() {
    return i18n$12._(...arguments);
  };
  return {
    locale,
    i18n: i18n$12,
    supportedLocales,
    t: t2
  };
}), _createContextState2 = _slicedToArray(_createContextState, 2), I18nProvider = _createContextState2[0], useI18n = _createContextState2[1];
var _excluded$3$1 = ["core", "react"];
function createReactManager(extensions) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var core = options.core, react2 = options.react, settings = _objectWithoutProperties(options, _excluded$3$1);
  if (isRemirrorManager(extensions)) {
    return extensions;
  }
  return RemirrorManager.create(() => [...getLazyArray(extensions), new ReactExtension(react2), ...corePreset(core)], settings);
}
function useManager(extensions) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var extensionsRef = react$1.exports.useRef(extensions);
  var optionsRef = react$1.exports.useRef(options);
  var _useState = react$1.exports.useState(() => createReactManager(extensions, options)), _useState2 = _slicedToArray(_useState, 2), manager = _useState2[0], setManager = _useState2[1];
  extensionsRef.current = extensions;
  optionsRef.current = options;
  react$1.exports.useEffect(() => {
    return manager.addHandler("destroy", () => {
      setManager(() => createReactManager(extensionsRef.current, optionsRef.current));
    });
  }, [manager]);
  return manager;
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
var _excluded$2$1 = ["refKey", "ref"], _excluded2$8 = ["state"];
var _getShouldRenderClient = /* @__PURE__ */ new WeakMap();
var _setShouldRenderClient = /* @__PURE__ */ new WeakMap();
var _editorRef = /* @__PURE__ */ new WeakMap();
class ReactFramework extends Framework {
  get shouldRenderClient() {
    return _classPrivateFieldGet(this, _getShouldRenderClient).call(this);
  }
  get name() {
    return "react";
  }
  constructor(props) {
    var _this$props$placehold;
    super(props);
    _classPrivateFieldInitSpec(this, _getShouldRenderClient, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _setShouldRenderClient, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _editorRef, {
      writable: true,
      value: void 0
    });
    _defineProperty$3(this, "rootPropsConfig", {
      called: false,
      count: 0
    });
    _defineProperty$3(this, "getRootProps", (options) => {
      return this.internalGetRootProps(options, null);
    });
    _defineProperty$3(this, "internalGetRootProps", (options, children) => {
      this.rootPropsConfig.called = true;
      var _ref = options !== null && options !== void 0 ? options : object(), _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref2 = _ref.ref, config2 = _objectWithoutProperties(_ref, _excluded$2$1);
      return _objectSpread2$3(_objectSpread2$3({
        [refKey]: _default$2(ref2, this.onRef),
        key: this.uid
      }, config2), {}, {
        children: this.renderChildren(children)
      });
    });
    _defineProperty$3(this, "onRef", (element) => {
      if (!element) {
        return;
      }
      this.rootPropsConfig.count += 1;
      !(this.rootPropsConfig.count <= 1) ? invariant(false, {
        code: ErrorConstant.REACT_GET_ROOT_PROPS,
        message: "Called ".concat(this.rootPropsConfig.count, " times")
      }) : void 0;
      _classPrivateFieldSet(this, _editorRef, element);
      this.onRefLoad();
    });
    _defineProperty$3(this, "renderSsr", () => {
      var _this$props = this.props, suppressHydrationWarning = _this$props.suppressHydrationWarning, editable = _this$props.editable;
      if (shouldUseDomEnvironment(this.manager.settings.forceEnvironment) && (!suppressHydrationWarning || this.shouldRenderClient)) {
        return null;
      }
      return /* @__PURE__ */ jsx(RemirrorSSR, {
        attributes: this.getAttributes(true),
        state: this.getState(),
        manager: this.manager,
        editable: editable !== null && editable !== void 0 ? editable : true
      });
    });
    var getShouldRenderClient = props.getShouldRenderClient, setShouldRenderClient = props.setShouldRenderClient;
    _classPrivateFieldSet(this, _getShouldRenderClient, getShouldRenderClient);
    _classPrivateFieldSet(this, _setShouldRenderClient, setShouldRenderClient);
    if (this.manager.view) {
      this.manager.view.setProps({
        state: this.manager.view.state,
        dispatchTransaction: this.dispatchTransaction,
        attributes: () => this.getAttributes(),
        editable: () => {
          var _this$props$editable;
          return (_this$props$editable = this.props.editable) !== null && _this$props$editable !== void 0 ? _this$props$editable : true;
        }
      });
      return;
    }
    this.manager.getExtension(ReactPlaceholderExtension).setOptions({
      placeholder: (_this$props$placehold = this.props.placeholder) !== null && _this$props$placehold !== void 0 ? _this$props$placehold : ""
    });
  }
  update(props) {
    super.update(props);
    var getShouldRenderClient = props.getShouldRenderClient, setShouldRenderClient = props.setShouldRenderClient;
    _classPrivateFieldSet(this, _getShouldRenderClient, getShouldRenderClient);
    _classPrivateFieldSet(this, _setShouldRenderClient, setShouldRenderClient);
    return this;
  }
  createView(state) {
    return createEditorView(void 0, {
      state,
      dispatchTransaction: this.dispatchTransaction,
      attributes: () => this.getAttributes(),
      editable: () => {
        var _this$props$editable2;
        return (_this$props$editable2 = this.props.editable) !== null && _this$props$editable2 !== void 0 ? _this$props$editable2 : true;
      }
    }, this.manager.settings.forceEnvironment);
  }
  updateState(_ref2) {
    var state = _ref2.state, rest = _objectWithoutProperties(_ref2, _excluded2$8);
    var _rest$triggerChange = rest.triggerChange, triggerChange = _rest$triggerChange === void 0 ? true : _rest$triggerChange, tr = rest.tr, transactions = rest.transactions;
    if (this.props.state) {
      var onChange = this.props.onChange;
      !onChange ? invariant(false, {
        code: ErrorConstant.REACT_CONTROLLED,
        message: "You are required to provide the `onChange` handler when creating a controlled editor."
      }) : void 0;
      !triggerChange ? invariant(false, {
        code: ErrorConstant.REACT_CONTROLLED,
        message: "Controlled editors do not support `clearContent` or `setContent` where `triggerChange` is `true`. Update the `state` prop instead."
      }) : void 0;
      if (!this.previousStateOverride) {
        this.previousStateOverride = this.getState();
      }
      this.onChange({
        state,
        tr,
        transactions
      });
      return;
    }
    if (!tr && !transactions) {
      state = state.apply(state.tr.setMeta(STATE_OVERRIDE, {}));
    }
    this.view.updateState(state);
    if (triggerChange && (transactions === null || transactions === void 0 ? void 0 : transactions.length) !== 0) {
      this.onChange({
        state,
        tr,
        transactions
      });
    }
    this.manager.onStateUpdate({
      previousState: this.previousState,
      state,
      tr,
      transactions
    });
  }
  updateControlledState(state, previousState) {
    this.previousStateOverride = previousState;
    state = state.apply(state.tr.setMeta(STATE_OVERRIDE, {}));
    this.view.updateState(state);
    this.manager.onStateUpdate({
      previousState: this.previousState,
      state
    });
    this.previousStateOverride = void 0;
  }
  addProsemirrorViewToDom(element, viewDom) {
    if (this.props.insertPosition === "start") {
      element.insertBefore(viewDom, element.firstChild);
    } else {
      element.append(viewDom);
    }
  }
  onRefLoad() {
    !_classPrivateFieldGet(this, _editorRef) ? invariant(false, {
      code: ErrorConstant.REACT_EDITOR_VIEW,
      message: "Something went wrong when initializing the text editor. Please check your setup."
    }) : void 0;
    var autoFocus = this.props.autoFocus;
    this.addProsemirrorViewToDom(_classPrivateFieldGet(this, _editorRef), this.view.dom);
    if (autoFocus) {
      this.focus(autoFocus);
    }
    this.onChange();
    this.addFocusListeners();
  }
  onMount() {
    var suppressHydrationWarning = this.props.suppressHydrationWarning;
    if (suppressHydrationWarning) {
      _classPrivateFieldGet(this, _setShouldRenderClient).call(this, true);
    }
  }
  onUpdate() {
    if (this.view && _classPrivateFieldGet(this, _editorRef)) {
      this.view.setProps(_objectSpread2$3(_objectSpread2$3({}, this.view.props), {}, {
        editable: () => {
          var _this$props$editable3;
          return (_this$props$editable3 = this.props.editable) !== null && _this$props$editable3 !== void 0 ? _this$props$editable3 : true;
        }
      }));
    }
  }
  get frameworkOutput() {
    return _objectSpread2$3(_objectSpread2$3({}, this.baseOutput), {}, {
      getRootProps: this.getRootProps,
      portalContainer: this.manager.store.portalContainer,
      renderSsr: this.renderSsr
    });
  }
  renderChildren() {
    var child3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    var _this$props2 = this.props, _this$props2$insertPo = _this$props2.insertPosition, insertPosition = _this$props2$insertPo === void 0 ? "end" : _this$props2$insertPo, suppressHydrationWarning = _this$props2.suppressHydrationWarning;
    var children = isArray(child3) ? child3 : [child3];
    if (shouldUseDomEnvironment(this.manager.settings.forceEnvironment) && (!suppressHydrationWarning || this.shouldRenderClient)) {
      return children;
    }
    var ssrElement = this.renderSsr();
    return (insertPosition === "start" ? [ssrElement, ...children] : [...children, ssrElement]).map(addKeyToElement);
  }
  resetRender() {
    this.rootPropsConfig.called = false;
    this.rootPropsConfig.count = 0;
  }
}
function useReactFramework(props) {
  var _props$initialContent;
  var manager = props.manager, state = props.state;
  var placeholder = props.placeholder, editable = props.editable, suppressHydrationWarning = props.suppressHydrationWarning;
  var firstUpdate = react$1.exports.useRef(true);
  if (firstUpdate.current && !isNullOrUndefined(placeholder)) {
    manager.getExtension(ReactExtension).setOptions({
      placeholder
    });
  }
  react$1.exports.useEffect(() => {
    manager.getExtension(ReactExtension).setOptions({
      placeholder
    });
  }, [placeholder, manager]);
  var fallback = manager.createEmptyDoc();
  var _ref = isArray(props.initialContent) ? props.initialContent : [(_props$initialContent = props.initialContent) !== null && _props$initialContent !== void 0 ? _props$initialContent : fallback], _ref2 = _slicedToArray(_ref, 2), initialContent = _ref2[0], initialSelection = _ref2[1];
  var initialEditorState = state ? state : manager.createState({
    content: initialContent,
    selection: initialSelection
  });
  var _useState = react$1.exports.useState(suppressHydrationWarning ? false : void 0), _useState2 = _slicedToArray(_useState, 2), shouldRenderClient = _useState2[0], setShouldRenderClient = _useState2[1];
  var framework = useFramework({
    initialEditorState,
    setShouldRenderClient,
    getProps: () => props,
    getShouldRenderClient: () => shouldRenderClient
  });
  react$1.exports.useEffect(() => {
    framework.onMount();
    return () => {
      framework.destroy();
    };
  }, [framework]);
  react$1.exports.useEffect(() => {
    framework.onUpdate();
  }, [editable, framework]);
  useControlledEditor(framework);
  return framework.frameworkOutput;
}
function useFramework(props) {
  var propsRef = react$1.exports.useRef(props);
  propsRef.current = props;
  var framework = react$1.exports.useMemo(() => new ReactFramework(propsRef.current), []);
  framework.update(props);
  return framework;
}
function useControlledEditor(framework) {
  var state = framework.props.state;
  var isControlledRef = react$1.exports.useRef(!!state);
  var previousValue = usePrevious$1(state);
  index2(() => {
    var validUpdate = state ? isControlledRef.current === true : isControlledRef.current === false;
    !validUpdate ? invariant(false, {
      code: ErrorConstant.REACT_CONTROLLED,
      message: isControlledRef.current ? "You have attempted to switch from a controlled to an uncontrolled editor. Once you set up an editor as a controlled editor it must always provide a `state` prop." : "You have provided a `state` prop to an uncontrolled editor. In order to set up your editor as controlled you must provide the `state` prop from the very first render."
    }) : void 0;
    if (!state || state === previousValue) {
      return;
    }
    framework.updateControlledState(state, previousValue !== null && previousValue !== void 0 ? previousValue : void 0);
  }, [state, previousValue, framework]);
}
var _excluded$1$1 = ["content", "document", "selection", "extensions"];
function useRemirror() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var content2 = props.content;
  props.document;
  var selection = props.selection, extensions = props.extensions, settings = _objectWithoutProperties(props, _excluded$1$1);
  var manager = useManager(extensions !== null && extensions !== void 0 ? extensions : () => [], settings);
  var _useState = react$1.exports.useState(() => manager.createState({
    selection,
    content: content2 !== null && content2 !== void 0 ? content2 : manager.createEmptyDoc()
  })), _useState2 = _slicedToArray(_useState, 2), state = _useState2[0], setState = _useState2[1];
  var onChange = react$1.exports.useCallback((_ref) => {
    var state2 = _ref.state;
    setState(state2);
  }, []);
  var getContext = react$1.exports.useCallback(() => {
    var context2 = manager.output;
    return context2;
  }, [manager]);
  return react$1.exports.useMemo(() => ({
    state,
    setState,
    manager,
    onChange,
    getContext
  }), [getContext, manager, onChange, state]);
}
var _excluded$4 = ["children", "autoRender", "i18n", "locale", "supportedLocales", "hooks"];
var EditorComponent = () => {
  return /* @__PURE__ */ jsx("div", _objectSpread2$3({
    className: componentsTheme.EDITOR_WRAPPER
  }, useRemirrorContext().getRootProps()));
};
var HookComponent = (props) => {
  props.hook();
  return null;
};
function Remirror(props) {
  var children = props.children, autoRender = props.autoRender, i18n2 = props.i18n, locale = props.locale, supportedLocales = props.supportedLocales, _props$hooks = props.hooks, hooks = _props$hooks === void 0 ? [] : _props$hooks, frameworkProps = _objectWithoutProperties(props, _excluded$4);
  var context2 = useReactFramework(frameworkProps);
  var portals = usePortals(context2.portalContainer);
  var autoRenderAtStart = autoRender === "start" || autoRender === true || !children && isNullOrUndefined(autoRender);
  var autoRenderAtEnd = autoRender === "end";
  return /* @__PURE__ */ jsx(I18nProvider, {
    i18n: i18n2,
    locale,
    supportedLocales,
    children: /* @__PURE__ */ jsxs(RemirrorContext.Provider, {
      value: context2,
      children: [/* @__PURE__ */ jsx(RemirrorPortals, {
        portals
      }), hooks.map((hook, index3) => /* @__PURE__ */ jsx(HookComponent, {
        hook
      }, index3)), autoRenderAtStart && /* @__PURE__ */ jsx(EditorComponent, {}), children, autoRenderAtEnd && /* @__PURE__ */ jsx(EditorComponent, {})]
    })
  });
}
function useEvent(event, handler) {
  useExtension(EventsExtension, (_ref) => {
    var addHandler = _ref.addHandler;
    return addHandler(event, handler);
  }, [event, handler]);
}
function useEditorFocus() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _props$ignoredElement = props.ignoredElements, ignoredElements = _props$ignoredElement === void 0 ? [] : _props$ignoredElement, _props$blurOnInactive = props.blurOnInactive, blurOnInactive = _props$blurOnInactive === void 0 ? false : _props$blurOnInactive;
  var _useRemirrorContext = useRemirrorContext(), view = _useRemirrorContext.view, commands = _useRemirrorContext.commands;
  var _useState = react$1.exports.useState(() => view.hasFocus()), _useState2 = _slicedToArray(_useState, 2), isFocused = _useState2[0], setIsFocused = _useState2[1];
  useEvent("blur", react$1.exports.useCallback((event) => {
    var focusedElement = isElementDomNode(event.target) ? event.target : document.activeElement;
    var ignoreBlur = !blurOnInactive && !focusedElement;
    if (ignoreBlur || view.dom.contains(focusedElement)) {
      return false;
    }
    var _iterator = _createForOfIteratorHelper(ignoredElements), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var element = _step.value;
        if (element !== null && element !== void 0 && element.contains(focusedElement)) {
          return false;
        }
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    setIsFocused(false);
    return false;
  }, [blurOnInactive, ignoredElements, view.dom]));
  useEvent("focus", react$1.exports.useCallback((_2) => {
    if (isFocused) {
      return false;
    }
    setIsFocused(true);
    return false;
  }, [isFocused]));
  return [isFocused, commands.focus];
}
function useMultiPositioner(positioner, deps) {
  var _useState = react$1.exports.useState([]), _useState2 = _slicedToArray(_useState, 2), state = _useState2[0], setState = _useState2[1];
  var _useState3 = react$1.exports.useState(() => getPositioner(positioner)), _useState4 = _slicedToArray(_useState3, 2), memoizedPositioner = _useState4[0], setMemoizedPositioner = _useState4[1];
  var _useState5 = react$1.exports.useState([]), _useState6 = _slicedToArray(_useState5, 2), collectRefs = _useState6[0], setCollectRefs = _useState6[1];
  var positionerRef = react$1.exports.useRef(positioner);
  var previousPositioner = usePrevious$1(memoizedPositioner);
  positionerRef.current = positioner;
  useExtension(PositionerExtension, (_ref) => {
    var addCustomHandler = _ref.addCustomHandler;
    var positioner2 = getPositioner(positionerRef.current);
    var dispose = addCustomHandler("positioner", positioner2);
    setMemoizedPositioner(positioner2);
    return dispose;
  }, deps);
  index2(() => {
    var disposeUpdate = memoizedPositioner.addListener("update", (options) => {
      var items = [];
      var _iterator = _createForOfIteratorHelper(options), _step;
      try {
        var _loop = function _loop2() {
          var _step$value = _step.value, id = _step$value.id, setElement = _step$value.setElement;
          var ref2 = (element) => {
            if (!element) {
              return;
            }
            setElement(element);
          };
          items.push({
            id,
            ref: ref2
          });
        };
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          _loop();
        }
      } catch (err2) {
        _iterator.e(err2);
      } finally {
        _iterator.f();
      }
      setCollectRefs(items);
    });
    var disposeDone = memoizedPositioner.addListener("done", (options) => {
      setState(options);
    });
    if (previousPositioner !== null && previousPositioner !== void 0 && previousPositioner.recentUpdate) {
      memoizedPositioner.onActiveChanged(previousPositioner === null || previousPositioner === void 0 ? void 0 : previousPositioner.recentUpdate);
    }
    return () => {
      disposeUpdate();
      disposeDone();
    };
  }, [memoizedPositioner, previousPositioner]);
  return react$1.exports.useMemo(() => {
    var positions = [];
    var _iterator2 = _createForOfIteratorHelper(collectRefs.entries()), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _step2$value = _slicedToArray(_step2.value, 2), index3 = _step2$value[0], _step2$value$ = _step2$value[1], ref2 = _step2$value$.ref, key = _step2$value$.id;
        var stateValue = state[index3];
        var _ref2 = stateValue !== null && stateValue !== void 0 ? stateValue : {}, element = _ref2.element, _ref2$position = _ref2.position, position = _ref2$position === void 0 ? {} : _ref2$position;
        var absolutePosition = _objectSpread2$3(_objectSpread2$3({}, defaultAbsolutePosition), omitUndefined(position));
        positions.push(_objectSpread2$3({
          ref: ref2,
          element,
          key
        }, absolutePosition));
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
    return positions;
  }, [collectRefs, state]);
}
function usePositioner(positioner, activeOrDeps) {
  var deps = activeOrDeps == null || isBoolean(activeOrDeps) ? [positioner] : activeOrDeps;
  var isActive = isBoolean(activeOrDeps) ? activeOrDeps : true;
  var key = react$1.exports.useRef(uniqueId());
  var positions = useMultiPositioner(positioner, deps);
  var position = positions[0];
  return react$1.exports.useMemo(() => {
    if (position && isActive) {
      return _objectSpread2$3(_objectSpread2$3({}, position), {}, {
        active: true
      });
    }
    return _objectSpread2$3(_objectSpread2$3({}, defaultAbsolutePosition), {}, {
      active: false,
      key: key.current
    });
  }, [isActive, position]);
}
function useSuggest(props) {
  var _useRemirrorContext = useRemirrorContext(), helpers = _useRemirrorContext.helpers;
  var _useState = react$1.exports.useState(() => _objectSpread2$3({
    change: void 0,
    exit: void 0,
    shouldResetChangeState: false,
    shouldResetExitState: false
  }, helpers.getSuggestMethods())), _useState2 = _slicedToArray(_useState, 2), hookState = _useState2[0], setHookState = _useState2[1];
  var stateRef = react$1.exports.useRef({});
  var onChange = react$1.exports.useCallback((options) => {
    var changeReason = options.changeReason, exitReason = options.exitReason, match = options.match, query = options.query, text3 = options.text, range2 = options.range;
    var stateUpdate = _objectSpread2$3({}, stateRef.current);
    stateRef.current = {};
    if (changeReason) {
      stateUpdate.change = {
        match,
        query,
        text: text3,
        range: range2,
        reason: changeReason
      };
      stateUpdate.shouldResetChangeState = false;
      if (!exitReason) {
        stateUpdate.exit = void 0;
      }
    }
    if (exitReason) {
      stateUpdate.exit = {
        match,
        query,
        text: text3,
        range: range2,
        reason: exitReason
      };
      stateUpdate.shouldResetExitState = false;
      if (!changeReason) {
        stateUpdate.change = void 0;
      }
    }
    if (!isEmptyObject(stateUpdate)) {
      setHookState((prevState) => _objectSpread2$3(_objectSpread2$3({}, prevState), stateUpdate));
    }
  }, []);
  var onApplyState = react$1.exports.useCallback((_ref) => {
    var tr = _ref.tr, state = _ref.state, previousState = _ref.previousState;
    if (!hasStateChanged({
      tr,
      state,
      previousState
    }) || helpers.getSuggestState().removed) {
      return;
    }
    var stateUpdate = _objectSpread2$3({}, stateRef.current);
    if ((hookState.shouldResetChangeState || stateUpdate.shouldResetChangeState) && hookState.change) {
      stateUpdate.change = void 0;
    }
    if ((hookState.shouldResetExitState || stateUpdate.shouldResetExitState) && hookState.exit) {
      stateUpdate.exit = void 0;
    }
    if (!(hookState.shouldResetChangeState || stateUpdate.shouldResetChangeState) && hookState.change) {
      stateUpdate.shouldResetChangeState = true;
    }
    if (!(hookState.shouldResetExitState || stateUpdate.shouldResetExitState) && hookState.exit) {
      stateUpdate.shouldResetExitState = true;
    }
    stateRef.current = stateUpdate;
  }, [hookState, helpers]);
  useExtension(PluginsExtension, (p2) => p2.addHandler("applyState", onApplyState), [onApplyState]);
  useExtension(SuggestExtension, (p2) => p2.addCustomHandler("suggester", _objectSpread2$3(_objectSpread2$3({}, props), {}, {
    onChange
  })), [onChange, ...Object.values(props)]);
  return react$1.exports.useMemo(() => ({
    addIgnored: hookState.addIgnored,
    change: hookState.change,
    exit: hookState.exit,
    clearIgnored: hookState.clearIgnored,
    ignoreNextExit: hookState.ignoreNextExit,
    removeIgnored: hookState.removeIgnored,
    setMarkRemoved: hookState.setMarkRemoved
  }), [hookState.addIgnored, hookState.change, hookState.clearIgnored, hookState.exit, hookState.ignoreNextExit, hookState.removeIgnored, hookState.setMarkRemoved]);
}
var BOX_KEYS = ["unstable_system"];
var useBox = createHook({
  name: "Box",
  keys: BOX_KEYS,
  propsAreEqual: function propsAreEqual5(prev, next) {
    var prevSystem = prev.unstable_system, prevProps = _objectWithoutPropertiesLoose$2(prev, ["unstable_system"]);
    var nextSystem = next.unstable_system, nextProps = _objectWithoutPropertiesLoose$2(next, ["unstable_system"]);
    if (prevSystem !== nextSystem && !shallowEqual(prevSystem, nextSystem)) {
      return false;
    }
    return shallowEqual(prevProps, nextProps);
  }
});
var Box = createComponent({
  as: "div",
  useHook: useBox
});
var TOOLTIP_STATE_KEYS = ["baseId", "unstable_idCountRef", "visible", "animated", "animating", "setBaseId", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation", "unstable_disclosureRef", "unstable_referenceRef", "unstable_popoverRef", "unstable_arrowRef", "unstable_popoverStyles", "unstable_arrowStyles", "unstable_originalPlacement", "unstable_update", "placement", "place", "unstable_timeout", "unstable_setTimeout"];
var TOOLTIP_KEYS = [].concat(TOOLTIP_STATE_KEYS, ["unstable_portal"]);
var TOOLTIP_ARROW_KEYS = TOOLTIP_STATE_KEYS;
var TOOLTIP_REFERENCE_KEYS = TOOLTIP_ARROW_KEYS;
var globalState = {
  currentTooltipId: null,
  listeners: /* @__PURE__ */ new Set(),
  subscribe: function subscribe(listener) {
    var _this = this;
    this.listeners.add(listener);
    return function() {
      _this.listeners.delete(listener);
    };
  },
  show: function show(id) {
    this.currentTooltipId = id;
    this.listeners.forEach(function(listener) {
      return listener(id);
    });
  },
  hide: function hide2(id) {
    if (this.currentTooltipId === id) {
      this.currentTooltipId = null;
      this.listeners.forEach(function(listener) {
        return listener(null);
      });
    }
  }
};
function globallyHideTooltipOnEscape(event) {
  if (event.defaultPrevented)
    return;
  if (event.key === "Escape") {
    globalState.show(null);
  }
}
var useTooltip = createHook({
  name: "Tooltip",
  compose: useDisclosureContent,
  keys: TOOLTIP_KEYS,
  useOptions: function useOptions12(_ref) {
    var _ref$unstable_portal = _ref.unstable_portal, unstable_portal = _ref$unstable_portal === void 0 ? true : _ref$unstable_portal, options = _objectWithoutPropertiesLoose$2(_ref, ["unstable_portal"]);
    return _objectSpread2$2({
      unstable_portal
    }, options);
  },
  useProps: function useProps20(options, _ref2) {
    var htmlRef = _ref2.ref, htmlStyle = _ref2.style, htmlWrapElement = _ref2.wrapElement, htmlProps = _objectWithoutPropertiesLoose$2(_ref2, ["ref", "style", "wrapElement"]);
    react$1.exports.useEffect(function() {
      var _options$unstable_pop;
      var document2 = getDocument((_options$unstable_pop = options.unstable_popoverRef) === null || _options$unstable_pop === void 0 ? void 0 : _options$unstable_pop.current);
      document2.addEventListener("keydown", globallyHideTooltipOnEscape);
    }, []);
    var wrapElement = react$1.exports.useCallback(function(element) {
      if (options.unstable_portal) {
        element = /* @__PURE__ */ react$1.exports.createElement(Portal, null, element);
      }
      if (htmlWrapElement) {
        return htmlWrapElement(element);
      }
      return element;
    }, [options.unstable_portal, htmlWrapElement]);
    return _objectSpread2$2({
      ref: useForkRef(options.unstable_popoverRef, htmlRef),
      role: "tooltip",
      style: _objectSpread2$2(_objectSpread2$2({}, options.unstable_popoverStyles), {}, {
        pointerEvents: "none"
      }, htmlStyle),
      wrapElement
    }, htmlProps);
  }
});
var Tooltip = createComponent({
  as: "div",
  memo: true,
  useHook: useTooltip
});
var useTooltipReference = createHook({
  name: "TooltipReference",
  compose: useRole,
  keys: TOOLTIP_REFERENCE_KEYS,
  useProps: function useProps21(options, _ref) {
    var htmlRef = _ref.ref, htmlOnFocus = _ref.onFocus, htmlOnBlur = _ref.onBlur, htmlOnMouseEnter = _ref.onMouseEnter, htmlOnMouseLeave = _ref.onMouseLeave, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["ref", "onFocus", "onBlur", "onMouseEnter", "onMouseLeave"]);
    var onFocusRef = useLiveRef(htmlOnFocus);
    var onBlurRef = useLiveRef(htmlOnBlur);
    var onMouseEnterRef = useLiveRef(htmlOnMouseEnter);
    var onMouseLeaveRef = useLiveRef(htmlOnMouseLeave);
    var onFocus = react$1.exports.useCallback(function(event) {
      var _onFocusRef$current, _options$show;
      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
      if (event.defaultPrevented)
        return;
      (_options$show = options.show) === null || _options$show === void 0 ? void 0 : _options$show.call(options);
    }, [options.show]);
    var onBlur = react$1.exports.useCallback(function(event) {
      var _onBlurRef$current, _options$hide;
      (_onBlurRef$current = onBlurRef.current) === null || _onBlurRef$current === void 0 ? void 0 : _onBlurRef$current.call(onBlurRef, event);
      if (event.defaultPrevented)
        return;
      (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
    }, [options.hide]);
    var onMouseEnter = react$1.exports.useCallback(function(event) {
      var _onMouseEnterRef$curr, _options$show2;
      (_onMouseEnterRef$curr = onMouseEnterRef.current) === null || _onMouseEnterRef$curr === void 0 ? void 0 : _onMouseEnterRef$curr.call(onMouseEnterRef, event);
      if (event.defaultPrevented)
        return;
      (_options$show2 = options.show) === null || _options$show2 === void 0 ? void 0 : _options$show2.call(options);
    }, [options.show]);
    var onMouseLeave = react$1.exports.useCallback(function(event) {
      var _onMouseLeaveRef$curr, _options$hide2;
      (_onMouseLeaveRef$curr = onMouseLeaveRef.current) === null || _onMouseLeaveRef$curr === void 0 ? void 0 : _onMouseLeaveRef$curr.call(onMouseLeaveRef, event);
      if (event.defaultPrevented)
        return;
      (_options$hide2 = options.hide) === null || _options$hide2 === void 0 ? void 0 : _options$hide2.call(options);
    }, [options.hide]);
    return _objectSpread2$2({
      ref: useForkRef(options.unstable_referenceRef, htmlRef),
      tabIndex: 0,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      "aria-describedby": options.baseId
    }, htmlProps);
  }
});
var TooltipReference = createComponent({
  as: "div",
  useHook: useTooltipReference
});
function useTooltipState(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var _useSealedState = useSealedState(initialState2), _useSealedState$place = _useSealedState.placement, placement = _useSealedState$place === void 0 ? "top" : _useSealedState$place, _useSealedState$unsta = _useSealedState.unstable_timeout, initialTimeout = _useSealedState$unsta === void 0 ? 0 : _useSealedState$unsta, sealed = _objectWithoutPropertiesLoose$2(_useSealedState, ["placement", "unstable_timeout"]);
  var _React$useState = react$1.exports.useState(initialTimeout), timeout = _React$useState[0], setTimeout2 = _React$useState[1];
  var showTimeout = react$1.exports.useRef(null);
  var hideTimeout = react$1.exports.useRef(null);
  var _usePopoverState = usePopoverState(_objectSpread2$2(_objectSpread2$2({}, sealed), {}, {
    placement
  }));
  _usePopoverState.modal;
  _usePopoverState.setModal;
  var popover = _objectWithoutPropertiesLoose$2(_usePopoverState, ["modal", "setModal"]);
  var clearTimeouts = react$1.exports.useCallback(function() {
    if (showTimeout.current !== null) {
      window.clearTimeout(showTimeout.current);
    }
    if (hideTimeout.current !== null) {
      window.clearTimeout(hideTimeout.current);
    }
  }, []);
  var hide3 = react$1.exports.useCallback(function() {
    clearTimeouts();
    popover.hide();
    hideTimeout.current = window.setTimeout(function() {
      globalState.hide(popover.baseId);
    }, timeout);
  }, [clearTimeouts, popover.hide, timeout, popover.baseId]);
  var show2 = react$1.exports.useCallback(function() {
    clearTimeouts();
    if (!timeout || globalState.currentTooltipId) {
      globalState.show(popover.baseId);
      popover.show();
    } else {
      globalState.show(null);
      showTimeout.current = window.setTimeout(function() {
        globalState.show(popover.baseId);
        popover.show();
      }, timeout);
    }
  }, [clearTimeouts, timeout, popover.show, popover.baseId]);
  react$1.exports.useEffect(function() {
    return globalState.subscribe(function(id) {
      if (id !== popover.baseId) {
        clearTimeouts();
        if (popover.visible) {
          popover.hide();
        }
      }
    });
  }, [popover.baseId, clearTimeouts, popover.visible, popover.hide]);
  react$1.exports.useEffect(function() {
    return function() {
      clearTimeouts();
      globalState.hide(popover.baseId);
    };
  }, [clearTimeouts, popover.baseId]);
  return _objectSpread2$2(_objectSpread2$2({}, popover), {}, {
    hide: hide3,
    show: show2,
    unstable_timeout: timeout,
    unstable_setTimeout: setTimeout2
  });
}
var ab = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M5 15v2c0 1.054.95 2 2 2h3v2H7a4 4 0 0 1-4-4v-2h2zm13-5l4.4 11h-2.155l-1.201-3h-4.09l-1.199 3h-2.154L16 10h2zm-1 2.885L15.753 16h2.492L17 12.885zM3 3h6a3 3 0 0 1 2.235 5A3 3 0 0 1 9 13H3V3zm6 6H5v2h4a1 1 0 0 0 0-2zm8-6a4 4 0 0 1 4 4v2h-2V7a2 2 0 0 0-2-2h-3V3h3zM9 5H5v2h4a1 1 0 1 0 0-2z"
  }
}];
var addFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"
  }
}];
var addLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"
  }
}];
var alertLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    fillRule: "nonzero",
    d: "M12.866 3l9.526 16.5a1 1 0 0 1-.866 1.5H2.474a1 1 0 0 1-.866-1.5L11.134 3a1 1 0 0 1 1.732 0zm-8.66 16h15.588L12 5.5 4.206 19zM11 16h2v2h-2v-2zm0-7h2v5h-2V9z"
  }
}];
var alignBottom = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 19h18v2H3v-2zm5-6h3l-4 4-4-4h3V3h2v10zm10 0h3l-4 4-4-4h3V3h2v10z"
  }
}];
var alignCenter = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z"
  }
}];
var alignJustify = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 4h18v2H3V4zm0 15h18v2H3v-2zm0-5h18v2H3v-2zm0-5h18v2H3V9z"
  }
}];
var alignLeft = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z"
  }
}];
var alignRight = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z"
  }
}];
var alignTop = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 3h18v2H3V3zm5 8v10H6V11H3l4-4 4 4H8zm10 0v10h-2V11h-3l4-4 4 4h-3z"
  }
}];
var alignVertically = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 11h18v2H3v-2zm15 7v3h-2v-3h-3l4-4 4 4h-3zM8 18v3H6v-3H3l4-4 4 4H8zM18 6h3l-4 4-4-4h3V3h2v3zM8 6h3l-4 4-4-4h3V3h2v3z"
  }
}];
var appsLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M6.75 2.5A4.25 4.25 0 0 1 11 6.75V11H6.75a4.25 4.25 0 1 1 0-8.5zM9 9V6.75A2.25 2.25 0 1 0 6.75 9H9zm-2.25 4H11v4.25A4.25 4.25 0 1 1 6.75 13zm0 2A2.25 2.25 0 1 0 9 17.25V15H6.75zm10.5-12.5a4.25 4.25 0 1 1 0 8.5H13V6.75a4.25 4.25 0 0 1 4.25-4.25zm0 6.5A2.25 2.25 0 1 0 15 6.75V9h2.25zM13 13h4.25A4.25 4.25 0 1 1 13 17.25V13zm2 2v2.25A2.25 2.25 0 1 0 17.25 15H15z"
  }
}];
var arrowDownSFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 16l-6-6h12z"
  }
}];
var arrowGoBackFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M8 7v4L2 6l6-5v4h5a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H8z"
  }
}];
var arrowGoForwardFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M16 7h-5a6 6 0 1 0 0 12h9v2h-9a8 8 0 1 1 0-16h5V1l6 5-6 5V7z"
  }
}];
var arrowLeftSFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M8 12l6-6v12z"
  }
}];
var arrowRightSFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M16 12l-6 6V6z"
  }
}];
var arrowUpSFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 8l6 6H6z"
  }
}];
var asterisk = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M13 3v7.267l6.294-3.633 1 1.732-6.293 3.633 6.293 3.635-1 1.732L13 13.732V21h-2v-7.268l-6.294 3.634-1-1.732L9.999 12 3.706 8.366l1-1.732L11 10.267V3z"
  }
}];
var attachment2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M14.828 7.757l-5.656 5.657a1 1 0 1 0 1.414 1.414l5.657-5.656A3 3 0 1 0 12 4.929l-5.657 5.657a5 5 0 1 0 7.071 7.07L19.071 12l1.414 1.414-5.657 5.657a7 7 0 1 1-9.9-9.9l5.658-5.656a5 5 0 0 1 7.07 7.07L12 16.244A3 3 0 1 1 7.757 12l5.657-5.657 1.414 1.414z"
  }
}];
var bold = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M8 11h4.5a2.5 2.5 0 1 0 0-5H8v5zm10 4.5a4.5 4.5 0 0 1-4.5 4.5H6V4h6.5a4.5 4.5 0 0 1 3.256 7.606A4.498 4.498 0 0 1 18 15.5zM8 13v5h5.5a2.5 2.5 0 1 0 0-5H8z"
  }
}];
var bracesLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M4 18v-3.7a1.5 1.5 0 0 0-1.5-1.5H2v-1.6h.5A1.5 1.5 0 0 0 4 9.7V6a3 3 0 0 1 3-3h1v2H7a1 1 0 0 0-1 1v4.1A2 2 0 0 1 4.626 12 2 2 0 0 1 6 13.9V18a1 1 0 0 0 1 1h1v2H7a3 3 0 0 1-3-3zm16-3.7V18a3 3 0 0 1-3 3h-1v-2h1a1 1 0 0 0 1-1v-4.1a2 2 0 0 1 1.374-1.9A2 2 0 0 1 18 10.1V6a1 1 0 0 0-1-1h-1V3h1a3 3 0 0 1 3 3v3.7a1.5 1.5 0 0 0 1.5 1.5h.5v1.6h-.5a1.5 1.5 0 0 0-1.5 1.5z"
  }
}];
var bringForward = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M14 3c.552 0 1 .448 1 1v5h5c.552 0 1 .448 1 1v10c0 .552-.448 1-1 1H10c-.552 0-1-.448-1-1v-5H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h10zm-1 2H5v8h8V5z"
  }
}];
var bringToFront = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 3c.552 0 1 .448 1 1v2h5c.552 0 1 .448 1 1v5h2c.552 0 1 .448 1 1v7c0 .552-.448 1-1 1h-7c-.552 0-1-.448-1-1v-2H7c-.552 0-1-.448-1-1v-5H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h7zm5 5H8v8h8V8z"
  }
}];
var chatNewLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M14 3v2H4v13.385L5.763 17H20v-7h2v8a1 1 0 0 1-1 1H6.455L2 22.5V4a1 1 0 0 1 1-1h11zm5 0V0h2v3h3v2h-3v3h-2V5h-3V3h3z"
  }
}];
var checkboxCircleLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm-.997-4L6.76 11.757l1.414-1.414 2.829 2.829 5.656-5.657 1.415 1.414L11.003 16z"
  }
}];
var clipboardFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M6 4v4h12V4h2.007c.548 0 .993.445.993.993v16.014a.994.994 0 0 1-.993.993H3.993A.994.994 0 0 1 3 21.007V4.993C3 4.445 3.445 4 3.993 4H6zm2-2h8v4H8V2z"
  }
}];
var clipboardLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M7 4V2h10v2h3.007c.548 0 .993.445.993.993v16.014a.994.994 0 0 1-.993.993H3.993A.994.994 0 0 1 3 21.007V4.993C3 4.445 3.445 4 3.993 4H7zm0 2H5v14h14V6h-2v2H7V6zm2-2v2h6V4H9z"
  }
}];
var closeCircleLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm0-9.414l2.828-2.829 1.415 1.415L13.414 12l2.829 2.828-1.415 1.415L12 13.414l-2.828 2.829-1.415-1.415L10.586 12 7.757 9.172l1.415-1.415L12 10.586z"
  }
}];
var closeFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"
  }
}];
var closeLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"
  }
}];
var codeLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M23 12l-7.071 7.071-1.414-1.414L20.172 12l-5.657-5.657 1.414-1.414L23 12zM3.828 12l5.657 5.657-1.414 1.414L1 12l7.071-7.071 1.414 1.414L3.828 12z"
  }
}];
var codeView = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M16.95 8.464l1.414-1.414 4.95 4.95-4.95 4.95-1.414-1.414L20.485 12 16.95 8.464zm-9.9 0L3.515 12l3.535 3.536-1.414 1.414L.686 12l4.95-4.95L7.05 8.464z"
  }
}];
var deleteBinFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M17 6h5v2h-2v13a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8H2V6h5V3a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v3zm-8 5v6h2v-6H9zm4 0v6h2v-6h-2zM9 4v2h6V4H9z"
  }
}];
var deleteBinLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M17 6h5v2h-2v13a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8H2V6h5V3a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v3zm1 2H6v12h12V8zm-9 3h2v6H9v-6zm4 0h2v6h-2v-6zM9 4v2h6V4H9z"
  }
}];
var deleteColumn = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 3c.552 0 1 .448 1 1v8c.835-.628 1.874-1 3-1 2.761 0 5 2.239 5 5s-2.239 5-5 5c-1.032 0-1.99-.313-2.787-.848L13 20c0 .552-.448 1-1 1H6c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h6zm-1 2H7v14h4V5zm8 10h-6v2h6v-2z"
  }
}];
var deleteRow = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M20 5c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1 .628.835 1 1.874 1 3 0 2.761-2.239 5-5 5s-5-2.239-5-5c0-1.126.372-2.165 1-3H4c-.552 0-1-.448-1-1V6c0-.552.448-1 1-1h16zm-7 10v2h6v-2h-6zm6-8H5v4h14V7z"
  }
}];
var doubleQuotesL = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M4.583 17.321C3.553 16.227 3 15 3 13.011c0-3.5 2.457-6.637 6.03-8.188l.893 1.378c-3.335 1.804-3.987 4.145-4.247 5.621.537-.278 1.24-.375 1.929-.311 1.804.167 3.226 1.648 3.226 3.489a3.5 3.5 0 0 1-3.5 3.5c-1.073 0-2.099-.49-2.748-1.179zm10 0C13.553 16.227 13 15 13 13.011c0-3.5 2.457-6.637 6.03-8.188l.893 1.378c-3.335 1.804-3.987 4.145-4.247 5.621.537-.278 1.24-.375 1.929-.311 1.804.167 3.226 1.648 3.226 3.489a3.5 3.5 0 0 1-3.5 3.5c-1.073 0-2.099-.49-2.748-1.179z"
  }
}];
var doubleQuotesR = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M19.417 6.679C20.447 7.773 21 9 21 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311-1.804-.167-3.226-1.648-3.226-3.489a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179zm-10 0C10.447 7.773 11 9 11 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311C4.591 12.322 3.17 10.841 3.17 9a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179z"
  }
}];
var download2Fill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M4 19h16v-7h2v8a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-8h2v7zM14 9h5l-7 7-7-7h5V3h4v6z"
  }
}];
var dragDropLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    fillRule: "nonzero",
    d: "M16 13l6.964 4.062-2.973.85 2.125 3.681-1.732 1-2.125-3.68-2.223 2.15L16 13zm-2-7h2v2h5a1 1 0 0 1 1 1v4h-2v-3H10v10h4v2H9a1 1 0 0 1-1-1v-5H6v-2h2V9a1 1 0 0 1 1-1h5V6zM4 14v2H2v-2h2zm0-4v2H2v-2h2zm0-4v2H2V6h2zm0-4v2H2V2h2zm4 0v2H6V2h2zm4 0v2h-2V2h2zm4 0v2h-2V2h2z"
  }
}];
var emphasisCn = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 19a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm-5.5 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm11 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zM13 2v2h6v2h-1.968a18.222 18.222 0 0 1-3.621 6.302 14.685 14.685 0 0 0 5.327 3.042l-.536 1.93A16.685 16.685 0 0 1 12 13.726a16.696 16.696 0 0 1-6.202 3.547l-.536-1.929a14.7 14.7 0 0 0 5.327-3.042 18.077 18.077 0 0 1-2.822-4.3h2.24A16.031 16.031 0 0 0 12 10.876a16.168 16.168 0 0 0 2.91-4.876L5 6V4h6V2h2z"
  }
}];
var emphasis = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 19a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm-5.5 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm11 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zM18 3v2H8v4h9v2H8v4h10v2H6V3h12z"
  }
}];
var englishInput = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M14 10h2v.757a4.5 4.5 0 0 1 7 3.743V20h-2v-5.5c0-1.43-1.175-2.5-2.5-2.5S16 13.07 16 14.5V20h-2V10zm-2-6v2H4v5h8v2H4v5h8v2H2V4h10z"
  }
}];
var errorWarningLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm-1-5h2v2h-2v-2zm0-8h2v6h-2V7z"
  }
}];
var externalLinkFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M10 6v2H5v11h11v-5h2v6a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm11-3v9l-3.794-3.793-5.999 6-1.414-1.414 5.999-6L12 3h9z"
  }
}];
var fileCopyLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M7 6V3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1h-3v3c0 .552-.45 1-1.007 1H4.007A1.001 1.001 0 0 1 3 21l.003-14c0-.552.45-1 1.007-1H7zM5.003 8L5 20h10V8H5.003zM9 6h8v10h2V4H9v2z"
  }
}];
var flowChart = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M6 21.5c-1.933 0-3.5-1.567-3.5-3.5s1.567-3.5 3.5-3.5c1.585 0 2.924 1.054 3.355 2.5H15v-2h2V9.242L14.757 7H9V9H3V3h6v2h5.757L18 1.756 22.243 6 19 9.241V15L21 15v6h-6v-2H9.355c-.43 1.446-1.77 2.5-3.355 2.5zm0-5c-.828 0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5 1.5-.672 1.5-1.5-.672-1.5-1.5-1.5zm13 .5h-2v2h2v-2zM18 4.586L16.586 6 18 7.414 19.414 6 18 4.586zM7 5H5v2h2V5z"
  }
}];
var fontColor = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M15.246 14H8.754l-1.6 4H5l6-15h2l6 15h-2.154l-1.6-4zm-.8-2L12 5.885 9.554 12h4.892zM3 20h18v2H3v-2z"
  }
}];
var fontSize2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M10 6v15H8V6H2V4h14v2h-6zm8 8v7h-2v-7h-3v-2h8v2h-3z"
  }
}];
var fontSize = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"
  }
}];
var formatClear = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12.651 14.065L11.605 20H9.574l1.35-7.661-7.41-7.41L4.93 3.515 20.485 19.07l-1.414 1.414-6.42-6.42zm-.878-6.535l.27-1.53h-1.8l-2-2H20v2h-5.927L13.5 9.257 11.773 7.53z"
  }
}];
var fullscreenExitLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"
  }
}];
var fullscreenLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M20 3h2v6h-2V5h-4V3h4zM4 3h4v2H4v4H2V3h2zm16 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"
  }
}];
var functions = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M5 18l7.68-6L5 6V4h14v2H8.263L16 12l-7.737 6H19v2H5v-2z"
  }
}];
var galleryUploadLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M8 1v4H4v14h16V3h1.008c.548 0 .992.445.992.993v16.014a1 1 0 0 1-.992.993H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3H6V1h2zm4 7l4 4h-3v4h-2v-4H8l4-4zm6-7v4h-8V3h6V1h2z"
  }
}];
var h1 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm8-12v12h-2v-9.796l-2 .536V8.67L19.5 8H21z"
  }
}];
var h2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 4c2.071 0 3.75 1.679 3.75 3.75 0 .857-.288 1.648-.772 2.28l-.148.18L18.034 18H22v2h-7v-1.556l4.82-5.546c.268-.307.43-.709.43-1.148 0-.966-.784-1.75-1.75-1.75-.918 0-1.671.707-1.744 1.606l-.006.144h-2C14.75 9.679 16.429 8 18.5 8z"
  }
}];
var h3 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M22 8l-.002 2-2.505 2.883c1.59.435 2.757 1.89 2.757 3.617 0 2.071-1.679 3.75-3.75 3.75-1.826 0-3.347-1.305-3.682-3.033l1.964-.382c.156.806.866 1.415 1.718 1.415.966 0 1.75-.784 1.75-1.75s-.784-1.75-1.75-1.75c-.286 0-.556.069-.794.19l-1.307-1.547L19.35 10H15V8h7zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z"
  }
}];
var h4 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm9-12v8h1.5v2H22v2h-2v-2h-5.5v-1.34l5-8.66H22zm-2 3.133L17.19 16H20v-4.867z"
  }
}];
var h5 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M22 8v2h-4.323l-.464 2.636c.33-.089.678-.136 1.037-.136 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.827 0-3.367-1.224-3.846-2.897l1.923-.551c.24.836 1.01 1.448 1.923 1.448 1.105 0 2-.895 2-2s-.895-2-2-2c-.63 0-1.193.292-1.56.748l-1.81-.904L16 8h6zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z"
  }
}];
var h6 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M21.097 8l-2.598 4.5c2.21 0 4.001 1.79 4.001 4s-1.79 4-4 4-4-1.79-4-4c0-.736.199-1.426.546-2.019L18.788 8h2.309zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 10.5c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z"
  }
}];
var hashtag = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M7.784 14l.42-4H4V8h4.415l.525-5h2.011l-.525 5h3.989l.525-5h2.011l-.525 5H20v2h-3.784l-.42 4H20v2h-4.415l-.525 5h-2.011l.525-5H9.585l-.525 5H7.049l.525-5H4v-2h3.784zm2.011 0h3.99l.42-4h-3.99l-.42 4z"
  }
}];
var heading = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M17 11V4h2v17h-2v-8H7v8H5V4h2v7z"
  }
}];
var imageAddLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M21 15v3h3v2h-3v3h-2v-3h-3v-2h3v-3h2zm.008-12c.548 0 .992.445.992.993V13h-2V5H4v13.999L14 9l3 3v2.829l-3-3L6.827 19H14v2H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3h18.016zM8 7a2 2 0 1 1 0 4 2 2 0 0 1 0-4z"
  }
}];
var imageEditLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M20 3c.552 0 1 .448 1 1v1.757l-2 2V5H5v8.1l4-4 4.328 4.329-1.415 1.413L9 11.93l-4 3.999V19h10.533l.708.001 1.329-1.33L18.9 19h.1v-2.758l2-2V20c0 .552-.448 1-1 1H4c-.55 0-1-.45-1-1V4c0-.552.448-1 1-1h16zm1.778 4.808l1.414 1.414L15.414 17l-1.416-.002.002-1.412 7.778-7.778zM15.5 7c.828 0 1.5.672 1.5 1.5s-.672 1.5-1.5 1.5S14 9.328 14 8.5 14.672 7 15.5 7z"
  }
}];
var imageLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M4.828 21l-.02.02-.021-.02H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3h18.016c.548 0 .992.445.992.993v16.014a1 1 0 0 1-.992.993H4.828zM20 15V5H4v14L14 9l6 6zm0 2.828l-6-6L6.828 19H20v-1.172zM8 11a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"
  }
}];
var indentDecrease = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 4h18v2H3V4zm0 15h18v2H3v-2zm8-5h10v2H11v-2zm0-5h10v2H11V9zm-8 3.5L7 9v7l-4-3.5z"
  }
}];
var indentIncrease = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 4h18v2H3V4zm0 15h18v2H3v-2zm8-5h10v2H11v-2zm0-5h10v2H11V9zm-4 3.5L3 16V9l4 3.5z"
  }
}];
var informationLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zM11 7h2v2h-2V7zm0 4h2v6h-2v-6z"
  }
}];
var inputCursorMove = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M8 21v-2h3V5H8V3h8v2h-3v14h3v2H8zM18.05 7.05L23 12l-4.95 4.95-1.414-1.414L20.172 12l-3.536-3.536L18.05 7.05zm-12.1 0l1.414 1.414L3.828 12l3.536 3.536L5.95 16.95 1 12l4.95-4.95z"
  }
}];
var insertColumnLeft = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M20 3c.552 0 1 .448 1 1v16c0 .552-.448 1-1 1h-6c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h6zm-1 2h-4v14h4V5zM6 7c2.761 0 5 2.239 5 5s-2.239 5-5 5-5-2.239-5-5 2.239-5 5-5zm1 2H5v1.999L3 11v2l2-.001V15h2v-2.001L9 13v-2l-2-.001V9z"
  }
}];
var insertColumnRight = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M10 3c.552 0 1 .448 1 1v16c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h6zM9 5H5v14h4V5zm9 2c2.761 0 5 2.239 5 5s-2.239 5-5 5-5-2.239-5-5 2.239-5 5-5zm1 2h-2v1.999L15 11v2l2-.001V15h2v-2.001L21 13v-2l-2-.001V9z"
  }
}];
var insertRowBottom = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 13c2.761 0 5 2.239 5 5s-2.239 5-5 5-5-2.239-5-5 2.239-5 5-5zm1 2h-2v1.999L9 17v2l2-.001V21h2v-2.001L15 19v-2l-2-.001V15zm7-12c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h16zM5 5v4h14V5H5z"
  }
}];
var insertRowTop = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M20 13c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1v-6c0-.552.448-1 1-1h16zm-1 2H5v4h14v-4zM12 1c2.761 0 5 2.239 5 5s-2.239 5-5 5-5-2.239-5-5 2.239-5 5-5zm1 2h-2v1.999L9 5v2l2-.001V9h2V6.999L15 7V5l-2-.001V3z"
  }
}];
var italic = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z"
  }
}];
var layoutColumnLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    fillRule: "nonzero",
    d: "M11 5H5v14h6V5zm2 0v14h6V5h-6zM4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"
  }
}];
var lineHeight = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 4h10v2H11V4zM6 7v4H4V7H1l4-4 4 4H6zm0 10h3l-4 4-4-4h3v-4h2v4zm5 1h10v2H11v-2zm-2-7h12v2H9v-2z"
  }
}];
var linkM = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M17.657 14.828l-1.414-1.414L17.657 12A4 4 0 1 0 12 6.343l-1.414 1.414-1.414-1.414 1.414-1.414a6 6 0 0 1 8.485 8.485l-1.414 1.414zm-2.829 2.829l-1.414 1.414a6 6 0 1 1-8.485-8.485l1.414-1.414 1.414 1.414L6.343 12A4 4 0 1 0 12 17.657l1.414-1.414 1.414 1.414zm0-9.9l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z"
  }
}];
var linkUnlinkM = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M17.657 14.828l-1.414-1.414L17.657 12A4 4 0 1 0 12 6.343l-1.414 1.414-1.414-1.414 1.414-1.414a6 6 0 0 1 8.485 8.485l-1.414 1.414zm-2.829 2.829l-1.414 1.414a6 6 0 1 1-8.485-8.485l1.414-1.414 1.414 1.414L6.343 12A4 4 0 1 0 12 17.657l1.414-1.414 1.414 1.414zm0-9.9l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07zM5.775 2.293l1.932-.518L8.742 5.64l-1.931.518-1.036-3.864zm9.483 16.068l1.931-.518 1.036 3.864-1.932.518-1.035-3.864zM2.293 5.775l3.864 1.036-.518 1.931-3.864-1.035.518-1.932zm16.068 9.483l3.864 1.035-.518 1.932-3.864-1.036.518-1.931z"
  }
}];
var linkUnlink = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M17 17h5v2h-3v3h-2v-5zM7 7H2V5h3V2h2v5zm11.364 8.536L16.95 14.12l1.414-1.414a5 5 0 1 0-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 0 1 9.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 0 1-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 1 0 7.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z"
  }
}];
var link$1 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M18.364 15.536L16.95 14.12l1.414-1.414a5 5 0 1 0-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 0 1 9.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 0 1-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 1 0 7.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z"
  }
}];
var listCheck2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 4h10v2H11V4zm0 4h6v2h-6V8zm0 6h10v2H11v-2zm0 4h6v2h-6v-2zM3 4h6v6H3V4zm2 2v2h2V6H5zm-2 8h6v6H3v-6zm2 2v2h2v-2H5z"
  }
}];
var listCheck = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M8 4h13v2H8V4zm-5-.5h3v3H3v-3zm0 7h3v3H3v-3zm0 7h3v3H3v-3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z"
  }
}];
var listOrdered = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z"
  }
}];
var listUnordered = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 6.9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z"
  }
}];
var markPenLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M15.243 4.515l-6.738 6.737-.707 2.121-1.04 1.041 2.828 2.829 1.04-1.041 2.122-.707 6.737-6.738-4.242-4.242zm6.364 3.535a1 1 0 0 1 0 1.414l-7.779 7.779-2.12.707-1.415 1.414a1 1 0 0 1-1.414 0l-4.243-4.243a1 1 0 0 1 0-1.414l1.414-1.414.707-2.121 7.779-7.779a1 1 0 0 1 1.414 0l5.657 5.657zm-6.364-.707l1.414 1.414-4.95 4.95-1.414-1.414 4.95-4.95zM4.283 16.89l2.828 2.829-1.414 1.414-4.243-1.414 2.828-2.829z"
  }
}];
var markdownFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 3h18a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm4 12.5v-4l2 2 2-2v4h2v-7h-2l-2 2-2-2H5v7h2zm11-3v-4h-2v4h-2l3 3 3-3h-2z"
  }
}];
var markdownLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    fillRule: "nonzero",
    d: "M3 3h18a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm1 2v14h16V5H4zm3 10.5H5v-7h2l2 2 2-2h2v7h-2v-4l-2 2-2-2v4zm11-3h2l-3 3-3-3h2v-4h2v4z"
  }
}];
var mergeCellsHorizontal = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M20 3c.552 0 1 .448 1 1v16c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h16zm-9 2H5v5.999h2V9l3 3-3 3v-2H5v6h6v-2h2v2h6v-6h-2v2l-3-3 3-3v1.999h2V5h-6v2h-2V5zm2 8v2h-2v-2h2zm0-4v2h-2V9h2z"
  }
}];
var mergeCellsVertical = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M21 20c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h16c.552 0 1 .448 1 1v16zm-2-9V5h-5.999v2H15l-3 3-3-3h2V5H5v6h2v2H5v6h6v-2H9l3-3 3 3h-1.999v2H19v-6h-2v-2h2zm-8 2H9v-2h2v2zm4 0h-2v-2h2v2z"
  }
}];
var mindMap = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M18 3c1.657 0 3 1.343 3 3s-1.343 3-3 3h-3c-1.306 0-2.417-.834-2.829-2H11c-1.1 0-2 .9-2 2v.171c1.166.412 2 1.523 2 2.829 0 1.306-.834 2.417-2 2.829V15c0 1.1.9 2 2 2h1.17c.412-1.165 1.524-2 2.83-2h3c1.657 0 3 1.343 3 3s-1.343 3-3 3h-3c-1.306 0-2.417-.834-2.829-2H11c-2.21 0-4-1.79-4-4H5c-1.657 0-3-1.343-3-3s1.343-3 3-3h2c0-2.21 1.79-4 4-4h1.17c.412-1.165 1.524-2 2.83-2h3zm0 14h-3c-.552 0-1 .448-1 1s.448 1 1 1h3c.552 0 1-.448 1-1s-.448-1-1-1zM8 11H5c-.552 0-1 .448-1 1s.448 1 1 1h3c.552 0 1-.448 1-1s-.448-1-1-1zm10-6h-3c-.552 0-1 .448-1 1s.448 1 1 1h3c.552 0 1-.448 1-1s-.448-1-1-1z"
  }
}];
var moreFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M5 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm14 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-7 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
  }
}];
var nodeTree = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M10 2c.552 0 1 .448 1 1v4c0 .552-.448 1-1 1H8v2h5V9c0-.552.448-1 1-1h6c.552 0 1 .448 1 1v4c0 .552-.448 1-1 1h-6c-.552 0-1-.448-1-1v-1H8v6h5v-1c0-.552.448-1 1-1h6c.552 0 1 .448 1 1v4c0 .552-.448 1-1 1h-6c-.552 0-1-.448-1-1v-1H7c-.552 0-1-.448-1-1V8H4c-.552 0-1-.448-1-1V3c0-.552.448-1 1-1h6zm9 16h-4v2h4v-2zm0-8h-4v2h4v-2zM9 4H5v2h4V4z"
  }
}];
var number0 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 1.5c1.321 0 2.484.348 3.447.994.963.645 1.726 1.588 2.249 2.778.522 1.19.804 2.625.804 4.257v4.942c0 1.632-.282 3.068-.804 4.257-.523 1.19-1.286 2.133-2.25 2.778-.962.646-2.125.994-3.446.994-1.321 0-2.484-.348-3.447-.994-.963-.645-1.726-1.588-2.249-2.778-.522-1.19-.804-2.625-.804-4.257V9.529c0-1.632.282-3.068.804-4.257.523-1.19 1.286-2.133 2.25-2.778C9.515 1.848 10.678 1.5 12 1.5zm0 2c-.916 0-1.694.226-2.333.655-.637.427-1.158 1.07-1.532 1.92-.412.94-.635 2.108-.635 3.454v4.942c0 1.346.223 2.514.635 3.453.374.851.895 1.494 1.532 1.921.639.429 1.417.655 2.333.655.916 0 1.694-.226 2.333-.655.637-.427 1.158-1.07 1.532-1.92.412-.94.635-2.108.635-3.454V9.529c0-1.346-.223-2.514-.635-3.453-.374-.851-.895-1.494-1.532-1.921C13.694 3.726 12.916 3.5 12 3.5z"
  }
}];
var number1 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M14 1.5V22h-2V3.704L7.5 4.91V2.839l5-1.339z"
  }
}];
var number2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M16 7.5a4 4 0 1 0-8 0H6a6 6 0 1 1 10.663 3.776l-7.32 8.723L18 20v2H6v-1.127l9.064-10.802A3.982 3.982 0 0 0 16 7.5z"
  }
}];
var number3 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M18 2v1.362L12.809 9.55a6.501 6.501 0 1 1-7.116 8.028l1.94-.486A4.502 4.502 0 0 0 16.5 16a4.5 4.5 0 0 0-6.505-4.03l-.228.122-.69-1.207L14.855 4 6.5 4V2H18z"
  }
}];
var number4 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M16 1.5V16h3v2h-3v4h-2v-4H4v-1.102L14 1.5h2zM14 16V5.171L6.968 16H14z"
  }
}];
var number5 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M18 2v2H9.3l-.677 6.445a6.5 6.5 0 1 1-2.93 7.133l1.94-.486A4.502 4.502 0 0 0 16.5 16a4.5 4.5 0 0 0-4.5-4.5c-2.022 0-3.278.639-3.96 1.53l-1.575-1.182L7.5 2H18z"
  }
}];
var number6 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M14.886 2l-4.438 7.686A6.5 6.5 0 1 1 6.4 12.7L12.576 2h2.31zM12 11.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9z"
  }
}];
var number7 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M19 2v1.5L10.763 22H8.574l8.013-18H6V2z"
  }
}];
var number8 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 1.5a5.5 5.5 0 0 1 3.352 9.86C17.24 12.41 18.5 14.32 18.5 16.5c0 3.314-2.91 6-6.5 6s-6.5-2.686-6.5-6c0-2.181 1.261-4.09 3.147-5.141A5.5 5.5 0 0 1 12 1.5zm0 11c-2.52 0-4.5 1.828-4.5 4 0 2.172 1.98 4 4.5 4s4.5-1.828 4.5-4c0-2.172-1.98-4-4.5-4zm0-9a3.5 3.5 0 1 0 0 7 3.5 3.5 0 0 0 0-7z"
  }
}];
var number9 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 1.5a6.5 6.5 0 0 1 5.619 9.77l-6.196 10.729H9.114l4.439-7.686A6.5 6.5 0 1 1 12 1.5zm0 2a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9z"
  }
}];
var omega = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    fillRule: "nonzero",
    d: "M14 20v-2.157c1.863-1.192 3.5-3.875 3.5-6.959 0-3.073-2-6.029-5.5-6.029s-5.5 2.956-5.5 6.03c0 3.083 1.637 5.766 3.5 6.958V20H3v-2h4.76C5.666 16.505 4 13.989 4 10.884 4 6.247 7.5 3 12 3s8 3.247 8 7.884c0 3.105-1.666 5.621-3.76 7.116H21v2h-7z"
  }
}];
var organizationChart = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M15 3c.552 0 1 .448 1 1v4c0 .552-.448 1-1 1h-2v2h4c.552 0 1 .448 1 1v3h2c.552 0 1 .448 1 1v4c0 .552-.448 1-1 1h-6c-.552 0-1-.448-1-1v-4c0-.552.448-1 1-1h2v-2H8v2h2c.552 0 1 .448 1 1v4c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1v-4c0-.552.448-1 1-1h2v-3c0-.552.448-1 1-1h4V9H9c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h6zM9 17H5v2h4v-2zm10 0h-4v2h4v-2zM14 5h-4v2h4V5z"
  }
}];
var pageSeparator = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M17 21v-4H7v4H5v-5a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v5h-2zM7 3v4h10V3h2v5a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V3h2zM2 9l4 3-4 3V9zm20 0v6l-4-3 4-3z"
  }
}];
var paragraph = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 6v15h-2v-5a6 6 0 1 1 0-12h10v2h-3v15h-2V6h-3zm-2 0a4 4 0 1 0 0 8V6z"
  }
}];
var pencilFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12.9 6.858l4.242 4.243L7.242 21H3v-4.243l9.9-9.9zm1.414-1.414l2.121-2.122a1 1 0 0 1 1.414 0l2.829 2.829a1 1 0 0 1 0 1.414l-2.122 2.121-4.242-4.242z"
  }
}];
var pencilLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M15.728 9.686l-1.414-1.414L5 17.586V19h1.414l9.314-9.314zm1.414-1.414l1.414-1.414-1.414-1.414-1.414 1.414 1.414 1.414zM7.242 21H3v-4.243L16.435 3.322a1 1 0 0 1 1.414 0l2.829 2.829a1 1 0 0 1 0 1.414L7.243 21z"
  }
}];
var pinyinInput = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M17.934 3.036l1.732 1L18.531 6H21v2h-2v4h2v2h-2v7h-2v-7h-3.084c-.325 2.862-1.564 5.394-3.37 7.193l-1.562-1.27c1.52-1.438 2.596-3.522 2.917-5.922L10 14v-2l2-.001V8h-2V6h2.467l-1.133-1.964 1.732-1L14.777 6h1.444l1.713-2.964zM5 13.803l-2 .536v-2.071l2-.536V8H3V6h2V3h2v3h2v2H7v3.197l2-.536v2.07l-2 .536V18.5A2.5 2.5 0 0 1 4.5 21H3v-2h1.5a.5.5 0 0 0 .492-.41L5 18.5v-4.697zM17 8h-3v4h3V8z"
  }
}];
var questionMark = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M12 19c.828 0 1.5.672 1.5 1.5S12.828 22 12 22s-1.5-.672-1.5-1.5.672-1.5 1.5-1.5zm0-17c3.314 0 6 2.686 6 6 0 2.165-.753 3.29-2.674 4.923C13.399 14.56 13 15.297 13 17h-2c0-2.474.787-3.695 3.031-5.601C15.548 10.11 16 9.434 16 8c0-2.21-1.79-4-4-4S8 5.79 8 8v1H6V8c0-3.314 2.686-6 6-6z"
  }
}];
var roundedCorner = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M21 19v2h-2v-2h2zm-4 0v2h-2v-2h2zm-4 0v2h-2v-2h2zm-4 0v2H7v-2h2zm-4 0v2H3v-2h2zm16-4v2h-2v-2h2zM5 15v2H3v-2h2zm0-4v2H3v-2h2zm11-8c2.687 0 4.882 2.124 4.995 4.783L21 8v5h-2V8c0-1.591-1.255-2.903-2.824-2.995L16 5h-5V3h5zM5 7v2H3V7h2zm0-4v2H3V3h2zm4 0v2H7V3h2z"
  }
}];
var scissorsFill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M9.683 7.562L12 9.88l6.374-6.375a2 2 0 0 1 2.829 0l.707.707L9.683 16.438a4 4 0 1 1-2.121-2.121L9.88 12 7.562 9.683a4 4 0 1 1 2.121-2.121zM6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 12a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm9.535-6.587l6.375 6.376-.707.707a2 2 0 0 1-2.829 0l-4.96-4.961 2.12-2.122z"
  }
}];
var sendBackward = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M14 3c.552 0 1 .448 1 1v5h5c.552 0 1 .448 1 1v10c0 .552-.448 1-1 1H10c-.552 0-1-.448-1-1v-5H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h10zm-1 2H5v8h4v-3c0-.552.448-1 1-1h3V5z"
  }
}];
var sendToBack = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 3c.552 0 1 .448 1 1v2h5c.552 0 1 .448 1 1v5h2c.552 0 1 .448 1 1v7c0 .552-.448 1-1 1h-7c-.552 0-1-.448-1-1v-2H7c-.552 0-1-.448-1-1v-5H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h7zm5 5h-4v3c0 .552-.448 1-1 1H8v4h4v-3c0-.552.448-1 1-1h3V8z"
  }
}];
var separator = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M2 11h2v2H2v-2zm4 0h12v2H6v-2zm14 0h2v2h-2v-2z"
  }
}];
var singleQuotesL = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M9.583 17.321C8.553 16.227 8 15 8 13.011c0-3.5 2.457-6.637 6.03-8.188l.893 1.378c-3.335 1.804-3.987 4.145-4.247 5.621.537-.278 1.24-.375 1.929-.311 1.804.167 3.226 1.648 3.226 3.489a3.5 3.5 0 0 1-3.5 3.5c-1.073 0-2.099-.49-2.748-1.179z"
  }
}];
var singleQuotesR = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M14.417 6.679C15.447 7.773 16 9 16 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311C9.591 12.322 8.17 10.841 8.17 9a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179z"
  }
}];
var sortAsc = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M19 3l4 5h-3v12h-2V8h-3l4-5zm-5 15v2H3v-2h11zm0-7v2H3v-2h11zm-2-7v2H3V4h9z"
  }
}];
var sortDesc = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M20 4v12h3l-4 5-4-5h3V4h2zm-8 14v2H3v-2h9zm2-7v2H3v-2h11zm0-7v2H3V4h11z"
  }
}];
var space = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M4 9v4h16V9h2v5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V9h2z"
  }
}];
var spamLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    fillRule: "nonzero",
    d: "M17.5 2.5L23 12l-5.5 9.5h-11L1 12l5.5-9.5h11zm-1.153 2H7.653L3.311 12l4.342 7.5h8.694l4.342-7.5-4.342-7.5zM11 15h2v2h-2v-2zm0-8h2v6h-2V7z"
  }
}];
var splitCellsHorizontal = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M20 3c.552 0 1 .448 1 1v16c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h16zm-9 2H5v14h6v-4h2v4h6V5h-6v4h-2V5zm4 4l3 3-3 3v-2H9v2l-3-3 3-3v2h6V9z"
  }
}];
var splitCellsVertical = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0H24V24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M20 3c.552 0 1 .448 1 1v16c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h16zm-1 2H5v5.999L9 11v2H5v6h14v-6h-4v-2l4-.001V5zm-7 1l3 3h-2v6h2l-3 3-3-3h2V9H9l3-3z"
  }
}];
var strikethrough2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M13 9h-2V6H5V4h14v2h-6v3zm0 6v5h-2v-5h2zM3 11h18v2H3v-2z"
  }
}];
var strikethrough = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M17.154 14c.23.516.346 1.09.346 1.72 0 1.342-.524 2.392-1.571 3.147C14.88 19.622 13.433 20 11.586 20c-1.64 0-3.263-.381-4.87-1.144V16.6c1.52.877 3.075 1.316 4.666 1.316 2.551 0 3.83-.732 3.839-2.197a2.21 2.21 0 0 0-.648-1.603l-.12-.117H3v-2h18v2h-3.846zm-4.078-3H7.629a4.086 4.086 0 0 1-.481-.522C6.716 9.92 6.5 9.246 6.5 8.452c0-1.236.466-2.287 1.397-3.153C8.83 4.433 10.271 4 12.222 4c1.471 0 2.879.328 4.222.984v2.152c-1.2-.687-2.515-1.03-3.946-1.03-2.48 0-3.719.782-3.719 2.346 0 .42.218.786.654 1.099.436.313.974.562 1.613.75.62.18 1.297.414 2.03.699z"
  }
}];
var subscript2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 6v13H9V6H3V4h14v2h-6zm8.55 10.58a.8.8 0 1 0-1.32-.36l-1.154.33A2.001 2.001 0 0 1 19 14a2 2 0 0 1 1.373 3.454L18.744 19H21v1h-4v-1l2.55-2.42z"
  }
}];
var subscript = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M5.596 4L10.5 9.928 15.404 4H18l-6.202 7.497L18 18.994V19h-2.59l-4.91-5.934L5.59 19H3v-.006l6.202-7.497L3 4h2.596zM21.55 16.58a.8.8 0 1 0-1.32-.36l-1.155.33A2.001 2.001 0 0 1 21 14a2 2 0 0 1 1.373 3.454L20.744 19H23v1h-4v-1l2.55-2.42z"
  }
}];
var subtractLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M5 11h14v2H5z"
  }
}];
var superscript2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 7v13H9V7H3V5h12v2h-4zm8.55-.42a.8.8 0 1 0-1.32-.36l-1.154.33A2.001 2.001 0 0 1 19 4a2 2 0 0 1 1.373 3.454L18.744 9H21v1h-4V9l2.55-2.42z"
  }
}];
var superscript = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M5.596 5l4.904 5.928L15.404 5H18l-6.202 7.497L18 19.994V20h-2.59l-4.91-5.934L5.59 20H3v-.006l6.202-7.497L3 5h2.596zM21.55 6.58a.8.8 0 1 0-1.32-.36l-1.155.33A2.001 2.001 0 0 1 21 4a2 2 0 0 1 1.373 3.454L20.744 9H23v1h-4V9l2.55-2.42z"
  }
}];
var table2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    fillRule: "nonzero",
    d: "M13 10v4h6v-4h-6zm-2 0H5v4h6v-4zm2 9h6v-3h-6v3zm-2 0v-3H5v3h6zm2-14v3h6V5h-6zm-2 0H5v3h6V5zM4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"
  }
}];
var tableLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M4 8h16V5H4v3zm10 11v-9h-4v9h4zm2 0h4v-9h-4v9zm-8 0v-9H4v9h4zM3 3h18a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"
  }
}];
var textDirectionL = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 5v10H9v-4a4 4 0 1 1 0-8h8v2h-2v10h-2V5h-2zM9 5a2 2 0 1 0 0 4V5zm8 12v-2.5l4 3.5-4 3.5V19H5v-2h12z"
  }
}];
var textDirectionR = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M11 5v10H9v-4a4 4 0 1 1 0-8h8v2h-2v10h-2V5h-2zM9 5a2 2 0 1 0 0 4V5zM7 17h12v2H7v2.5L3 18l4-3.5V17z"
  }
}];
var textSpacing = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M7 17h10v-2.5l3.5 3.5-3.5 3.5V19H7v2.5L3.5 18 7 14.5V17zm6-11v9h-2V6H5V4h14v2h-6z"
  }
}];
var textWrap = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M15 18h1.5a2.5 2.5 0 1 0 0-5H3v-2h13.5a4.5 4.5 0 1 1 0 9H15v2l-4-3 4-3v2zM3 4h18v2H3V4zm6 14v2H3v-2h6z"
  }
}];
var text2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M13 6v15h-2V6H5V4h14v2z"
  }
}];
var translate2 = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M18.5 10l4.4 11h-2.155l-1.201-3h-4.09l-1.199 3h-2.154L16.5 10h2zM10 2v2h6v2h-1.968a18.222 18.222 0 0 1-3.62 6.301 14.864 14.864 0 0 0 2.336 1.707l-.751 1.878A17.015 17.015 0 0 1 9 13.725a16.676 16.676 0 0 1-6.201 3.548l-.536-1.929a14.7 14.7 0 0 0 5.327-3.042A18.078 18.078 0 0 1 4.767 8h2.24A16.032 16.032 0 0 0 9 10.877a16.165 16.165 0 0 0 2.91-4.876L2 6V4h6V2h2zm7.5 10.885L16.253 16h2.492L17.5 12.885z"
  }
}];
var translate = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M5 15v2a2 2 0 0 0 1.85 1.995L7 19h3v2H7a4 4 0 0 1-4-4v-2h2zm13-5l4.4 11h-2.155l-1.201-3h-4.09l-1.199 3h-2.154L16 10h2zm-1 2.885L15.753 16h2.492L17 12.885zM8 2v2h4v7H8v3H6v-3H2V4h4V2h2zm9 1a4 4 0 0 1 4 4v2h-2V7a2 2 0 0 0-2-2h-3V3h3zM6 6H4v3h2V6zm4 0H8v3h2V6z"
  }
}];
var underline = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M8 3v9a4 4 0 1 0 8 0V3h2v9a6 6 0 1 1-12 0V3h2zM4 20h16v2H4v-2z"
  }
}];
var upload2Fill = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M4 19h16v-7h2v8a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-8h2v7zM14 9v6h-4V9H5l7-7 7 7h-5z"
  }
}];
var videoLine = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 3.993C3 3.445 3.445 3 3.993 3h16.014c.548 0 .993.445.993.993v16.014a.994.994 0 0 1-.993.993H3.993A.994.994 0 0 1 3 20.007V3.993zM5 5v14h14V5H5zm5.622 3.415l4.879 3.252a.4.4 0 0 1 0 .666l-4.88 3.252a.4.4 0 0 1-.621-.332V8.747a.4.4 0 0 1 .622-.332z"
  }
}];
var wubiInput = [{
  tag: "path",
  attr: {
    fill: "none",
    d: "M0 0h24v24H0z"
  }
}, {
  tag: "path",
  attr: {
    d: "M3 21v-2h3.662l1.234-7H5v-2h3.249l.881-5H4V3h16v2h-8.839l-.882 5H18v9h3v2H3zm13-9H9.927l-1.235 7H16v-7z"
  }
}];
var Icons = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  ab,
  addFill,
  addLine,
  alertLine,
  alignBottom,
  alignCenter,
  alignJustify,
  alignLeft,
  alignRight,
  alignTop,
  alignVertically,
  appsLine,
  arrowDownSFill,
  arrowGoBackFill,
  arrowGoForwardFill,
  arrowLeftSFill,
  arrowRightSFill,
  arrowUpSFill,
  asterisk,
  attachment2,
  bold,
  bracesLine,
  bringForward,
  bringToFront,
  chatNewLine,
  checkboxCircleLine,
  clipboardFill,
  clipboardLine,
  closeCircleLine,
  closeFill,
  closeLine,
  codeLine,
  codeView,
  deleteBinFill,
  deleteBinLine,
  deleteColumn,
  deleteRow,
  doubleQuotesL,
  doubleQuotesR,
  download2Fill,
  dragDropLine,
  emphasis,
  emphasisCn,
  englishInput,
  errorWarningLine,
  externalLinkFill,
  fileCopyLine,
  flowChart,
  fontColor,
  fontSize,
  fontSize2,
  formatClear,
  fullscreenExitLine,
  fullscreenLine,
  functions,
  galleryUploadLine,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  hashtag,
  heading,
  imageAddLine,
  imageEditLine,
  imageLine,
  indentDecrease,
  indentIncrease,
  informationLine,
  inputCursorMove,
  insertColumnLeft,
  insertColumnRight,
  insertRowBottom,
  insertRowTop,
  italic,
  layoutColumnLine,
  lineHeight,
  link: link$1,
  linkM,
  linkUnlink,
  linkUnlinkM,
  listCheck,
  listCheck2,
  listOrdered,
  listUnordered,
  markPenLine,
  markdownFill,
  markdownLine,
  mergeCellsHorizontal,
  mergeCellsVertical,
  mindMap,
  moreFill,
  nodeTree,
  number0,
  number1,
  number2,
  number3,
  number4,
  number5,
  number6,
  number7,
  number8,
  number9,
  omega,
  organizationChart,
  pageSeparator,
  paragraph,
  pencilFill,
  pencilLine,
  pinyinInput,
  questionMark,
  roundedCorner,
  scissorsFill,
  sendBackward,
  sendToBack,
  separator,
  singleQuotesL,
  singleQuotesR,
  sortAsc,
  sortDesc,
  space,
  spamLine,
  splitCellsHorizontal,
  splitCellsVertical,
  strikethrough,
  strikethrough2,
  subscript,
  subscript2,
  subtractLine,
  superscript,
  superscript2,
  table2,
  tableLine,
  text: text2,
  textDirectionL,
  textDirectionR,
  textSpacing,
  textWrap,
  translate,
  translate2,
  underline,
  upload2Fill,
  videoLine,
  wubiInput
});
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = /* @__PURE__ */ react$1.exports.createContext(DefaultContext);
IconContext.Provider;
var _excluded$1 = ["title"];
function Tree2Element(tree) {
  return tree.map((node4, index3) => {
    var _node$child;
    return /* @__PURE__ */ react$1.exports.createElement(node4.tag, _objectSpread2$3({
      key: index3
    }, node4.attr), Tree2Element((_node$child = node4.child) !== null && _node$child !== void 0 ? _node$child : []));
  });
}
var Icon = (props) => {
  var name = props.name;
  return /* @__PURE__ */ jsx(IconBase, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
    children: Tree2Element(Icons[name])
  }));
};
var IconBase = (props) => {
  var renderSvg = (context2) => {
    var _ref, _props$size, _props$color;
    var computedSize = (_ref = (_props$size = props.size) !== null && _props$size !== void 0 ? _props$size : context2.size) !== null && _ref !== void 0 ? _ref : "1em";
    var className;
    if (context2.className) {
      className = context2.className;
    }
    if (props.className) {
      className = (className ? "".concat(className, " ") : "") + props.className;
    }
    var title = props.title, svgProps = _objectWithoutProperties(props, _excluded$1);
    return /* @__PURE__ */ jsxs("svg", _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, context2.attr), svgProps), {}, {
      className,
      style: _objectSpread2$3(_objectSpread2$3({
        color: (_props$color = props.color) !== null && _props$color !== void 0 ? _props$color : context2.color
      }, context2.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      children: [title && /* @__PURE__ */ jsx("title", {
        children: title
      }), props.children]
    }));
  };
  return /* @__PURE__ */ jsx(IconContext.Consumer, {
    children: renderSvg
  });
};
var GROUP_KEYS = [];
var useGroup = createHook({
  name: "Group",
  compose: useRole,
  keys: GROUP_KEYS,
  useProps: function useProps22(_2, htmlProps) {
    return _objectSpread2$2({
      role: "group"
    }, htmlProps);
  }
});
var Group = createComponent({
  as: "div",
  useHook: useGroup
});
function unstable_getIn(object2, path, defaultValue) {
  if (typeof path === "string") {
    return object2[path] == null ? defaultValue : object2[path];
  }
  var result2 = object2;
  for (var _iterator = _createForOfIteratorHelperLoose$2(path), _step; !(_step = _iterator()).done; ) {
    var key = _step.value;
    if (!(key in result2))
      return defaultValue;
    result2 = result2[key];
  }
  if (result2 == null) {
    return defaultValue;
  }
  return result2;
}
var TOOLBAR_STATE_KEYS = ["baseId", "unstable_idCountRef", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "setBaseId", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget"];
var TOOLBAR_KEYS = TOOLBAR_STATE_KEYS;
var TOOLBAR_ITEM_KEYS = TOOLBAR_KEYS;
var TOOLBAR_SEPARATOR_KEYS = TOOLBAR_ITEM_KEYS;
var useToolbar = createHook({
  name: "Toolbar",
  compose: useComposite,
  keys: TOOLBAR_KEYS,
  useProps: function useProps23(options, htmlProps) {
    return _objectSpread2$2({
      role: "toolbar",
      "aria-orientation": options.orientation
    }, htmlProps);
  }
});
var Toolbar$1 = createComponent({
  as: "div",
  useHook: useToolbar,
  useCreateElement: function useCreateElement$16(type2, props, children) {
    useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/toolbar");
    return useCreateElement(type2, props, children);
  }
});
var useToolbarItem = createHook({
  name: "ToolbarItem",
  compose: useCompositeItem,
  keys: TOOLBAR_ITEM_KEYS
});
var ToolbarItem = createComponent({
  as: "button",
  memo: true,
  useHook: useToolbarItem
});
var useToolbarSeparator = createHook({
  name: "ToolbarSeparator",
  compose: useSeparator,
  keys: TOOLBAR_SEPARATOR_KEYS,
  useOptions: function useOptions13(_ref) {
    var _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? "vertical" : _ref$orientation, options = _objectWithoutPropertiesLoose$2(_ref, ["orientation"]);
    return _objectSpread2$2({
      orientation: orientation === "vertical" ? "horizontal" : "vertical"
    }, options);
  }
});
var ToolbarSeparator$1 = createComponent({
  as: "hr",
  memo: true,
  useHook: useToolbarSeparator
});
function useToolbarState(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var _useSealedState = useSealedState(initialState2), _useSealedState$orien = _useSealedState.orientation, orientation = _useSealedState$orien === void 0 ? "horizontal" : _useSealedState$orien, sealed = _objectWithoutPropertiesLoose$2(_useSealedState, ["orientation"]);
  return useCompositeState(_objectSpread2$2({
    orientation
  }, sealed));
}
var VISUALLY_HIDDEN_KEYS = [];
var useVisuallyHidden = createHook({
  name: "VisuallyHidden",
  compose: useRole,
  keys: VISUALLY_HIDDEN_KEYS,
  useProps: function useProps24(_2, _ref) {
    var htmlStyle = _ref.style, htmlProps = _objectWithoutPropertiesLoose$2(_ref, ["style"]);
    return _objectSpread2$2({
      style: _objectSpread2$2({
        border: 0,
        clip: "rect(0 0 0 0)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: 0,
        position: "absolute",
        whiteSpace: "nowrap",
        width: "1px"
      }, htmlStyle)
    }, htmlProps);
  }
});
var VisuallyHidden = createComponent({
  as: "span",
  memo: true,
  useHook: useVisuallyHidden
});
function SystemProvider(_ref) {
  var children = _ref.children, system2 = _ref.unstable_system;
  return /* @__PURE__ */ react$1.exports.createElement(SystemContext.Provider, {
    value: system2
  }, children);
}
var defaultSystem = {};
function Provider(_ref) {
  var prefix = _ref.unstable_prefix, _ref$unstable_system = _ref.unstable_system, system2 = _ref$unstable_system === void 0 ? defaultSystem : _ref$unstable_system, children = _ref.children;
  return /* @__PURE__ */ react$1.exports.createElement(unstable_IdProvider, {
    prefix
  }, /* @__PURE__ */ react$1.exports.createElement(SystemProvider, {
    unstable_system: system2
  }, children));
}
var colorString$1 = { exports: {} };
var colorName$1 = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var simpleSwizzle = { exports: {} };
var isArrayish$1 = function isArrayish(obj) {
  if (!obj || typeof obj === "string") {
    return false;
  }
  return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
};
var isArrayish2 = isArrayish$1;
var concat = Array.prototype.concat;
var slice4 = Array.prototype.slice;
var swizzle$1 = simpleSwizzle.exports = function swizzle(args) {
  var results = [];
  for (var i2 = 0, len = args.length; i2 < len; i2++) {
    var arg = args[i2];
    if (isArrayish2(arg)) {
      results = concat.call(results, slice4.call(arg));
    } else {
      results.push(arg);
    }
  }
  return results;
};
swizzle$1.wrap = function(fn2) {
  return function() {
    return fn2(swizzle$1(arguments));
  };
};
var colorNames = colorName$1;
var swizzle2 = simpleSwizzle.exports;
var hasOwnProperty = Object.hasOwnProperty;
var reverseNames = {};
for (var name in colorNames) {
  if (hasOwnProperty.call(colorNames, name)) {
    reverseNames[colorNames[name]] = name;
  }
}
var cs = colorString$1.exports = {
  to: {},
  get: {}
};
cs.get = function(string) {
  var prefix = string.substring(0, 3).toLowerCase();
  var val;
  var model;
  switch (prefix) {
    case "hsl":
      val = cs.get.hsl(string);
      model = "hsl";
      break;
    case "hwb":
      val = cs.get.hwb(string);
      model = "hwb";
      break;
    default:
      val = cs.get.rgb(string);
      model = "rgb";
      break;
  }
  if (!val) {
    return null;
  }
  return { model, value: val };
};
cs.get.rgb = function(string) {
  if (!string) {
    return null;
  }
  var abbr = /^#([a-f0-9]{3,4})$/i;
  var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
  var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var keyword = /^(\w+)$/;
  var rgb = [0, 0, 0, 1];
  var match;
  var i2;
  var hexAlpha;
  if (match = string.match(hex)) {
    hexAlpha = match[2];
    match = match[1];
    for (i2 = 0; i2 < 3; i2++) {
      var i22 = i2 * 2;
      rgb[i2] = parseInt(match.slice(i22, i22 + 2), 16);
    }
    if (hexAlpha) {
      rgb[3] = parseInt(hexAlpha, 16) / 255;
    }
  } else if (match = string.match(abbr)) {
    match = match[1];
    hexAlpha = match[3];
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] = parseInt(match[i2] + match[i2], 16);
    }
    if (hexAlpha) {
      rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
    }
  } else if (match = string.match(rgba)) {
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] = parseInt(match[i2 + 1], 0);
    }
    if (match[4]) {
      if (match[5]) {
        rgb[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(per)) {
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
    }
    if (match[4]) {
      if (match[5]) {
        rgb[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(keyword)) {
    if (match[1] === "transparent") {
      return [0, 0, 0, 0];
    }
    if (!hasOwnProperty.call(colorNames, match[1])) {
      return null;
    }
    rgb = colorNames[match[1]];
    rgb[3] = 1;
    return rgb;
  } else {
    return null;
  }
  for (i2 = 0; i2 < 3; i2++) {
    rgb[i2] = clamp(rgb[i2], 0, 255);
  }
  rgb[3] = clamp(rgb[3], 0, 1);
  return rgb;
};
cs.get.hsl = function(string) {
  if (!string) {
    return null;
  }
  var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hsl);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var s2 = clamp(parseFloat(match[2]), 0, 100);
    var l2 = clamp(parseFloat(match[3]), 0, 100);
    var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, s2, l2, a2];
  }
  return null;
};
cs.get.hwb = function(string) {
  if (!string) {
    return null;
  }
  var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hwb);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var w2 = clamp(parseFloat(match[2]), 0, 100);
    var b = clamp(parseFloat(match[3]), 0, 100);
    var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, w2, b, a2];
  }
  return null;
};
cs.to.hex = function() {
  var rgba = swizzle2(arguments);
  return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
};
cs.to.rgb = function() {
  var rgba = swizzle2(arguments);
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
};
cs.to.rgb.percent = function() {
  var rgba = swizzle2(arguments);
  var r2 = Math.round(rgba[0] / 255 * 100);
  var g = Math.round(rgba[1] / 255 * 100);
  var b = Math.round(rgba[2] / 255 * 100);
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r2 + "%, " + g + "%, " + b + "%)" : "rgba(" + r2 + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
};
cs.to.hsl = function() {
  var hsla = swizzle2(arguments);
  return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
};
cs.to.hwb = function() {
  var hwba = swizzle2(arguments);
  var a2 = "";
  if (hwba.length >= 4 && hwba[3] !== 1) {
    a2 = ", " + hwba[3];
  }
  return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
};
cs.to.keyword = function(rgb) {
  return reverseNames[rgb.slice(0, 3)];
};
function clamp(num, min3, max3) {
  return Math.min(Math.max(min3, num), max3);
}
function hexDouble(num) {
  var str = Math.round(num).toString(16).toUpperCase();
  return str.length < 2 ? "0" + str : str;
}
var conversions$2 = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var cssKeywords = colorName;
var reverseKeywords = {};
for (var key in cssKeywords) {
  if (cssKeywords.hasOwnProperty(key)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
}
var convert$2 = conversions$2.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
for (var model in convert$2) {
  if (convert$2.hasOwnProperty(model)) {
    if (!("channels" in convert$2[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$2[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$2[model].labels.length !== convert$2[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    var channels = convert$2[model].channels;
    var labels = convert$2[model].labels;
    delete convert$2[model].channels;
    delete convert$2[model].labels;
    Object.defineProperty(convert$2[model], "channels", { value: channels });
    Object.defineProperty(convert$2[model], "labels", { value: labels });
  }
}
convert$2.rgb.hsl = function(rgb) {
  var r2 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var min3 = Math.min(r2, g, b);
  var max3 = Math.max(r2, g, b);
  var delta = max3 - min3;
  var h;
  var s2;
  var l2;
  if (max3 === min3) {
    h = 0;
  } else if (r2 === max3) {
    h = (g - b) / delta;
  } else if (g === max3) {
    h = 2 + (b - r2) / delta;
  } else if (b === max3) {
    h = 4 + (r2 - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  l2 = (min3 + max3) / 2;
  if (max3 === min3) {
    s2 = 0;
  } else if (l2 <= 0.5) {
    s2 = delta / (max3 + min3);
  } else {
    s2 = delta / (2 - max3 - min3);
  }
  return [h, s2 * 100, l2 * 100];
};
convert$2.rgb.hsv = function(rgb) {
  var rdif;
  var gdif;
  var bdif;
  var h;
  var s2;
  var r2 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var v2 = Math.max(r2, g, b);
  var diff = v2 - Math.min(r2, g, b);
  var diffc = function(c2) {
    return (v2 - c2) / 6 / diff + 1 / 2;
  };
  if (diff === 0) {
    h = s2 = 0;
  } else {
    s2 = diff / v2;
    rdif = diffc(r2);
    gdif = diffc(g);
    bdif = diffc(b);
    if (r2 === v2) {
      h = bdif - gdif;
    } else if (g === v2) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v2) {
      h = 2 / 3 + gdif - rdif;
    }
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }
  return [
    h * 360,
    s2 * 100,
    v2 * 100
  ];
};
convert$2.rgb.hwb = function(rgb) {
  var r2 = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  var h = convert$2.rgb.hsl(rgb)[0];
  var w2 = 1 / 255 * Math.min(r2, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r2, Math.max(g, b));
  return [h, w2 * 100, b * 100];
};
convert$2.rgb.cmyk = function(rgb) {
  var r2 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var c2;
  var m2;
  var y;
  var k;
  k = Math.min(1 - r2, 1 - g, 1 - b);
  c2 = (1 - r2 - k) / (1 - k) || 0;
  m2 = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c2 * 100, m2 * 100, y * 100, k * 100];
};
function comparativeDistance(x, y) {
  return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
}
convert$2.rgb.keyword = function(rgb) {
  var reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  var currentClosestDistance = Infinity;
  var currentClosestKeyword;
  for (var keyword in cssKeywords) {
    if (cssKeywords.hasOwnProperty(keyword)) {
      var value = cssKeywords[keyword];
      var distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
  }
  return currentClosestKeyword;
};
convert$2.keyword.rgb = function(keyword) {
  return cssKeywords[keyword];
};
convert$2.rgb.xyz = function(rgb) {
  var r2 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r2 * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r2 * 0.2126 + g * 0.7152 + b * 0.0722;
  var z2 = r2 * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z2 * 100];
};
convert$2.rgb.lab = function(rgb) {
  var xyz = convert$2.rgb.xyz(rgb);
  var x = xyz[0];
  var y = xyz[1];
  var z2 = xyz[2];
  var l2;
  var a2;
  var b;
  x /= 95.047;
  y /= 100;
  z2 /= 108.883;
  x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
  l2 = 116 * y - 16;
  a2 = 500 * (x - y);
  b = 200 * (y - z2);
  return [l2, a2, b];
};
convert$2.hsl.rgb = function(hsl) {
  var h = hsl[0] / 360;
  var s2 = hsl[1] / 100;
  var l2 = hsl[2] / 100;
  var t1;
  var t2;
  var t3;
  var rgb;
  var val;
  if (s2 === 0) {
    val = l2 * 255;
    return [val, val, val];
  }
  if (l2 < 0.5) {
    t2 = l2 * (1 + s2);
  } else {
    t2 = l2 + s2 - l2 * s2;
  }
  t1 = 2 * l2 - t2;
  rgb = [0, 0, 0];
  for (var i2 = 0; i2 < 3; i2++) {
    t3 = h + 1 / 3 * -(i2 - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i2] = val * 255;
  }
  return rgb;
};
convert$2.hsl.hsv = function(hsl) {
  var h = hsl[0];
  var s2 = hsl[1] / 100;
  var l2 = hsl[2] / 100;
  var smin = s2;
  var lmin = Math.max(l2, 0.01);
  var sv;
  var v2;
  l2 *= 2;
  s2 *= l2 <= 1 ? l2 : 2 - l2;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v2 = (l2 + s2) / 2;
  sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
  return [h, sv * 100, v2 * 100];
};
convert$2.hsv.rgb = function(hsv) {
  var h = hsv[0] / 60;
  var s2 = hsv[1] / 100;
  var v2 = hsv[2] / 100;
  var hi = Math.floor(h) % 6;
  var f2 = h - Math.floor(h);
  var p2 = 255 * v2 * (1 - s2);
  var q = 255 * v2 * (1 - s2 * f2);
  var t2 = 255 * v2 * (1 - s2 * (1 - f2));
  v2 *= 255;
  switch (hi) {
    case 0:
      return [v2, t2, p2];
    case 1:
      return [q, v2, p2];
    case 2:
      return [p2, v2, t2];
    case 3:
      return [p2, q, v2];
    case 4:
      return [t2, p2, v2];
    case 5:
      return [v2, p2, q];
  }
};
convert$2.hsv.hsl = function(hsv) {
  var h = hsv[0];
  var s2 = hsv[1] / 100;
  var v2 = hsv[2] / 100;
  var vmin = Math.max(v2, 0.01);
  var lmin;
  var sl;
  var l2;
  l2 = (2 - s2) * v2;
  lmin = (2 - s2) * vmin;
  sl = s2 * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l2 /= 2;
  return [h, sl * 100, l2 * 100];
};
convert$2.hwb.rgb = function(hwb) {
  var h = hwb[0] / 360;
  var wh = hwb[1] / 100;
  var bl = hwb[2] / 100;
  var ratio = wh + bl;
  var i2;
  var v2;
  var f2;
  var n2;
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  i2 = Math.floor(6 * h);
  v2 = 1 - bl;
  f2 = 6 * h - i2;
  if ((i2 & 1) !== 0) {
    f2 = 1 - f2;
  }
  n2 = wh + f2 * (v2 - wh);
  var r2;
  var g;
  var b;
  switch (i2) {
    default:
    case 6:
    case 0:
      r2 = v2;
      g = n2;
      b = wh;
      break;
    case 1:
      r2 = n2;
      g = v2;
      b = wh;
      break;
    case 2:
      r2 = wh;
      g = v2;
      b = n2;
      break;
    case 3:
      r2 = wh;
      g = n2;
      b = v2;
      break;
    case 4:
      r2 = n2;
      g = wh;
      b = v2;
      break;
    case 5:
      r2 = v2;
      g = wh;
      b = n2;
      break;
  }
  return [r2 * 255, g * 255, b * 255];
};
convert$2.cmyk.rgb = function(cmyk) {
  var c2 = cmyk[0] / 100;
  var m2 = cmyk[1] / 100;
  var y = cmyk[2] / 100;
  var k = cmyk[3] / 100;
  var r2;
  var g;
  var b;
  r2 = 1 - Math.min(1, c2 * (1 - k) + k);
  g = 1 - Math.min(1, m2 * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r2 * 255, g * 255, b * 255];
};
convert$2.xyz.rgb = function(xyz) {
  var x = xyz[0] / 100;
  var y = xyz[1] / 100;
  var z2 = xyz[2] / 100;
  var r2;
  var g;
  var b;
  r2 = x * 3.2406 + y * -1.5372 + z2 * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z2 * 0.0415;
  b = x * 0.0557 + y * -0.204 + z2 * 1.057;
  r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : r2 * 12.92;
  g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
  b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
  r2 = Math.min(Math.max(0, r2), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r2 * 255, g * 255, b * 255];
};
convert$2.xyz.lab = function(xyz) {
  var x = xyz[0];
  var y = xyz[1];
  var z2 = xyz[2];
  var l2;
  var a2;
  var b;
  x /= 95.047;
  y /= 100;
  z2 /= 108.883;
  x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
  l2 = 116 * y - 16;
  a2 = 500 * (x - y);
  b = 200 * (y - z2);
  return [l2, a2, b];
};
convert$2.lab.xyz = function(lab) {
  var l2 = lab[0];
  var a2 = lab[1];
  var b = lab[2];
  var x;
  var y;
  var z2;
  y = (l2 + 16) / 116;
  x = a2 / 500 + y;
  z2 = y - b / 200;
  var y2 = Math.pow(y, 3);
  var x2 = Math.pow(x, 3);
  var z22 = Math.pow(z2, 3);
  y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
  z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z2 *= 108.883;
  return [x, y, z2];
};
convert$2.lab.lch = function(lab) {
  var l2 = lab[0];
  var a2 = lab[1];
  var b = lab[2];
  var hr;
  var h;
  var c2;
  hr = Math.atan2(b, a2);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c2 = Math.sqrt(a2 * a2 + b * b);
  return [l2, c2, h];
};
convert$2.lch.lab = function(lch) {
  var l2 = lch[0];
  var c2 = lch[1];
  var h = lch[2];
  var a2;
  var b;
  var hr;
  hr = h / 360 * 2 * Math.PI;
  a2 = c2 * Math.cos(hr);
  b = c2 * Math.sin(hr);
  return [l2, a2, b];
};
convert$2.rgb.ansi16 = function(args) {
  var r2 = args[0];
  var g = args[1];
  var b = args[2];
  var value = 1 in arguments ? arguments[1] : convert$2.rgb.hsv(args)[2];
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r2 / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert$2.hsv.ansi16 = function(args) {
  return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
};
convert$2.rgb.ansi256 = function(args) {
  var r2 = args[0];
  var g = args[1];
  var b = args[2];
  if (r2 === g && g === b) {
    if (r2 < 8) {
      return 16;
    }
    if (r2 > 248) {
      return 231;
    }
    return Math.round((r2 - 8) / 247 * 24) + 232;
  }
  var ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};
convert$2.ansi16.rgb = function(args) {
  var color2 = args % 10;
  if (color2 === 0 || color2 === 7) {
    if (args > 50) {
      color2 += 3.5;
    }
    color2 = color2 / 10.5 * 255;
    return [color2, color2, color2];
  }
  var mult = (~~(args > 50) + 1) * 0.5;
  var r2 = (color2 & 1) * mult * 255;
  var g = (color2 >> 1 & 1) * mult * 255;
  var b = (color2 >> 2 & 1) * mult * 255;
  return [r2, g, b];
};
convert$2.ansi256.rgb = function(args) {
  if (args >= 232) {
    var c2 = (args - 232) * 10 + 8;
    return [c2, c2, c2];
  }
  args -= 16;
  var rem;
  var r2 = Math.floor(args / 36) / 5 * 255;
  var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  var b = rem % 6 / 5 * 255;
  return [r2, g, b];
};
convert$2.rgb.hex = function(args) {
  var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$2.hex.rgb = function(args) {
  var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  var colorString2 = match[0];
  if (match[0].length === 3) {
    colorString2 = colorString2.split("").map(function(char) {
      return char + char;
    }).join("");
  }
  var integer = parseInt(colorString2, 16);
  var r2 = integer >> 16 & 255;
  var g = integer >> 8 & 255;
  var b = integer & 255;
  return [r2, g, b];
};
convert$2.rgb.hcg = function(rgb) {
  var r2 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var max3 = Math.max(Math.max(r2, g), b);
  var min3 = Math.min(Math.min(r2, g), b);
  var chroma = max3 - min3;
  var grayscale;
  var hue;
  if (chroma < 1) {
    grayscale = min3 / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue = 0;
  } else if (max3 === r2) {
    hue = (g - b) / chroma % 6;
  } else if (max3 === g) {
    hue = 2 + (b - r2) / chroma;
  } else {
    hue = 4 + (r2 - g) / chroma + 4;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert$2.hsl.hcg = function(hsl) {
  var s2 = hsl[1] / 100;
  var l2 = hsl[2] / 100;
  var c2 = 1;
  var f2 = 0;
  if (l2 < 0.5) {
    c2 = 2 * s2 * l2;
  } else {
    c2 = 2 * s2 * (1 - l2);
  }
  if (c2 < 1) {
    f2 = (l2 - 0.5 * c2) / (1 - c2);
  }
  return [hsl[0], c2 * 100, f2 * 100];
};
convert$2.hsv.hcg = function(hsv) {
  var s2 = hsv[1] / 100;
  var v2 = hsv[2] / 100;
  var c2 = s2 * v2;
  var f2 = 0;
  if (c2 < 1) {
    f2 = (v2 - c2) / (1 - c2);
  }
  return [hsv[0], c2 * 100, f2 * 100];
};
convert$2.hcg.rgb = function(hcg) {
  var h = hcg[0] / 360;
  var c2 = hcg[1] / 100;
  var g = hcg[2] / 100;
  if (c2 === 0) {
    return [g * 255, g * 255, g * 255];
  }
  var pure = [0, 0, 0];
  var hi = h % 1 * 6;
  var v2 = hi % 1;
  var w2 = 1 - v2;
  var mg = 0;
  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v2;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w2;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v2;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w2;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v2;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w2;
  }
  mg = (1 - c2) * g;
  return [
    (c2 * pure[0] + mg) * 255,
    (c2 * pure[1] + mg) * 255,
    (c2 * pure[2] + mg) * 255
  ];
};
convert$2.hcg.hsv = function(hcg) {
  var c2 = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v2 = c2 + g * (1 - c2);
  var f2 = 0;
  if (v2 > 0) {
    f2 = c2 / v2;
  }
  return [hcg[0], f2 * 100, v2 * 100];
};
convert$2.hcg.hsl = function(hcg) {
  var c2 = hcg[1] / 100;
  var g = hcg[2] / 100;
  var l2 = g * (1 - c2) + 0.5 * c2;
  var s2 = 0;
  if (l2 > 0 && l2 < 0.5) {
    s2 = c2 / (2 * l2);
  } else if (l2 >= 0.5 && l2 < 1) {
    s2 = c2 / (2 * (1 - l2));
  }
  return [hcg[0], s2 * 100, l2 * 100];
};
convert$2.hcg.hwb = function(hcg) {
  var c2 = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v2 = c2 + g * (1 - c2);
  return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
};
convert$2.hwb.hcg = function(hwb) {
  var w2 = hwb[1] / 100;
  var b = hwb[2] / 100;
  var v2 = 1 - b;
  var c2 = v2 - w2;
  var g = 0;
  if (c2 < 1) {
    g = (v2 - c2) / (1 - c2);
  }
  return [hwb[0], c2 * 100, g * 100];
};
convert$2.apple.rgb = function(apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert$2.rgb.apple = function(rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert$2.gray.rgb = function(args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};
convert$2.gray.hsl = convert$2.gray.hsv = function(args) {
  return [0, 0, args[0]];
};
convert$2.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};
convert$2.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};
convert$2.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};
convert$2.gray.hex = function(gray) {
  var val = Math.round(gray[0] / 100 * 255) & 255;
  var integer = (val << 16) + (val << 8) + val;
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$2.rgb.gray = function(rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};
var conversions$1 = conversions$2.exports;
function buildGraph() {
  var graph = {};
  var models2 = Object.keys(conversions$1);
  for (var len = models2.length, i2 = 0; i2 < len; i2++) {
    graph[models2[i2]] = {
      distance: -1,
      parent: null
    };
  }
  return graph;
}
function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue = [fromModel];
  graph[fromModel].distance = 0;
  while (queue.length) {
    var current = queue.pop();
    var adjacents = Object.keys(conversions$1[current]);
    for (var len = adjacents.length, i2 = 0; i2 < len; i2++) {
      var adjacent = adjacents[i2];
      var node4 = graph[adjacent];
      if (node4.distance === -1) {
        node4.distance = graph[current].distance + 1;
        node4.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from4, to) {
  return function(args) {
    return to(from4(args));
  };
}
function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel];
  var fn2 = conversions$1[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn2 = link(conversions$1[graph[cur].parent][cur], fn2);
    cur = graph[cur].parent;
  }
  fn2.conversion = path;
  return fn2;
}
var route$1 = function(fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models2 = Object.keys(graph);
  for (var len = models2.length, i2 = 0; i2 < len; i2++) {
    var toModel = models2[i2];
    var node4 = graph[toModel];
    if (node4.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};
var conversions = conversions$2.exports;
var route = route$1;
var convert$1 = {};
var models = Object.keys(conversions);
function wrapRaw(fn2) {
  var wrappedFn = function(args) {
    if (args === void 0 || args === null) {
      return args;
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }
    return fn2(args);
  };
  if ("conversion" in fn2) {
    wrappedFn.conversion = fn2.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn2) {
  var wrappedFn = function(args) {
    if (args === void 0 || args === null) {
      return args;
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }
    var result2 = fn2(args);
    if (typeof result2 === "object") {
      for (var len = result2.length, i2 = 0; i2 < len; i2++) {
        result2[i2] = Math.round(result2[i2]);
      }
    }
    return result2;
  };
  if ("conversion" in fn2) {
    wrappedFn.conversion = fn2.conversion;
  }
  return wrappedFn;
}
models.forEach(function(fromModel) {
  convert$1[fromModel] = {};
  Object.defineProperty(convert$1[fromModel], "channels", { value: conversions[fromModel].channels });
  Object.defineProperty(convert$1[fromModel], "labels", { value: conversions[fromModel].labels });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function(toModel) {
    var fn2 = routes[toModel];
    convert$1[fromModel][toModel] = wrapRounded(fn2);
    convert$1[fromModel][toModel].raw = wrapRaw(fn2);
  });
});
var colorConvert = convert$1;
var colorString = colorString$1.exports;
var convert = colorConvert;
var _slice = [].slice;
var skippedModels = [
  "keyword",
  "gray",
  "hex"
];
var hashedModelKeys = {};
Object.keys(convert).forEach(function(model) {
  hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
});
var limiters = {};
function Color(obj, model) {
  if (!(this instanceof Color)) {
    return new Color(obj, model);
  }
  if (model && model in skippedModels) {
    model = null;
  }
  if (model && !(model in convert)) {
    throw new Error("Unknown model: " + model);
  }
  var i2;
  var channels;
  if (obj == null) {
    this.model = "rgb";
    this.color = [0, 0, 0];
    this.valpha = 1;
  } else if (obj instanceof Color) {
    this.model = obj.model;
    this.color = obj.color.slice();
    this.valpha = obj.valpha;
  } else if (typeof obj === "string") {
    var result2 = colorString.get(obj);
    if (result2 === null) {
      throw new Error("Unable to parse color from string: " + obj);
    }
    this.model = result2.model;
    channels = convert[this.model].channels;
    this.color = result2.value.slice(0, channels);
    this.valpha = typeof result2.value[channels] === "number" ? result2.value[channels] : 1;
  } else if (obj.length) {
    this.model = model || "rgb";
    channels = convert[this.model].channels;
    var newArr = _slice.call(obj, 0, channels);
    this.color = zeroArray(newArr, channels);
    this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
  } else if (typeof obj === "number") {
    obj &= 16777215;
    this.model = "rgb";
    this.color = [
      obj >> 16 & 255,
      obj >> 8 & 255,
      obj & 255
    ];
    this.valpha = 1;
  } else {
    this.valpha = 1;
    var keys2 = Object.keys(obj);
    if ("alpha" in obj) {
      keys2.splice(keys2.indexOf("alpha"), 1);
      this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
    }
    var hashedKeys = keys2.sort().join("");
    if (!(hashedKeys in hashedModelKeys)) {
      throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
    }
    this.model = hashedModelKeys[hashedKeys];
    var labels = convert[this.model].labels;
    var color2 = [];
    for (i2 = 0; i2 < labels.length; i2++) {
      color2.push(obj[labels[i2]]);
    }
    this.color = zeroArray(color2);
  }
  if (limiters[this.model]) {
    channels = convert[this.model].channels;
    for (i2 = 0; i2 < channels; i2++) {
      var limit = limiters[this.model][i2];
      if (limit) {
        this.color[i2] = limit(this.color[i2]);
      }
    }
  }
  this.valpha = Math.max(0, Math.min(1, this.valpha));
  if (Object.freeze) {
    Object.freeze(this);
  }
}
Color.prototype = {
  toString: function() {
    return this.string();
  },
  toJSON: function() {
    return this[this.model]();
  },
  string: function(places) {
    var self = this.model in colorString.to ? this : this.rgb();
    self = self.round(typeof places === "number" ? places : 1);
    var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
    return colorString.to[self.model](args);
  },
  percentString: function(places) {
    var self = this.rgb().round(typeof places === "number" ? places : 1);
    var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
    return colorString.to.rgb.percent(args);
  },
  array: function() {
    return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
  },
  object: function() {
    var result2 = {};
    var channels = convert[this.model].channels;
    var labels = convert[this.model].labels;
    for (var i2 = 0; i2 < channels; i2++) {
      result2[labels[i2]] = this.color[i2];
    }
    if (this.valpha !== 1) {
      result2.alpha = this.valpha;
    }
    return result2;
  },
  unitArray: function() {
    var rgb = this.rgb().color;
    rgb[0] /= 255;
    rgb[1] /= 255;
    rgb[2] /= 255;
    if (this.valpha !== 1) {
      rgb.push(this.valpha);
    }
    return rgb;
  },
  unitObject: function() {
    var rgb = this.rgb().object();
    rgb.r /= 255;
    rgb.g /= 255;
    rgb.b /= 255;
    if (this.valpha !== 1) {
      rgb.alpha = this.valpha;
    }
    return rgb;
  },
  round: function(places) {
    places = Math.max(places || 0, 0);
    return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
  },
  alpha: function(val) {
    if (arguments.length) {
      return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
    }
    return this.valpha;
  },
  red: getset("rgb", 0, maxfn(255)),
  green: getset("rgb", 1, maxfn(255)),
  blue: getset("rgb", 2, maxfn(255)),
  hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
    return (val % 360 + 360) % 360;
  }),
  saturationl: getset("hsl", 1, maxfn(100)),
  lightness: getset("hsl", 2, maxfn(100)),
  saturationv: getset("hsv", 1, maxfn(100)),
  value: getset("hsv", 2, maxfn(100)),
  chroma: getset("hcg", 1, maxfn(100)),
  gray: getset("hcg", 2, maxfn(100)),
  white: getset("hwb", 1, maxfn(100)),
  wblack: getset("hwb", 2, maxfn(100)),
  cyan: getset("cmyk", 0, maxfn(100)),
  magenta: getset("cmyk", 1, maxfn(100)),
  yellow: getset("cmyk", 2, maxfn(100)),
  black: getset("cmyk", 3, maxfn(100)),
  x: getset("xyz", 0, maxfn(100)),
  y: getset("xyz", 1, maxfn(100)),
  z: getset("xyz", 2, maxfn(100)),
  l: getset("lab", 0, maxfn(100)),
  a: getset("lab", 1),
  b: getset("lab", 2),
  keyword: function(val) {
    if (arguments.length) {
      return new Color(val);
    }
    return convert[this.model].keyword(this.color);
  },
  hex: function(val) {
    if (arguments.length) {
      return new Color(val);
    }
    return colorString.to.hex(this.rgb().round().color);
  },
  rgbNumber: function() {
    var rgb = this.rgb().color;
    return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
  },
  luminosity: function() {
    var rgb = this.rgb().color;
    var lum = [];
    for (var i2 = 0; i2 < rgb.length; i2++) {
      var chan = rgb[i2] / 255;
      lum[i2] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  },
  contrast: function(color2) {
    var lum1 = this.luminosity();
    var lum2 = color2.luminosity();
    if (lum1 > lum2) {
      return (lum1 + 0.05) / (lum2 + 0.05);
    }
    return (lum2 + 0.05) / (lum1 + 0.05);
  },
  level: function(color2) {
    var contrastRatio = this.contrast(color2);
    if (contrastRatio >= 7.1) {
      return "AAA";
    }
    return contrastRatio >= 4.5 ? "AA" : "";
  },
  isDark: function() {
    var rgb = this.rgb().color;
    var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
    return yiq < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  negate: function() {
    var rgb = this.rgb();
    for (var i2 = 0; i2 < 3; i2++) {
      rgb.color[i2] = 255 - rgb.color[i2];
    }
    return rgb;
  },
  lighten: function(ratio) {
    var hsl = this.hsl();
    hsl.color[2] += hsl.color[2] * ratio;
    return hsl;
  },
  darken: function(ratio) {
    var hsl = this.hsl();
    hsl.color[2] -= hsl.color[2] * ratio;
    return hsl;
  },
  saturate: function(ratio) {
    var hsl = this.hsl();
    hsl.color[1] += hsl.color[1] * ratio;
    return hsl;
  },
  desaturate: function(ratio) {
    var hsl = this.hsl();
    hsl.color[1] -= hsl.color[1] * ratio;
    return hsl;
  },
  whiten: function(ratio) {
    var hwb = this.hwb();
    hwb.color[1] += hwb.color[1] * ratio;
    return hwb;
  },
  blacken: function(ratio) {
    var hwb = this.hwb();
    hwb.color[2] += hwb.color[2] * ratio;
    return hwb;
  },
  grayscale: function() {
    var rgb = this.rgb().color;
    var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
    return Color.rgb(val, val, val);
  },
  fade: function(ratio) {
    return this.alpha(this.valpha - this.valpha * ratio);
  },
  opaquer: function(ratio) {
    return this.alpha(this.valpha + this.valpha * ratio);
  },
  rotate: function(degrees) {
    var hsl = this.hsl();
    var hue = hsl.color[0];
    hue = (hue + degrees) % 360;
    hue = hue < 0 ? 360 + hue : hue;
    hsl.color[0] = hue;
    return hsl;
  },
  mix: function(mixinColor, weight) {
    if (!mixinColor || !mixinColor.rgb) {
      throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
    }
    var color1 = mixinColor.rgb();
    var color2 = this.rgb();
    var p2 = weight === void 0 ? 0.5 : weight;
    var w2 = 2 * p2 - 1;
    var a2 = color1.alpha() - color2.alpha();
    var w1 = ((w2 * a2 === -1 ? w2 : (w2 + a2) / (1 + w2 * a2)) + 1) / 2;
    var w22 = 1 - w1;
    return Color.rgb(w1 * color1.red() + w22 * color2.red(), w1 * color1.green() + w22 * color2.green(), w1 * color1.blue() + w22 * color2.blue(), color1.alpha() * p2 + color2.alpha() * (1 - p2));
  }
};
Object.keys(convert).forEach(function(model) {
  if (skippedModels.indexOf(model) !== -1) {
    return;
  }
  var channels = convert[model].channels;
  Color.prototype[model] = function() {
    if (this.model === model) {
      return new Color(this);
    }
    if (arguments.length) {
      return new Color(arguments, model);
    }
    var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
    return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
  };
  Color[model] = function(color2) {
    if (typeof color2 === "number") {
      color2 = zeroArray(_slice.call(arguments), channels);
    }
    return new Color(color2, model);
  };
});
function roundTo(num, places) {
  return Number(num.toFixed(places));
}
function roundToPlace(places) {
  return function(num) {
    return roundTo(num, places);
  };
}
function getset(model, channel, modifier) {
  model = Array.isArray(model) ? model : [model];
  model.forEach(function(m2) {
    (limiters[m2] || (limiters[m2] = []))[channel] = modifier;
  });
  model = model[0];
  return function(val) {
    var result2;
    if (arguments.length) {
      if (modifier) {
        val = modifier(val);
      }
      result2 = this[model]();
      result2.color[channel] = val;
      return result2;
    }
    result2 = this[model]().color[channel];
    if (modifier) {
      result2 = modifier(result2);
    }
    return result2;
  };
}
function maxfn(max3) {
  return function(v2) {
    return Math.max(0, Math.min(max3, v2));
  };
}
function assertArray(val) {
  return Array.isArray(val) ? val : [val];
}
function zeroArray(arr, length) {
  for (var i2 = 0; i2 < length; i2++) {
    if (typeof arr[i2] !== "number") {
      arr[i2] = 0;
    }
  }
  return arr;
}
var color = Color;
function isLight(color$1) {
  return color(color$1).isLight();
}
function contrast(color2) {
  if (!color2)
    return function() {
      return void 0;
    };
  if (typeof color2 === "function") {
    return function(palette2) {
      return contrast(color2(palette2))(palette2);
    };
  }
  var colorIsLight = isLight(color2);
  return function(palette2) {
    if (colorIsLight)
      return getPalette(palette2, "black") || "black";
    return getPalette(palette2, "white") || "white";
  };
}
var palette = {
  white: "#ffffff",
  black: "#212121",
  light: "#f8f9fa",
  dark: "#343a40",
  primary: "#006DFF",
  secondary: "#6C757D",
  success: "#28A745",
  info: "#17A2B8",
  warning: "#FFC107",
  danger: "#DC3545",
  background: ref("white", "#ffffff"),
  foreground: contrast(ref("background", "#ffffff"))
};
function getPalette(palette$1, name) {
  if (palette$1 === void 0) {
    palette$1 = palette;
  }
  if (!name)
    return void 0;
  var color2 = palette$1[name];
  while (typeof color2 === "function") {
    color2 = color2(palette$1);
  }
  return color2;
}
function ref(name, fallback) {
  return function(palette2) {
    return getPalette(palette2, name) || fallback;
  };
}
var CommandIconComponent = (props) => {
  var icon = props.icon, wrapperClass = props.wrapperClass;
  if (isString$1(icon)) {
    return /* @__PURE__ */ jsx(Icon, {
      name: icon
    });
  }
  return /* @__PURE__ */ jsxs(Box, {
    as: "span",
    className: wrapperClass,
    children: [icon.sup && icon.sup, /* @__PURE__ */ jsx(Icon, {
      name: icon.name
    }), icon.sub && icon.sub]
  });
};
var _excluded$b = ["fill", "palette"], _excluded2$7 = ["unstable_system"];
function useButtonOptions(_ref) {
  var _ref$unstable_system = _ref.unstable_system;
  _ref$unstable_system = _ref$unstable_system === void 0 ? {} : _ref$unstable_system;
  var _ref$unstable_system$ = _ref$unstable_system.fill, fill = _ref$unstable_system$ === void 0 ? "opaque" : _ref$unstable_system$, _ref$unstable_system$2 = _ref$unstable_system.palette, palette2 = _ref$unstable_system$2 === void 0 ? "primary" : _ref$unstable_system$2, system2 = _objectWithoutProperties(_ref$unstable_system, _excluded$b), options = _objectWithoutProperties(_ref, _excluded2$7);
  return _objectSpread2$3({
    unstable_system: _objectSpread2$3({
      fill,
      palette: palette2
    }, system2)
  }, options);
}
function useButtonProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.BUTTON, htmlProps.className)
  });
}
var _excluded$a = ["fill", "palette"], _excluded2$6 = ["unstable_system"];
function useCompositeItemOptions(_ref) {
  var _ref$unstable_system = _ref.unstable_system;
  _ref$unstable_system = _ref$unstable_system === void 0 ? {} : _ref$unstable_system;
  var _ref$unstable_system$ = _ref$unstable_system.fill, fill = _ref$unstable_system$ === void 0 ? "opaque" : _ref$unstable_system$, _ref$unstable_system$2 = _ref$unstable_system.palette, palette2 = _ref$unstable_system$2 === void 0 ? "primary" : _ref$unstable_system$2, system2 = _objectWithoutProperties(_ref$unstable_system, _excluded$a), options = _objectWithoutProperties(_ref, _excluded2$6);
  return _objectSpread2$3({
    unstable_system: _objectSpread2$3({
      fill,
      palette: palette2
    }, system2)
  }, options);
}
function useCompositeItemProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3({}, htmlProps);
}
var _excluded$9 = ["palette", "fill"], _excluded2$5 = ["unstable_system"];
function useDialogOptions(_ref) {
  var _ref$unstable_system = _ref.unstable_system;
  _ref$unstable_system = _ref$unstable_system === void 0 ? {} : _ref$unstable_system;
  var _ref$unstable_system$ = _ref$unstable_system.palette, palette2 = _ref$unstable_system$ === void 0 ? "background" : _ref$unstable_system$, _ref$unstable_system$2 = _ref$unstable_system.fill, fill = _ref$unstable_system$2 === void 0 ? "opaque" : _ref$unstable_system$2, system2 = _objectWithoutProperties(_ref$unstable_system, _excluded$9), options = _objectWithoutProperties(_ref, _excluded2$5);
  return _objectSpread2$3(_objectSpread2$3({}, options), {}, {
    unstable_system: _objectSpread2$3({
      palette: palette2,
      fill
    }, system2)
  });
}
function useDialogProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.DIALOG, htmlProps.className)
  });
}
function useDialogBackdropProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.DIALOG_BACKDROP, htmlProps.className)
  });
}
var _excluded$8 = ["fill"], _excluded2$4 = ["unstable_system"], _excluded3$1 = ["unstable_system"], _excluded4$1 = ["fill"], _excluded5 = ["unstable_system"], _excluded6 = ["palette"], _excluded7 = ["unstable_system"];
function useFormProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.FORM)
  });
}
function useFormInputOptions(_ref) {
  var _ref$unstable_system = _ref.unstable_system;
  _ref$unstable_system = _ref$unstable_system === void 0 ? {} : _ref$unstable_system;
  var _ref$unstable_system$ = _ref$unstable_system.fill, fill = _ref$unstable_system$ === void 0 ? "outline" : _ref$unstable_system$, system2 = _objectWithoutProperties(_ref$unstable_system, _excluded$8), options = _objectWithoutProperties(_ref, _excluded2$4);
  var isInvalid = Boolean(unstable_getIn(options.touched, options.name) && unstable_getIn(options.errors, options.name));
  return _objectSpread2$3({
    unstable_system: _objectSpread2$3(_objectSpread2$3({
      fill
    }, system2), {}, {
      palette: isInvalid ? "danger" : system2.palette
    })
  }, options);
}
function useFormMessageOptions(_ref2) {
  var _ref2$unstable_system = _ref2.unstable_system, system2 = _ref2$unstable_system === void 0 ? {} : _ref2$unstable_system, options = _objectWithoutProperties(_ref2, _excluded3$1);
  var isInvalid = Boolean(unstable_getIn(options.errors, options.name));
  return _objectSpread2$3({
    unstable_system: _objectSpread2$3(_objectSpread2$3({}, system2), {}, {
      palette: isInvalid ? "danger" : system2.palette || "success"
    })
  }, options);
}
function useFormMessageProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.FORM_MESSAGE)
  });
}
function useFormLabelProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.FORM_LABEL)
  });
}
function useFormGroupOptions(_ref3) {
  var _ref3$unstable_system = _ref3.unstable_system;
  _ref3$unstable_system = _ref3$unstable_system === void 0 ? {} : _ref3$unstable_system;
  var _ref3$unstable_system2 = _ref3$unstable_system.fill, fill = _ref3$unstable_system2 === void 0 ? "outline" : _ref3$unstable_system2, system2 = _objectWithoutProperties(_ref3$unstable_system, _excluded4$1), options = _objectWithoutProperties(_ref3, _excluded5);
  var isInvalid = Boolean(unstable_getIn(options.touched, options.name) && unstable_getIn(options.errors, options.name));
  return _objectSpread2$3({
    unstable_system: _objectSpread2$3(_objectSpread2$3({
      fill
    }, system2), {}, {
      palette: isInvalid ? "danger" : system2.palette
    })
  }, options);
}
function useFormGroupProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.FORM_GROUP)
  });
}
function useFormRemoveButtonOptions(_ref4) {
  var _ref4$unstable_system = _ref4.unstable_system;
  _ref4$unstable_system = _ref4$unstable_system === void 0 ? {} : _ref4$unstable_system;
  var _ref4$unstable_system2 = _ref4$unstable_system.palette, palette2 = _ref4$unstable_system2 === void 0 ? "danger" : _ref4$unstable_system2, system2 = _objectWithoutProperties(_ref4$unstable_system, _excluded6), options = _objectWithoutProperties(_ref4, _excluded7);
  return _objectSpread2$3({
    unstable_system: _objectSpread2$3({
      palette: palette2
    }, system2)
  }, options);
}
function useGroupProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.GROUP)
  });
}
function useInputProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.INPUT)
  });
}
var _excluded$7 = ["palette", "fill"], _excluded2$3 = ["unstable_system"], _excluded3 = ["wrapElement"], _excluded4 = ["children"];
function useMenuBarProps(_ref) {
  var orientation = _ref.orientation;
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.MENU_BAR, orientation === "horizontal" ? componentsTheme.FLEX_ROW : componentsTheme.FLEX_COLUMN, htmlProps.className)
  });
}
function useMenuItemProps(_ref2) {
  var orientation = _ref2.orientation;
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.MENU_ITEM, orientation === "horizontal" ? componentsTheme.MENU_ITEM_ROW : componentsTheme.MENU_ITEM_COLUMN, htmlProps.className)
  });
}
var OrientationContext = /* @__PURE__ */ react$1.exports.createContext(void 0);
function useMenuOptions(_ref3) {
  var _options$unstable_pop, _options$unstable_pop2;
  var _ref3$unstable_system = _ref3.unstable_system;
  _ref3$unstable_system = _ref3$unstable_system === void 0 ? {} : _ref3$unstable_system;
  var _ref3$unstable_system2 = _ref3$unstable_system.palette, palette2 = _ref3$unstable_system2 === void 0 ? "background" : _ref3$unstable_system2, _ref3$unstable_system3 = _ref3$unstable_system.fill, fill = _ref3$unstable_system3 === void 0 ? "opaque" : _ref3$unstable_system3, system2 = _objectWithoutProperties(_ref3$unstable_system, _excluded$7), options = _objectWithoutProperties(_ref3, _excluded2$3);
  var parentOrientation = react$1.exports.useContext(OrientationContext);
  var unstable_system = _objectSpread2$3({
    palette: palette2,
    fill
  }, system2);
  var transform = (_options$unstable_pop = (_options$unstable_pop2 = options.unstable_popoverStyles) === null || _options$unstable_pop2 === void 0 ? void 0 : _options$unstable_pop2.transform) !== null && _options$unstable_pop !== void 0 ? _options$unstable_pop : "";
  if (parentOrientation === "vertical" && options.orientation === "vertical") {
    return _objectSpread2$3(_objectSpread2$3({}, options), {}, {
      unstable_system,
      unstable_popoverStyles: _objectSpread2$3(_objectSpread2$3({}, options.unstable_popoverStyles), {}, {
        transform: "".concat(transform, " translate3d(0px, -0.3em, 0px)")
      })
    });
  }
  return _objectSpread2$3(_objectSpread2$3({}, options), {}, {
    unstable_system
  });
}
function useMenuProps(options) {
  var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var htmlWrapElement = _ref4.wrapElement, htmlProps = _objectWithoutProperties(_ref4, _excluded3);
  var wrapElement = react$1.exports.useCallback((element) => {
    if (htmlWrapElement) {
      element = htmlWrapElement(element);
    }
    return /* @__PURE__ */ jsx(OrientationContext.Provider, {
      value: options.orientation,
      children: element
    });
  }, [htmlWrapElement, options.orientation]);
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    wrapElement,
    className: cx2(componentsTheme.MENU, htmlProps.className)
  });
}
function useMenuButtonProps(options) {
  var _options$unstable_ori;
  var _ref5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var children = _ref5.children, htmlProps = _objectWithoutProperties(_ref5, _excluded4);
  var placement = (_options$unstable_ori = options.unstable_originalPlacement) !== null && _options$unstable_ori !== void 0 ? _options$unstable_ori : options.placement;
  var dir = placement ? placement.split("-")[0] : void 0;
  var svg = dir ? {
    top: /* @__PURE__ */ jsx("svg", {
      viewBox: "0 0 50 43.3",
      children: /* @__PURE__ */ jsx("polygon", {
        points: "25 0 0 43.3 50 43.3 25 0"
      })
    }),
    bottom: /* @__PURE__ */ jsx("svg", {
      viewBox: "0 0 50 43.3",
      children: /* @__PURE__ */ jsx("polygon", {
        points: "25 43.3 50 0 0 0 25 43.3"
      })
    }),
    right: /* @__PURE__ */ jsx("svg", {
      viewBox: "0 0 43.3 50",
      children: /* @__PURE__ */ jsx("polygon", {
        points: "43.3 25 0 0 0 50 43.3 25"
      })
    }),
    left: /* @__PURE__ */ jsx("svg", {
      viewBox: "0 0 43.3 50",
      children: /* @__PURE__ */ jsx("polygon", {
        points: "0 25 43.3 50 43.3 0 0 25"
      })
    })
  }[dir] : null;
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    children: typeof children === "function" ? (props) => {
      var child3 = children(props);
      return /* @__PURE__ */ react$1.exports.cloneElement(child3, {
        children: /* @__PURE__ */ jsxs(Fragment$1, {
          children: [child3.props.children, svg]
        })
      });
    } : /* @__PURE__ */ jsxs(Fragment$1, {
      children: [children, svg]
    }),
    className: cx2(componentsTheme.MENU_BUTTON, dir === "left" ? componentsTheme.MENU_BUTTON_LEFT : componentsTheme.MENU_BUTTON_RIGHT, children && dir === "left" && componentsTheme.MENU_BUTTON_NESTED_LEFT, children && dir === "right" && componentsTheme.MENU_BUTTON_NESTED_RIGHT, htmlProps.className)
  });
}
function useMenuItemCheckboxProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.MENU_ITEM_CHECKBOX, htmlProps.className)
  });
}
function useMenuItemRadioProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.MENU_ITEM_CHECKBOX, htmlProps.className)
  });
}
function useMenuGroupProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.MENU_GROUP, htmlProps.className)
  });
}
var _excluded$6 = ["palette", "fill"], _excluded2$2 = ["unstable_system"];
function usePopoverOptions(_ref) {
  var _ref$unstable_system = _ref.unstable_system;
  _ref$unstable_system = _ref$unstable_system === void 0 ? {} : _ref$unstable_system;
  var _ref$unstable_system$ = _ref$unstable_system.palette, palette2 = _ref$unstable_system$ === void 0 ? "background" : _ref$unstable_system$, _ref$unstable_system$2 = _ref$unstable_system.fill, fill = _ref$unstable_system$2 === void 0 ? "opaque" : _ref$unstable_system$2, system2 = _objectWithoutProperties(_ref$unstable_system, _excluded$6), options = _objectWithoutProperties(_ref, _excluded2$2);
  return _objectSpread2$3({
    unstable_system: _objectSpread2$3({
      palette: palette2,
      fill
    }, system2)
  }, options);
}
function usePopoverProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.POPOVER, htmlProps.className)
  });
}
function usePopoverArrowProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3({
    "data-arrow": ""
  }, htmlProps);
}
function useRoleProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.ROLE, htmlProps.className)
  });
}
function useSeparatorProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.SEPARATOR)
  });
}
function useTabProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.TAB, htmlProps.className)
  });
}
function useTabListProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.TAB_LIST)
  });
}
function useTabbableProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.TABBABLE)
  });
}
function useToolbarProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(htmlProps.className, componentsTheme.TOOLBAR)
  });
}
var _excluded$5 = ["palette", "fill"], _excluded2$1 = ["unstable_system"];
function useTooltipOptions(_ref) {
  var _ref$unstable_system = _ref.unstable_system;
  _ref$unstable_system = _ref$unstable_system === void 0 ? {} : _ref$unstable_system;
  var _ref$unstable_system$ = _ref$unstable_system.palette, palette2 = _ref$unstable_system$ === void 0 ? "foreground" : _ref$unstable_system$, _ref$unstable_system$2 = _ref$unstable_system.fill, fill = _ref$unstable_system$2 === void 0 ? "opaque" : _ref$unstable_system$2, system2 = _objectWithoutProperties(_ref$unstable_system, _excluded$5), options = _objectWithoutProperties(_ref, _excluded2$1);
  return _objectSpread2$3({
    unstable_system: _objectSpread2$3({
      palette: palette2,
      fill
    }, system2)
  }, options);
}
function useTooltipProps(_2) {
  var htmlProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _objectSpread2$3(_objectSpread2$3({}, htmlProps), {}, {
    className: cx2(componentsTheme.TOOLTIP, htmlProps.className)
  });
}
var system = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  useButtonOptions,
  useButtonProps,
  useCompositeItemOptions,
  useCompositeItemProps,
  useDialogOptions,
  useDialogProps,
  useDialogBackdropProps,
  useFormProps,
  useFormInputOptions,
  useFormMessageOptions,
  useFormMessageProps,
  useFormLabelProps,
  useFormGroupOptions,
  useFormGroupProps,
  useFormRemoveButtonOptions,
  useGroupProps,
  useInputProps,
  useMenuBarProps,
  useMenuItemProps,
  useMenuOptions,
  useMenuProps,
  useMenuButtonProps,
  useMenuItemCheckboxProps,
  useMenuItemRadioProps,
  useMenuGroupProps,
  palette,
  usePopoverOptions,
  usePopoverProps,
  usePopoverArrowProps,
  useRoleProps,
  useSeparatorProps,
  useTabProps,
  useTabListProps,
  useTabbableProps,
  useToolbarProps,
  useTooltipOptions,
  useTooltipProps
});
var ThemeContext = /* @__PURE__ */ react$1.exports.createContext({});
function useTheme() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var parent = react$1.exports.useContext(ThemeContext);
  var theme2 = react$1.exports.useMemo(() => {
    var _props$theme;
    return deepMerge(parent, (_props$theme = props.theme) !== null && _props$theme !== void 0 ? _props$theme : {});
  }, [parent, props.theme]);
  var style = react$1.exports.useMemo(() => createThemeVariables(theme2).styles, [theme2]);
  var className = cx2(THEME, props.className);
  return react$1.exports.useMemo(() => ({
    style,
    className,
    theme: theme2
  }), [style, className, theme2]);
}
var ThemeProvider = (props) => {
  var children = props.children, _props$as = props.as, Component2 = _props$as === void 0 ? "div" : _props$as;
  var _useTheme = useTheme({
    theme: props.theme
  }), theme2 = _useTheme.theme, style = _useTheme.style, className = _useTheme.className;
  return /* @__PURE__ */ jsx(Provider, {
    unstable_system: system,
    children: /* @__PURE__ */ jsx(ThemeContext.Provider, {
      value: theme2,
      children: /* @__PURE__ */ jsx(Component2, {
        style,
        className,
        children
      })
    })
  });
};
var ComponentItem;
(function(ComponentItem2) {
  ComponentItem2["Toolbar"] = "toolbar";
  ComponentItem2["ToolbarButton"] = "toolbar-button";
  ComponentItem2["ToolbarCommandButton"] = "toolbar-command-button";
  ComponentItem2["ToolbarComponent"] = "toolbar-component";
  ComponentItem2["ToolbarElement"] = "toolbar-element";
  ComponentItem2["ToolbarSeparator"] = "toolbar-separator";
  ComponentItem2["ToolbarGroup"] = "toolbar-group";
  ComponentItem2["ToolbarMenu"] = "toolbar-menu";
  ComponentItem2["MenuBar"] = "menu-bar";
  ComponentItem2["MenuBarGroup"] = "menu-bar-group";
  ComponentItem2["MenuDropdown"] = "menu-bar-dropdown";
  ComponentItem2["MenuSeparator"] = "menu-separator";
  ComponentItem2["MenuPane"] = "menu-pane";
  ComponentItem2["MenuCommandPane"] = "menu-command-pane";
  ComponentItem2["MenuGroup"] = "menu-group";
  ComponentItem2["MenuAction"] = "menu-action";
  ComponentItem2["MenuCommandAction"] = "menu-command-action";
})(ComponentItem || (ComponentItem = {}));
function getCommandOptionValue(value, commandProps) {
  return isFunction$1(value) ? value(commandProps) : value;
}
function isStringArray(array) {
  return isString$1(array[0]);
}
function getUiShortcutString(uiShortcut, attrs) {
  var _shortcut, _ref, _uiShortcut$find;
  if (isString$1(uiShortcut)) {
    return uiShortcut;
  }
  if (!isArray(uiShortcut)) {
    return uiShortcut.shortcut;
  }
  if (isStringArray(uiShortcut)) {
    var _uiShortcut$;
    return (_uiShortcut$ = uiShortcut[0]) !== null && _uiShortcut$ !== void 0 ? _uiShortcut$ : "";
  }
  return (_shortcut = (_ref = (_uiShortcut$find = uiShortcut.find((shortcut) => isEqual(shortcut.attrs, attrs))) !== null && _uiShortcut$find !== void 0 ? _uiShortcut$find : uiShortcut[0]) === null || _ref === void 0 ? void 0 : _ref.shortcut) !== null && _shortcut !== void 0 ? _shortcut : "";
}
var CASINGS = {
  title: (value) => capitalize(value),
  upper: (value) => value.toLocaleUpperCase(),
  lower: (value) => value.toLocaleLowerCase()
};
function getShortcutString(shortcut, options) {
  var _options$casing = options.casing, casing = _options$casing === void 0 ? "title" : _options$casing, _options$namedAsSymbo = options.namedAsSymbol, namedAsSymbol = _options$namedAsSymbo === void 0 ? false : _options$namedAsSymbo, _options$modifierAsSy = options.modifierAsSymbol, modifierAsSymbol = _options$modifierAsSy === void 0 ? true : _options$modifierAsSy, _options$separator = options.separator, separator2 = _options$separator === void 0 ? " " : _options$separator, t2 = options.t;
  var symbols = getShortcutSymbols(shortcut);
  var stringSymbols = [];
  var transform = CASINGS[casing];
  var _iterator = _createForOfIteratorHelper(symbols), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var sym = _step.value;
      if (sym.type === "char") {
        stringSymbols.push(transform(sym.key));
        continue;
      }
      if (sym.type === "named") {
        var _sym$symbol;
        var _value = namedAsSymbol === true || isArray(namedAsSymbol) && includes(namedAsSymbol, sym.key) ? (_sym$symbol = sym.symbol) !== null && _sym$symbol !== void 0 ? _sym$symbol : t2(sym.i18n) : t2(sym.i18n);
        stringSymbols.push(transform(_value));
        continue;
      }
      var value = modifierAsSymbol === true || isArray(modifierAsSymbol) && includes(modifierAsSymbol, sym.key) ? sym.symbol : t2(sym.i18n);
      stringSymbols.push(transform(value));
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  return stringSymbols.join(separator2);
}
var _excluded$3 = ["menuItems", "label", "menuLabel", "icon"];
var MenuGroup = (props) => {
  var menuState = props.menuState, group = props.item;
  var items = group.items, label = group.label, role = group.role, separator2 = group.separator;
  var startSeparator = includes(["start", "both"], separator2) && /* @__PURE__ */ jsx(MenuSeparator, _objectSpread2$3({}, menuState));
  var endSeparator = includes(["end", "both"], separator2) && /* @__PURE__ */ jsx(MenuSeparator, _objectSpread2$3({}, menuState));
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [startSeparator, /* @__PURE__ */ jsx(MenuGroup$1, _objectSpread2$3(_objectSpread2$3({}, menuState), {}, {
      "aria-label": label,
      children: items.map((item, index3) => {
        switch (item.type) {
          case ComponentItem.MenuPane:
            return /* @__PURE__ */ jsx(MenuPane, {
              menuState,
              item
            }, index3);
          case ComponentItem.MenuCommandPane:
            return /* @__PURE__ */ jsx(MenuCommandPane, {
              menuState,
              item,
              role
            }, index3);
          case ComponentItem.MenuDropdown:
            return /* @__PURE__ */ jsx(MenuDropdown, {
              item,
              menuState
            }, index3);
        }
      })
    })), endSeparator]
  });
};
var MenuPane = (props) => {
  return /* @__PURE__ */ jsx(MenuItem, _objectSpread2$3({}, props.menuState));
};
var MenuCommandPane = (props) => {
  var _ref, _item$refocusEditor, _commands$commandName, _commands$commandName2, _active$options$name, _active$options$name2;
  var context2 = useRemirrorContext();
  var menuState = props.menuState, item = props.item, role = props.role;
  var commands = useCommands();
  var chain = useChainedCommands();
  var _useHelpers = useHelpers(), getCommandOptions = _useHelpers.getCommandOptions;
  var _useI18n = useI18n(), t2 = _useI18n.t;
  var autoFocus = (_ref = (_item$refocusEditor = item.refocusEditor) !== null && _item$refocusEditor !== void 0 ? _item$refocusEditor : props.autoFocus) !== null && _ref !== void 0 ? _ref : false;
  var active = useActive();
  var commandName = item.commandName, attrs = item.attrs, _item$displayShortcut = item.displayShortcut, displayShortcut = _item$displayShortcut === void 0 ? true : _item$displayShortcut;
  var options = getCommandOptions(commandName);
  if (!options) {
    return /* @__PURE__ */ jsxs("span", {
      children: ["Not found: ", commandName]
    });
  }
  var enabled = (_commands$commandName = (_commands$commandName2 = commands[commandName]) === null || _commands$commandName2 === void 0 ? void 0 : _commands$commandName2.isEnabled(attrs)) !== null && _commands$commandName !== void 0 ? _commands$commandName : false;
  var isActive = (_active$options$name = (_active$options$name2 = active[options.name]) === null || _active$options$name2 === void 0 ? void 0 : _active$options$name2.call(active, attrs)) !== null && _active$options$name !== void 0 ? _active$options$name : false;
  var commandProps = {
    active: isActive,
    attrs,
    enabled,
    t: t2
  };
  var label = getCommandOptionValue(options.label, commandProps);
  var icon = getCommandOptionValue(options.icon, commandProps);
  var shortcutString = displayShortcut && options.shortcut ? "".concat(getShortcutString(getUiShortcutString(options.shortcut, attrs !== null && attrs !== void 0 ? attrs : {}), {
    t: t2
  })) : void 0;
  var onClick = (event) => {
    var _chain$commandName;
    if (item.onClick) {
      item.onClick(event, context2);
      return;
    }
    if (options.disableChaining) {
      var _commands$commandName3;
      (_commands$commandName3 = commands[commandName]) === null || _commands$commandName3 === void 0 ? void 0 : _commands$commandName3.call(commands, attrs);
      return;
    }
    var command2 = (_chain$commandName = chain[commandName]) === null || _chain$commandName === void 0 ? void 0 : _chain$commandName.call(chain, attrs);
    if (autoFocus) {
      var _command$focus;
      command2 === null || command2 === void 0 ? void 0 : (_command$focus = command2.focus) === null || _command$focus === void 0 ? void 0 : _command$focus.call(command2);
    }
    command2 === null || command2 === void 0 ? void 0 : command2.run();
  };
  return /* @__PURE__ */ jsxs(BaseMenuPane, {
    menuState,
    disabled: !enabled,
    focusable: enabled,
    onClick,
    active: isActive,
    role,
    children: [icon && /* @__PURE__ */ jsx(Box, {
      as: "span",
      className: componentsTheme.MENU_PANE_ICON,
      children: /* @__PURE__ */ jsx(CommandIconComponent, {
        icon
      })
    }), /* @__PURE__ */ jsx(Box, {
      as: "span",
      className: componentsTheme.MENU_PANE_LABEL,
      children: label
    }), shortcutString && /* @__PURE__ */ jsx(Box, {
      as: "span",
      className: componentsTheme.MENU_PANE_SHORTCUT,
      children: shortcutString
    })]
  });
};
var MenuDropdown = (props) => {
  var menuState = props.menuState, item = props.item;
  var items = item.items, label = item.label, menuLabel = item.menuLabel;
  return /* @__PURE__ */ jsx(MenuItem, _objectSpread2$3(_objectSpread2$3({
    as: DropdownComponent
  }, menuState), {}, {
    menuItems: items,
    label,
    menuLabel
  }));
};
var DropdownComponent = /* @__PURE__ */ react$1.exports.forwardRef((props, ref2) => {
  var menuState = useMenuState();
  var menuItems = props.menuItems, Label = props.label, menuLabel = props.menuLabel, icon = props.icon, rest = _objectWithoutProperties(props, _excluded$3);
  var labelElement;
  var label = menuLabel;
  if (isString$1(Label)) {
    var _label;
    (_label = label) !== null && _label !== void 0 ? _label : label = Label;
  } else if (Label != null) {
    labelElement = /* @__PURE__ */ jsx(Label, {
      menuState
    });
  }
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsxs(MenuButton, _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, menuState), rest), {}, {
      ref: ref2,
      "aria-label": label,
      children: [labelElement && /* @__PURE__ */ jsx(Box, {
        as: "span",
        className: componentsTheme.MENU_DROPDOWN_LABEL,
        children: labelElement
      }), icon && /* @__PURE__ */ jsx(Box, {
        as: "span",
        className: componentsTheme.MENU_PANE_ICON,
        children: /* @__PURE__ */ jsx(CommandIconComponent, {
          icon
        })
      })]
    })), /* @__PURE__ */ jsx(MenuComponent, {
      items: menuItems,
      menuState,
      label
    })]
  });
});
DropdownComponent.displayName = "Dropdown";
var MenuComponent = (props) => {
  var open = props.open, items = props.items, menuState = props.menuState, label = props.label;
  var isControlled = react$1.exports.useRef(open != null);
  react$1.exports.useEffect(() => {
    !(isControlled.current === (open != null)) ? invariant(false, {
      code: ErrorConstant.REACT_COMPONENTS,
      message: "The controllable menu must either be controlled with a boolean value for `open` or uncontrolled (null | undefined value for `open`) for the lifetime of the component."
    }) : void 0;
    if (!isControlled.current) {
      return;
    }
    open ? menuState.show() : menuState.hide();
  }, [open, menuState]);
  return /* @__PURE__ */ jsx(Menu, _objectSpread2$3(_objectSpread2$3({}, menuState), {}, {
    "aria-label": label,
    children: items.map((item, index3) => {
      switch (item.type) {
        case ComponentItem.MenuSeparator:
          return /* @__PURE__ */ react$1.exports.createElement(MenuSeparator, _objectSpread2$3(_objectSpread2$3({}, menuState), {}, {
            key: index3
          }));
        case ComponentItem.MenuPane:
          return /* @__PURE__ */ jsx(MenuPane, {
            menuState,
            item
          }, index3);
        case ComponentItem.MenuCommandPane:
          return /* @__PURE__ */ jsx(MenuCommandPane, {
            menuState,
            item
          }, index3);
        case ComponentItem.MenuGroup:
          return /* @__PURE__ */ jsx(MenuGroup, {
            item,
            menuState
          }, index3);
        case ComponentItem.MenuDropdown:
          return /* @__PURE__ */ jsx(MenuDropdown, {
            item,
            menuState
          }, index3);
        default:
          return /* @__PURE__ */ jsx(Fragment$1, {});
      }
    })
  }));
};
var BaseMenuPane = (props) => {
  var state = props.menuState, _children = props.children, tooltip = props.tooltip, disabled = props.disabled, focusable = props.focusable, onClick = props.onClick, tooltipClass = props.tooltipClass, active = props.active, className = props.className;
  var tooltipState = useTooltipState({
    gutter: 5
  });
  var themeProps = useTheme({
    className: tooltipClass
  });
  var checked = props.role ? active ? "true" : "false" : void 0;
  var role = props.role === "checkbox" ? "menuitemcheckbox" : props.role === "radio" ? "menuitemradio" : void 0;
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(TooltipReference, _objectSpread2$3(_objectSpread2$3({}, tooltipState), {}, {
      children: (props2) => /* @__PURE__ */ jsx(MenuItem, _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, props2), state), {}, {
        role,
        "aria-checked": checked,
        disabled,
        focusable,
        onClick,
        className: cx2(className, componentsTheme.MENU_PANE, active && componentsTheme.MENU_PANE_ACTIVE),
        children: _children
      }))
    })), tooltip && /* @__PURE__ */ jsx(Tooltip, _objectSpread2$3(_objectSpread2$3({}, tooltipState), {}, {
      style: themeProps.style,
      className: cx2(themeProps.className),
      children: tooltip
    }))]
  });
};
var Toolbar = (props) => {
  var items = props.items, loop = props.loop, label = props.label, refocusEditor = props.refocusEditor, focusable = props.focusable;
  var toolbarState = useToolbarState({
    loop
  });
  var focusableProps = focusable === false ? {
    focusable: false,
    tabIndex: -1
  } : {};
  return /* @__PURE__ */ jsx(Toolbar$1, _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, toolbarState), focusableProps), {}, {
    "aria-label": label,
    children: items.map(getToolbarComponent({
      toolbarState,
      refocusEditor
    }))
  }));
};
var ToolbarCommandButton = (props) => {
  var _ref, _item$refocusEditor, _commands$name$isEnab, _commands$name, _active$options$name, _active$options$name2;
  var toolbarState = props.toolbarState, item = props.item;
  var commands = useCommands();
  var chain = useChainedCommands();
  var _useHelpers = useHelpers(), getCommandOptions = _useHelpers.getCommandOptions;
  var context2 = useRemirrorContext();
  var _useI18n = useI18n(), t2 = _useI18n.t;
  var refocusEditor = (_ref = (_item$refocusEditor = item.refocusEditor) !== null && _item$refocusEditor !== void 0 ? _item$refocusEditor : props.refocusEditor) !== null && _ref !== void 0 ? _ref : false;
  var active = useActive();
  var display = item.display, name = item.commandName, attrs = item.attrs, _item$displayShortcut = item.displayShortcut, displayShortcut = _item$displayShortcut === void 0 ? true : _item$displayShortcut;
  var options = getCommandOptions(name);
  if (!options) {
    return /* @__PURE__ */ jsx(Fragment$1, {});
  }
  var enabled = (_commands$name$isEnab = (_commands$name = commands[name]) === null || _commands$name === void 0 ? void 0 : _commands$name.isEnabled(attrs)) !== null && _commands$name$isEnab !== void 0 ? _commands$name$isEnab : false;
  var isActive = (_active$options$name = (_active$options$name2 = active[options.name]) === null || _active$options$name2 === void 0 ? void 0 : _active$options$name2.call(active, attrs)) !== null && _active$options$name !== void 0 ? _active$options$name : false;
  var commandProps = {
    active: isActive,
    attrs,
    enabled,
    t: t2
  };
  var description = getCommandOptionValue(options.description, commandProps);
  var label = getCommandOptionValue(options.label, commandProps);
  var icon = getCommandOptionValue(options.icon, commandProps);
  var shortcutString = displayShortcut && options.shortcut ? " (".concat(getShortcutString(getUiShortcutString(options.shortcut, attrs !== null && attrs !== void 0 ? attrs : {}), {
    t: t2
  }), ")") : "";
  var onClick = (event) => {
    var _chain$name;
    if (item.onClick) {
      item.onClick(event, context2);
      return;
    }
    if (options.disableChaining) {
      var _commands$name2;
      (_commands$name2 = commands[name]) === null || _commands$name2 === void 0 ? void 0 : _commands$name2.call(commands, attrs);
      return;
    }
    var command2 = (_chain$name = chain[name]) === null || _chain$name === void 0 ? void 0 : _chain$name.call(chain, attrs);
    if (refocusEditor) {
      var _command$focus;
      command2 === null || command2 === void 0 ? void 0 : (_command$focus = command2.focus) === null || _command$focus === void 0 ? void 0 : _command$focus.call(command2);
    }
    command2 === null || command2 === void 0 ? void 0 : command2.run();
  };
  switch (display) {
    case "icon": {
      !(label && icon) ? invariant(false, {
        code: ErrorConstant.REACT_CONTROLLED,
        message: "Both label and icon are needed for the command: ".concat(name, " in extension: ").concat(options.name)
      }) : void 0;
      return /* @__PURE__ */ jsxs(BaseToolbarButton, {
        toolbarState,
        disabled: !enabled,
        focusable: enabled,
        tooltip: "".concat(label).concat(shortcutString),
        onClick,
        active: isActive,
        children: [/* @__PURE__ */ jsx(VisuallyHidden, {
          children: label
        }), /* @__PURE__ */ jsx(CommandIconComponent, {
          icon
        })]
      });
    }
    case "label": {
      !(label && description) ? invariant(false, {
        code: ErrorConstant.REACT_CONTROLLED,
        message: "Both label and description are needed for the command: ".concat(name, " in extension: ").concat(options.name)
      }) : void 0;
      return /* @__PURE__ */ jsx(BaseToolbarButton, {
        toolbarState,
        disabled: !enabled,
        focusable: enabled,
        tooltip: "".concat(description).concat(shortcutString),
        onClick,
        active: isActive,
        children: label
      });
    }
    default: {
      !(label && icon) ? invariant(false, {
        code: ErrorConstant.REACT_CONTROLLED,
        message: "Icon, label and description are needed for the command: ".concat(name, " in extension: ").concat(options.name)
      }) : void 0;
      return /* @__PURE__ */ jsxs(BaseToolbarButton, {
        toolbarState,
        disabled: !enabled,
        focusable: enabled,
        tooltip: "".concat(label).concat(shortcutString),
        onClick,
        active: isActive,
        children: [display === "label-icon" && /* @__PURE__ */ jsxs(Box, {
          as: "span",
          children: [" ", label]
        }), /* @__PURE__ */ jsx(CommandIconComponent, {
          icon
        }), " ", display === "icon-label" && /* @__PURE__ */ jsxs(Box, {
          as: "span",
          children: [" ", label]
        })]
      });
    }
  }
};
var BaseToolbarButton = (props) => {
  var toolbarState = props.toolbarState, _children = props.children, tooltip = props.tooltip, disabled = props.disabled, focusable = props.focusable, onClick = props.onClick, tooltipClass = props.tooltipClass, active = props.active, className = props.className;
  var tooltipState = useTooltipState({
    gutter: 5
  });
  var themeProps = useTheme({
    className: tooltipClass
  });
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(TooltipReference, _objectSpread2$3(_objectSpread2$3({}, tooltipState), {}, {
      children: (props2) => /* @__PURE__ */ jsx(ToolbarItem, _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, props2), toolbarState), {}, {
        as: Button,
        disabled,
        focusable,
        onClick,
        className: cx2(className, active && componentsTheme.BUTTON_ACTIVE),
        children: _children
      }))
    })), tooltip && /* @__PURE__ */ jsx(Tooltip, _objectSpread2$3(_objectSpread2$3({}, tooltipState), {}, {
      style: themeProps.style,
      className: cx2(themeProps.className),
      children: tooltip
    }))]
  });
};
var ToolbarSeparator = (props) => {
  return /* @__PURE__ */ jsx(ToolbarSeparator$1, _objectSpread2$3({}, props.toolbarState));
};
var ToolbarGroup = (props) => {
  var toolbarState = props.toolbarState, refocusEditor = props.refocusEditor, group = props.item;
  var startSeparator = includes(["start", "both"], group.separator) && /* @__PURE__ */ jsx(ToolbarSeparator, {
    toolbarState
  });
  var endSeparator = includes(["end", "both"], group.separator) && /* @__PURE__ */ jsx(ToolbarSeparator, {
    toolbarState
  });
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [startSeparator, /* @__PURE__ */ jsx(Group, {
      "aria-label": group.label,
      children: group.items.map(getToolbarComponent({
        toolbarState,
        refocusEditor
      }))
    }), endSeparator]
  });
};
var ToolbarButton = (props) => {
  var _ref2, _item$refocusEditor2;
  var toolbarState = props.toolbarState, focusable = props.focusable, item = props.item;
  var context2 = useRemirrorContext();
  var refocusEditor = (_ref2 = (_item$refocusEditor2 = item.refocusEditor) !== null && _item$refocusEditor2 !== void 0 ? _item$refocusEditor2 : props.refocusEditor) !== null && _ref2 !== void 0 ? _ref2 : false;
  var disabled = item.disabled, label = item.label, icon = item.icon, _item$active = item.active, active = _item$active === void 0 ? false : _item$active;
  var onClick = react$1.exports.useCallback((event) => {
    item.onClick(event, context2);
    if (refocusEditor) {
      requestAnimationFrame(() => context2.commands.focus());
    }
  }, [refocusEditor, context2, item]);
  return /* @__PURE__ */ jsxs(BaseToolbarButton, {
    toolbarState,
    disabled,
    focusable,
    onClick,
    active,
    children: [/* @__PURE__ */ jsx(Box, {
      as: "span",
      children: label
    }), icon && /* @__PURE__ */ jsx(CommandIconComponent, {
      icon
    })]
  });
};
function getToolbarComponent(props) {
  return (item, index3, _2) => {
    var _item$key, _item$key2, _item$key3, _item$key4, _item$key5, _item$key6;
    var toolbarState = props.toolbarState, refocusEditor = props.refocusEditor;
    switch (item.type) {
      case ComponentItem.ToolbarCommandButton:
        return /* @__PURE__ */ jsx(ToolbarCommandButton, {
          item,
          toolbarState,
          refocusEditor
        }, (_item$key = item.key) !== null && _item$key !== void 0 ? _item$key : index3);
      case ComponentItem.ToolbarButton:
        return /* @__PURE__ */ jsx(ToolbarButton, {
          item,
          toolbarState,
          refocusEditor
        }, (_item$key2 = item.key) !== null && _item$key2 !== void 0 ? _item$key2 : index3);
      case ComponentItem.ToolbarGroup:
        return /* @__PURE__ */ jsx(ToolbarGroup, {
          item,
          toolbarState,
          refocusEditor
        }, (_item$key3 = item.key) !== null && _item$key3 !== void 0 ? _item$key3 : index3);
      case ComponentItem.ToolbarSeparator:
        return /* @__PURE__ */ jsx(ToolbarSeparator, {
          toolbarState
        }, (_item$key4 = item.key) !== null && _item$key4 !== void 0 ? _item$key4 : index3);
      case ComponentItem.ToolbarElement:
        return item.element;
      case ComponentItem.ToolbarComponent:
        return /* @__PURE__ */ jsx(item.Component, {
          Wrapper: ToolbarItem,
          toolbarState
        }, (_item$key5 = item.key) !== null && _item$key5 !== void 0 ? _item$key5 : index3);
      case ComponentItem.ToolbarMenu:
        return /* @__PURE__ */ jsx(ToolbarMenu, {
          item,
          toolbarState
        }, (_item$key6 = item.key) !== null && _item$key6 !== void 0 ? _item$key6 : index3);
    }
  };
}
var ToolbarMenu = (props) => {
  var item = props.item, toolbarState = props.toolbarState;
  var items = item.items, label = item.label, menuLabel = item.menuLabel;
  return /* @__PURE__ */ jsx(ToolbarItem, _objectSpread2$3(_objectSpread2$3({}, toolbarState), {}, {
    as: DropdownComponent,
    menuItems: items,
    label,
    menuLabel
  }));
};
var isSafari = isUA("Mac") && !isUA("Chrome") && isUA("Safari");
function applyStyles(styles2) {
  return (prevStyles) => {
    if (styles2 && !shallowEqual(prevStyles, styles2)) {
      return styles2;
    }
    return prevStyles;
  };
}
function usePopper() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _props$gutter = props.gutter, gutter = _props$gutter === void 0 ? 12 : _props$gutter, _props$placement = props.placement, sealedPlacement = _props$placement === void 0 ? "bottom" : _props$placement, _props$flip = props.flip, flip2 = _props$flip === void 0 ? true : _props$flip, sealedOffset = props.offset, _props$preventOverflo = props.preventOverflow, preventOverflow2 = _props$preventOverflo === void 0 ? true : _props$preventOverflo, _props$fixed = props.fixed, fixed = _props$fixed === void 0 ? false : _props$fixed, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible;
  var popper2 = react$1.exports.useRef(null);
  var referenceRef = react$1.exports.useRef();
  var popperRef = react$1.exports.useRef();
  var arrowRef = react$1.exports.useRef();
  var _useState = react$1.exports.useState(sealedPlacement), _useState2 = _slicedToArray(_useState, 2), originalPlacement = _useState2[0], place = _useState2[1];
  var _useState3 = react$1.exports.useState(sealedPlacement), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var _useState5 = react$1.exports.useState(sealedOffset || [0, gutter]), _useState6 = _slicedToArray(_useState5, 1), offset3 = _useState6[0];
  var _useState7 = react$1.exports.useState({
    position: fixed ? "fixed" : "absolute",
    left: "-9999999px",
    top: "-9999999px"
  }), _useState8 = _slicedToArray(_useState7, 2), popoverStyles = _useState8[0], setPopoverStyles = _useState8[1];
  var _useState9 = react$1.exports.useState({}), _useState10 = _slicedToArray(_useState9, 2), arrowStyles = _useState10[0], setArrowStyles = _useState10[1];
  var update2 = react$1.exports.useCallback(() => {
    if (popper2.current) {
      popper2.current.forceUpdate();
      return true;
    }
    return false;
  }, []);
  var updateState2 = react$1.exports.useCallback((state) => {
    if (state.placement) {
      setPlacement(state.placement);
    }
    if (state.styles) {
      setPopoverStyles(applyStyles(state.styles.popper));
      if (arrowRef.current) {
        setArrowStyles(applyStyles(state.styles.arrow));
      }
    }
  }, []);
  index2(() => {
    if (referenceRef.current && popperRef.current) {
      popper2.current = createPopper(referenceRef.current, popperRef.current, {
        placement: originalPlacement,
        strategy: fixed ? "fixed" : "absolute",
        onFirstUpdate: isSafari ? updateState2 : void 0,
        modifiers: [{
          name: "eventListeners",
          enabled: visible
        }, {
          name: "applyStyles",
          enabled: false
        }, {
          name: "flip",
          enabled: flip2,
          options: {
            padding: 8
          }
        }, {
          name: "offset",
          options: {
            offset: offset3
          }
        }, {
          name: "preventOverflow",
          enabled: preventOverflow2,
          options: {
            tetherOffset: () => {
              var _arrowRef$current;
              return ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.clientWidth) || 0;
            }
          }
        }, {
          name: "arrow",
          enabled: !!arrowRef.current,
          options: {
            element: arrowRef.current
          }
        }, {
          name: "updateState",
          phase: "write",
          requires: ["computeStyles"],
          enabled: visible,
          fn: (_ref) => {
            var state = _ref.state;
            return updateState2(state);
          }
        }]
      });
    }
    return () => {
      if (popper2.current) {
        popper2.current.destroy();
        popper2.current = null;
      }
    };
  }, [originalPlacement, fixed, visible, flip2, offset3, preventOverflow2, updateState2]);
  react$1.exports.useEffect(() => {
    if (!visible) {
      return;
    }
    var id = window.requestAnimationFrame(() => {
      var _popper$current;
      (_popper$current = popper2.current) === null || _popper$current === void 0 ? void 0 : _popper$current.forceUpdate();
    });
    return () => {
      window.cancelAnimationFrame(id);
    };
  }, [visible]);
  return react$1.exports.useMemo(() => ({
    referenceRef,
    popperRef,
    arrowRef,
    popoverStyles,
    arrowStyles,
    update: update2,
    originalPlacement,
    placement,
    place
  }), [arrowStyles, originalPlacement, placement, popoverStyles, update2]);
}
var _excluded$2 = ["placement", "positioner", "animated", "animatedClass", "containerClass", "blurOnInactive", "enabled", "floatingLabel", "ignoredElements"], _excluded2 = ["actions", "animated", "placement", "positioner", "blurOnInactive", "ignoredElements", "enabled"];
function useMemoizedPosition(props) {
  var height = props.height, left2 = props.left, top2 = props.top, width = props.width;
  return react$1.exports.useMemo(() => ({
    height,
    left: left2,
    top: top2,
    width
  }), [height, left2, top2, width]);
}
var FloatingWrapper = (props) => {
  var containerClass = props.containerClass, _props$placement = props.placement, placement = _props$placement === void 0 ? "right-end" : _props$placement, positioner = props.positioner, children = props.children, _props$blurOnInactive = props.blurOnInactive, blurOnInactive = _props$blurOnInactive === void 0 ? false : _props$blurOnInactive, _props$ignoredElement = props.ignoredElements, ignoredElements = _props$ignoredElement === void 0 ? [] : _props$ignoredElement, _props$enabled = props.enabled, enabled = _props$enabled === void 0 ? true : _props$enabled, floatingLabel = props.floatingLabel, _props$hideWhenInvisi = props.hideWhenInvisible, hideWhenInvisible = _props$hideWhenInvisi === void 0 ? true : _props$hideWhenInvisi, _props$renderOutsideE = props.renderOutsideEditor, renderOutsideEditor = _props$renderOutsideE === void 0 ? false : _props$renderOutsideE;
  var _useEditorFocus = useEditorFocus({
    blurOnInactive,
    ignoredElements
  }), _useEditorFocus2 = _slicedToArray(_useEditorFocus, 1), isFocused = _useEditorFocus2[0];
  var _usePositioner = usePositioner(() => {
    var active2 = isFocused && enabled;
    var refinedPositioner = getPositioner(positioner);
    return refinedPositioner.active(active2);
  }, [isFocused, enabled, renderOutsideEditor]), ref2 = _usePositioner.ref, active = _usePositioner.active, height = _usePositioner.height, left2 = _usePositioner.x, top2 = _usePositioner.y, width = _usePositioner.width, visible = _usePositioner.visible;
  var shouldShow = (hideWhenInvisible ? visible : true) && active;
  var position = useMemoizedPosition({
    height,
    left: left2,
    top: top2,
    width
  });
  var _usePopper = usePopper({
    placement,
    visible
  }), popperRef = _usePopper.popperRef, referenceRef = _usePopper.referenceRef, popoverStyles = _usePopper.popoverStyles, update2 = _usePopper.update;
  var floatingElement = /* @__PURE__ */ jsx("div", {
    "aria-label": floatingLabel,
    ref: popperRef,
    style: popoverStyles,
    className: cx2(componentsTheme.FLOATING_POPOVER, containerClass),
    children: shouldShow && children
  });
  if (!renderOutsideEditor) {
    floatingElement = /* @__PURE__ */ jsx(PositionerPortal, {
      children: floatingElement
    });
  }
  index2(() => {
    update2();
  }, [shouldShow, update2, height, left2, top2, width]);
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(PositionerPortal, {
      children: /* @__PURE__ */ jsx("span", {
        className: extensionPositionerTheme.POSITIONER,
        style: {
          top: position.top,
          left: position.left,
          width: position.width,
          height: position.height
        },
        ref: _default$2(ref2, referenceRef)
      })
    }), floatingElement]
  });
};
var FloatingToolbar = (props) => {
  var placement = props.placement, positioner = props.positioner, _props$animated = props.animated, animated2 = _props$animated === void 0 ? 200 : _props$animated, _props$animatedClass = props.animatedClass, animatedClass = _props$animatedClass === void 0 ? componentsTheme.ANIMATED_POPOVER : _props$animatedClass, containerClass = props.containerClass, blurOnInactive = props.blurOnInactive, enabled = props.enabled, floatingLabel = props.floatingLabel, ignoredElements = props.ignoredElements, toolbarProps = _objectWithoutProperties(props, _excluded$2);
  var floatingWrapperProps = {
    placement,
    positioner,
    animated: animated2,
    animatedClass,
    containerClass,
    blurOnInactive,
    enabled,
    floatingLabel,
    ignoredElements
  };
  return /* @__PURE__ */ jsx(FloatingWrapper, _objectSpread2$3(_objectSpread2$3({}, floatingWrapperProps), {}, {
    children: /* @__PURE__ */ jsx(Toolbar, _objectSpread2$3(_objectSpread2$3({}, toolbarProps), {}, {
      refocusEditor: false
    }))
  }));
};
var PositionerPortal = (props) => {
  var container = useHelpers().getPositionerWidget();
  return /* @__PURE__ */ reactDom.exports.createPortal(/* @__PURE__ */ jsx(Fragment$1, {
    children: props.children
  }), container);
};
var FloatingActionsMenu = (props) => {
  var actions2 = props.actions, _props$animated2 = props.animated, animated2 = _props$animated2 === void 0 ? false : _props$animated2, _props$placement2 = props.placement, placement = _props$placement2 === void 0 ? "right-end" : _props$placement2, _props$positioner = props.positioner, positioner = _props$positioner === void 0 ? "nearestWord" : _props$positioner, blurOnInactive = props.blurOnInactive, ignoredElements = props.ignoredElements, _props$enabled2 = props.enabled, enabled = _props$enabled2 === void 0 ? true : _props$enabled2, floatingWrapperProps = _objectWithoutProperties(props, _excluded2);
  var _useSuggest = useSuggest({
    char: "/",
    name: "actions-dropdown",
    matchOffset: 0
  }), change = _useSuggest.change;
  var query = change === null || change === void 0 ? void 0 : change.query.full;
  var menuState = useMenuState({
    unstable_virtual: true,
    wrap: true,
    loop: true
  });
  var items = (query ? matchSorter(actions2, query, {
    keys: ["tags", "description", (item) => {
      var _item$description$rep, _item$description;
      return (_item$description$rep = (_item$description = item.description) === null || _item$description === void 0 ? void 0 : _item$description.replace(/\W/g, "")) !== null && _item$description$rep !== void 0 ? _item$description$rep : "";
    }],
    threshold: matchSorter.rankings.CONTAINS
  }) : actions2).map((item) => item.type === ComponentItem.MenuAction ? _objectSpread2$3(_objectSpread2$3({}, item), {}, {
    type: ComponentItem.MenuPane
  }) : _objectSpread2$3(_objectSpread2$3({}, item), {}, {
    type: ComponentItem.MenuCommandPane
  }));
  return /* @__PURE__ */ jsxs(FloatingWrapper, _objectSpread2$3(_objectSpread2$3({
    enabled: !!query,
    positioner,
    placement,
    animated: animated2,
    blurOnInactive,
    ignoredElements
  }, floatingWrapperProps), {}, {
    children: [/* @__PURE__ */ jsx("div", {
      style: {
        width: 50,
        height: 50,
        background: "red"
      }
    }), /* @__PURE__ */ jsx(MenuComponent, {
      open: !!query && enabled,
      items,
      menuState
    })]
  }));
};
var _dec$b, _dec2$a, _class$b;
var BlockquoteExtension = (_dec$b = command({
  icon: "doubleQuotesL",
  description: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionBlockquoteMessages.DESCRIPTION);
  },
  label: (_ref2) => {
    var t2 = _ref2.t;
    return t2(extensionBlockquoteMessages.LABEL);
  }
}), _dec2$a = keyBinding({
  shortcut: "Ctrl->",
  command: "toggleBlockquote"
}), _class$b = class BlockquoteExtension2 extends NodeExtension {
  get name() {
    return "blockquote";
  }
  createTags() {
    return [ExtensionTag.Block, ExtensionTag.FormattingNode];
  }
  createNodeSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({
      content: "block+",
      defining: true,
      draggable: false
    }, override), {}, {
      attrs: extra.defaults(),
      parseDOM: [{
        tag: "blockquote",
        getAttrs: extra.parse,
        priority: 100
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => ["blockquote", extra.dom(node4), 0]
    });
  }
  toggleBlockquote() {
    return toggleWrap(this.type);
  }
  shortcut(props) {
    return this.toggleBlockquote()(props);
  }
  createInputRules() {
    return [wrappingInputRule(/^\s*>\s$/, this.type)];
  }
  createPasteRules() {
    return {
      type: "node",
      nodeType: this.type,
      regexp: /^\s*>\s$/,
      startOfTextBlock: true
    };
  }
}, _applyDecoratedDescriptor(_class$b.prototype, "toggleBlockquote", [_dec$b], Object.getOwnPropertyDescriptor(_class$b.prototype, "toggleBlockquote"), _class$b.prototype), _applyDecoratedDescriptor(_class$b.prototype, "shortcut", [_dec2$a], Object.getOwnPropertyDescriptor(_class$b.prototype, "shortcut"), _class$b.prototype), _class$b);
var _dec$a, _dec2$9, _dec3$6, _dec4$1, _dec5$1, _class$a, _class2$8;
var toggleBoldOptions = {
  icon: "bold",
  label: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionBoldMessages.LABEL);
  },
  description: (_ref2) => {
    var t2 = _ref2.t;
    return t2(extensionBoldMessages.DESCRIPTION);
  }
};
var BoldExtension = (_dec$a = extension({
  defaultOptions: {
    weight: void 0
  },
  staticKeys: ["weight"]
}), _dec2$9 = command(toggleBoldOptions), _dec3$6 = command(), _dec4$1 = command(), _dec5$1 = keyBinding({
  shortcut: NamedShortcut.Bold,
  command: "toggleBold"
}), _dec$a(_class$a = (_class2$8 = class BoldExtension2 extends MarkExtension {
  get name() {
    return "bold";
  }
  createTags() {
    return [ExtensionTag.FormattingMark, ExtensionTag.FontStyle];
  }
  createMarkSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({}, override), {}, {
      attrs: extra.defaults(),
      parseDOM: [
        {
          tag: "strong",
          getAttrs: extra.parse
        },
        {
          tag: "b",
          getAttrs: (node4) => isElementDomNode(node4) && node4.style.fontWeight !== "normal" ? extra.parse(node4) : false
        },
        {
          style: "font-weight",
          getAttrs: (node4) => isString$1(node4) && /^(bold(er)?|[5-9]\d{2,})$/.test(node4) ? null : false
        },
        ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []
      ],
      toDOM: (node4) => {
        var weight = this.options.weight;
        if (weight) {
          return ["strong", {
            "font-weight": weight.toString()
          }, 0];
        }
        return ["strong", extra.dom(node4), 0];
      }
    });
  }
  createInputRules() {
    return [markInputRule({
      regexp: /(?:\*\*|__)([^*_]+)(?:\*\*|__)$/,
      type: this.type,
      ignoreWhitespace: true
    })];
  }
  toggleBold(selection) {
    return toggleMark({
      type: this.type,
      selection
    });
  }
  setBold(selection) {
    return (_ref3) => {
      var tr = _ref3.tr, dispatch2 = _ref3.dispatch;
      var _getTextSelection = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc), from4 = _getTextSelection.from, to = _getTextSelection.to;
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.addMark(from4, to, this.type.create()));
      return true;
    };
  }
  removeBold(selection) {
    return (_ref4) => {
      var tr = _ref4.tr, dispatch2 = _ref4.dispatch;
      var _getTextSelection2 = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc), from4 = _getTextSelection2.from, to = _getTextSelection2.to;
      if (!tr.doc.rangeHasMark(from4, to, this.type)) {
        return false;
      }
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.removeMark(from4, to, this.type));
      return true;
    };
  }
  shortcut(props) {
    return this.toggleBold()(props);
  }
}, _applyDecoratedDescriptor(_class2$8.prototype, "toggleBold", [_dec2$9], Object.getOwnPropertyDescriptor(_class2$8.prototype, "toggleBold"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "setBold", [_dec3$6], Object.getOwnPropertyDescriptor(_class2$8.prototype, "setBold"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "removeBold", [_dec4$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "removeBold"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "shortcut", [_dec5$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "shortcut"), _class2$8.prototype), _class2$8)) || _class$a);
var _dec$9, _dec2$8, _class$9, _class2$7;
var HardBreakExtension = (_dec$9 = extension({
  defaultPriority: ExtensionPriority.Low
}), _dec2$8 = command(), _dec$9(_class$9 = (_class2$7 = class HardBreakExtension2 extends NodeExtension {
  get name() {
    return "hardBreak";
  }
  createTags() {
    return [ExtensionTag.InlineNode];
  }
  createNodeSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({
      inline: true,
      selectable: false,
      atom: true
    }, override), {}, {
      attrs: extra.defaults(),
      parseDOM: [{
        tag: "br",
        getAttrs: extra.parse
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => ["br", extra.dom(node4)]
    });
  }
  createKeymap() {
    var command2 = chainCommands$1(convertCommand(exitCode), () => {
      this.store.commands.insertHardBreak();
      return true;
    });
    return {
      "Mod-Enter": command2,
      "Shift-Enter": command2
    };
  }
  insertHardBreak() {
    return (props) => {
      var tr = props.tr, dispatch2 = props.dispatch;
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.replaceSelectionWith(this.type.create()).scrollIntoView());
      return true;
    };
  }
}, _applyDecoratedDescriptor(_class2$7.prototype, "insertHardBreak", [_dec2$8], Object.getOwnPropertyDescriptor(_class2$7.prototype, "insertHardBreak"), _class2$7.prototype), _class2$7)) || _class$9);
var LABEL = extensionHeadingMessages.LABEL;
var toggleHeadingOptions = {
  icon: (_ref) => {
    var _attrs$level;
    var attrs = _ref.attrs;
    return "h".concat((_attrs$level = attrs === null || attrs === void 0 ? void 0 : attrs.level) !== null && _attrs$level !== void 0 ? _attrs$level : "1");
  },
  label: (_ref2) => {
    var t2 = _ref2.t, attrs = _ref2.attrs;
    return t2(LABEL, {
      level: attrs === null || attrs === void 0 ? void 0 : attrs.level
    });
  }
};
var shortcuts = [NamedShortcut.H1, NamedShortcut.H2, NamedShortcut.H3, NamedShortcut.H4, NamedShortcut.H5, NamedShortcut.H6];
var _dec$8, _dec2$7, _class$8, _class2$6;
var HeadingExtension = (_dec$8 = extension({
  defaultOptions: {
    levels: [1, 2, 3, 4, 5, 6],
    defaultLevel: 1
  },
  staticKeys: ["defaultLevel", "levels"]
}), _dec2$7 = command(toggleHeadingOptions), _dec$8(_class$8 = (_class2$6 = class HeadingExtension2 extends NodeExtension {
  get name() {
    return "heading";
  }
  createTags() {
    return [ExtensionTag.Block, ExtensionTag.TextBlock, ExtensionTag.FormattingNode];
  }
  createNodeSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({
      content: "inline*",
      defining: true,
      draggable: false
    }, override), {}, {
      attrs: _objectSpread2$3(_objectSpread2$3({}, extra.defaults()), {}, {
        level: {
          default: this.options.defaultLevel
        }
      }),
      parseDOM: [...this.options.levels.map((level) => ({
        tag: "h".concat(level),
        getAttrs: (element) => _objectSpread2$3(_objectSpread2$3({}, extra.parse(element)), {}, {
          level
        })
      })), ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => {
        if (!this.options.levels.includes(node4.attrs.level)) {
          return ["h".concat(this.options.defaultLevel), extra.dom(node4), 0];
        }
        return ["h".concat(node4.attrs.level), extra.dom(node4), 0];
      }
    });
  }
  toggleHeading() {
    var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return toggleBlockItem({
      type: this.type,
      toggleType: "paragraph",
      attrs
    });
  }
  createKeymap(fn2) {
    var commandsExtension = this.store.getExtension(CommandsExtension);
    var keys2 = object();
    var attrShortcuts = [];
    var _iterator = _createForOfIteratorHelper(this.options.levels), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _shortcuts;
        var level = _step.value;
        var _shortcut = (_shortcuts = shortcuts[level - 1]) !== null && _shortcuts !== void 0 ? _shortcuts : NamedShortcut.H1;
        keys2[_shortcut] = setBlockType(this.type, {
          level
        });
        attrShortcuts.push({
          attrs: {
            level
          },
          shortcut: fn2(_shortcut)[0]
        });
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    commandsExtension.updateDecorated("toggleHeading", {
      shortcut: attrShortcuts
    });
    return keys2;
  }
  createInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule(new RegExp("^(#{1,".concat(level, "})\\s$")), this.type, () => ({
        level
      }));
    });
  }
  createPasteRules() {
    return this.options.levels.map((level) => ({
      type: "node",
      nodeType: this.type,
      regexp: new RegExp("^#{1,".concat(level, "}\\s([\\s\\w]+)$")),
      getAttributes: () => ({
        level
      }),
      startOfTextBlock: true
    }));
  }
}, _applyDecoratedDescriptor(_class2$6.prototype, "toggleHeading", [_dec2$7], Object.getOwnPropertyDescriptor(_class2$6.prototype, "toggleHeading"), _class2$6.prototype), _class2$6)) || _class$8);
var toggleItalicOptions = {
  icon: "italic",
  label: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionItalicMessages.LABEL);
  },
  description: (_ref2) => {
    var t2 = _ref2.t;
    return t2(extensionItalicMessages.DESCRIPTION);
  }
};
var _dec$7, _dec2$6, _dec3$5, _class$7, _class2$5;
var ItalicExtension = (_dec$7 = extension({}), _dec2$6 = command(toggleItalicOptions), _dec3$5 = keyBinding({
  shortcut: NamedShortcut.Italic,
  command: "toggleItalic"
}), _dec$7(_class$7 = (_class2$5 = class ItalicExtension2 extends MarkExtension {
  get name() {
    return "italic";
  }
  createTags() {
    return [ExtensionTag.FontStyle, ExtensionTag.FormattingMark];
  }
  createMarkSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({}, override), {}, {
      attrs: extra.defaults(),
      parseDOM: [{
        tag: "i",
        getAttrs: extra.parse
      }, {
        tag: "em",
        getAttrs: extra.parse
      }, {
        style: "font-style=italic"
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (mark3) => ["em", extra.dom(mark3), 0]
    });
  }
  createKeymap() {
    return {
      "Mod-i": toggleMark({
        type: this.type
      })
    };
  }
  createInputRules() {
    return [markInputRule({
      regexp: /(?:^|[^*])\*([^*]+)\*$/,
      type: this.type,
      ignoreWhitespace: true,
      updateCaptured: (_ref) => {
        var fullMatch = _ref.fullMatch, start4 = _ref.start;
        return !fullMatch.startsWith("*") ? {
          fullMatch: fullMatch.slice(1),
          start: start4 + 1
        } : {};
      }
    }), markInputRule({
      regexp: /(?:^|[^_])_([^_]+)_$/,
      type: this.type,
      ignoreWhitespace: true,
      updateCaptured: (_ref2) => {
        var fullMatch = _ref2.fullMatch, start4 = _ref2.start;
        return !fullMatch.startsWith("_") ? {
          fullMatch: fullMatch.slice(1),
          start: start4 + 1
        } : {};
      }
    })];
  }
  createPasteRules() {
    return [{
      type: "mark",
      markType: this.type,
      regexp: /_([^_]+)_/g
    }, {
      type: "mark",
      markType: this.type,
      regexp: /\*([^*]+)\*/g
    }];
  }
  toggleItalic(selection) {
    return toggleMark({
      type: this.type,
      selection
    });
  }
  shortcut(props) {
    return this.toggleItalic()(props);
  }
}, _applyDecoratedDescriptor(_class2$5.prototype, "toggleItalic", [_dec2$6], Object.getOwnPropertyDescriptor(_class2$5.prototype, "toggleItalic"), _class2$5.prototype), _applyDecoratedDescriptor(_class2$5.prototype, "shortcut", [_dec3$5], Object.getOwnPropertyDescriptor(_class2$5.prototype, "shortcut"), _class2$5.prototype), _class2$5)) || _class$7);
var _excluded = ["auto", "target"];
var _dec$6, _dec2$5, _dec3$4, _dec4, _dec5, _class$6, _class2$4;
var UPDATE_LINK = "updateLink";
var DEFAULT_AUTO_LINK_REGEX = /(?:(?:(?:https?|ftp):)?\/\/)?(?:\S+(?::\S*)?@)?(?:(?:[\da-z\u00A1-\uFFFF][\w\u00A1-\uFFFF-]{0,62})?[\da-z\u00A1-\uFFFF]\.)+[a-z\u00A1-\uFFFF]{2,}\.?(?::\d{2,5})?(?:[#/?]\S*)?/gi;
var LinkExtension = (_dec$6 = extension({
  defaultOptions: {
    autoLink: false,
    defaultProtocol: "",
    selectTextOnClick: false,
    openLinkOnClick: false,
    autoLinkRegex: DEFAULT_AUTO_LINK_REGEX,
    defaultTarget: null,
    supportedTargets: [],
    extractHref
  },
  staticKeys: ["autoLinkRegex"],
  handlerKeyOptions: {
    onClick: {
      earlyReturnValue: true
    }
  },
  handlerKeys: ["onActivateLink", "onShortcut", "onUpdateLink", "onClick"],
  defaultPriority: ExtensionPriority.Medium
}), _dec2$5 = keyBinding({
  shortcut: NamedShortcut.InsertLink
}), _dec3$4 = command(), _dec4 = command(), _dec5 = command(), _dec$6(_class$6 = (_class2$4 = class LinkExtension2 extends MarkExtension {
  constructor() {
    super(...arguments);
    _defineProperty$3(this, "_autoLinkRegexNonGlobal", void 0);
  }
  get name() {
    return "link";
  }
  createTags() {
    return [ExtensionTag.Link, ExtensionTag.ExcludeInputRules];
  }
  createMarkSpec(extra, override) {
    var _override$parseDOM;
    var AUTO_ATTRIBUTE = "data-link-auto";
    var getTargetObject = (target) => {
      var _this$options = this.options, defaultTarget = _this$options.defaultTarget, supportedTargets = _this$options.supportedTargets;
      var targets = defaultTarget ? [...supportedTargets, defaultTarget] : supportedTargets;
      return target && includes(targets, target) ? {
        target
      } : void 0;
    };
    return _objectSpread2$3(_objectSpread2$3({
      inclusive: false,
      excludes: "_"
    }, override), {}, {
      attrs: _objectSpread2$3(_objectSpread2$3({}, extra.defaults()), {}, {
        href: {},
        target: {
          default: this.options.defaultTarget
        },
        auto: {
          default: false
        }
      }),
      parseDOM: [{
        tag: "a[href]",
        getAttrs: (node4) => {
          if (!isElementDomNode(node4)) {
            return false;
          }
          var href = node4.getAttribute("href");
          var auto2 = node4.hasAttribute(AUTO_ATTRIBUTE);
          return _objectSpread2$3(_objectSpread2$3({}, extra.parse(node4)), {}, {
            href,
            auto: auto2
          }, getTargetObject(node4.getAttribute("target")));
        }
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => {
        var _omitExtraAttributes = omitExtraAttributes(node4.attrs, extra);
        _omitExtraAttributes.auto;
        _omitExtraAttributes.target;
        var rest = _objectWithoutProperties(_omitExtraAttributes, _excluded);
        var auto2 = node4.attrs.auto ? {
          [AUTO_ATTRIBUTE]: ""
        } : {};
        var rel = "noopener noreferrer nofollow";
        var attrs = _objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, extra.dom(node4)), rest), {}, {
          rel
        }, auto2), getTargetObject(node4.attrs.target));
        return ["a", attrs, 0];
      }
    });
  }
  onCreate() {
    var autoLinkRegex = this.options.autoLinkRegex;
    this._autoLinkRegexNonGlobal = new RegExp("^".concat(autoLinkRegex.source, "$"), autoLinkRegex.flags.replace("g", ""));
  }
  shortcut(_ref) {
    var tr = _ref.tr;
    var selectedText = "";
    var _tr$selection = tr.selection, from4 = _tr$selection.from, to = _tr$selection.to, empty2 = _tr$selection.empty, $from = _tr$selection.$from;
    var expandedSelection = false;
    var mark3 = getMarkRange($from, this.type);
    if (empty2) {
      var selectedWord = mark3 !== null && mark3 !== void 0 ? mark3 : getSelectedWord(tr);
      if (!selectedWord) {
        return false;
      }
      selectedText = selectedWord.text;
      from4 = selectedWord.from;
      to = selectedWord.to;
      expandedSelection = true;
    }
    if (from4 === to) {
      return false;
    }
    if (!expandedSelection) {
      selectedText = tr.doc.textBetween(from4, to);
    }
    this.options.onActivateLink(selectedText);
    this.options.onShortcut({
      activeLink: mark3 ? {
        attrs: mark3.mark.attrs,
        from: mark3.from,
        to: mark3.to
      } : void 0,
      selectedText,
      from: from4,
      to
    });
    return true;
  }
  updateLink(attrs, range2) {
    return (props) => {
      var tr = props.tr;
      var selectionIsValid = isTextSelection(tr.selection) && !isSelectionEmpty(tr.selection) || isAllSelection(tr.selection) || isMarkActive({
        trState: tr,
        type: this.type
      });
      if (!selectionIsValid && !range2) {
        return false;
      }
      tr.setMeta(this.name, {
        command: UPDATE_LINK,
        attrs,
        range: range2
      });
      return updateMark({
        type: this.type,
        attrs,
        range: range2
      })(props);
    };
  }
  selectLink() {
    return this.store.commands.selectMark.original(this.type);
  }
  removeLink(range2) {
    return (props) => {
      var tr = props.tr;
      if (!isMarkActive(_objectSpread2$3({
        trState: tr,
        type: this.type
      }, range2))) {
        return false;
      }
      return removeMark({
        type: this.type,
        expand: true,
        range: range2
      })(props);
    };
  }
  createPasteRules() {
    return [{
      type: "mark",
      regexp: this.options.autoLinkRegex,
      markType: this.type,
      getAttributes: (url, isReplacement) => ({
        href: getMatchString(url),
        auto: !isReplacement
      })
    }];
  }
  createEventHandlers() {
    return {
      clickMark: (event, clickState) => {
        var markRange = clickState.getMark(this.type);
        if (!markRange) {
          return;
        }
        var attrs = markRange.mark.attrs;
        var data = _objectSpread2$3(_objectSpread2$3({}, attrs), markRange);
        if (this.options.onClick(event, data)) {
          return true;
        }
        var handled = false;
        if (this.options.openLinkOnClick) {
          handled = true;
          var href = attrs.href;
          window.open(href, "_blank");
        }
        if (this.options.selectTextOnClick) {
          handled = true;
          this.store.commands.selectText(markRange);
        }
        return handled;
      }
    };
  }
  createPlugin() {
    return {
      props: {
        handleClick: (view, pos) => {
          if (!this.options.selectTextOnClick && !this.options.openLinkOnClick) {
            return false;
          }
          var _view$state = view.state, doc2 = _view$state.doc, tr = _view$state.tr;
          var range2 = getMarkRange(doc2.resolve(pos), this.type);
          if (!range2) {
            return false;
          }
          if (this.options.openLinkOnClick) {
            var href = range2.mark.attrs.href;
            window.open(href, "_blank");
          }
          if (this.options.selectTextOnClick) {
            var $start = doc2.resolve(range2.from);
            var $end = doc2.resolve(range2.to);
            var transaction = tr.setSelection(new TextSelection($start, $end));
            view.dispatch(transaction);
          }
          return true;
        }
      },
      appendTransaction: (transactions, prevState, state) => {
        var transactionsWithLinkMeta = transactions.filter((tr2) => !!tr2.getMeta(this.name));
        transactionsWithLinkMeta.forEach((tr2) => {
          var trMeta = tr2.getMeta(this.name);
          if (trMeta.command === UPDATE_LINK) {
            var range2 = trMeta.range, attrs = trMeta.attrs;
            var selection = state.selection, _doc = state.doc;
            var _meta = {
              range: range2,
              selection,
              doc: _doc,
              attrs
            };
            var _ref2 = range2 !== null && range2 !== void 0 ? range2 : selection, from4 = _ref2.from, to = _ref2.to;
            this.options.onUpdateLink(_doc.textBetween(from4, to), _meta);
          }
        });
        if (!this.options.autoLink) {
          return;
        }
        var isUndo = undoDepth(prevState) - undoDepth(state) === 1;
        if (isUndo) {
          return;
        }
        var docChanged = transactions.some((tr2) => tr2.docChanged);
        if (!docChanged) {
          return;
        }
        var composedTransaction = prevState.tr;
        transactions.forEach((transaction) => {
          transaction.steps.forEach((step2) => {
            composedTransaction.step(step2);
          });
        });
        var changes = getChangedRanges(composedTransaction, [ReplaceAroundStep, ReplaceStep]);
        var mapping = composedTransaction.mapping;
        var tr = state.tr, doc2 = state.doc;
        var _this$store$chain = this.store.chain(tr), updateLink = _this$store$chain.updateLink, removeLink = _this$store$chain.removeLink;
        changes.forEach((_ref3) => {
          var from4 = _ref3.from, to = _ref3.to, prevFrom = _ref3.prevFrom, prevTo = _ref3.prevTo;
          this.getLinkMarksInRange(prevState.doc, prevFrom, prevTo, true).forEach((prevMark) => {
            var newFrom = mapping.map(prevMark.from);
            var newTo = mapping.map(prevMark.to);
            var newMarks = this.getLinkMarksInRange(doc2, newFrom, newTo, true);
            newMarks.forEach((newMark) => {
              var _this$_autoLinkRegexN, _this$_autoLinkRegexN2;
              var wasLink = (_this$_autoLinkRegexN = this._autoLinkRegexNonGlobal) === null || _this$_autoLinkRegexN === void 0 ? void 0 : _this$_autoLinkRegexN.test(prevMark.text);
              var isLink = (_this$_autoLinkRegexN2 = this._autoLinkRegexNonGlobal) === null || _this$_autoLinkRegexN2 === void 0 ? void 0 : _this$_autoLinkRegexN2.test(newMark.text);
              if (wasLink && !isLink) {
                removeLink({
                  from: newMark.from,
                  to: newMark.to
                }).tr();
              }
            });
          });
          var onUpdateCallbacks = [];
          tr.doc.nodesBetween(from4, to, (node4, pos) => {
            if (!node4.isTextblock) {
              return;
            }
            var nodeText = tr.doc.textBetween(pos, pos + node4.nodeSize, void 0, " ");
            this.findAutoLinks(nodeText).map((link2) => _objectSpread2$3(_objectSpread2$3({}, link2), {}, {
              from: pos + link2.start + 1,
              to: pos + link2.end + 1
            })).filter((link2) => {
              return within$1(link2.from, from4, to) || within$1(link2.to, from4, to) || within$1(from4, link2.from, link2.to) || within$1(to, link2.from, link2.to);
            }).filter((link2) => {
              var marks2 = this.getLinkMarksInRange(tr.doc, link2.from, link2.to, false);
              return marks2.length === 0;
            }).forEach((_ref4) => {
              var from5 = _ref4.from, to2 = _ref4.to, href = _ref4.href, text3 = _ref4.text;
              var attrs = {
                href,
                auto: true
              };
              var range2 = {
                from: from5,
                to: to2
              };
              updateLink(attrs, range2).tr();
              onUpdateCallbacks.push({
                attrs,
                range: range2,
                text: text3
              });
            });
          });
          onUpdateCallbacks.forEach((_ref5) => {
            var range2 = _ref5.range, attrs = _ref5.attrs, text3 = _ref5.text;
            var doc3 = tr.doc, selection = tr.selection;
            this.options.onUpdateLink(text3, {
              doc: doc3,
              selection,
              range: range2,
              attrs
            });
          });
        });
        if (tr.steps.length === 0) {
          return;
        }
        return tr;
      }
    };
  }
  buildHref(url) {
    return this.options.extractHref({
      url,
      defaultProtocol: this.options.defaultProtocol
    });
  }
  getLinkMarksInRange(doc2, from4, to, isAutoLink) {
    var linkMarks = [];
    if (from4 === to) {
      var $pos = doc2.resolve(from4);
      $pos.marks().forEach(() => {
        var range2 = getMarkRange($pos, this.type);
        if ((range2 === null || range2 === void 0 ? void 0 : range2.mark.attrs.auto) === isAutoLink) {
          linkMarks.push(range2);
        }
      });
    } else {
      doc2.nodesBetween(from4, to, (node4, pos) => {
        var _node$marks;
        var marks2 = (_node$marks = node4.marks) !== null && _node$marks !== void 0 ? _node$marks : [];
        var linkMark = marks2.find((_ref6) => {
          var type2 = _ref6.type, attrs = _ref6.attrs;
          return type2 === this.type && attrs.auto === isAutoLink;
        });
        if (linkMark) {
          linkMarks.push({
            from: pos,
            to: pos + node4.nodeSize,
            mark: linkMark,
            text: node4.textContent
          });
        }
      });
    }
    return linkMarks;
  }
  findAutoLinks(str) {
    var toAutoLink = [];
    var _iterator = _createForOfIteratorHelper(findMatches(str, this.options.autoLinkRegex)), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var match = _step.value;
        var text3 = match[0];
        if (!text3) {
          continue;
        }
        toAutoLink.push({
          text: text3,
          href: this.buildHref(text3),
          start: match.index,
          end: match.index + text3.length
        });
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    return toAutoLink;
  }
}, _applyDecoratedDescriptor(_class2$4.prototype, "shortcut", [_dec2$5], Object.getOwnPropertyDescriptor(_class2$4.prototype, "shortcut"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "updateLink", [_dec3$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "updateLink"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectLink", [_dec4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectLink"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "removeLink", [_dec5], Object.getOwnPropertyDescriptor(_class2$4.prototype, "removeLink"), _class2$4.prototype), _class2$4)) || _class$6);
function extractHref(_ref7) {
  var url = _ref7.url, defaultProtocol = _ref7.defaultProtocol;
  var startsWithProtocol = /^((?:https?|ftp)?:)\/\//.test(url);
  var isEmail = !startsWithProtocol && url.includes("@");
  if (isEmail) {
    return "mailto:".concat(url);
  }
  return startsWithProtocol ? url : "".concat(defaultProtocol, "//").concat(url);
}
function wrapInList(listType, attrs) {
  return function(state, dispatch2) {
    var ref2 = state.selection;
    var $from = ref2.$from;
    var $to = ref2.$to;
    var range2 = $from.blockRange($to), doJoin = false, outerRange = range2;
    if (!range2) {
      return false;
    }
    if (range2.depth >= 2 && $from.node(range2.depth - 1).type.compatibleContent(listType) && range2.startIndex == 0) {
      if ($from.index(range2.depth - 1) == 0) {
        return false;
      }
      var $insert = state.doc.resolve(range2.start - 2);
      outerRange = new NodeRange($insert, $insert, range2.depth);
      if (range2.endIndex < range2.parent.childCount) {
        range2 = new NodeRange($from, state.doc.resolve($to.end(range2.depth)), range2.depth);
      }
      doJoin = true;
    }
    var wrap = findWrapping3(outerRange, listType, attrs, range2);
    if (!wrap) {
      return false;
    }
    if (dispatch2) {
      dispatch2(doWrapInList(state.tr, range2, wrap, doJoin, listType).scrollIntoView());
    }
    return true;
  };
}
function doWrapInList(tr, range2, wrappers, joinBefore, listType) {
  var content2 = Fragment.empty;
  for (var i2 = wrappers.length - 1; i2 >= 0; i2--) {
    content2 = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content2));
  }
  tr.step(new ReplaceAroundStep(range2.start - (joinBefore ? 2 : 0), range2.end, range2.start, range2.end, new Slice(content2, 0, 0), wrappers.length, true));
  var found2 = 0;
  for (var i$1 = 0; i$1 < wrappers.length; i$1++) {
    if (wrappers[i$1].type == listType) {
      found2 = i$1 + 1;
    }
  }
  var splitDepth = wrappers.length - found2;
  var splitPos = range2.start + wrappers.length - (joinBefore ? 2 : 0), parent = range2.parent;
  for (var i$2 = range2.startIndex, e2 = range2.endIndex, first = true; i$2 < e2; i$2++, first = false) {
    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i$2).nodeSize;
  }
  return tr;
}
function liftListItem(itemType) {
  return function(state, dispatch2) {
    var ref2 = state.selection;
    var $from = ref2.$from;
    var $to = ref2.$to;
    var range2 = $from.blockRange($to, function(node4) {
      return node4.childCount && node4.firstChild.type == itemType;
    });
    if (!range2) {
      return false;
    }
    if (!dispatch2) {
      return true;
    }
    if ($from.node(range2.depth - 1).type == itemType) {
      return liftToOuterList(state, dispatch2, itemType, range2);
    } else {
      return liftOutOfList$1(state, dispatch2, range2);
    }
  };
}
function liftToOuterList(state, dispatch2, itemType, range2) {
  var tr = state.tr, end3 = range2.end, endOfList = range2.$to.end(range2.depth);
  if (end3 < endOfList) {
    tr.step(new ReplaceAroundStep(end3 - 1, endOfList, end3, endOfList, new Slice(Fragment.from(itemType.create(null, range2.parent.copy())), 1, 0), 1, true));
    range2 = new NodeRange(tr.doc.resolve(range2.$from.pos), tr.doc.resolve(endOfList), range2.depth);
  }
  dispatch2(tr.lift(range2, liftTarget(range2)).scrollIntoView());
  return true;
}
function liftOutOfList$1(state, dispatch2, range2) {
  var tr = state.tr, list = range2.parent;
  for (var pos = range2.end, i2 = range2.endIndex - 1, e2 = range2.startIndex; i2 > e2; i2--) {
    pos -= list.child(i2).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  var $start = tr.doc.resolve(range2.start), item = $start.nodeAfter;
  if (tr.mapping.map(range2.end) != range2.start + $start.nodeAfter.nodeSize) {
    return false;
  }
  var atStart2 = range2.startIndex == 0, atEnd2 = range2.endIndex == list.childCount;
  var parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart2 ? 0 : 1), indexBefore + 1, item.content.append(atEnd2 ? Fragment.empty : Fragment.from(list)))) {
    return false;
  }
  var start4 = $start.pos, end3 = start4 + item.nodeSize;
  tr.step(new ReplaceAroundStep(start4 - (atStart2 ? 1 : 0), end3 + (atEnd2 ? 1 : 0), start4 + 1, end3 - 1, new Slice((atStart2 ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd2 ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart2 ? 0 : 1, atEnd2 ? 0 : 1), atStart2 ? 0 : 1));
  dispatch2(tr.scrollIntoView());
  return true;
}
function isList(type2) {
  var _type$spec$group;
  return !!((_type$spec$group = type2.spec.group) !== null && _type$spec$group !== void 0 && _type$spec$group.includes(ExtensionTag.ListContainerNode));
}
function isListItem(type2) {
  var _type$spec$group2;
  return !!((_type$spec$group2 = type2.spec.group) !== null && _type$spec$group2 !== void 0 && _type$spec$group2.includes(ExtensionTag.ListItemNode));
}
function isListNode(node4) {
  return isList(node4.type);
}
function isListItemNode(node4) {
  return isListItem(node4.type);
}
function toggleList(listType, itemType) {
  return (props) => {
    var dispatch2 = props.dispatch, tr = props.tr;
    var state = chainableEditorState(tr, props.state);
    var _tr$selection = tr.selection, $from = _tr$selection.$from, $to = _tr$selection.$to;
    var range2 = $from.blockRange($to);
    if (!range2) {
      return false;
    }
    var parentList = findParentNode({
      predicate: (node4) => isList(node4.type),
      selection: tr.selection
    });
    if (parentList && range2.depth - parentList.depth <= 1 && range2.startIndex === 0) {
      if (parentList.node.type === listType) {
        return liftListItemOutOfList(itemType)(props);
      }
      if (isList(parentList.node.type)) {
        if (listType.validContent(parentList.node.content)) {
          dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.setNodeMarkup(parentList.pos, listType));
          return true;
        }
        if (deepChangeListType(tr, parentList, listType, itemType)) {
          dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.scrollIntoView());
          return true;
        }
        return false;
      }
    }
    return wrapInList(listType)(state, dispatch2);
  };
}
function splitListItem(listItemTypeOrName) {
  var ignoreAttrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["checked"];
  return function(_ref) {
    var tr = _ref.tr, dispatch2 = _ref.dispatch, state = _ref.state;
    var listItemType = getNodeType(listItemTypeOrName, state.schema);
    var _tr$selection2 = tr.selection, $from = _tr$selection2.$from, $to = _tr$selection2.$to;
    if (isNodeSelection(tr.selection) && tr.selection.node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    var grandParent = $from.node(-1);
    if (grandParent.type !== listItemType) {
      return false;
    }
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      if ($from.depth === 2 || $from.node(-3).type !== listItemType || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch2) {
        var _listItemType$content;
        var keepItem = $from.index(-1) > 0;
        var wrap = Fragment.empty;
        for (var depth = $from.depth - (keepItem ? 1 : 2); depth >= $from.depth - 3; depth--) {
          wrap = Fragment.from($from.node(depth).copy(wrap));
        }
        var content2 = ((_listItemType$content = listItemType.contentMatch.defaultType) === null || _listItemType$content === void 0 ? void 0 : _listItemType$content.createAndFill()) || void 0;
        wrap = wrap.append(Fragment.from(listItemType.createAndFill(null, content2) || void 0));
        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        tr.replace($from.before(keepItem ? void 0 : -1), $from.after(-depthAfter), new Slice(wrap, keepItem ? 3 : 2, 2));
        tr.setSelection(tr.selection.constructor.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
    if (grandParent.attrs.closed && $from.sameParent($to) && $to.pos === $to.end()) {
      if (dispatch2) {
        var _listItemType$content2;
        var newListItemStartPos = $from.after(-1);
        var _content = ((_listItemType$content2 = listItemType.contentMatch.defaultType) === null || _listItemType$content2 === void 0 ? void 0 : _listItemType$content2.createAndFill()) || void 0;
        var newListItem = listItemType.createAndFill(null, _content);
        if (newListItem) {
          tr.insert(newListItemStartPos, newListItem);
          tr.setSelection(TextSelection.create(tr.doc, newListItemStartPos + 1));
        }
        tr.delete($from.pos, $to.pos);
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
    var listItemAttributes = Object.fromEntries(Object.entries(grandParent.attrs).filter((_ref2) => {
      var _ref3 = _slicedToArray(_ref2, 1), attr = _ref3[0];
      return !ignoreAttrs.includes(attr);
    }));
    var contentType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var contentAttributes = _objectSpread2$3({}, $from.node().attrs);
    tr.delete($from.pos, $to.pos);
    var types = contentType ? [{
      type: listItemType,
      attrs: listItemAttributes
    }, {
      type: contentType,
      attrs: contentAttributes
    }] : [{
      type: listItemType,
      attrs: listItemAttributes
    }];
    if (!canSplit(tr.doc, $from.pos, 2)) {
      return false;
    }
    if (dispatch2) {
      dispatch2(tr.split($from.pos, 2, types).scrollIntoView());
    }
    return true;
  };
}
function deepChangeListType(tr, foundList, listType, itemType) {
  var oldList = foundList.node;
  var $start = tr.doc.resolve(foundList.start);
  var listParent = $start.node(-1);
  var indexBefore = $start.index(-1);
  if (!listParent) {
    return false;
  }
  if (!listParent.canReplace(indexBefore, indexBefore + 1, Fragment.from(listType.create()))) {
    return false;
  }
  var newItems = [];
  for (var index3 = 0; index3 < oldList.childCount; index3++) {
    var oldItem = oldList.child(index3);
    if (!itemType.validContent(oldItem.content)) {
      return false;
    }
    var newItem = itemType.createChecked(null, oldItem.content);
    newItems.push(newItem);
  }
  var newList = listType.createChecked(null, newItems);
  var start4 = foundList.pos;
  var end3 = start4 + oldList.nodeSize;
  var from4 = tr.selection.from;
  tr.replaceRangeWith(start4, end3, newList);
  tr.setSelection(tr.selection.constructor.near(tr.doc.resolve(from4)));
  return true;
}
function wrapItems(_ref6) {
  var _slice$content$firstC;
  var listType = _ref6.listType, itemType = _ref6.itemType, tr = _ref6.tr, range2 = _ref6.range;
  var oldList = range2.parent;
  var slice5 = tr.doc.slice(range2.start, range2.end);
  if (oldList.type === listType && ((_slice$content$firstC = slice5.content.firstChild) === null || _slice$content$firstC === void 0 ? void 0 : _slice$content$firstC.type) === itemType) {
    return false;
  }
  var newItems = [];
  for (var i2 = 0; i2 < slice5.content.childCount; i2++) {
    var oldItem = slice5.content.child(i2);
    if (!itemType.validContent(oldItem.content)) {
      return false;
    }
    var newItem = itemType.createChecked(null, oldItem.content);
    newItems.push(newItem);
  }
  var newList = listType.createChecked(null, newItems);
  tr.replaceRange(range2.start, range2.end, new Slice(Fragment.from(newList), 0, 0));
  return true;
}
function wrapSelectedItems(_ref7) {
  var listType = _ref7.listType, itemType = _ref7.itemType, tr = _ref7.tr;
  var range2 = calculateItemRange(tr.selection);
  if (!range2) {
    return false;
  }
  var atStart2 = range2.startIndex === 0;
  var _tr$selection3 = tr.selection, from4 = _tr$selection3.from, to = _tr$selection3.to;
  if (!wrapItems({
    listType,
    itemType,
    tr,
    range: range2
  })) {
    return false;
  }
  tr.setSelection(new TextSelection(tr.doc.resolve(atStart2 ? from4 : from4 + 2), tr.doc.resolve(atStart2 ? to : to + 2)));
  tr.scrollIntoView();
  return true;
}
function liftOutOfList(state, dispatch2, range2) {
  var tr = state.tr, list = range2.parent;
  var originMappingLength = tr.mapping.maps.length;
  for (var pos = range2.end, i2 = range2.endIndex - 1, e2 = range2.startIndex; i2 > e2; i2--) {
    pos -= list.child(i2).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  var $start = tr.doc.resolve(range2.start), item = $start.nodeAfter;
  if (!item) {
    return false;
  }
  if (tr.mapping.slice(originMappingLength).map(range2.end) !== range2.start + item.nodeSize) {
    return false;
  }
  var atStart2 = range2.startIndex === 0, atEnd2 = range2.endIndex === list.childCount;
  var parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart2 ? 0 : 1), indexBefore + 1, item.content.append(atEnd2 ? Fragment.empty : Fragment.from(list)))) {
    return false;
  }
  var start4 = $start.pos, end3 = start4 + item.nodeSize;
  tr.step(new ReplaceAroundStep(start4 - (atStart2 ? 1 : 0), end3 + (atEnd2 ? 1 : 0), start4 + 1, end3 - 1, new Slice((atStart2 ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd2 ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart2 ? 0 : 1, atEnd2 ? 0 : 1), atStart2 ? 0 : 1));
  dispatch2(tr.scrollIntoView());
  return true;
}
function maybeJoinList(tr, $pos) {
  var $from = $pos || tr.selection.$from;
  var joinable2 = [];
  var index3;
  var parent;
  var before2;
  var after2;
  for (var depth = $from.depth; depth >= 0; depth--) {
    parent = $from.node(depth);
    index3 = $from.index(depth);
    before2 = parent.maybeChild(index3 - 1);
    after2 = parent.maybeChild(index3);
    if (before2 && after2 && before2.type.name === after2.type.name && isListNode(before2)) {
      var pos = $from.before(depth + 1);
      joinable2.push(pos);
    }
    index3 = $from.indexAfter(depth);
    before2 = parent.maybeChild(index3 - 1);
    after2 = parent.maybeChild(index3);
    if (before2 && after2 && before2.type.name === after2.type.name && isListNode(before2)) {
      var _pos = $from.after(depth + 1);
      joinable2.push(_pos);
    }
  }
  joinable2 = [...new Set(joinable2)].sort((a2, b) => b - a2);
  var updated = false;
  var _iterator3 = _createForOfIteratorHelper(joinable2), _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var _pos2 = _step3.value;
      if (canJoin(tr.doc, _pos2)) {
        tr.join(_pos2);
        updated = true;
      }
    }
  } catch (err2) {
    _iterator3.e(err2);
  } finally {
    _iterator3.f();
  }
  return updated;
}
function liftListItemOutOfList(itemType) {
  return (props) => {
    var dispatch2 = props.dispatch, tr = props.tr;
    var state = chainableEditorState(tr, props.state);
    var range2 = getItemRange(itemType, tr.selection);
    if (!range2) {
      return false;
    }
    if (!dispatch2) {
      return true;
    }
    liftOutOfList(state, dispatch2, range2);
    return true;
  };
}
function getItemRange(itemType, selection) {
  var $from = selection.$from, $to = selection.$to;
  var range2 = $from.blockRange($to, (node4) => {
    var _node$firstChild;
    return ((_node$firstChild = node4.firstChild) === null || _node$firstChild === void 0 ? void 0 : _node$firstChild.type) === itemType;
  });
  return range2;
}
function calculateItemRange(selection) {
  var $from = selection.$from, $to = selection.$to;
  return $from.blockRange($to, isListNode);
}
function wrapListBackward(tr) {
  var $cursor = tr.selection.$from;
  var range2 = $cursor.blockRange();
  if (!range2 || !isListItemNode(range2.parent) || range2.startIndex !== 0) {
    return false;
  }
  var root = $cursor.node(range2.depth - 2);
  var itemIndex = $cursor.index(range2.depth);
  var listIndex = $cursor.index(range2.depth - 1);
  var rootIndex = $cursor.index(range2.depth - 2);
  var previousList = root.maybeChild(rootIndex - 1);
  var previousListItem = previousList === null || previousList === void 0 ? void 0 : previousList.lastChild;
  if (itemIndex !== 0 || listIndex !== 0) {
    return false;
  }
  if (previousList && isListNode(previousList) && previousListItem && isListItemNode(previousListItem)) {
    return wrapSelectedItems({
      listType: previousList.type,
      itemType: previousListItem.type,
      tr
    });
  }
  if (isListItemNode(root)) {
    var parentListItem = root;
    var parentList = $cursor.node(range2.depth - 3);
    if (isListNode(parentList)) {
      return wrapSelectedItems({
        listType: parentList.type,
        itemType: parentListItem.type,
        tr
      });
    }
  }
  return false;
}
function listBackspace(_ref8) {
  var view = _ref8.view;
  if (!view) {
    return false;
  }
  {
    var $cursor = view.state.selection.$cursor;
    if (!$cursor || $cursor.parentOffset > 0) {
      return false;
    }
    var range2 = $cursor.blockRange();
    if (!range2 || !isListItemNode(range2.parent) || range2.startIndex !== 0) {
      return false;
    }
  }
  {
    var tr = view.state.tr;
    if (wrapListBackward(tr)) {
      view.dispatch(tr);
    }
  }
  {
    var _$cursor = view.state.selection.$cursor;
    if (!_$cursor || _$cursor.parentOffset > 0) {
      return false;
    }
    var _range = _$cursor.blockRange();
    if (!_range || !isListItemNode(_range.parent) || _range.startIndex !== 0) {
      return false;
    }
    var itemIndex = _$cursor.index(_range.depth);
    var listIndex = _$cursor.index(_range.depth - 1);
    var rootIndex = _$cursor.index(_range.depth - 2);
    var isNestedList = _range.depth - 2 >= 1 && isListItemNode(_$cursor.node(_range.depth - 2));
    if (itemIndex === 0 && listIndex === 0 && rootIndex <= 1 && isNestedList) {
      liftListItem(_range.parent.type)(view.state, view.dispatch);
    }
  }
  joinBackward(view.state, view.dispatch, view);
  return true;
}
function createCustomMarkListItemNodeView(_ref) {
  var node4 = _ref.node, mark3 = _ref.mark, updateDOM = _ref.updateDOM, updateMark2 = _ref.updateMark;
  var markContainer = document.createElement("label");
  markContainer.contentEditable = "false";
  markContainer.classList.add(extensionListTheme.LIST_ITEM_MARKER_CONTAINER);
  markContainer.append(mark3);
  var contentDOM = document.createElement("div");
  var dom = document.createElement("li");
  dom.classList.add(extensionListTheme.LIST_ITEM_WITH_CUSTOM_MARKER);
  dom.append(markContainer);
  dom.append(contentDOM);
  var update2 = (newNode) => {
    if (newNode.type !== node4.type) {
      return false;
    }
    node4 = newNode;
    updateDOM(node4, dom);
    updateMark2(node4, mark3);
    return true;
  };
  update2(node4);
  return {
    dom,
    contentDOM,
    update: update2
  };
}
function findParentItem($from, range2) {
  var parentItem = $from.node(range2.depth - 1);
  var parentList = $from.node(range2.depth - 2);
  if (!isListItemNode(parentItem) || !isListNode(parentList)) {
    return false;
  }
  return {
    parentItem,
    parentList
  };
}
function indentSiblingsOfItems(tr, range2) {
  var selectedList = range2.parent;
  var lastSelectedItem = range2.parent.child(range2.endIndex - 1);
  var endOfRange = range2.end;
  var endOfSelectedList = range2.$to.end(range2.depth);
  if (endOfRange < endOfSelectedList) {
    tr.step(new ReplaceAroundStep(endOfRange - 1, endOfSelectedList, endOfRange, endOfSelectedList, new Slice(Fragment.from(lastSelectedItem.type.create(null, selectedList.copy())), 1, 0), 1, true));
    return new NodeRange(tr.doc.resolve(range2.$from.pos), tr.doc.resolve(endOfSelectedList), range2.depth);
  }
  return range2;
}
function indentSiblingsOfList(tr, range2) {
  var selectedList = range2.parent;
  var lastSelectedItem = range2.parent.child(range2.endIndex - 1);
  var endOfSelectedList = range2.end;
  var endOfParentListItem = range2.$to.end(range2.depth - 1);
  if (endOfSelectedList + 1 < endOfParentListItem) {
    tr.step(new ReplaceAroundStep(endOfSelectedList - 1, endOfParentListItem, endOfSelectedList + 1, endOfParentListItem, new Slice(Fragment.from(selectedList.type.create(null, lastSelectedItem.type.create(null))), 2, 0), 0, true));
    return new NodeRange(tr.selection.$from, tr.selection.$to, range2.depth);
  }
  return range2;
}
function changeItemsType(tr, range2, parentList, parentItem) {
  var wrapped = wrapSelectedItems({
    listType: parentList.type,
    itemType: parentItem.type,
    tr
  });
  if (wrapped) {
    return new NodeRange(tr.selection.$from, tr.selection.$to, range2.depth);
  }
  return range2;
}
function dedentList(tr) {
  var range2 = calculateItemRange(tr.selection);
  if (!range2) {
    return false;
  }
  var findParentItemResult = findParentItem(tr.selection.$from, range2);
  if (!findParentItemResult) {
    return false;
  }
  var parentItem = findParentItemResult.parentItem, parentList = findParentItemResult.parentList;
  range2 = indentSiblingsOfItems(tr, range2);
  range2 = indentSiblingsOfList(tr, range2);
  range2 = changeItemsType(tr, range2, parentList, parentItem);
  var target = liftTarget(range2);
  if (typeof target !== "number") {
    return true;
  }
  tr.lift(range2, target);
  range2 = calculateItemRange(tr.selection);
  if (range2) {
    maybeJoinList(tr, tr.doc.resolve(range2.end - 2));
  }
  return true;
}
var dedentListCommand = (_ref) => {
  var tr = _ref.tr, dispatch2 = _ref.dispatch;
  if (dedentList(tr)) {
    dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.scrollIntoView());
  }
  return true;
};
function findPreviousItem(selectedList, $from, range2) {
  var previousItem;
  var previousList;
  var previousItemStart;
  var previousListStart;
  var doc2 = $from.doc;
  if (range2.startIndex >= 1) {
    previousItem = selectedList.child(range2.startIndex - 1);
    previousList = selectedList;
    previousListStart = doc2.resolve(range2.start).start(range2.depth);
    previousItemStart = previousListStart + 1;
    for (var i2 = 0; i2 < range2.startIndex - 1; i2++) {
      previousItemStart += previousList.child(i2).nodeSize;
    }
  } else {
    var listIndex = $from.index(range2.depth - 1);
    if (listIndex >= 1) {
      var listParent = $from.node(range2.depth - 1);
      var listParentStart = $from.start(range2.depth - 1);
      previousList = listParent.child(listIndex - 1);
      if (!isListNode(previousList)) {
        return false;
      }
      previousListStart = listParentStart + 1;
      for (var _i = 0; _i < listIndex - 1; _i++) {
        previousListStart += listParent.child(_i).nodeSize;
      }
      previousItem = previousList.child(previousList.childCount - 1);
      previousItemStart = previousListStart + previousList.nodeSize - previousItem.nodeSize - 1;
      if (!isListItemNode(previousItem)) {
        return false;
      }
    } else {
      return false;
    }
  }
  return {
    previousItem,
    previousList,
    previousItemStart,
    previousListStart
  };
}
function sliceSelectedItems(doc2, $to, range2) {
  var selectedSlice;
  var unselectedSlice;
  var start4 = range2.start;
  var mid = $to.depth >= range2.depth + 2 ? $to.end(range2.depth + 2) : range2.end - 1;
  var end3 = range2.end;
  if (mid + 1 >= end3) {
    selectedSlice = doc2.slice(start4, end3);
    unselectedSlice = null;
  } else {
    selectedSlice = doc2.slice(start4, mid);
    unselectedSlice = doc2.slice(mid + 1, end3 - 1);
  }
  return {
    selectedSlice,
    unselectedSlice
  };
}
function indentList(tr) {
  var _tr$selection = tr.selection, $from = _tr$selection.$from, $to = _tr$selection.$to;
  var range2 = calculateItemRange(tr.selection);
  if (!range2) {
    return false;
  }
  var selectedList = tr.doc.resolve(range2.start).node();
  if (!isListNode(selectedList)) {
    return false;
  }
  var findPreviousItemResult = findPreviousItem(selectedList, $from, range2);
  if (!findPreviousItemResult) {
    return false;
  }
  var previousItem = findPreviousItemResult.previousItem, previousList = findPreviousItemResult.previousList, previousItemStart = findPreviousItemResult.previousItemStart;
  var _sliceSelectedItems = sliceSelectedItems(tr.doc, $to, range2), selectedSlice = _sliceSelectedItems.selectedSlice, unselectedSlice = _sliceSelectedItems.unselectedSlice;
  var newPreviousItemContent = previousItem.content.append(Fragment.fromArray([selectedList.copy(selectedSlice.content)])).append(unselectedSlice ? unselectedSlice.content : Fragment.empty);
  tr.deleteRange(range2.start, range2.end);
  var previousItemEnd = previousItemStart + previousItem.nodeSize - 2;
  var newPreviousItem = previousItem.copy(newPreviousItemContent);
  newPreviousItem.check();
  tr.replaceRangeWith(previousItemStart - 1, previousItemEnd + 1, newPreviousItem);
  tr.setSelection(previousList === selectedList ? TextSelection.create(tr.doc, $from.pos, $to.pos) : TextSelection.create(tr.doc, $from.pos - 2, $to.pos - 2));
  return true;
}
var indentListCommand = (_ref) => {
  var tr = _ref.tr, dispatch2 = _ref.dispatch;
  if (indentList(tr)) {
    dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.scrollIntoView());
  }
  return true;
};
class ListItemSharedExtension extends PlainExtension {
  get name() {
    return "listItemShared";
  }
  createKeymap() {
    var pcKeymap = {
      Tab: indentListCommand,
      "Shift-Tab": dedentListCommand,
      Backspace: listBackspace,
      "Mod-Backspace": listBackspace
    };
    if (environment.isMac) {
      var macKeymap = {
        "Ctrl-h": pcKeymap["Backspace"],
        "Alt-Backspace": pcKeymap["Mod-Backspace"]
      };
      return _objectSpread2$3(_objectSpread2$3({}, pcKeymap), macKeymap);
    }
    return pcKeymap;
  }
  createPlugin() {
    return {
      appendTransaction: (_transactions, _oldState, newState) => {
        var tr = newState.tr;
        var updated = maybeJoinList(tr);
        return updated ? tr : null;
      }
    };
  }
}
var _dec$4, _dec2$3, _dec3$2, _class$4, _class2$2;
var ListItemExtension = (_dec$4 = extension({
  defaultOptions: {
    enableCollapsible: false
  },
  staticKeys: ["enableCollapsible"]
}), _dec2$3 = command(), _dec3$2 = command(), _dec$4(_class$4 = (_class2$2 = class ListItemExtension2 extends NodeExtension {
  get name() {
    return "listItem";
  }
  createTags() {
    return [ExtensionTag.ListItemNode];
  }
  createNodeSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({
      content: "paragraph block*",
      defining: true,
      draggable: false
    }, override), {}, {
      attrs: _objectSpread2$3(_objectSpread2$3({}, extra.defaults()), {}, {
        closed: {
          default: false
        },
        nested: {
          default: false
        }
      }),
      parseDOM: [{
        tag: "li",
        getAttrs: extra.parse,
        priority: ExtensionPriority.Lowest
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => {
        var attrs = extra.dom(node4);
        return ["li", attrs, 0];
      }
    });
  }
  createNodeViews() {
    if (!this.options.enableCollapsible) {
      return {};
    }
    return (node4, view, getPos) => {
      var mark3 = document.createElement("div");
      mark3.classList.add(extensionListTheme.COLLAPSIBLE_LIST_ITEM_BUTTON);
      mark3.contentEditable = "false";
      mark3.addEventListener("click", () => {
        if (mark3.classList.contains("disabled")) {
          return;
        }
        var pos = getPos();
        var selection = NodeSelection.create(view.state.doc, pos);
        view.dispatch(view.state.tr.setSelection(selection));
        this.store.commands.toggleListItemClosed();
        return true;
      });
      return createCustomMarkListItemNodeView({
        mark: mark3,
        node: node4,
        updateDOM: updateNodeViewDOM$1,
        updateMark: updateNodeViewMark$1
      });
    };
  }
  createKeymap() {
    return {
      Enter: splitListItem(this.type)
    };
  }
  createExtensions() {
    return [new ListItemSharedExtension()];
  }
  toggleListItemClosed(closed) {
    return (_ref) => {
      var _ref$state = _ref.state, tr = _ref$state.tr, selection = _ref$state.selection, dispatch2 = _ref.dispatch;
      if (!isNodeSelection(selection) || selection.node.type.name !== this.name) {
        return false;
      }
      var node4 = selection.node, from4 = selection.from;
      closed = isBoolean(closed) ? closed : !node4.attrs.closed;
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.setNodeMarkup(from4, void 0, _objectSpread2$3(_objectSpread2$3({}, node4.attrs), {}, {
        closed
      })));
      return true;
    };
  }
  liftListItemOutOfList(listItemType) {
    return liftListItemOutOfList(listItemType !== null && listItemType !== void 0 ? listItemType : this.type);
  }
}, _applyDecoratedDescriptor(_class2$2.prototype, "toggleListItemClosed", [_dec2$3], Object.getOwnPropertyDescriptor(_class2$2.prototype, "toggleListItemClosed"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "liftListItemOutOfList", [_dec3$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "liftListItemOutOfList"), _class2$2.prototype), _class2$2)) || _class$4);
function updateNodeViewDOM$1(node4, dom) {
  node4.attrs.closed ? dom.classList.add(extensionListTheme.COLLAPSIBLE_LIST_ITEM_CLOSED) : dom.classList.remove(extensionListTheme.COLLAPSIBLE_LIST_ITEM_CLOSED);
}
function updateNodeViewMark$1(node4, mark3) {
  node4.childCount <= 1 ? mark3.classList.add("disabled") : mark3.classList.remove("disabled");
}
var _dec$3, _dec2$2, _dec3$1$1, _class$3, _class2$1$1;
var BulletListExtension = (_dec$3 = extension({
  defaultOptions: {
    enableSpine: false
  },
  staticKeys: ["enableSpine"]
}), _dec2$2 = command({
  icon: "listUnordered",
  label: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionListMessages.BULLET_LIST_LABEL);
  }
}), _dec3$1$1 = keyBinding({
  shortcut: NamedShortcut.BulletList,
  command: "toggleBulletList"
}), _dec$3(_class$3 = (_class2$1$1 = class BulletListExtension2 extends NodeExtension {
  get name() {
    return "bulletList";
  }
  createTags() {
    return [ExtensionTag.Block, ExtensionTag.ListContainerNode];
  }
  createNodeSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({
      content: "listItem+"
    }, override), {}, {
      attrs: extra.defaults(),
      parseDOM: [{
        tag: "ul",
        getAttrs: extra.parse
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => ["ul", extra.dom(node4), 0]
    });
  }
  createNodeViews() {
    if (!this.options.enableSpine) {
      return {};
    }
    return (_2, view, getPos) => {
      var _parentListItemNode$t;
      var dom = document.createElement("ul");
      dom.style.position = "relative";
      var pos = getPos();
      var $pos = view.state.doc.resolve(pos + 1);
      var parentListItemNode = $pos.node($pos.depth - 1);
      var isFirstLevel = (parentListItemNode === null || parentListItemNode === void 0 ? void 0 : (_parentListItemNode$t = parentListItemNode.type) === null || _parentListItemNode$t === void 0 ? void 0 : _parentListItemNode$t.name) !== "listItem";
      if (!isFirstLevel) {
        var spine = document.createElement("div");
        spine.contentEditable = "false";
        spine.classList.add(extensionListTheme.LIST_SPINE);
        spine.addEventListener("click", (event) => {
          var pos2 = getPos();
          var $pos2 = view.state.doc.resolve(pos2 + 1);
          var parentListItemPos = $pos2.start($pos2.depth - 1);
          var selection = NodeSelection.create(view.state.doc, parentListItemPos - 1);
          view.dispatch(view.state.tr.setSelection(selection));
          this.store.commands.toggleListItemClosed();
          event.preventDefault();
          event.stopPropagation();
        });
        dom.append(spine);
      }
      var contentDOM = document.createElement("div");
      contentDOM.classList.add(extensionListTheme.UL_LIST_CONTENT);
      dom.append(contentDOM);
      return {
        dom,
        contentDOM
      };
    };
  }
  createExtensions() {
    return [new ListItemExtension({
      priority: ExtensionPriority.Low,
      enableCollapsible: this.options.enableSpine
    })];
  }
  toggleBulletList() {
    return toggleList(this.type, assertGet(this.store.schema.nodes, "listItem"));
  }
  listShortcut(props) {
    return this.toggleBulletList()(props);
  }
  createInputRules() {
    var regexp = /^\s*([*+-])\s$/;
    return [wrappingInputRule(regexp, this.type), new InputRule(regexp, (state, _match, start4, end3) => {
      var tr = state.tr;
      tr.deleteRange(start4, end3);
      var canUpdate = wrapSelectedItems({
        listType: this.type,
        itemType: assertGet(this.store.schema.nodes, "listItem"),
        tr
      });
      if (!canUpdate) {
        return null;
      }
      return tr;
    })];
  }
}, _applyDecoratedDescriptor(_class2$1$1.prototype, "toggleBulletList", [_dec2$2], Object.getOwnPropertyDescriptor(_class2$1$1.prototype, "toggleBulletList"), _class2$1$1.prototype), _applyDecoratedDescriptor(_class2$1$1.prototype, "listShortcut", [_dec3$1$1], Object.getOwnPropertyDescriptor(_class2$1$1.prototype, "listShortcut"), _class2$1$1.prototype), _class2$1$1)) || _class$3);
var _dec$2$1, _dec2$1$1, _dec3$3, _class$2$1, _class2$3;
var OrderedListExtension = (_dec$2$1 = extension({}), _dec2$1$1 = command({
  icon: "listOrdered",
  label: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionListMessages.ORDERED_LIST_LABEL);
  }
}), _dec3$3 = keyBinding({
  shortcut: NamedShortcut.OrderedList,
  command: "toggleOrderedList"
}), _dec$2$1(_class$2$1 = (_class2$3 = class OrderedListExtension2 extends NodeExtension {
  get name() {
    return "orderedList";
  }
  createTags() {
    return [ExtensionTag.Block, ExtensionTag.ListContainerNode];
  }
  createNodeSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({
      content: "listItem+"
    }, override), {}, {
      attrs: _objectSpread2$3(_objectSpread2$3({}, extra.defaults()), {}, {
        order: {
          default: 1
        }
      }),
      parseDOM: [{
        tag: "ol",
        getAttrs: (node4) => {
          var _node$getAttribute;
          if (!isElementDomNode(node4)) {
            return {};
          }
          return _objectSpread2$3(_objectSpread2$3({}, extra.parse(node4)), {}, {
            order: +((_node$getAttribute = node4.getAttribute("start")) !== null && _node$getAttribute !== void 0 ? _node$getAttribute : 1)
          });
        }
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => {
        var extraAttributes = extra.dom(node4);
        return node4.attrs.order === 1 ? ["ol", extraAttributes, 0] : ["ol", _objectSpread2$3(_objectSpread2$3({}, extraAttributes), {}, {
          start: node4.attrs.order
        }), 0];
      }
    });
  }
  createExtensions() {
    return [new ListItemExtension({
      priority: ExtensionPriority.Low
    })];
  }
  toggleOrderedList() {
    return toggleList(this.type, assertGet(this.store.schema.nodes, "listItem"));
  }
  listShortcut(props) {
    return this.toggleOrderedList()(props);
  }
  createInputRules() {
    var regexp = /^(\d+)\.\s$/;
    return [wrappingInputRule(regexp, this.type, (match) => ({
      order: +assertGet(match, 1)
    }), (match, node4) => node4.childCount + node4.attrs.order === +assertGet(match, 1)), new InputRule(regexp, (state, match, start4, end3) => {
      var tr = state.tr;
      tr.deleteRange(start4, end3);
      var canUpdate = wrapSelectedItems({
        listType: this.type,
        itemType: assertGet(this.store.schema.nodes, "listItem"),
        tr
      });
      if (!canUpdate) {
        return null;
      }
      var order2 = +assertGet(match, 1);
      if (order2 !== 1) {
        var found2 = findParentNodeOfType({
          selection: tr.selection,
          types: this.type
        });
        if (found2) {
          tr.setNodeMarkup(found2.pos, void 0, {
            order: order2
          });
        }
      }
      return tr;
    })];
  }
}, _applyDecoratedDescriptor(_class2$3.prototype, "toggleOrderedList", [_dec2$1$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "toggleOrderedList"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "listShortcut", [_dec3$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "listShortcut"), _class2$3.prototype), _class2$3)) || _class$2$1);
var _dec$1$1, _class$1$1;
var TaskListItemExtension = (_dec$1$1 = command(), _class$1$1 = class TaskListItemExtension2 extends NodeExtension {
  get name() {
    return "taskListItem";
  }
  createTags() {
    return [ExtensionTag.ListItemNode];
  }
  createNodeSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({
      content: "paragraph block*",
      defining: true,
      draggable: false
    }, override), {}, {
      attrs: _objectSpread2$3(_objectSpread2$3({}, extra.defaults()), {}, {
        checked: {
          default: false
        }
      }),
      parseDOM: [{
        tag: "li[data-task-list-item]",
        getAttrs: (node4) => {
          var checked = false;
          if (isElementDomNode(node4) && node4.getAttribute("data-checked") !== null) {
            checked = true;
          }
          return _objectSpread2$3({
            checked
          }, extra.parse(node4));
        },
        priority: ExtensionPriority.Medium
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => {
        return ["li", _objectSpread2$3(_objectSpread2$3({}, extra.dom(node4)), {}, {
          "data-task-list-item": "",
          "data-checked": node4.attrs.checked ? "" : void 0
        }), 0];
      }
    });
  }
  createNodeViews() {
    return (node4, view, getPos) => {
      var mark3 = document.createElement("input");
      mark3.type = "checkbox";
      mark3.classList.add(extensionListTheme.LIST_ITEM_CHECKBOX);
      mark3.contentEditable = "false";
      mark3.addEventListener("click", () => {
        var pos = getPos();
        var $pos = view.state.doc.resolve(pos + 1);
        this.store.commands.toggleCheckboxChecked({
          $pos
        });
        return true;
      });
      return createCustomMarkListItemNodeView({
        node: node4,
        mark: mark3,
        updateDOM: updateNodeViewDOM,
        updateMark: updateNodeViewMark
      });
    };
  }
  createKeymap() {
    return {
      Enter: splitListItem(this.type)
    };
  }
  createExtensions() {
    return [new ListItemSharedExtension()];
  }
  toggleCheckboxChecked(props) {
    var checked;
    var $pos;
    if (typeof props === "boolean") {
      checked = props;
    } else if (props) {
      checked = props.checked;
      $pos = props.$pos;
    }
    return (_ref) => {
      var _$pos, _checked;
      var tr = _ref.tr, dispatch2 = _ref.dispatch;
      var found2 = findParentNodeOfType({
        selection: (_$pos = $pos) !== null && _$pos !== void 0 ? _$pos : tr.selection.$from,
        types: this.type
      });
      if (!found2) {
        return false;
      }
      var node4 = found2.node, pos = found2.pos;
      var attrs = _objectSpread2$3(_objectSpread2$3({}, node4.attrs), {}, {
        checked: (_checked = checked) !== null && _checked !== void 0 ? _checked : !node4.attrs.checked
      });
      dispatch2 === null || dispatch2 === void 0 ? void 0 : dispatch2(tr.setNodeMarkup(pos, void 0, attrs));
      return true;
    };
  }
  createInputRules() {
    var regexp = /^\s*(\[( ?|x|X)]\s)$/;
    return [wrappingInputRule(regexp, this.type, (match) => {
      return {
        checked: ["x", "X"].includes(getMatchString(match, 2))
      };
    }), new InputRule(regexp, (state, match, start4, end3) => {
      var tr = state.tr;
      tr.deleteRange(start4, end3);
      var canUpdate = wrapSelectedItems({
        listType: assertGet(this.store.schema.nodes, "taskList"),
        itemType: this.type,
        tr
      });
      if (!canUpdate) {
        return null;
      }
      var checked = ["x", "X"].includes(getMatchString(match, 2));
      if (checked) {
        var found2 = findParentNodeOfType({
          selection: tr.selection,
          types: this.type
        });
        if (found2) {
          tr.setNodeMarkup(found2.pos, void 0, {
            checked
          });
        }
      }
      return tr;
    })];
  }
}, _applyDecoratedDescriptor(_class$1$1.prototype, "toggleCheckboxChecked", [_dec$1$1], Object.getOwnPropertyDescriptor(_class$1$1.prototype, "toggleCheckboxChecked"), _class$1$1.prototype), _class$1$1);
function updateNodeViewDOM(node4, dom) {
  node4.attrs.checked ? dom.setAttribute("data-checked", "") : dom.removeAttribute("data-checked");
  dom.setAttribute("data-task-list-item", "");
}
function updateNodeViewMark(node4, mark3) {
  mark3.checked = !!node4.attrs.checked;
}
var _dec$5, _dec2$4, _class$5;
var TaskListExtension = (_dec$5 = command({
  icon: "listCheck",
  label: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionListMessages.TASK_LIST_LABEL);
  }
}), _dec2$4 = keyBinding({
  shortcut: NamedShortcut.TaskList,
  command: "toggleTaskList"
}), _class$5 = class TaskListExtension2 extends NodeExtension {
  get name() {
    return "taskList";
  }
  createTags() {
    return [ExtensionTag.Block, ExtensionTag.ListContainerNode];
  }
  createNodeSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({
      content: "taskListItem+"
    }, override), {}, {
      attrs: extra.defaults(),
      parseDOM: [{
        tag: "ul[data-task-list]",
        getAttrs: extra.parse,
        priority: ExtensionPriority.Medium
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (node4) => ["ul", _objectSpread2$3(_objectSpread2$3({}, extra.dom(node4)), {}, {
        "data-task-list": ""
      }), 0]
    });
  }
  createExtensions() {
    return [new TaskListItemExtension({})];
  }
  toggleTaskList() {
    return toggleList(this.type, assertGet(this.store.schema.nodes, "taskListItem"));
  }
  listShortcut(props) {
    return this.toggleTaskList()(props);
  }
}, _applyDecoratedDescriptor(_class$5.prototype, "toggleTaskList", [_dec$5], Object.getOwnPropertyDescriptor(_class$5.prototype, "toggleTaskList"), _class$5.prototype), _applyDecoratedDescriptor(_class$5.prototype, "listShortcut", [_dec2$4], Object.getOwnPropertyDescriptor(_class$5.prototype, "listShortcut"), _class$5.prototype), _class$5);
var toggleStrikeOptions = {
  icon: "strikethrough",
  label: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionStrikeMessages.LABEL);
  },
  description: (_ref2) => {
    var t2 = _ref2.t;
    return t2(extensionStrikeMessages.DESCRIPTION);
  }
};
var _dec$2, _dec2$1, _dec3$1, _class$2, _class2$1;
var StrikeExtension = (_dec$2 = extension({}), _dec2$1 = command(toggleStrikeOptions), _dec3$1 = keyBinding({
  shortcut: NamedShortcut.Strike,
  command: "toggleStrike"
}), _dec$2(_class$2 = (_class2$1 = class StrikeExtension2 extends MarkExtension {
  get name() {
    return "strike";
  }
  createTags() {
    return [ExtensionTag.FontStyle, ExtensionTag.FormattingMark];
  }
  createMarkSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({}, override), {}, {
      attrs: extra.defaults(),
      parseDOM: [{
        tag: "s",
        getAttrs: extra.parse
      }, {
        tag: "del",
        getAttrs: extra.parse
      }, {
        tag: "strike",
        getAttrs: extra.parse
      }, {
        style: "text-decoration",
        getAttrs: (node4) => node4 === "line-through" ? {} : false
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (mark3) => ["s", extra.dom(mark3), 0]
    });
  }
  toggleStrike() {
    return toggleMark({
      type: this.type
    });
  }
  shortcut(props) {
    return this.toggleStrike()(props);
  }
  createInputRules() {
    return [markInputRule({
      regexp: /~([^~]+)~$/,
      type: this.type,
      ignoreWhitespace: true
    })];
  }
  createPasteRules() {
    return [{
      regexp: /~([^~]+)~/g,
      type: "mark",
      markType: this.type
    }];
  }
}, _applyDecoratedDescriptor(_class2$1.prototype, "toggleStrike", [_dec2$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "toggleStrike"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "shortcut", [_dec3$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "shortcut"), _class2$1.prototype), _class2$1)) || _class$2);
var trailingNodePluginKey = new PluginKey("trailingNode");
function trailingNode(options) {
  var _ref = options !== null && options !== void 0 ? options : {}, _ref$ignoredNodes = _ref.ignoredNodes, ignoredNodes = _ref$ignoredNodes === void 0 ? [] : _ref$ignoredNodes, _ref$nodeName = _ref.nodeName, nodeName = _ref$nodeName === void 0 ? "paragraph" : _ref$nodeName;
  var ignoredNodeNames = uniqueArray([...ignoredNodes, nodeName]);
  var type2;
  var types;
  return new Plugin({
    key: trailingNodePluginKey,
    appendTransaction(_2, __, state) {
      var doc2 = state.doc, tr = state.tr;
      var shouldInsertNodeAtEnd = trailingNodePluginKey.getState(state);
      var endPosition = doc2.content.size;
      if (!shouldInsertNodeAtEnd) {
        return;
      }
      return tr.insert(endPosition, type2.create());
    },
    state: {
      init: (_2, _ref2) => {
        var _doc$lastChild;
        var doc2 = _ref2.doc, schema = _ref2.schema;
        var nodeType2 = schema.nodes[nodeName];
        if (!nodeType2) {
          throw new Error("Invalid node being used for trailing node extension: '".concat(nodeName, "'"));
        }
        type2 = nodeType2;
        types = Object.values(schema.nodes).map((node4) => node4).filter((node4) => !ignoredNodeNames.includes(node4.name));
        return includes(types, (_doc$lastChild = doc2.lastChild) === null || _doc$lastChild === void 0 ? void 0 : _doc$lastChild.type);
      },
      apply: (tr, value) => {
        var _tr$doc$lastChild;
        if (!tr.docChanged) {
          return value;
        }
        return includes(types, (_tr$doc$lastChild = tr.doc.lastChild) === null || _tr$doc$lastChild === void 0 ? void 0 : _tr$doc$lastChild.type);
      }
    }
  });
}
var _dec$1, _class$1;
var TrailingNodeExtension = (_dec$1 = extension({
  defaultOptions: {
    ignoredNodes: [],
    disableTags: false,
    nodeName: "paragraph"
  }
}), _dec$1(_class$1 = class TrailingNodeExtension2 extends PlainExtension {
  get name() {
    return "trailingNode";
  }
  onSetOptions(props) {
    var changes = props.changes;
    if (changes.disableTags.changed || changes.ignoredNodes.changed || changes.nodeName.changed) {
      this.store.updateExtensionPlugins(this);
    }
  }
  createExternalPlugins() {
    var tags = this.store.tags;
    var _this$options = this.options, disableTags = _this$options.disableTags, nodeName = _this$options.nodeName;
    var ignoredNodes = disableTags ? [...this.options.ignoredNodes] : [...this.options.ignoredNodes, ...tags.lastNodeCompatible];
    return [trailingNode({
      ignoredNodes,
      nodeName
    })];
  }
}) || _class$1);
var toggleUnderlineOptions = {
  icon: "underline",
  label: (_ref) => {
    var t2 = _ref.t;
    return t2(extensionUnderlineMessages.LABEL);
  },
  description: (_ref2) => {
    var t2 = _ref2.t;
    return t2(extensionUnderlineMessages.DESCRIPTION);
  }
};
var _dec, _dec2, _dec3, _class, _class2;
var UnderlineExtension = (_dec = extension({}), _dec2 = command(toggleUnderlineOptions), _dec3 = keyBinding({
  shortcut: NamedShortcut.Underline,
  command: "toggleUnderline"
}), _dec(_class = (_class2 = class UnderlineExtension2 extends MarkExtension {
  get name() {
    return "underline";
  }
  createTags() {
    return [ExtensionTag.FontStyle, ExtensionTag.FormattingMark];
  }
  createMarkSpec(extra, override) {
    var _override$parseDOM;
    return _objectSpread2$3(_objectSpread2$3({}, override), {}, {
      attrs: extra.defaults(),
      parseDOM: [{
        tag: "u",
        getAttrs: extra.parse
      }, {
        style: "text-decoration",
        getAttrs: (node4) => node4 === "underline" ? {} : false
      }, ...(_override$parseDOM = override.parseDOM) !== null && _override$parseDOM !== void 0 ? _override$parseDOM : []],
      toDOM: (mark3) => ["u", extra.dom(mark3), 0]
    });
  }
  toggleUnderline(selection) {
    return toggleMark({
      type: this.type,
      selection
    });
  }
  shortcut(props) {
    return this.toggleUnderline()(props);
  }
}, _applyDecoratedDescriptor(_class2.prototype, "toggleUnderline", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "toggleUnderline"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "shortcut", [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, "shortcut"), _class2.prototype), _class2)) || _class);
var _jsxFileName$1c = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/editor/editors/ExtendedOptions.tsx";
const actions = [{
  type: ComponentItem.MenuCommandAction,
  commandName: "toggleHeading",
  attrs: {
    level: 1
  },
  tags: ["heading", "1", "one"]
}, {
  type: ComponentItem.MenuCommandAction,
  commandName: "toggleHeading",
  attrs: {
    level: 2
  },
  tags: ["heading", "2", "two"]
}, {
  type: ComponentItem.MenuCommandAction,
  commandName: "toggleHeading",
  attrs: {
    level: 3
  },
  tags: ["heading", "3", "three"]
}, {
  type: ComponentItem.MenuCommandAction,
  commandName: "toggleBulletList",
  tags: ["bullet", "list"]
}, {
  type: ComponentItem.MenuCommandAction,
  commandName: "toggleOrderedList",
  tags: ["ordered", "list"]
}, {
  type: ComponentItem.MenuCommandAction,
  commandName: "toggleTaskList",
  tags: ["task", "list"]
}];
const ExtendedOptions = ({
  readonly
}) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(FloatingActionsMenu, {
    placement: "right",
    enabled: !readonly,
    renderOutsideEditor: true,
    actions
  }, void 0, false, {
    fileName: _jsxFileName$1c,
    lineNumber: 42,
    columnNumber: 10
  }, globalThis);
};
var _jsxFileName$1b = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/editor/editors/FloatingActionBar.tsx";
const basicFormatting = ["toggleBold", "toggleItalic", "toggleUnderline", "toggleStrike", "toggleBlockquote"];
const actionBarItems = [{
  type: ComponentItem.ToolbarGroup,
  label: "Basic bitch formatting",
  items: basicFormatting.map((a2) => ({
    type: ComponentItem.ToolbarCommandButton,
    commandName: a2,
    display: "icon"
  }))
}];
const FloatingActionBar = ({
  readonly
}) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(FloatingToolbar, {
  items: actionBarItems,
  positioner: "selection",
  renderOutsideEditor: true,
  enabled: !readonly,
  placement: "top"
}, void 0, false, {
  fileName: _jsxFileName$1b,
  lineNumber: 19,
  columnNumber: 3
}, globalThis);
const DEFAULT_OPTIONS = __spreadValues(__spreadValues({}, BoldExtension.defaultOptions), TrailingNodeExtension.defaultOptions);
const getExtensions = () => {
  const gapCursorExtension = new GapCursorExtension();
  const hardBreakExtension = new HardBreakExtension();
  const italicExtension = new ItalicExtension();
  const strikeExtension = new StrikeExtension();
  const underlineExtension = new UnderlineExtension();
  const blockquoteExtension = new BlockquoteExtension();
  const bulletListExtension = new BulletListExtension();
  const orderedListExtension = new OrderedListExtension();
  const taskListExtension = new TaskListExtension({});
  const linkExtension = new LinkExtension({ autoLink: true });
  const { weight } = DEFAULT_OPTIONS;
  const boldExtension = new BoldExtension({ weight });
  const headingExtension = new HeadingExtension({ defaultLevel: 1, levels: [1, 2, 3] });
  const { disableTags, ignoredNodes, nodeName } = DEFAULT_OPTIONS;
  const trailingNodeExtension = new TrailingNodeExtension({
    disableTags,
    ignoredNodes,
    nodeName
  });
  return [
    gapCursorExtension,
    hardBreakExtension,
    italicExtension,
    strikeExtension,
    underlineExtension,
    blockquoteExtension,
    bulletListExtension,
    orderedListExtension,
    taskListExtension,
    linkExtension,
    boldExtension,
    headingExtension,
    trailingNodeExtension
  ];
};
var all = "";
var editor = "";
var _jsxFileName$1a = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/editor/index.tsx";
const Editor = (props) => {
  var _a, _b;
  const extensions = react$1.exports.useCallback(() => [new PlaceholderExtension({
    placeholder: props.placeholder
  }), ...getExtensions()], [props.placeholder]);
  const {
    manager,
    state,
    setState
  } = useRemirror({
    extensions,
    stringHandler: "text",
    content: props.defaultValue
  });
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ThemeProvider, {
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Remirror, {
      manager,
      state,
      onChange: (parameter) => {
        props.onChange(parameter.helpers.getHTML());
        setState(parameter.state);
      },
      editable: !props.readonly,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(EditorComponent, {}, void 0, false, {
        fileName: _jsxFileName$1a,
        lineNumber: 30,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ExtendedOptions, {
        readonly: (_a = props.readonly) != null ? _a : false
      }, void 0, false, {
        fileName: _jsxFileName$1a,
        lineNumber: 31,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(FloatingActionBar, {
        readonly: (_b = props.readonly) != null ? _b : false
      }, void 0, false, {
        fileName: _jsxFileName$1a,
        lineNumber: 32,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$1a,
      lineNumber: 21,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$1a,
    lineNumber: 20,
    columnNumber: 5
  }, globalThis);
};
const setCurrentNote = (note) => {
  genericAction("phone.apps.notes", {
    current: note
  });
};
const addNewNote = async () => {
  const newNote = await nuiAction("phone/notes/new", {
    title: "New Note",
    note: "",
    date: Date.now()
  });
  const appState = getState3("phone.apps.notes");
  appState.list.unshift(newNote);
  appState.current = newNote;
  genericAction("phone.apps.notes", appState);
};
const removeCurrentNote = () => {
  const appState = getState3("phone.apps.notes");
  if (!appState.current)
    return;
  appState.list = appState.list.filter((n2) => {
    var _a;
    return n2.id !== ((_a = appState.current) == null ? void 0 : _a.id);
  });
  appState.current = null;
  genericAction("phone.apps.notes", appState);
};
const updateNote = (id, title, text3) => {
  const appState = getState3("phone.apps.notes");
  const note = appState.list.find((n2) => n2.id === id);
  if (!note)
    return;
  note.title = title;
  note.note = text3;
  note.date = Date.now();
  genericAction("phone.apps.notes", appState);
  nuiAction("phone/notes/save", {
    id: note.id,
    note: text3,
    title
  });
};
var _jsxFileName$19 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/notes-app/components/editor.tsx";
const Document = ({
  note
}) => {
  var _a, _b;
  const [title, setTitle] = react$1.exports.useState((_a = note.title) != null ? _a : "");
  const [noteText, setNoteText] = react$1.exports.useState((_b = note.note) != null ? _b : "");
  const [inEditMode, setEditMode] = react$1.exports.useState(false);
  const readActions = [{
    title: "Bewerk",
    icon: "pencil",
    onClick: () => setEditMode(true)
  }];
  const readAuxActions = [{
    title: "Share (Local)",
    icon: "share-alt",
    onClick: () => {
      nuiAction("phone/notes/share", {
        type: "local",
        id: note.id,
        duration: 0
      });
    }
  }, {
    title: "Share (Permanent)",
    icon: "share",
    onClick: () => {
      nuiAction("phone/notes/share", {
        type: "permanent",
        id: note.id,
        duration: 0
      });
    }
  }, {
    title: "Delete",
    icon: "trash",
    onClick: () => {
      nuiAction("phone/notes/delete", {
        id: note.id
      });
      removeCurrentNote();
    }
  }];
  const editActions = [{
    title: "Save",
    icon: "save",
    onClick: () => {
      updateNote(note.id, title, noteText);
      setEditMode(false);
    }
  }];
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
    input: {
      value: title,
      onChange: setTitle,
      label: "Titel"
    },
    primaryActions: note.readonly ? [] : inEditMode ? editActions : readActions,
    auxActions: !note.readonly && !inEditMode ? readAuxActions : void 0,
    onClickBack: () => setCurrentNote(null),
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Editor, {
      onChange: setNoteText,
      placeholder: "Plaats hier je text",
      defaultValue: noteText,
      readonly: !inEditMode
    }, void 0, false, {
      fileName: _jsxFileName$19,
      lineNumber: 79,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$19,
    lineNumber: 69,
    columnNumber: 5
  }, globalThis);
};
const styles$c = makeStyles({
  list: {
    display: "flex",
    flexDirection: "column"
  }
});
var _jsxFileName$18 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/notes-app/components/list.tsx";
const List = (props) => {
  const classes = styles$c();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
    primaryActions: [{
      icon: "plus",
      title: "Nieuw",
      onClick() {
        addNewNote();
      }
    }],
    emptyList: props.list.length === 0,
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.list,
      children: props.list.map((note) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Paper, {
        title: note.title,
        onClick: () => setCurrentNote(note)
      }, note.id, false, {
        fileName: _jsxFileName$18,
        lineNumber: 31,
        columnNumber: 11
      }, globalThis))
    }, void 0, false, {
      fileName: _jsxFileName$18,
      lineNumber: 29,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$18,
    lineNumber: 17,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$17 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/notes-app/components/notes.tsx";
const Notes = (props) => {
  return props.current === null ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(List, {
    list: props.list,
    updateState: props.updateState
  }, void 0, false, {
    fileName: _jsxFileName$17,
    lineNumber: 8,
    columnNumber: 5
  }, globalThis) : /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Document, {
    note: props.current
  }, void 0, false, {
    fileName: _jsxFileName$17,
    lineNumber: 10,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$16 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/notes-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$e,
  mapDispatchToProps: mapDispatchToProps$e
} = compose(store$6, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$e extends React.Component {
  async fetchNotes() {
    const _notes = await nuiAction("phone/notes/get", {}, devData.notes);
    const sortedNotes = _notes.sort((n1, n2) => n1.date - n2.date);
    this.props.updateState({
      list: sortedNotes
    });
  }
  componentDidMount() {
    this.fetchNotes();
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Notes, __spreadValues({}, this.props), void 0, false, {
      fileName: _jsxFileName$16,
      lineNumber: 29,
      columnNumber: 12
    }, this);
  }
}
var Container$e = connect(mapStateToProps$e, mapDispatchToProps$e)(Component$e);
const events$4 = {};
events$4.share = (data) => {
  addNotification({
    id: `note-${data.id}`,
    icon: "notes",
    title: "View Note",
    description: `a note is being shared`,
    onAccept: async (notiData) => {
      const noteId = await nuiAction("phone/notes/resolveShare", {
        id: notiData.id,
        accepted: true
      });
      if (typeof noteId === "number") {
        notiData.note.id = noteId;
      }
      setCurrentNote(notiData.note);
      changeApp("notes");
    },
    onDecline: (notiData) => {
      nuiAction("phone/notes/resolveShare", {
        id: notiData.id,
        accepted: false
      });
    },
    timer: 30,
    _data: {
      id: data.id,
      note: data.note
    }
  });
};
var _jsxFileName$15 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/notes-app/_config.tsx";
const config$e = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "notes",
  label: "Notities",
  icon: {
    name: "folders",
    color: "white",
    background: "#ec1aa4",
    backgroundGradient: "#9420c2",
    size: `1.4rem`
  },
  position: 9,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$e, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$15,
    lineNumber: 21,
    columnNumber: 16
  }, globalThis),
  events: events$4
});
var __glob_1_9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$e
});
var _jsxFileName$14 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/payconiq-app/components/modals.tsx";
const TransactionModal = () => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
  elements: [{
    name: "target",
    render: (props) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Contact, __spreadValues({}, props), void 0, false, {
      fileName: _jsxFileName$14,
      lineNumber: 13,
      columnNumber: 26
    }, globalThis)
  }, {
    name: "amount",
    render: (props) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Number, __spreadProps(__spreadValues({}, props), {
      label: "Amount",
      icon: "euro-sign"
    }), void 0, false, {
      fileName: _jsxFileName$14,
      lineNumber: 17,
      columnNumber: 26
    }, globalThis)
  }, {
    name: "comment",
    render: (props) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props), {
      label: "Opmerking",
      icon: "comment"
    }), void 0, false, {
      fileName: _jsxFileName$14,
      lineNumber: 21,
      columnNumber: 26
    }, globalThis)
  }],
  onAccept: (vals) => {
    nuiAction("phone/payconiq/makeTransaction", vals);
    showCheckmarkModal(() => {
      genericAction("phone.apps.payconiq", {
        dirty: true
      });
    });
  }
}, void 0, false, {
  fileName: _jsxFileName$14,
  lineNumber: 9,
  columnNumber: 3
}, globalThis);
const styles$b = makeStyles({
  transTitle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    width: "100%",
    "& .green": {
      color: green[400]
    },
    "& .red": {
      color: orange[500]
    }
  }
});
var _jsxFileName$13 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/payconiq-app/components/payconiq.tsx";
const Payconiq = (props) => {
  const characterState = useSelector((s2) => s2.character);
  const classes = styles$b();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
    primaryActions: [{
      title: "Schrijf over",
      icon: "hand-holding-usd",
      onClick: () => showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(TransactionModal, {}, void 0, false, {
        fileName: _jsxFileName$13,
        lineNumber: 21,
        columnNumber: 40
      }, globalThis))
    }],
    emptyList: props.list.length === 0,
    children: props.list.map((t2) => {
      const incoming2 = t2.accepted_by === characterState.firstname + " " + characterState.lastname;
      return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Paper, {
        title: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: classes.transTitle,
          children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: incoming2 ? "green" : "red",
            children: ["\u20AC", t2.change]
          }, void 0, true, {
            fileName: _jsxFileName$13,
            lineNumber: 33,
            columnNumber: 17
          }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            children: incoming2 ? t2.triggered_by : t2.accepted_by
          }, void 0, false, {
            fileName: _jsxFileName$13,
            lineNumber: 34,
            columnNumber: 17
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$13,
          lineNumber: 32,
          columnNumber: 15
        }, globalThis),
        description: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          children: formatRelativeTime(t2.date)
        }, void 0, false, {
          fileName: _jsxFileName$13,
          lineNumber: 37,
          columnNumber: 26
        }, globalThis)
      }, t2.transaction_id, false, {
        fileName: _jsxFileName$13,
        lineNumber: 29,
        columnNumber: 11
      }, globalThis);
    })
  }, void 0, false, {
    fileName: _jsxFileName$13,
    lineNumber: 16,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$12 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/payconiq-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$d,
  mapDispatchToProps: mapDispatchToProps$d
} = compose(store$5, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$d extends React.Component {
  async fetchList() {
    const trans = await nuiAction("phone/payconiq/get", {}, devData.bankTrans);
    this.props.updateState({
      list: trans
    });
  }
  componentDidUpdate() {
    if (this.props.dirty) {
      this.fetchList();
      this.props.updateState({
        dirty: false
      });
    }
  }
  componentDidMount() {
    this.fetchList();
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Payconiq, __spreadValues({}, this.props), void 0, false, {
      fileName: _jsxFileName$12,
      lineNumber: 37,
      columnNumber: 12
    }, this);
  }
}
var Container$d = connect(mapStateToProps$d, mapDispatchToProps$d)(Component$d);
var _jsxFileName$11 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/payconiq-app/_config.tsx";
const config$d = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "payconiq",
  label: "Payconiq",
  icon: {
    name: "euro-sign",
    color: "#a84858",
    background: "white"
  },
  position: 11,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$d, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$11,
    lineNumber: 19,
    columnNumber: 16
  }, globalThis)
});
var __glob_1_10 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$d
});
var Dialpad = {};
var _interopRequireDefault$1 = interopRequireDefault.exports;
Object.defineProperty(Dialpad, "__esModule", {
  value: true
});
var default_1$1 = Dialpad.default = void 0;
var _createSvgIcon$1 = _interopRequireDefault$1(createSvgIcon);
var _jsxRuntime$1 = require$$2;
var _default$1 = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
  d: "M12 19c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM6 1c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12-8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-6 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "Dialpad");
default_1$1 = Dialpad.default = _default$1;
var Phone$2 = {};
var _interopRequireDefault = interopRequireDefault.exports;
Object.defineProperty(Phone$2, "__esModule", {
  value: true
});
var default_1 = Phone$2.default = void 0;
var _createSvgIcon = _interopRequireDefault(createSvgIcon);
var _jsxRuntime = require$$2;
var _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
  d: "M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"
}), "Phone");
default_1 = Phone$2.default = _default;
const styles$a = makeStyles({
  list: {
    display: "flex",
    flexDirection: "column",
    width: "100%",
    justifyContent: "center"
  },
  dialerRoot: {
    display: "flex",
    flexDirection: "column",
    width: "65%",
    height: "75%",
    justifyContent: "center",
    alignItems: "center",
    margin: "0 auto"
  },
  dialerBtns: {
    width: "100%",
    display: "flex",
    flexDirection: "column",
    marginTop: "1vh"
  },
  dialerRow: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-evenly",
    marginBottom: "1vh"
  }
});
var _jsxFileName$10 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/phone-app/components/dialer.tsx";
const DialerBtn = styled(Button$2)({
  borderRadius: "50%",
  minWidth: "3vh",
  width: "3vh",
  minHeight: "3vh",
  height: "3vh"
});
const btns = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0]];
const Dialer = () => {
  const classes = styles$a();
  const [value, setValue] = react$1.exports.useState("");
  const handleStartCall = () => {
    startPhoneCall(value);
    setValue("");
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.dialerRoot,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Number, {
      onChange: setValue,
      value,
      label: "TelefoonNr",
      onEnter: handleStartCall
    }, void 0, false, {
      fileName: _jsxFileName$10,
      lineNumber: 31,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.dialerBtns,
      children: btns.map((row, i2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.dialerRow,
        children: row.map((btn, j) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(DialerBtn, {
          onClick: () => setValue(value + btn),
          variant: "outlined",
          children: btn
        }, j, false, {
          fileName: _jsxFileName$10,
          lineNumber: 36,
          columnNumber: 15
        }, globalThis))
      }, i2, false, {
        fileName: _jsxFileName$10,
        lineNumber: 34,
        columnNumber: 11
      }, globalThis))
    }, void 0, false, {
      fileName: _jsxFileName$10,
      lineNumber: 32,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(DialerBtn, {
      variant: "contained",
      sx: {
        background: "#34ad2b",
        color: "white",
        "&:hover": {
          background: "#2c8e24"
        }
      },
      onClick: handleStartCall,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
        className: "fas fa-phone-alt"
      }, void 0, false, {
        fileName: _jsxFileName$10,
        lineNumber: 54,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$10,
      lineNumber: 43,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$10,
    lineNumber: 30,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$$ = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/phone-app/components/list.tsx";
const PhoneList = () => {
  const calls = useSelector((state) => state["phone.apps.phone"].calls);
  const classes = styles$a();
  const actions2 = [{
    title: "Bel terug",
    icon: "phone",
    onClick: (e2) => {
      if (!e2.number)
        return;
      startPhoneCall(e2.number);
    }
  }, {
    title: "Toevoegen aan contacten",
    icon: "user-plus",
    onClick: (e2) => {
      if (!e2.number)
        return;
      if (getContact(e2.number)) {
        addNotification({
          id: "phoneapp-history-contact-exists",
          title: "Phone",
          description: "Contact bestaat al",
          icon: "phone"
        });
        return;
      }
      showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ContactModal, {
        contact: {
          phone: e2.number
        },
        type: "new"
      }, void 0, false, {
        fileName: _jsxFileName$$,
        lineNumber: 40,
        columnNumber: 11
      }, globalThis));
    }
  }];
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.list,
    children: [calls.map((c2) => {
      var _a, _b, _c, _d;
      return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Paper, {
        actions: actions2.map((a2) => __spreadProps(__spreadValues({}, a2), {
          _data: c2
        })),
        image: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: `fas fa-phone${c2.incoming ? "-alt" : ""}`
        }, void 0, false, {
          fileName: _jsxFileName$$,
          lineNumber: 56,
          columnNumber: 18
        }, globalThis),
        title: (_b = (_a = c2.name) != null ? _a : c2.number) != null ? _b : "",
        description: formatRelativeTime(c2.date)
      }, `${(_d = (_c = c2.name) != null ? _c : c2.number) != null ? _d : ""}${c2.date}`, false, {
        fileName: _jsxFileName$$,
        lineNumber: 53,
        columnNumber: 9
      }, globalThis);
    }), calls.length === 0 && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "emptylist",
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
        className: "fas fa-frown"
      }, void 0, false, {
        fileName: _jsxFileName$$,
        lineNumber: 63,
        columnNumber: 11
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("p", {
        children: "Geen gesprekken"
      }, void 0, false, {
        fileName: _jsxFileName$$,
        lineNumber: 64,
        columnNumber: 11
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$$,
      lineNumber: 62,
      columnNumber: 9
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$$,
    lineNumber: 51,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$_ = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/phone-app/components/phone.tsx";
const Phone$1 = () => {
  const [tab, setTab] = react$1.exports.useState(0);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tabs, {
      value: tab,
      onChange: (e2, v2) => setTab(v2),
      variant: "fullWidth",
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tab, {
        icon: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(default_1, {}, void 0, false, {
          fileName: _jsxFileName$_,
          lineNumber: 18,
          columnNumber: 20
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$_,
        lineNumber: 18,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tab, {
        icon: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(default_1$1, {}, void 0, false, {
          fileName: _jsxFileName$_,
          lineNumber: 19,
          columnNumber: 20
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$_,
        lineNumber: 19,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$_,
      lineNumber: 17,
      columnNumber: 7
    }, globalThis), tab === 0 && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(PhoneList, {}, void 0, false, {
      fileName: _jsxFileName$_,
      lineNumber: 21,
      columnNumber: 21
    }, globalThis), tab === 1 && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Dialer, {}, void 0, false, {
      fileName: _jsxFileName$_,
      lineNumber: 22,
      columnNumber: 21
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$_,
    lineNumber: 16,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$Z = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/phone-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$c,
  mapDispatchToProps: mapDispatchToProps$c
} = compose(store$4, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$c extends React.Component {
  componentWillUnmount() {
    this.props.updateState({
      currentNumber: null
    });
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Phone$1, {}, void 0, false, {
      fileName: _jsxFileName$Z,
      lineNumber: 20,
      columnNumber: 12
    }, this);
  }
}
var Container$c = connect(mapStateToProps$c, mapDispatchToProps$c)(Component$c);
const events$3 = {};
events$3.endCurrentCall = endPhoneCall;
events$3.incomingCall = setIncomingCall;
events$3.setCallActive = setActiveCall;
events$3.startAnonCall = (nr) => startPhoneCall(nr, true);
var _jsxFileName$Y = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/phone-app/_config.tsx";
const config$c = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "phone",
  label: "Telefoon",
  icon: {
    name: "phone-alt",
    color: "white",
    background: "#34ad2b"
  },
  position: 4,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$c, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$Y,
    lineNumber: 19,
    columnNumber: 16
  }, globalThis),
  events: events$3
});
var __glob_1_11 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$c
});
var map15 = "./assets/map.6494f3a5.png";
const styles$9 = makeStyles({
  root: {
    width: "55%",
    height: "100%",
    margin: "0 auto",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    "& > *": {
      marginTop: "2vh"
    }
  }
});
var _jsxFileName$X = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/pinger-app/components/pinger.tsx";
const Pinger = () => {
  const [target, setTarget] = react$1.exports.useState("");
  const hasVpn = useSelector((state) => state.character.hasVPN);
  const classes = styles$9();
  const sendPingRequest = (isAnon = false) => {
    nuiAction("phone/pinger/request", {
      target: target.replace(/[^0-9]/g, ""),
      isAnon
    });
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.root,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Number, {
      onChange: setTarget,
      value: target,
      min: 1,
      label: "Speler id",
      icon: "id-card-alt"
    }, void 0, false, {
      fileName: _jsxFileName$X,
      lineNumber: 21,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Primary, {
      onClick: () => sendPingRequest(),
      children: "Ping"
    }, void 0, false, {
      fileName: _jsxFileName$X,
      lineNumber: 22,
      columnNumber: 7
    }, globalThis), hasVpn && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Primary, {
      onClick: () => sendPingRequest(true),
      startIcon: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
        className: "fas fa-user-secret"
      }, void 0, false, {
        fileName: _jsxFileName$X,
        lineNumber: 24,
        columnNumber: 74
      }, globalThis),
      children: "Anon Ping"
    }, void 0, false, {
      fileName: _jsxFileName$X,
      lineNumber: 24,
      columnNumber: 9
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$X,
    lineNumber: 20,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$W = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/pinger-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$b,
  mapDispatchToProps: mapDispatchToProps$b
} = compose(store$3, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$b extends React.Component {
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Pinger, {}, void 0, false, {
        fileName: _jsxFileName$W,
        lineNumber: 18,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$W,
      lineNumber: 17,
      columnNumber: 7
    }, this);
  }
}
var Container$b = connect(mapStateToProps$b, mapDispatchToProps$b)(Component$b);
const events$2 = {};
events$2.doRequest = (data) => {
  var _a, _b;
  addNotification({
    id: `ping-${data.id}`,
    icon: "pinger",
    title: "Binnenkomende ping",
    description: `From ${(_b = (_a = getContact(data.origin)) == null ? void 0 : _a.label) != null ? _b : data.origin}`,
    timer: 30,
    onAccept: () => {
      nuiAction("phone/pinger/accept", { id: data.id });
    },
    onDecline: () => {
      nuiAction("phone/pinger/decline", { id: data.id });
    }
  });
};
var _jsxFileName$V = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/pinger-app/_config.tsx";
const config$b = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "pinger",
  label: "Pinger",
  icon: {
    name: "map-pin",
    color: "white",
    background: "#db3f0a",
    backgroundGradient: "#DB8116"
  },
  background: {
    background: `url(${map15}) no-repeat 0 0 / cover #686666`,
    backgroundBlendMode: "multiply",
    transition: "background-position 5s ease-in-out"
  },
  position: 5,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$b, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$V,
    lineNumber: 26,
    columnNumber: 16
  }, globalThis),
  events: events$2
});
var __glob_1_12 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$b
});
var _jsxFileName$U = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/twitter-app/components/modals.tsx";
const TweetModal = (props) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
  header: "Tweet",
  elements: [{
    name: "tweet",
    render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props2), {
      multiline: true,
      icon: "twitter",
      iconLib: "fab",
      label: "Tweet"
    }), void 0, false, {
      fileName: _jsxFileName$U,
      lineNumber: 14,
      columnNumber: 26
    }, globalThis),
    defaultValue: props.text
  }],
  onAccept: (vals) => {
    nuiAction("phone/twitter/new", __spreadProps(__spreadValues({}, vals), {
      date: Date.now()
    }));
    showCheckmarkModal(() => {
      if (props.onAccept) {
        props.onAccept(vals);
      }
    });
  }
}, void 0, false, {
  fileName: _jsxFileName$U,
  lineNumber: 9,
  columnNumber: 3
}, globalThis);
const styles$8 = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center"
  },
  tweet: {
    display: "flex",
    flexDirection: "column",
    backgroundColor: "#0b57a6",
    width: "100%",
    padding: "1vh 1.3vh",
    borderRadius: ".5vh",
    boxShadow: "0px 3px 5px 0px black",
    marginBottom: "1vh"
  },
  header: {
    display: "flex",
    flexDirection: "column",
    justifyContent: "space-between",
    alignItems: "start",
    fontSize: "1rem",
    "& > p:last-child": {
      textAlign: "right",
      alignSelf: "flex-end",
      color: baseStyle.gray.light,
      fontSize: "0.8rem"
    }
  },
  body: {
    marginTop: ".5vh",
    fontSize: ".9rem"
  },
  btns: {
    display: "flex",
    alignItems: "center",
    marginTop: ".5vh",
    "& .like button:hover": {
      color: "#ff4242"
    },
    "& .retweet button:hover": {
      color: "#2ecc71"
    }
  }
});
var _jsxFileName$T = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/twitter-app/components/twitter.tsx";
const Tweet = (_a) => {
  var _b = _a, {
    tweet
  } = _b, props = __objRest(_b, [
    "tweet"
  ]);
  const classes = styles$8();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.tweet,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.header,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("p", {
        children: tweet.sender_name
      }, void 0, false, {
        fileName: _jsxFileName$T,
        lineNumber: 22,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("p", {
        children: formatRelativeTime(tweet.date)
      }, void 0, false, {
        fileName: _jsxFileName$T,
        lineNumber: 23,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$T,
      lineNumber: 21,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.body,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Textwrapper, {
        children: tweet.tweet
      }, void 0, false, {
        fileName: _jsxFileName$T,
        lineNumber: 26,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$T,
      lineNumber: 25,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.btns,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "like",
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(IconButton, {
          size: "small",
          sx: {
            color: tweet.liked ? "#ff4242" : "#fff"
          },
          onClick: () => props.toggleLike(tweet.id, tweet.liked),
          children: tweet.liked ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
            className: "fas fa-heart"
          }, void 0, false, {
            fileName: _jsxFileName$T,
            lineNumber: 37,
            columnNumber: 28
          }, globalThis) : /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
            className: "far fa-heart"
          }, void 0, false, {
            fileName: _jsxFileName$T,
            lineNumber: 37,
            columnNumber: 61
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$T,
          lineNumber: 30,
          columnNumber: 11
        }, globalThis), tweet.like_count]
      }, void 0, true, {
        fileName: _jsxFileName$T,
        lineNumber: 29,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "retweet",
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(IconButton, {
          size: "small",
          sx: {
            color: tweet.retweeted ? "#2ecc71" : "#fff"
          },
          onClick: () => tweet.retweeted ? {} : props.doRetweet(tweet),
          children: tweet.retweeted ? /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
            className: "fas fa-retweet"
          }, void 0, false, {
            fileName: _jsxFileName$T,
            lineNumber: 49,
            columnNumber: 32
          }, globalThis) : /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
            className: "fal fa-retweet"
          }, void 0, false, {
            fileName: _jsxFileName$T,
            lineNumber: 49,
            columnNumber: 67
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$T,
          lineNumber: 42,
          columnNumber: 11
        }, globalThis), tweet.retweet_count]
      }, void 0, true, {
        fileName: _jsxFileName$T,
        lineNumber: 41,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$T,
      lineNumber: 28,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$T,
    lineNumber: 20,
    columnNumber: 5
  }, globalThis);
};
const Twitter = (props) => {
  const classes = styles$8();
  const [disableLoad, setDisableLoad] = react$1.exports.useState(false);
  const loadMore = async () => {
    if (disableLoad)
      return;
    setDisableLoad(true);
    await props.fetchTweets();
    setDisableLoad(false);
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.root,
    children: [props.tweets.map((tweet) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Tweet, {
      tweet,
      toggleLike: props.toggleLike,
      doDelete: props.doDelete,
      doRetweet: props.doRetweet
    }, `phone-twt-${tweet.id}`, false, {
      fileName: _jsxFileName$T,
      lineNumber: 79,
      columnNumber: 9
    }, globalThis)), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Primary, {
      disabled: disableLoad,
      onClick: loadMore,
      children: "Laad meer"
    }, void 0, false, {
      fileName: _jsxFileName$T,
      lineNumber: 87,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$T,
    lineNumber: 77,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$S = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/twitter-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$a,
  mapDispatchToProps: mapDispatchToProps$a
} = compose(store$2, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$a extends React.Component {
  constructor(props) {
    super(props);
    this.toggleLike = (tweetId, isLiked) => {
      nuiAction(isLiked ? "phone/twitter/removeLike" : "phone/twitter/addLike", {
        tweetId
      });
      const newTweets = [...this.props.tweets];
      const index3 = newTweets.findIndex((tweet) => tweet.id === tweetId);
      if (index3 !== -1) {
        newTweets[index3].liked = !isLiked;
      }
      this.props.updateState({
        tweets: newTweets
      });
    };
    this.doRetweet = (tweet) => {
      showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(TweetModal, {
        onAccept: () => {
          nuiAction("phone/twitter/addRetweet", {
            tweetId: tweet.id
          });
          const newTweets = [...this.props.tweets];
          const index3 = newTweets.findIndex((_tweet) => _tweet.id === tweet.id);
          if (index3 !== -1) {
            this.props.tweets[index3].retweeted = true;
          }
          this.props.updateState({
            tweets: newTweets
          });
        },
        text: `RT ${tweet.sender_name}: ${tweet.tweet}`
      }, void 0, false, {
        fileName: _jsxFileName$S,
        lineNumber: 40,
        columnNumber: 7
      }, this));
    };
    this.doDelete = (tweetId) => {
      nuiAction("phone/twitter/deleteTweet", {
        tweetId
      });
    };
    this.fetchTweets = async () => {
      const newTweets = await nuiAction("phone/twitter/getTweets", {
        recBatches: this.props.requestAmount
      }, devData.tweets);
      const tweets = [...this.props.tweets, ...newTweets.reverse()];
      this.setState({
        list: tweets
      });
      this.props.updateState({
        tweets,
        requestAmount: this.props.requestAmount + 1
      });
    };
    this.state = {
      list: []
    };
  }
  componentDidMount() {
    this.fetchTweets();
  }
  componentWillUnmount() {
    this.props.updateState({
      requestAmount: 0,
      tweets: []
    });
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      primaryActions: [{
        icon: "twitter",
        iconLib: "fab",
        title: "Nieuwe tweet",
        onClick: () => {
          showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(TweetModal, {}, void 0, false, {
            fileName: _jsxFileName$S,
            lineNumber: 91,
            columnNumber: 29
          }, this));
        }
      }],
      emptyList: this.props.tweets.length === 0,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Twitter, __spreadProps(__spreadValues({}, this.props), {
        toggleLike: this.toggleLike,
        doRetweet: this.doRetweet,
        doDelete: this.doDelete,
        fetchTweets: this.fetchTweets
      }), void 0, false, {
        fileName: _jsxFileName$S,
        lineNumber: 97,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 84,
      columnNumber: 7
    }, this);
  }
}
var Container$a = connect(mapStateToProps$a, mapDispatchToProps$a)(Component$a);
const changeTweetStatus = (tweetId, action2) => {
  const appState = getState3("phone.apps.twitter");
  const tweets = [...appState.tweets];
  const index3 = tweets.findIndex((tweet) => tweet.id === tweetId);
  if (index3 !== -1) {
    switch (action2) {
      case "addLike": {
        tweets[index3].like_count++;
        break;
      }
      case "removeLike": {
        tweets[index3].like_count--;
        break;
      }
      case "addRetweet": {
        tweets[index3].retweet_count++;
        break;
      }
    }
    genericAction("phone.apps.twitter", { tweets });
  } else {
    console.warn(`couldn't find tweet with id: ${tweetId}`);
  }
};
const events$1 = {};
events$1.newTweet = (tweet) => {
  const appState = getState3("phone.apps.twitter");
  appState.tweets.unshift(tweet);
  genericAction("phone.apps.twitter", appState);
  const characterState = getState3("character");
  if (`${characterState.firstname}_${characterState.lastname}`.replace(" ", "_") === tweet.sender_name)
    return;
  addNotification({
    id: `tweet_${tweet.id}`,
    icon: "twitter",
    title: `${tweet.sender_name} tweeted`,
    description: tweet.tweet,
    app: "twitter"
  });
};
events$1.addLike = (tweetId) => {
  changeTweetStatus(tweetId, "addLike");
};
events$1.removeLike = (tweetId) => {
  changeTweetStatus(tweetId, "removeLike");
};
events$1.addRetweet = (tweetId) => {
  changeTweetStatus(tweetId, "addRetweet");
};
events$1.deleteTweet = (tweetId) => {
  const appState = getState3("phone.apps.twitter");
  appState.tweets = appState.tweets.filter((tweet) => tweet.id !== tweetId);
  genericAction("phone.apps.twitter", appState);
};
var _jsxFileName$R = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/twitter-app/_config.tsx";
const config$a = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "twitter",
  label: "Twitter",
  icon: {
    name: "twitter",
    lib: "fab fa-",
    color: "#1DA1F2",
    background: "#282828"
  },
  position: 8,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$a, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$R,
    lineNumber: 20,
    columnNumber: 16
  }, globalThis),
  events: events$1
});
var __glob_1_13 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$a
});
var _jsxFileName$Q = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/yp-app/components/modals.tsx";
const NewAd = (props) => {
  var _a, _b;
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
    header: "Nieuwe advertentie",
    elements: [{
      name: "text",
      render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props2), {
        icon: "text"
      }), void 0, false, {
        fileName: _jsxFileName$Q,
        lineNumber: 14,
        columnNumber: 26
      }, globalThis),
      defaultValue: (_b = (_a = props == null ? void 0 : props.ad) == null ? void 0 : _a.text) != null ? _b : ""
    }],
    onAccept: (vals) => {
      if (vals.text.trim() === "") {
        nuiAction("phone/yellowpages/remove");
      } else {
        nuiAction("phone/yellowpages/new", vals);
      }
      showCheckmarkModal(props.onAccept);
    }
  }, void 0, false, {
    fileName: _jsxFileName$Q,
    lineNumber: 9,
    columnNumber: 3
  }, globalThis);
};
const styles$7 = makeStyles({
  list: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center"
  },
  entry: {
    width: "100%",
    display: "flex",
    flexDirection: "column",
    backgroundColor: "#e2cf1c",
    color: baseStyle.gray.dark,
    border: `0.1vh solid ${baseStyle.gray.dark}`,
    borderRadius: ".5vh",
    boxShadow: "0px 3px 5px 0px black",
    textAlign: "center",
    "&:not(:last-child)": {
      marginBottom: "1vh"
    },
    "& > div": {
      padding: ".3vh .5vh",
      borderBottom: `0.1vh solid ${baseStyle.gray.dark}`
    },
    "& > .title": {
      fontSize: "1.1rem"
    },
    "& > .description": {
      fontSize: "0.9rem"
    }
  },
  btnWrapper: {
    display: "flex",
    flexDirection: "row",
    fontSize: "0.8rem",
    textAlign: "left"
  },
  btn: {
    width: "50%",
    display: "flex",
    alignItems: "center",
    cursor: "pointer",
    padding: ".3vh .5vh",
    "&:not(:last-child)": {
      borderRight: `0.1vh solid ${baseStyle.gray.dark}`
    },
    "& > .MuiIcon-root": {
      marginRight: "0.5vh"
    }
  }
});
var _jsxFileName$P = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/yp-app/components/yellowpages.tsx";
const YPAd = ({
  ad
}) => {
  const classes = styles$7();
  const replaceSpan = (e2, rplStr) => {
    const span = e2.target.querySelector("span.replaceSpan");
    if (span) {
      span.innerText = rplStr;
    }
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.entry,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "title",
      children: ad.name
    }, void 0, false, {
      fileName: _jsxFileName$P,
      lineNumber: 22,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "description",
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Textwrapper, {
        children: ad.text
      }, void 0, false, {
        fileName: _jsxFileName$P,
        lineNumber: 24,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$P,
      lineNumber: 23,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.btnWrapper,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.btn,
        onClick: () => startPhoneCall(ad.phone),
        onMouseEnter: (e2) => replaceSpan(e2, ad.phone),
        onMouseLeave: (e2) => replaceSpan(e2, "Bel"),
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Icon$2, {
          name: "phone"
        }, void 0, false, {
          fileName: _jsxFileName$P,
          lineNumber: 33,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
          className: "replaceSpan",
          children: "Bel"
        }, void 0, false, {
          fileName: _jsxFileName$P,
          lineNumber: 34,
          columnNumber: 11
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$P,
        lineNumber: 27,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.btn,
        onClick: () => openConversation(ad.phone),
        onMouseEnter: (e2) => replaceSpan(e2, ad.phone),
        onMouseLeave: (e2) => replaceSpan(e2, "Bericht"),
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Icon$2, {
          name: "comments-alt"
        }, void 0, false, {
          fileName: _jsxFileName$P,
          lineNumber: 42,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
          className: "replaceSpan",
          children: "Bericht"
        }, void 0, false, {
          fileName: _jsxFileName$P,
          lineNumber: 43,
          columnNumber: 11
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$P,
        lineNumber: 36,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$P,
      lineNumber: 26,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$P,
    lineNumber: 21,
    columnNumber: 5
  }, globalThis);
};
const YellowPages = (props) => {
  const classes = styles$7();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.list,
    children: props.list.map((ad) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(YPAd, {
      ad
    }, ad.id, false, {
      fileName: _jsxFileName$P,
      lineNumber: 55,
      columnNumber: 9
    }, globalThis))
  }, void 0, false, {
    fileName: _jsxFileName$P,
    lineNumber: 53,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$O = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/yp-app/component.tsx";
const {
  mapStateToProps: mapStateToProps$9,
  mapDispatchToProps: mapDispatchToProps$9
} = compose(store$1, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$9 extends React.Component {
  constructor(props) {
    super(props);
    this.fetchListings = async () => {
      const listings = await nuiAction("phone/yellowpages/getList", {}, devData.YPListings);
      this.props.updateState({
        list: listings
      });
      this.setState({
        list: listings
      });
    };
    this.state = {
      list: this.props.list
    };
  }
  componentDidMount() {
    this.fetchListings();
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppContainer, {
      primaryActions: [{
        title: "Nieuw",
        icon: "ad",
        onClick: () => {
          showFormModal(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NewAd, {
            ad: this.props.current,
            onAccept: this.fetchListings
          }, void 0, false, {
            fileName: _jsxFileName$O,
            lineNumber: 48,
            columnNumber: 29
          }, this));
        }
      }],
      search: {
        list: this.props.list,
        filter: ["phone", "text", "name"],
        onChange: (value) => {
          this.setState({
            list: value
          });
        }
      },
      emptyList: this.props.list.length === 0,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(YellowPages, __spreadProps(__spreadValues({}, this.props), {
        list: this.state.list
      }), void 0, false, {
        fileName: _jsxFileName$O,
        lineNumber: 63,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$O,
      lineNumber: 42,
      columnNumber: 7
    }, this);
  }
}
var Container$9 = connect(mapStateToProps$9, mapDispatchToProps$9)(Component$9);
const events = {};
events.setCurrentAd = (ad) => {
  ad = ad != null ? ad : null;
  genericAction("phone.apps.yellowpages", {
    current: ad
  });
};
var _jsxFileName$N = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/apps/yp-app/_config.tsx";
const config$9 = () => __spreadProps(__spreadValues({}, defaultConfigObject), {
  name: "yellowpages",
  label: "Advertenties",
  icon: {
    name: "newspaper",
    color: "#000000",
    background: "#eec41d",
    backgroundGradient: "#eec41d"
  },
  position: 7,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$9, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$N,
    lineNumber: 20,
    columnNumber: 16
  }, globalThis),
  events
});
var __glob_1_14 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$9
});
const defaultConfigObject = {
  background: baseStyle.primaryDarker.darker,
  hidden: () => false,
  position: 30
};
const phoneApps = [];
const phoneEvents = {};
const getPhoneApp = (name) => {
  return phoneApps.find((app) => app.name === name);
};
const getPhoneApps = () => {
  const importAll = (r2) => {
    Object.keys(r2).forEach((key) => {
      const config2 = r2[key].default();
      if (phoneApps.find((cmp2) => cmp2.name == config2.name)) {
        return;
      }
      if (config2.events) {
        phoneEvents[config2.name] = config2.events;
      }
      phoneApps.push(config2);
    });
    phoneApps.sort((a2, b) => a2.position - b.position);
  };
  importAll({ "./apps/contacts-app/_config.tsx": __glob_1_0$1, "./apps/crypto-app/_config.tsx": __glob_1_1$1, "./apps/example-app/_config.tsx": __glob_1_2$1, "./apps/gallery-app/_config.tsx": __glob_1_3$1, "./apps/home-screen/_config.tsx": __glob_1_4$1, "./apps/info-app/_config.tsx": __glob_1_5$1, "./apps/justice-app/_config.tsx": __glob_1_6$1, "./apps/mail-app/_config.tsx": __glob_1_7$1, "./apps/message-app/_config.tsx": __glob_1_8$1, "./apps/notes-app/_config.tsx": __glob_1_9, "./apps/payconiq-app/_config.tsx": __glob_1_10, "./apps/phone-app/_config.tsx": __glob_1_11, "./apps/pinger-app/_config.tsx": __glob_1_12, "./apps/twitter-app/_config.tsx": __glob_1_13, "./apps/yp-app/_config.tsx": __glob_1_14 });
  return phoneApps;
};
const baseBgURL = `url(${baseBackground})`;
const getState3 = (key = "phone") => store.getState()[key];
const genericAction = (storeKey, data) => {
  store.dispatch({
    type,
    cb: (state) => __spreadProps(__spreadValues({}, state), {
      [storeKey]: __spreadValues(__spreadValues({}, state[storeKey]), data)
    })
  });
};
const hidePhone = () => {
  const state = getState3();
  genericAction("phone", {
    animating: false
  });
  setTimeout(() => {
    if (state.hasNotifications)
      return;
    genericAction("phone", {
      visible: false
    });
  }, 300);
  nuiAction("phone/close", { inCamera: state.inCamera });
  genericAction("phone", {
    inCamera: false
  });
};
const phoneInit = async () => {
  const results = [];
  for (const app of getPhoneApps()) {
    if (app.init) {
      results.push({
        app: app.name,
        result: await app.init()
      });
    }
  }
  results.map(({ app, result: result2 }) => {
    genericAction(`phone.apps.${app}`, result2);
  });
};
const setBackground = () => {
  const currentAppInfo = phoneApps.find((app) => app.name === getState3().activeApp);
  const getStandardBackground = () => {
    return {
      background: baseBgURL
    };
  };
  if (!currentAppInfo || !(currentAppInfo == null ? void 0 : currentAppInfo.background)) {
    genericAction("phone", {
      background: getStandardBackground()
    });
    return;
  }
  const newBackground = (currentAppInfo == null ? void 0 : currentAppInfo.background) === "transparent" ? getStandardBackground() : typeof (currentAppInfo == null ? void 0 : currentAppInfo.background) === "string" ? { background: currentAppInfo == null ? void 0 : currentAppInfo.background } : currentAppInfo == null ? void 0 : currentAppInfo.background;
  genericAction("phone", {
    background: newBackground
  });
};
const changeApp = (app) => {
  if (!phoneApps.find((a2) => a2.name === app)) {
    console.error(`Phone app ${app} not found`);
  }
  genericAction("phone", {
    activeApp: app
  });
  setBackground();
};
const showFormModal = (Form2) => {
  genericAction("phone.form", {
    visible: true,
    element: Form2,
    checkmark: false
  });
};
const hideFormModal = () => {
  genericAction("phone.form", {
    visible: false,
    checkmark: false,
    element: null
  });
};
const showCheckmarkModal = (payload) => {
  genericAction("phone.form", {
    visible: false,
    checkmark: true,
    element: null
  });
  setTimeout(() => {
    hideFormModal();
    if (!payload)
      return;
    payload();
  }, 2e3);
};
const stringEvents = ["onAccept", "onDecline"];
const addNotification = (notification) => {
  var _a;
  removeNotification(notification.id);
  if (typeof notification.icon === "string") {
    const app = phoneApps.find((app2) => app2.name === notification.icon);
    if (app) {
      notification.icon = app.icon;
    } else {
      notification.icon = {
        name: notification.icon,
        color: "white",
        background: "black"
      };
    }
  }
  stringEvents.forEach((e2) => {
    if (typeof notification[e2] === "string") {
      const eventName = notification[e2];
      notification[e2] = (_data) => {
        nuiAction("phone/notifications/event", {
          event: eventName,
          isAccept: e2 === "onAccept",
          data: _data
        });
      };
    }
  });
  if (notification.app && !getPhoneApp(notification.app)) {
    throw new Error(`Phone app ${notification.app} not found (notification: ${notification.id})`);
  }
  const notiState = getState3("phone.notifications");
  notiState.list.unshift(notification);
  genericAction("phone.notifications", {
    list: notiState.list
  });
  const phoneState = getState3();
  if (!phoneState.isSilent) {
    genericAction("phone", {
      visible: true,
      hasNotifications: true
    });
  }
  if (notification.sticky)
    return;
  let cd = (notification == null ? void 0 : notification.timer) && notification.timer > 0 ? notification.timer * 1e3 : 8e3;
  if ((notification.onAccept || notification.onDecline) && !(((_a = notification == null ? void 0 : notification.timer) != null ? _a : 0) > 0)) {
    cd = 3e4;
  }
  setTimeout(() => {
    removeNotification(notification.id);
    if (notification == null ? void 0 : notification.onDecline) {
      notification.onDecline(notification._data);
    }
  }, cd);
};
const removeNotification = (id) => {
  const notiState = getState3("phone.notifications");
  const index3 = notiState.list.findIndex((n2) => n2.id === id);
  if (index3 === -1)
    return;
  notiState.list.splice(index3, 1);
  genericAction("phone.notifications", {
    list: notiState.list
  });
  if (notiState.list.length === 0) {
    genericAction("phone", {
      hasNotifications: false
    });
  }
};
const acceptNotification = (id) => {
  const notiState = getState3("phone.notifications");
  const notification = notiState.list.find((n2) => n2.id === id);
  if (!notification)
    return;
  if (notification.onAccept) {
    notification.onAccept(notification._data);
  }
  if (notification.app) {
    changeApp(notification.app);
  }
  if (notification.keepOnAction)
    return;
  removeNotification(id);
};
const declineNotification = (id) => {
  const notiState = getState3("phone.notifications");
  const notification = notiState.list.find((n2) => n2.id === id);
  if (!notification)
    return;
  if (notification.onDecline) {
    notification.onDecline(notification._data);
  }
  if (notification.keepOnAction)
    return;
  removeNotification(id);
};
const updateNotification = (id, notification) => {
  const notiState = getState3("phone.notifications");
  const index3 = notiState.list.findIndex((n2) => n2.id === id);
  if (index3 === -1)
    return;
  notiState.list[index3] = __spreadValues(__spreadValues({}, notiState.list[index3]), notification);
  genericAction("phone.notifications", {
    list: notiState.list
  });
};
const styles$6 = makeStyles({
  root: {
    width: "95%",
    "& > *": {
      height: "100%",
      margin: ".5vh 0"
    },
    "& > .simpleform-element": {
      width: "100%"
    }
  },
  header: {
    textAlign: "center",
    width: "100%",
    fontWeight: "bold",
    marginBottom: "1vh"
  },
  btnWrapper: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: "2vh"
  }
});
var _jsxFileName$M = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/simpleform.tsx";
const SimpleForm = (props) => {
  var _a;
  const classes = styles$6();
  const [values2, setValues] = react$1.exports.useState({});
  const [errors, setErrors] = react$1.exports.useState({});
  react$1.exports.useEffect(() => {
    const newValues = {};
    props.elements.forEach((elememt) => {
      var _a2;
      newValues[elememt.name] = (_a2 = elememt.defaultValue) != null ? _a2 : "";
    });
    setValues(newValues);
  }, [props.elements]);
  const handleDecline = () => {
    if (props.onDecline) {
      props.onDecline();
    }
    hideFormModal();
  };
  const handleAccept = () => {
    var _a2;
    const newErrors = {};
    for (const element of props.elements) {
      if (((_a2 = element.required) != null ? _a2 : true) && (!values2[element.name] || values2[element.name].trim() === "")) {
        newErrors[element.name] = "Required";
      }
    }
    setErrors(newErrors);
    if (Object.keys(newErrors).length === 0) {
      props.onAccept(values2);
    }
  };
  const handleChange = (name, value) => {
    const _values = __spreadValues({}, values2);
    _values[name] = value;
    if (errors[name]) {
      setErrors(__spreadProps(__spreadValues({}, errors), {
        [name]: false
      }));
    }
    setValues(_values);
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.root,
    children: [((_a = props.header) == null ? void 0 : _a.trim()) !== "" && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
      variant: "h6",
      className: classes.header,
      children: props.header
    }, void 0, false, {
      fileName: _jsxFileName$M,
      lineNumber: 52,
      columnNumber: 9
    }, globalThis), props.elements.map((e2) => {
      var _a2, _b, _c;
      return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "simpleform-element",
        children: e2.render({
          name: e2.name,
          value: (_a2 = values2[e2.name]) != null ? _a2 : "",
          onChange: (val) => handleChange(e2.name, val),
          required: (_b = e2.required) != null ? _b : true,
          error: (_c = errors[e2.name]) != null ? _c : false
        })
      }, e2.name, false, {
        fileName: _jsxFileName$M,
        lineNumber: 57,
        columnNumber: 9
      }, globalThis);
    }), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.btnWrapper,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Secondary, {
        onClick: handleDecline,
        sx: {
          fontSize: ".75rem"
        },
        children: "Decline"
      }, void 0, false, {
        fileName: _jsxFileName$M,
        lineNumber: 68,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Primary, {
        onClick: handleAccept,
        sx: {
          fontSize: ".75rem"
        },
        children: "Accept"
      }, void 0, false, {
        fileName: _jsxFileName$M,
        lineNumber: 76,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$M,
      lineNumber: 67,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$M,
    lineNumber: 50,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$L = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/util.tsx";
const EmptyDiv = () => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {}, void 0, false, {
  fileName: _jsxFileName$L,
  lineNumber: 6,
  columnNumber: 31
}, globalThis);
const ConfirmationModal = (props) => {
  var _a;
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
    header: (_a = props.header) != null ? _a : "Weet je zeker dat je deze actie wilt doen",
    elements: [],
    onAccept: props.onAccept
  }, void 0, false, {
    fileName: _jsxFileName$L,
    lineNumber: 12,
    columnNumber: 3
  }, globalThis);
};
var _jsxFileName$K = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/numberformat.tsx";
const NumberFormat = {
  Phone: EmptyDiv,
  Bank: EmptyDiv
};
NumberFormat.Phone = (_c) => {
  var _d = _c, {
    onChange
  } = _d, props = __objRest(_d, [
    "onChange"
  ]);
  var _a;
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NumberFormat$1, __spreadProps(__spreadValues({}, props), {
    format: "#### ## ## ##",
    displayType: (_a = props.displayType) != null ? _a : "text",
    isNumericString: true,
    onValueChange: (values2) => {
      if (!onChange)
        return;
      if (!props.name)
        throw new Error("NumberFormat missing name");
      onChange({
        target: {
          name: props.name,
          value: values2.value
        }
      });
    }
  }), void 0, false, {
    fileName: _jsxFileName$K,
    lineNumber: 25,
    columnNumber: 5
  }, globalThis);
};
NumberFormat.Bank = (_e) => {
  var _f = _e, {
    onChange
  } = _f, props = __objRest(_f, [
    "onChange"
  ]);
  var _a;
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NumberFormat$1, __spreadProps(__spreadValues({}, props), {
    displayType: (_a = props.displayType) != null ? _a : "text",
    thousandsGroupStyle: "thousand",
    thousandSeparator: ".",
    decimalSeparator: ",",
    allowNegative: true,
    fixedDecimalScale: true,
    decimalScale: 2,
    isNumericString: true,
    onValueChange: (values2) => {
      if (!onChange)
        return;
      if (!props.name)
        throw new Error("NumberFormat missing name");
      onChange({
        target: {
          name: props.name,
          value: values2.value
        }
      });
    }
  }), void 0, false, {
    fileName: _jsxFileName$K,
    lineNumber: 46,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$J = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/components/inputs.tsx";
const inputNumberStyles = makeStyles({
  input: {
    "& input::-webkit-outer-spin-button, input::-webkit-inner-spin-button": {
      "-webkit-appearance": "none",
      margin: 0
    }
  }
});
const Input = {
  TextField: EmptyDiv,
  Password: EmptyDiv,
  Number: EmptyDiv,
  AutoComplete: EmptyDiv,
  Checkbox: EmptyDiv,
  MoneyAmount: EmptyDiv,
  PhoneNumber: EmptyDiv,
  Search: EmptyDiv,
  Contact: EmptyDiv
};
const StyledInput = styled(TextField)({
  "&": {
    pointerEvents: "none"
  },
  "& > div": {
    pointerEvents: "auto"
  }
});
Input.TextField = (props) => {
  var _a, _b, _c;
  const onChange = (e2) => {
    if (props.onChange) {
      props.onChange(e2.target.value, e2.target.name, e2);
    }
  };
  const handleKeyPress = (e2) => {
    switch (e2.key) {
      case "Enter":
        e2.preventDefault();
        if (props.onEnter) {
          props.onEnter(e2.target.value, e2.target.name, e2);
        }
        break;
    }
  };
  const handleFocus = (e2) => {
    nuiAction("controls/setFocus", {
      state: true
    });
    if (props.onFocus) {
      props.onFocus(e2);
    }
  };
  const handleBlur = (e2) => {
    nuiAction("controls/setFocus", {
      state: false
    });
    if (props.onBlur) {
      props.onBlur(e2);
    }
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(StyledInput, __spreadProps(__spreadValues({}, props), {
    variant: "standard",
    fullWidth: (_a = props.fullWidth) != null ? _a : true,
    onChange,
    onKeyPress: handleKeyPress,
    InputProps: __spreadProps(__spreadValues({}, props.InputProps), {
      type: (_b = props.type) != null ? _b : "normal",
      startAdornment: props.icon && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(InputAdornment, {
        position: "start",
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: `${(_c = props.iconLib) != null ? _c : "fas"} fa-${props.icon}`
        }, void 0, false, {
          fileName: _jsxFileName$J,
          lineNumber: 154,
          columnNumber: 15
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$J,
        lineNumber: 153,
        columnNumber: 13
      }, globalThis) || void 0
    }),
    onFocus: handleFocus,
    onBlur: handleBlur
  }), void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 142,
    columnNumber: 5
  }, globalThis);
};
Input.Password = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props), {
    type: "password"
  }), void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 166,
    columnNumber: 10
  }, globalThis);
};
Input.Number = (props) => {
  var _a;
  const styles2 = inputNumberStyles();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props), {
    className: `${styles2.input} ${(_a = props.className) != null ? _a : ""}`,
    inputProps: {
      inputMode: "numeric",
      pattern: "[0-9]*"
    },
    type: "number",
    InputProps: __spreadProps(__spreadValues({}, props.InputProps), {
      inputProps: {
        min: props.min,
        max: props.max
      },
      type: "number"
    })
  }), void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 172,
    columnNumber: 5
  }, globalThis);
};
Input.AutoComplete = (_g) => {
  var _h = _g, {
    options,
    freeSolo,
    inputValue
  } = _h, props = __objRest(_h, [
    "options",
    "freeSolo",
    "inputValue"
  ]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Autocomplete, {
    options: options.map((option) => option.label),
    onInputChange: (e2, inputval) => {
      var _a;
      const inputValue2 = (_a = options.find((option) => option.label === inputval)) == null ? void 0 : _a.value;
      props.onChange(inputValue2, props.name, e2);
    },
    freeSolo: freeSolo != null ? freeSolo : false,
    fullWidth: true,
    inputValue,
    renderInput: (params) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues(__spreadValues({}, params), props), {
      type: "text"
    }), void 0, false, {
      fileName: _jsxFileName$J,
      lineNumber: 205,
      columnNumber: 30
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 194,
    columnNumber: 5
  }, globalThis);
};
Input.Checkbox = (props) => {
  var _a;
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(FormControlLabel, {
    control: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Checkbox, __spreadProps(__spreadValues({}, props), {
      color: (_a = props.color) != null ? _a : "primary"
    }), void 0, false, {
      fileName: _jsxFileName$J,
      lineNumber: 211,
      columnNumber: 30
    }, globalThis),
    label: props.label
  }, void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 211,
    columnNumber: 3
  }, globalThis);
};
const NumberFormatCustom = react$1.exports.forwardRef(function NumberFormatCustom2(props, ref2) {
  const _a = props, {
    prefix,
    formatType
  } = _a, other = __objRest(_a, [
    "prefix",
    "formatType"
  ]);
  const Comp = NumberFormat[formatType];
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Comp, __spreadProps(__spreadValues({}, other), {
    getInputRef: ref2,
    displayType: "input",
    prefix: prefix != null ? prefix : ""
  }), void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 217,
    columnNumber: 10
  }, this);
});
Input.MoneyAmount = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props), {
    type: "text",
    InputProps: {
      inputComponent: NumberFormatCustom,
      inputProps: {
        prefix: props.prefix,
        min: props.min,
        max: props.max,
        value: String(props.value),
        formatType: "Bank"
      }
    }
  }), void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 222,
    columnNumber: 5
  }, globalThis);
};
Input.PhoneNumber = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props), {
    type: "text",
    InputProps: {
      inputComponent: NumberFormatCustom,
      inputProps: {
        value: String(props.value),
        name: props.name,
        formatType: "Phone"
      }
    }
  }), void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 241,
    columnNumber: 5
  }, globalThis);
};
Input.Search = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props), {
    label: "Search",
    icon: "search"
  }), void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 257,
    columnNumber: 10
  }, globalThis);
};
Input.Contact = (props) => {
  var _a, _b;
  const contacts = useSelector((state) => state["phone.apps.contacts"].contacts);
  const [selValue, setSelValue] = react$1.exports.useState("");
  const onChangeCapture = (value, name, evt) => {
    setSelValue(value != null ? value : "");
    props.onChange(value, name, evt);
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.AutoComplete, __spreadProps(__spreadValues({}, props), {
    icon: (_a = props.icon) != null ? _a : "mobile",
    inputValue: selValue,
    options: contacts.map((c2) => ({
      label: c2.label,
      value: c2.phone
    })),
    onChange: onChangeCapture,
    label: (_b = props.label) != null ? _b : "TelefoonNr",
    freeSolo: true
  }), void 0, false, {
    fileName: _jsxFileName$J,
    lineNumber: 270,
    columnNumber: 5
  }, globalThis);
};
const cmds = [
  {
    cmd: "show debuglogs",
    app: "debuglogs",
    show: true
  },
  {
    cmd: "interaction $1 $2",
    app: "interaction",
    show: true,
    data: {
      text: "$2",
      type: "$1"
    }
  },
  {
    cmd: "hide interaction",
    app: "interaction",
    hide: true,
    data: {}
  },
  {
    cmd: "notification $1 $2",
    app: "notifications",
    data: {
      action: "add",
      notification: {
        message: "$1",
        type: "$2"
      }
    }
  },
  {
    cmd: "persi-notification $1 $2",
    app: "notifications",
    data: {
      action: "add",
      notification: {
        message: "$1",
        type: "$2",
        persistent: true
      }
    }
  },
  {
    cmd: "show input $1",
    app: "input",
    show: true,
    data: {
      callbackURL: "testCB",
      header: "$1",
      inputs: [
        {
          name: "text-1",
          type: "text",
          label: "Text"
        },
        {
          name: "number-1",
          type: "number",
          label: "Number"
        },
        {
          name: "password-1",
          type: "password",
          label: "Password"
        },
        {
          name: "select-1",
          type: "select",
          label: "Select",
          options: [
            {
              label: "Option-1",
              value: "option-1"
            },
            {
              label: "Option-2",
              value: "option-2"
            },
            {
              label: "Option-3",
              value: "option-3"
            }
          ]
        }
      ]
    }
  },
  {
    cmd: "show hud",
    app: "hud",
    show: true,
    data: defaultState.hud
  },
  {
    cmd: "show contextmenu",
    app: "contextmenu",
    show: true,
    data: defaultState.contextmenu
  },
  {
    cmd: "hide contextmenu",
    app: "contextmenu",
    show: false
  },
  {
    cmd: "show phone",
    app: "phone",
    show: true,
    data: {}
  },
  {
    cmd: "hide phone",
    app: "phone",
    show: false
  },
  {
    cmd: "show bank",
    app: "financials",
    show: true,
    data: defaultState.financials
  },
  {
    cmd: "hide bank",
    app: "financials",
    show: false
  }
];
var _jsxFileName$I = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/cli/components/bar.tsx";
const Bar = () => {
  const [value, setValue] = React.useState("");
  const realCmds = cmds.map((cmd) => {
    return {
      name: cmd.cmd.replace(/\$\d+/g, "").trim(),
      cmd
    };
  });
  const autocompleteOpt = cmds.map((c2) => {
    const newCmd = c2.cmd.replace(/\$\d+/g, (match) => {
      if (!c2.data) {
        return "";
      }
      const loopEntries = (data) => {
        let val = "";
        Object.entries(data).forEach(([key, value2]) => {
          let loopVal = "";
          if (typeof value2 === "object") {
            loopVal = loopEntries(value2);
          }
          if (loopVal.trim() !== "") {
            val = loopVal;
            return val;
          }
          if (value2 === match) {
            val = `$${key}`;
          }
        });
        return val;
      };
      return loopEntries(c2.data);
    });
    return {
      value: newCmd,
      label: newCmd
    };
  });
  const setReplacer = (data, arg, idx) => {
    const _data = __spreadValues({}, data);
    Object.entries(_data).forEach(([key, val]) => {
      if (typeof val === "object" && !Array.isArray(val)) {
        _data[key] = setReplacer(val, arg, idx);
      }
      if (val === `$${idx + 1}`) {
        _data[key] = arg.replace(/^'(.*)'$/, "$1");
      }
    });
    return _data;
  };
  const doCmd = () => {
    var _a;
    const cmdInfo = realCmds.find((cmd) => {
      return value.startsWith(cmd.name);
    });
    if (!cmdInfo) {
      console.log(`no cmd found for ${value}`);
      return;
    }
    console.debug(`cmdInfo: ${cmdInfo.name}`);
    const args = value.replace(cmdInfo.name, "").trim();
    if (!cmdInfo.cmd.data) {
      cmdInfo.cmd.data = {};
    }
    let parsedData = (_a = cmdInfo.cmd.data) != null ? _a : {};
    if (args) {
      args.split(/(?<!'[^']+) (?![^' ]+')/).forEach((arg, idx) => {
        parsedData = setReplacer(parsedData, arg, idx);
      });
    }
    const extraData = {};
    if (cmdInfo.cmd.show !== void 0) {
      extraData.show = cmdInfo.cmd.show;
    }
    if (cmdInfo.cmd.hide !== void 0) {
      extraData.show = cmdInfo.cmd.hide;
    }
    mockEvent(cmdInfo.cmd.app, parsedData, extraData);
  };
  const onChange = (val) => {
    setValue(val);
  };
  const keyPress = (e2) => {
    if (e2.key === "Enter") {
      doCmd();
      setValue("");
    }
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "cli_bar",
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.AutoComplete, {
      name: "cmd",
      label: "Command",
      value,
      onChange,
      onKeyDown: keyPress,
      options: autocompleteOpt
    }, void 0, false, {
      fileName: _jsxFileName$I,
      lineNumber: 99,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$I,
    lineNumber: 98,
    columnNumber: 5
  }, globalThis);
};
var cli = "";
var _jsxFileName$H = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/cli/component.tsx";
const {
  mapStateToProps: mapStateToProps$8,
  mapDispatchToProps: mapDispatchToProps$8
} = compose(store$o, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$8 extends React.Component {
  constructor() {
    super(...arguments);
    this.handleVisibility = (isVis) => {
      this.props.updateState({
        visible: isVis
      });
    };
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppWrapper, {
      appName: store$o.key,
      onShow: () => this.handleVisibility(true),
      onHide: () => this.handleVisibility(false),
      center: true,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Bar, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$H,
        lineNumber: 30,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$H,
      lineNumber: 24,
      columnNumber: 7
    }, this);
  }
}
var Container$8 = connect(mapStateToProps$8, mapDispatchToProps$8)(Component$8);
var _jsxFileName$G = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/cli/_config.tsx";
const config$8 = {
  name: store$o.key,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$8, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$G,
    lineNumber: 9,
    columnNumber: 16
  }, globalThis),
  type: "interactive"
};
var __glob_1_0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$8
});
var _jsxFileName$F = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/contextmenu/components/contextmenu.tsx";
const MenuEntry = (props) => {
  var _a, _b, _c, _d, _e, _f, _g;
  const parentEntry = useSelector((state) => state.contextmenu.parentEntry);
  const handleClick2 = () => {
    let hasSub = false;
    if (props.submenu) {
      props.updateState({
        entries: props.submenu,
        parentEntry: parentEntry ? `${parentEntry}.${props.id}` : props.id
      });
      hasSub = true;
    }
    if (props.callbackURL) {
      nuiAction(props.callbackURL, props.data);
      if (!hasSub) {
        closeApplication(store$n.key);
      }
    }
    if (props.onClick) {
      props.onClick();
    }
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: `entry ${props.disabled ? "disabled" : ""}`,
    onClick: !props.disabled && handleClick2 || void 0,
    children: [props.icon && typeof props.icon === "string" && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "icon",
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
        className: `fas fa-${props.icon}`
      }, void 0, false, {
        fileName: _jsxFileName$F,
        lineNumber: 38,
        columnNumber: 11
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$F,
      lineNumber: 37,
      columnNumber: 9
    }, globalThis), props.icon && props.icon.name && ((_a = props.icon) == null ? void 0 : _a.position) === "left" && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "icon",
      style: {
        color: (_c = (_b = props.icon) == null ? void 0 : _b.color) != null ? _c : "inherit"
      },
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
        className: `fas fa-${props.icon.name}`
      }, void 0, false, {
        fileName: _jsxFileName$F,
        lineNumber: 43,
        columnNumber: 11
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$F,
      lineNumber: 42,
      columnNumber: 9
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "textWrapper",
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "title",
        children: props.title
      }, void 0, false, {
        fileName: _jsxFileName$F,
        lineNumber: 47,
        columnNumber: 9
      }, globalThis), props.description && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "description",
        children: props.description
      }, void 0, false, {
        fileName: _jsxFileName$F,
        lineNumber: 48,
        columnNumber: 31
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$F,
      lineNumber: 46,
      columnNumber: 7
    }, globalThis), props.icon && props.icon.name && ((_d = props.icon) == null ? void 0 : _d.position) === "right" && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "icon",
      style: {
        color: (_f = (_e = props.icon) == null ? void 0 : _e.color) != null ? _f : "inherit"
      },
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
        className: `${(_g = props.icon.lib) != null ? _g : "fas"} fa-${props.icon.name}`
      }, void 0, false, {
        fileName: _jsxFileName$F,
        lineNumber: 52,
        columnNumber: 11
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$F,
      lineNumber: 51,
      columnNumber: 9
    }, globalThis), props.submenu && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "icon",
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
        className: `fas fa-chevron-right`
      }, void 0, false, {
        fileName: _jsxFileName$F,
        lineNumber: 59,
        columnNumber: 11
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$F,
      lineNumber: 58,
      columnNumber: 9
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$F,
    lineNumber: 32,
    columnNumber: 5
  }, globalThis);
};
const ContextMenu = (props) => {
  const goMenuBack = () => {
    var _a;
    const keys2 = ((_a = props.parentEntry) != null ? _a : "").split(".");
    const searchForEntries = (entries2, key = 0) => {
      if (entries2.length === 0) {
        return false;
      }
      if (key === keys2.length) {
        return true;
      }
      const entry = entries2.find((entry2) => entry2.id === keys2[key]);
      if (entry == null ? void 0 : entry.submenu) {
        const hasFound = searchForEntries(entry.submenu, key + 1);
        return hasFound ? entries2 : false;
      }
      return [];
    };
    const newEntries = searchForEntries(props.allEntries);
    if (newEntries) {
      keys2.pop();
      props.updateState({
        entries: newEntries,
        parentEntry: newEntries ? keys2.join(".") : null
      });
    }
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "contextmenu__wrapper",
    children: [props.parentEntry && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(MenuEntry, {
      id: `back-${props.parentEntry}`,
      title: "Back",
      icon: "chevron-left",
      updateState: props.updateState,
      onClick: goMenuBack
    }, void 0, false, {
      fileName: _jsxFileName$F,
      lineNumber: 96,
      columnNumber: 9
    }, globalThis), props.entries.map((entry) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(MenuEntry, __spreadProps(__spreadValues({}, entry), {
      updateState: props.updateState
    }), entry.id, false, {
      fileName: _jsxFileName$F,
      lineNumber: 105,
      columnNumber: 9
    }, globalThis))]
  }, void 0, true, {
    fileName: _jsxFileName$F,
    lineNumber: 94,
    columnNumber: 5
  }, globalThis);
};
var contextmenu = "";
var _jsxFileName$E = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/contextmenu/component.tsx";
const {
  mapStateToProps: mapStateToProps$7,
  mapDispatchToProps: mapDispatchToProps$7
} = compose(store$n, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$7 extends React.Component {
  constructor(props) {
    super(props);
    this.generateIds = (entries2) => {
      const ids = [];
      const getId = () => {
        let id = uuidv4();
        while (ids.indexOf(id) !== -1) {
          id = uuidv4();
        }
        return id;
      };
      entries2.forEach((entry) => {
        if (!entry.id)
          return;
        ids.push(entry.id);
      });
      return entries2.map((entry) => {
        if (entry.id)
          return entry;
        entry.id = getId();
        if (entry.submenu) {
          entry.submenu = this.generateIds(entry.submenu);
        }
        return entry;
      });
    };
    this.onShow = (data) => {
      data = this.generateIds(data);
      this.props.updateState({
        visible: true,
        entries: data,
        allEntries: data,
        parentEntry: null
      });
    };
    this.onHide = () => {
      this.props.updateState({
        visible: false,
        entries: [],
        allEntries: [],
        parentEntry: null
      });
      return true;
    };
    this.state = {
      id: 0
    };
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppWrapper, {
      appName: store$n.key,
      onShow: this.onShow,
      onHide: this.onHide,
      onEscape: this.onHide,
      full: true,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ContextMenu, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$E,
        lineNumber: 71,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$E,
      lineNumber: 70,
      columnNumber: 7
    }, this);
  }
}
var Container$7 = connect(mapStateToProps$7, mapDispatchToProps$7)(Component$7);
var _jsxFileName$D = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/contextmenu/_config.tsx";
const config$7 = {
  name: store$n.key,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$7, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$D,
    lineNumber: 9,
    columnNumber: 16
  }, globalThis),
  type: "interactive"
};
var __glob_1_1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$7
});
var _jsxFileName$C = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/debuglogs/components/Log.tsx";
const Log = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: `log__entry ${props.log.isOk ? "" : "red"}`,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
      variant: "body1",
      sx: {
        fontWeight: "bold"
      },
      children: props.log.name
    }, void 0, false, {
      fileName: _jsxFileName$C,
      lineNumber: 7,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
      variant: "body2",
      children: "Body"
    }, void 0, false, {
      fileName: _jsxFileName$C,
      lineNumber: 10,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
      variant: "body2",
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(TextareaAutosize, {
        value: JSON.stringify(props.log.body, null, 2),
        minRows: 3,
        maxRows: 10,
        readOnly: true,
        style: {
          font: "inherit",
          width: "100%"
        }
      }, void 0, false, {
        fileName: _jsxFileName$C,
        lineNumber: 12,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$C,
      lineNumber: 11,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
      variant: "body2",
      children: "Response"
    }, void 0, false, {
      fileName: _jsxFileName$C,
      lineNumber: 20,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
      variant: "body2",
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(TextareaAutosize, {
        value: JSON.stringify(props.log.response, null, 2),
        minRows: 3,
        maxRows: 10,
        readOnly: true,
        style: {
          font: "inherit",
          width: "100%"
        }
      }, void 0, false, {
        fileName: _jsxFileName$C,
        lineNumber: 22,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$C,
      lineNumber: 21,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$C,
    lineNumber: 6,
    columnNumber: 5
  }, globalThis);
};
const LogList = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "log__list",
    children: props.logs.slice(0, 20).map((log) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Log, {
      log
    }, log.id, false, {
      fileName: _jsxFileName$C,
      lineNumber: 38,
      columnNumber: 9
    }, globalThis))
  }, void 0, false, {
    fileName: _jsxFileName$C,
    lineNumber: 36,
    columnNumber: 5
  }, globalThis);
};
var debuglogs = "";
var _jsxFileName$B = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/debuglogs/component.tsx";
const {
  mapStateToProps: mapStateToProps$6,
  mapDispatchToProps: mapDispatchToProps$6
} = compose(store$m, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$6 extends React.Component {
  constructor() {
    super(...arguments);
    this.handleVisibility = (isVis) => {
      this.props.updateState({
        visible: isVis
      });
    };
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppWrapper, {
      appName: store$m.key,
      onShow: () => this.handleVisibility(true),
      onHide: () => this.handleVisibility(false),
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(LogList, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$B,
        lineNumber: 29,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$B,
      lineNumber: 24,
      columnNumber: 7
    }, this);
  }
}
var Container$6 = connect(mapStateToProps$6, mapDispatchToProps$6)(Component$6);
var _jsxFileName$A = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/debuglogs/_config.tsx";
const config$6 = {
  name: store$m.key,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$6, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$A,
    lineNumber: 9,
    columnNumber: 16
  }, globalThis),
  type: "passive"
};
var __glob_1_2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$6
});
var AccountIcon = /* @__PURE__ */ ((AccountIcon2) => {
  AccountIcon2["standard"] = "coins";
  AccountIcon2["savings"] = "piggy-bank";
  AccountIcon2["business"] = "briefcase";
  return AccountIcon2;
})(AccountIcon || {});
const setModal = (modal) => {
  store.dispatch({
    type,
    cb: (state) => __spreadProps(__spreadValues({}, state), {
      financials: __spreadProps(__spreadValues({}, state.financials), {
        backdrop: true,
        modalComponent: modal
      })
    })
  });
};
const closeModal = () => {
  store.dispatch({
    type,
    cb: (state) => __spreadProps(__spreadValues({}, state), {
      financials: __spreadProps(__spreadValues({}, state.financials), {
        backdrop: false,
        modalComponent: null
      })
    })
  });
};
var _jsxFileName$z = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/financials/components/modals/DepositModal.tsx";
const DepositModal = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
    header: "Geld storten",
    elements: [{
      name: "amount",
      render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.MoneyAmount, __spreadProps(__spreadValues({}, props2), {
        label: "Amount",
        icon: "dollar-sign"
      }), void 0, false, {
        fileName: _jsxFileName$z,
        lineNumber: 15,
        columnNumber: 28
      }, globalThis)
    }, {
      name: "comment",
      render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props2), {
        label: "Comment",
        icon: "comment-alt"
      }), void 0, false, {
        fileName: _jsxFileName$z,
        lineNumber: 19,
        columnNumber: 28
      }, globalThis)
    }],
    onAccept: async (vals) => {
      await nuiAction("financials/account/deposit", __spreadValues({
        accountId: props.selected.account_id
      }, vals));
      await props.fetchAccounts();
      await props.fetchTransactions();
      closeModal();
    },
    onDecline: closeModal
  }, void 0, false, {
    fileName: _jsxFileName$z,
    lineNumber: 10,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$y = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/financials/components/modals/TransferModal.tsx";
const TransferModal = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
    header: "Geld overschrijven",
    elements: [{
      name: "amount",
      render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.MoneyAmount, __spreadProps(__spreadValues({}, props2), {
        label: "Amount",
        icon: "dollar-sign"
      }), void 0, false, {
        fileName: _jsxFileName$y,
        lineNumber: 15,
        columnNumber: 28
      }, globalThis)
    }, {
      name: "target",
      render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.MoneyAmount, __spreadProps(__spreadValues({}, props2), {
        label: "Target (citizenid, accountid or businessid)",
        icon: "user-circle"
      }), void 0, false, {
        fileName: _jsxFileName$y,
        lineNumber: 20,
        columnNumber: 13
      }, globalThis)
    }, {
      name: "comment",
      render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props2), {
        label: "Comment",
        icon: "comment-alt"
      }), void 0, false, {
        fileName: _jsxFileName$y,
        lineNumber: 25,
        columnNumber: 28
      }, globalThis)
    }],
    onAccept: async (vals) => {
      await nuiAction("financials/account/transfer", __spreadValues({
        accountId: props.selected.account_id
      }, vals));
      await props.fetchAccounts();
      await props.fetchTransactions();
      closeModal();
    },
    onDecline: closeModal
  }, void 0, false, {
    fileName: _jsxFileName$y,
    lineNumber: 10,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$x = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/financials/components/modals/WithdrawModal.tsx";
const WithdrawModal = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(SimpleForm, {
    header: "Geld afhalen",
    elements: [{
      name: "amount",
      render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.MoneyAmount, __spreadProps(__spreadValues({}, props2), {
        label: "Amount",
        icon: "dollar-sign"
      }), void 0, false, {
        fileName: _jsxFileName$x,
        lineNumber: 15,
        columnNumber: 28
      }, globalThis)
    }, {
      name: "comment",
      render: (props2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, props2), {
        label: "Comment",
        icon: "comment-alt"
      }), void 0, false, {
        fileName: _jsxFileName$x,
        lineNumber: 19,
        columnNumber: 28
      }, globalThis)
    }],
    onAccept: async (vals) => {
      await nuiAction("financials/account/withdraw", __spreadValues({
        accountId: props.selected.account_id
      }, vals));
      await props.fetchAccounts();
      await props.fetchTransactions();
      closeModal();
    },
    onDecline: closeModal
  }, void 0, false, {
    fileName: _jsxFileName$x,
    lineNumber: 10,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$w = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/financials/components/accountList.tsx";
const Account = ({
  account,
  setActiveAccount,
  selected
}) => {
  var _a;
  const btnClick = (e2, component) => {
    e2.stopPropagation();
    setModal(component);
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: `account ${selected ? "selected" : ""}`,
    onClick: () => setActiveAccount(account),
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "account__icon",
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: `fas fa-${AccountIcon[(_a = account.type) != null ? _a : "standard"]}`
        }, void 0, false, {
          fileName: _jsxFileName$w,
          lineNumber: 26,
          columnNumber: 11
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$w,
        lineNumber: 25,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "account__info",
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          id: "name",
          children: account.name
        }, void 0, false, {
          fileName: _jsxFileName$w,
          lineNumber: 29,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          id: "id",
          children: account.account_id
        }, void 0, false, {
          fileName: _jsxFileName$w,
          lineNumber: 30,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          id: "balance",
          children: ["\u20AC", /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NumberFormat.Bank, {
            value: account.balance
          }, void 0, false, {
            fileName: _jsxFileName$w,
            lineNumber: 32,
            columnNumber: 14
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$w,
          lineNumber: 31,
          columnNumber: 11
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$w,
        lineNumber: 28,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$w,
      lineNumber: 24,
      columnNumber: 7
    }, globalThis), selected && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "account__btns",
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$2, {
        color: "inherit",
        onClick: (e2) => btnClick(e2, DepositModal),
        children: "Deposit"
      }, void 0, false, {
        fileName: _jsxFileName$w,
        lineNumber: 38,
        columnNumber: 11
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$2, {
        color: "inherit",
        onClick: (e2) => btnClick(e2, TransferModal),
        children: "Transfer"
      }, void 0, false, {
        fileName: _jsxFileName$w,
        lineNumber: 41,
        columnNumber: 11
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$2, {
        color: "inherit",
        onClick: (e2) => btnClick(e2, WithdrawModal),
        children: "Withdraw"
      }, void 0, false, {
        fileName: _jsxFileName$w,
        lineNumber: 44,
        columnNumber: 11
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$w,
      lineNumber: 37,
      columnNumber: 9
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$w,
    lineNumber: 23,
    columnNumber: 5
  }, globalThis);
};
const AccountList = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "account__list",
    children: props.accounts.map((account) => {
      var _a;
      return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Account, {
        account,
        setActiveAccount: props.setActiveAccount,
        selected: account.account_id === ((_a = props == null ? void 0 : props.selected) == null ? void 0 : _a.account_id)
      }, account.account_id, false, {
        fileName: _jsxFileName$w,
        lineNumber: 61,
        columnNumber: 9
      }, globalThis);
    })
  }, void 0, false, {
    fileName: _jsxFileName$w,
    lineNumber: 59,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$v = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/financials/components/infoheader.tsx";
const Infoheader = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "financials__header",
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
        className: "fas fa-university"
      }, void 0, false, {
        fileName: _jsxFileName$v,
        lineNumber: 12,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
        children: props.bank.charAt(0).toUpperCase() + props.bank.slice(1)
      }, void 0, false, {
        fileName: _jsxFileName$v,
        lineNumber: 13,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$v,
      lineNumber: 11,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
        children: ["cash: \u20AC", /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NumberFormat.Bank, {
          value: props.cash
        }, void 0, false, {
          fileName: _jsxFileName$v,
          lineNumber: 17,
          columnNumber: 18
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$v,
        lineNumber: 16,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$v,
      lineNumber: 15,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$v,
    lineNumber: 10,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$u = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/financials/components/transactionList.tsx";
const Transaction = ({
  transaction,
  selected
}) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "transaction",
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "transaction__top",
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "transaction__title",
        children: selected.account_id === transaction.origin_account_id ? `${transaction.target_account_name} / ${transaction.target_account_id}` : `${transaction.origin_account_name} / ${transaction.origin_account_id}`
      }, void 0, false, {
        fileName: _jsxFileName$u,
        lineNumber: 14,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "transaction__metadata",
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
          children: transaction.transaction_id
        }, void 0, false, {
          fileName: _jsxFileName$u,
          lineNumber: 20,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
          children: transaction.type.toUpperCase()
        }, void 0, false, {
          fileName: _jsxFileName$u,
          lineNumber: 21,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
          children: formatRelativeTime(transaction.date)
        }, void 0, false, {
          fileName: _jsxFileName$u,
          lineNumber: 22,
          columnNumber: 11
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$u,
        lineNumber: 19,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$u,
      lineNumber: 13,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "transaction__body",
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: `transaction__amount ${transaction.type === "withdraw" || transaction.target_account_id !== selected.account_id ? "negative" : ""}`,
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
          children: ["\u20AC", /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NumberFormat.Bank, {
            value: transaction.change
          }, void 0, false, {
            fileName: _jsxFileName$u,
            lineNumber: 32,
            columnNumber: 14
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$u,
          lineNumber: 31,
          columnNumber: 11
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$u,
        lineNumber: 26,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "transaction__info",
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: "transaction__info__persons",
          children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
            children: transaction.triggered_by
          }, void 0, false, {
            fileName: _jsxFileName$u,
            lineNumber: 37,
            columnNumber: 13
          }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
            className: "fas fa-long-arrow-alt-right"
          }, void 0, false, {
            fileName: _jsxFileName$u,
            lineNumber: 38,
            columnNumber: 13
          }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
            children: transaction.accepted_by
          }, void 0, false, {
            fileName: _jsxFileName$u,
            lineNumber: 39,
            columnNumber: 13
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$u,
          lineNumber: 36,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: "transaction__info__comment",
          children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            children: "Comment:"
          }, void 0, false, {
            fileName: _jsxFileName$u,
            lineNumber: 42,
            columnNumber: 13
          }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            children: transaction.comment
          }, void 0, false, {
            fileName: _jsxFileName$u,
            lineNumber: 43,
            columnNumber: 13
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$u,
          lineNumber: 41,
          columnNumber: 11
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$u,
        lineNumber: 35,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$u,
      lineNumber: 25,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$u,
    lineNumber: 12,
    columnNumber: 5
  }, globalThis);
};
const TransactionList = (props) => {
  var _a, _b;
  const [loadBtnDisabled, setLoadBtnDisabled] = react$1.exports.useState(false);
  const loadMoreTrans = async () => {
    setLoadBtnDisabled(true);
    await props.fetchTransactions();
    setLoadBtnDisabled(false);
  };
  if (!props.selected) {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "transaction__list",
      children: "Kies een account om de transacties te bezichtegen"
    }, void 0, false, {
      fileName: _jsxFileName$u,
      lineNumber: 65,
      columnNumber: 12
    }, globalThis);
  }
  if (!((_b = (_a = props.selected) == null ? void 0 : _a.permissions) == null ? void 0 : _b.transactions)) {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "transaction__list",
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "transaction__no_perms",
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: "fas fa-frown"
        }, void 0, false, {
          fileName: _jsxFileName$u,
          lineNumber: 71,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("span", {
          children: "Je hebt geen toegang tot de transactielijst van dit account."
        }, void 0, false, {
          fileName: _jsxFileName$u,
          lineNumber: 72,
          columnNumber: 11
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$u,
        lineNumber: 70,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$u,
      lineNumber: 69,
      columnNumber: 7
    }, globalThis);
  }
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "transaction__list",
    children: [props.transactions.map((transaction) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Transaction, {
      transaction,
      selected: props.selected
    }, transaction.transaction_id, false, {
      fileName: _jsxFileName$u,
      lineNumber: 80,
      columnNumber: 9
    }, globalThis)), props.canLoadMore && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Primary, {
      disabled: loadBtnDisabled,
      onClick: loadMoreTrans,
      children: "Laad meer"
    }, void 0, false, {
      fileName: _jsxFileName$u,
      lineNumber: 87,
      columnNumber: 9
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$u,
    lineNumber: 78,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$t = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/financials/components/financials.tsx";
const Financials = (props) => {
  const openHeight = useVhToPixel(70);
  const rootStyles = useSpring({
    height: props.openPane ? openHeight : 0
  });
  react$1.exports.useEffect(() => {
    if (!props.visible)
      return;
    setTimeout(() => {
      props.fetchAccounts();
    }, 500);
  }, [props.visible]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(animated.div, {
    style: rootStyles,
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "financials__wrapper",
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Infoheader, {
          bank: props.bank,
          cash: props.cash
        }, void 0, false, {
          fileName: _jsxFileName$t,
          lineNumber: 33,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AccountList, {
          accounts: props.accounts,
          selected: props.selected,
          setActiveAccount: props.setActiveAccount
        }, void 0, false, {
          fileName: _jsxFileName$t,
          lineNumber: 34,
          columnNumber: 11
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$t,
        lineNumber: 32,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(TransactionList, {
        transactions: props.transactions,
        fetchTransactions: props.fetchTransactions,
        selected: props.selected,
        canLoadMore: props.canLoadMore
      }, void 0, false, {
        fileName: _jsxFileName$t,
        lineNumber: 36,
        columnNumber: 9
      }, globalThis), props.modalComponent && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "modal",
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          children: props.modalComponent({
            selected: props.selected,
            fetchAccounts: props.fetchAccounts,
            fetchTransactions: props.fetchTransactions
          })
        }, void 0, false, {
          fileName: _jsxFileName$t,
          lineNumber: 44,
          columnNumber: 13
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$t,
        lineNumber: 43,
        columnNumber: 11
      }, globalThis), props.backdrop && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: "financials__backdrop"
      }, void 0, false, {
        fileName: _jsxFileName$t,
        lineNumber: 53,
        columnNumber: 28
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$t,
      lineNumber: 31,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$t,
    lineNumber: 30,
    columnNumber: 5
  }, globalThis);
};
var financials = "";
var _jsxFileName$s = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/financials/component.tsx";
const {
  mapStateToProps: mapStateToProps$5,
  mapDispatchToProps: mapDispatchToProps$5
} = compose(store$l, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$5 extends React.Component {
  constructor() {
    super(...arguments);
    this.handleShow = (data) => {
      this.props.updateState(__spreadValues({
        visible: true,
        openPane: true
      }, data));
    };
    this.handleHide = () => {
      this.props.updateState({
        openPane: false,
        accounts: [],
        transactions: []
      });
      setTimeout(() => {
        this.props.updateState(store$l.initialState);
      }, 500);
    };
    this.fetchAccounts = async () => {
      const newAccounts = await nuiAction("financials/accounts/get", {}, devData.financialsAccounts);
      const cash = await nuiAction("financials/cash/get", {}, 500);
      this.props.updateState({
        accounts: newAccounts,
        transactions: [],
        cash
      });
    };
    this.fetchTransactions = async () => {
      var _a;
      if (!((_a = this.props.selected) == null ? void 0 : _a.account_id))
        return;
      const list = await nuiAction("financials/transactions/get", {
        accountId: this.props.selected.account_id,
        loaded: this.props.transactions.length
      }, devData.financialsTransactions);
      this.props.updateState({
        canLoadMore: list.length > 0,
        transactions: [...this.props.transactions, ...list]
      });
    };
    this.setActiveAccount = (acc) => {
      this.props.updateState({
        selected: acc,
        transactions: []
      });
      setTimeout(() => {
        this.fetchTransactions();
      }, 10);
    };
  }
  setModal(component) {
    this.props.updateState({
      modalComponent: component,
      backdrop: true
    });
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppWrapper, {
      appName: store$l.key,
      onShow: this.handleShow,
      onHide: this.handleHide,
      onEscape: () => closeApplication(store$l.key),
      center: true,
      full: true,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Financials, __spreadProps(__spreadValues({}, this.props), {
        setActiveAccount: this.setActiveAccount,
        fetchTransactions: this.fetchTransactions,
        fetchAccounts: this.fetchAccounts
      }), void 0, false, {
        fileName: _jsxFileName$s,
        lineNumber: 96,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$s,
      lineNumber: 88,
      columnNumber: 7
    }, this);
  }
}
var Container$5 = connect(mapStateToProps$5, mapDispatchToProps$5)(Component$5);
var _jsxFileName$r = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/financials/_config.tsx";
const config$5 = {
  name: store$l.key,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$5, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$r,
    lineNumber: 9,
    columnNumber: 16
  }, globalThis),
  type: "interactive"
};
var __glob_1_3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$5
});
const hudIcons = {
  voice: {
    name: "microphone"
  },
  hunger: {
    name: "apple-alt"
  },
  thirst: {
    name: "tint"
  },
  air: {
    name: "lungs"
  }
};
const hudColors = {
  health: "#8DEC96",
  armor: "#8D96EC",
  hunger: "#DBA758",
  thirst: "#588DDB",
  air: "#ABBEE2"
};
const CircleMargin = {
  right: ".15rem",
  left: "-.15rem",
  top: "0"
};
const CircleViewbox = {
  right: "22 22.5 44 22",
  left: "22 22 44 22",
  top: "22 22 44 44",
  "0-left": "22 22.25 44 22",
  "right-top": "44 22.5 22 22",
  "right-bottom": "22 22.5 22 22"
};
const CircleCy = {
  left: 44.75,
  right: 21.75,
  top: 44
};
const circleToBeSkipped = ["health", "armor"];
const CircleLocation = {
  1: ["top"],
  2: ["left", "right"],
  3: ["left", "right-top", "right-bottom"],
  4: ["left-top", "left-bottom", "right-top", "right-bottom"]
};
var voiceActiveColors = /* @__PURE__ */ ((voiceActiveColors2) => {
  voiceActiveColors2["normal"] = "#d5b34f";
  voiceActiveColors2["onRadio"] = "#C34F4F";
  return voiceActiveColors2;
})(voiceActiveColors || {});
const stylesBaseProps = {
  extraCirc: 0
};
const styles$5 = makeStyles({
  wrapper: {
    position: "relative",
    color: "black",
    height: "100%",
    pointerEvents: "none",
    "& > *": {
      pointerEvents: "all"
    }
  },
  compassWrapper: {},
  hudWrapper: {
    position: "absolute",
    bottom: "2vh",
    right: "2vh",
    backgroundColor: "transparent"
  },
  hudOuterCircle: {
    backgroundColor: "rgba(0,0,0,0.4)",
    borderRadius: "50%",
    minWidth: ({ extraCirc }) => `${17 + extraCirc * 2}.75vh`,
    minHeight: ({ extraCirc }) => `${17 + extraCirc * 2}.75vh`,
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  },
  hudIcons: {
    position: "absolute",
    width: "10.5vh",
    height: "10.5vh",
    display: "flex",
    "& > div": {
      width: "100%",
      height: "100%",
      display: "flex",
      flexDirection: "column",
      justifyContent: "space-between",
      alignItems: "flex-start",
      "&.right": {
        alignItems: "flex-end"
      }
    }
  },
  hudInnerWrapper: {
    position: "relative",
    width: "100%",
    height: "100%"
  },
  hudInnerCircle: {
    position: "absolute",
    height: "100%",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  },
  hudVoice: {
    position: "absolute",
    height: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  }
});
var _jsxFileName$q = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/hud/components/hud/circle.tsx";
const generateInnerCircle = (circleType) => {
  var _a;
  return styled(CircularProgress)({
    [`& .${circularProgressClasses.svg}`]: {
      marginTop: (_a = CircleMargin[circleType]) != null ? _a : CircleMargin[circleType.replace(/-(top|bottom)/, "")]
    }
  });
};
const HudCircle = (props) => {
  var _a, _b, _c, _d, _e;
  const classes = styles$5(stylesBaseProps);
  const [style, setStyle] = react$1.exports.useState({});
  const InnerCircle = generateInnerCircle(props.type);
  react$1.exports.useEffect(() => {
    if (props.type.includes("top")) {
      setStyle({
        width: `${props.size / 2}px`,
        marginBottom: `${props.size / 2}px`
      });
    }
    if (props.type.includes("bottom")) {
      setStyle({
        width: `${props.size / 2}px`,
        marginTop: `${props.size / 2}px`
      });
    }
  }, []);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.hudInnerCircle,
    style: {
      marginBottom: props.indent !== void 0 ? `${props.indent * 0.1}rem` : 0
    },
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(InnerCircle, __spreadProps(__spreadValues({}, props), {
      variant: "determinate",
      sx: __spreadValues(__spreadValues({}, props.sx), props.type.includes("right") ? {
        paddingTop: `${props.size / 2}px`
      } : {}),
      color: "inherit",
      thickness: 1.5,
      style,
      value: (_a = props.value) != null ? _a : 100,
      viewBox: (_c = props.indent !== void 0 ? (_b = CircleViewbox[`${props.indent}-${props.type}`]) != null ? _b : CircleViewbox[props.type] : CircleViewbox[props.type]) != null ? _c : CircleViewbox[props.type.replace(/-(top|bottom)/, "")],
      cy: (_e = props.indent !== void 0 ? (_d = CircleCy[`${props.indent}-${props.type}`]) != null ? _d : CircleCy[props.type] : CircleCy[props.type]) != null ? _e : CircleCy[props.type.replace(/-(top|bottom)/, "")]
    }), void 0, false, {
      fileName: _jsxFileName$q,
      lineNumber: 48,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$q,
    lineNumber: 42,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$p = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/hud/components/hud/icons.tsx";
const HudIcons = ({
  idx,
  circleLocByIndent
}) => {
  const classes = styles$5(stylesBaseProps);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.hudIcons,
    children: (circleLocByIndent == null ? void 0 : circleLocByIndent[0]) && ["left", "right"].map((ori) => {
      const filtered = Object.keys(circleLocByIndent[idx]).filter((c2) => circleLocByIndent[idx][c2].replace(/-.*$/, "") === ori);
      return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: `${ori}`,
        style: filtered.length === 1 ? {
          justifyContent: "center"
        } : {},
        children: filtered.map((circleName) => {
          var _a;
          return circleLocByIndent[idx][circleName].replace(/-.*$/, "") === ori && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Icon$2, {
            name: hudIcons[circleName].name,
            lib: (_a = hudIcons[circleName]) == null ? void 0 : _a.lib,
            size: "1.5rem",
            style: {
              textShadow: `-.2vh -.2vh 0px ${hudColors[circleName]}, .2vh .2vh 0px ${hudColors[circleName]}, -.2vh .2vh 0px ${hudColors[circleName]}, .2vh -.2vh 0px ${hudColors[circleName]}`,
              mixBlendMode: "lighten"
            },
            color: "#00000070"
          }, `hud-icon-${ori}-${circleName}`, false, {
            fileName: _jsxFileName$p,
            lineNumber: 29,
            columnNumber: 21
          }, globalThis);
        })
      }, `hud-icon-wrapper-${ori}`, false, {
        fileName: _jsxFileName$p,
        lineNumber: 21,
        columnNumber: 13
      }, globalThis);
    })
  }, void 0, false, {
    fileName: _jsxFileName$p,
    lineNumber: 14,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$o = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/hud/components/hud/voice.tsx";
const HudVoice = (props) => {
  const classes = styles$5(stylesBaseProps);
  const offset3 = useVhToPixel(1.5);
  const voiceState = useSelector((state) => state.hud.voice);
  const [thickness, setThickness] = React.useState(1.5);
  const [isGrowing, setIsGrowing] = React.useState(false);
  react$1.exports.useEffect(() => {
    const interval = setInterval(() => {
      setIsGrowing(isGrowing ? thickness < 2.5 : thickness < 1.5);
      setThickness(thickness + (isGrowing ? 1 : -1) * 0.1);
    }, 50);
    return () => clearInterval(interval);
  });
  if (voiceState.normal || voiceState.onRadio) {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.hudVoice,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(CircularProgress, {
        disableShrink: true,
        sx: {
          color: voiceState.onRadio ? voiceActiveColors.onRadio : voiceActiveColors.normal
        },
        variant: "determinate",
        value: 100,
        size: props.baseSize + offset3 * 1.55 * props.indentAm + offset3 * 0.75 * thickness,
        thickness,
        color: "inherit"
      }, void 0, false, {
        fileName: _jsxFileName$o,
        lineNumber: 27,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$o,
      lineNumber: 26,
      columnNumber: 7
    }, globalThis);
  }
  return null;
};
var _jsxFileName$n = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/hud/components/hud/wrapper.tsx";
const HudCircles = (props) => {
  const circleHeight = useVhToPixel(17);
  const [circleLocByIndent, setCircleLocByIndent] = react$1.exports.useState([]);
  const classes = styles$5(__spreadProps(__spreadValues({}, stylesBaseProps), {
    extraCirc: circleLocByIndent.length
  }));
  react$1.exports.useEffect(() => {
    const vals = [];
    let curIdx = 0;
    Object.keys(props.values).forEach((key) => {
      if (circleToBeSkipped.includes(key))
        return;
      if (!vals[curIdx]) {
        vals[curIdx] = [];
      }
      if (!props.values[key].enabled)
        return;
      vals[curIdx].push(key);
      if (vals[curIdx].length === 4) {
        curIdx++;
      }
    });
    const locVals = [];
    vals.forEach((circle, idx) => {
      const loc = CircleLocation[circle.length];
      if (!loc)
        return;
      circle.forEach((key, circleIdx) => {
        if (!locVals[idx]) {
          locVals[idx] = {};
        }
        locVals[idx][key] = loc[circleIdx];
      });
    });
    setCircleLocByIndent(locVals);
  }, [props.values]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.hudOuterCircle,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(HudIcons, {
      circleLocByIndent,
      idx: props.iconIdx
    }, void 0, false, {
      fileName: _jsxFileName$n,
      lineNumber: 50,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(HudVoice, {
      baseSize: circleHeight,
      indentAm: circleLocByIndent.length
    }, void 0, false, {
      fileName: _jsxFileName$n,
      lineNumber: 51,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.hudInnerWrapper,
      style: {
        maxHeight: `${circleHeight}px`
      },
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(HudCircle, {
        type: "left",
        sx: {
          color: hudColors.health
        },
        value: props.values.health.value,
        size: circleHeight,
        indent: -1
      }, void 0, false, {
        fileName: _jsxFileName$n,
        lineNumber: 58,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(HudCircle, {
        type: "right",
        sx: {
          color: hudColors.armor
        },
        value: props.values.armor.value,
        size: circleHeight,
        indent: -1
      }, void 0, false, {
        fileName: _jsxFileName$n,
        lineNumber: 67,
        columnNumber: 9
      }, globalThis), Object.entries(circleLocByIndent).map(([indent, circles]) => Object.entries(circles).map(([valName, loc]) => {
        var _a, _b;
        if (!((_b = (_a = props == null ? void 0 : props.values) == null ? void 0 : _a[valName]) == null ? void 0 : _b.enabled))
          return null;
        return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(HudCircle, {
          type: loc,
          sx: {
            color: hudColors[valName]
          },
          value: props.values[valName].value,
          size: circleHeight + vhToPixel(Number(indent + 1) * 2),
          indent: Number(indent)
        }, `${indent}-${valName}`, false, {
          fileName: _jsxFileName$n,
          lineNumber: 80,
          columnNumber: 15
        }, globalThis);
      }))]
    }, void 0, true, {
      fileName: _jsxFileName$n,
      lineNumber: 52,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$n,
    lineNumber: 49,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$m = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/hud/components/compass.tsx";
const Compass = (props) => {
  if (!props.visible)
    return null;
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("p", {
      children: "Nice compass bwo"
    }, void 0, false, {
      fileName: _jsxFileName$m,
      lineNumber: 7,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$m,
    lineNumber: 6,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$l = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/hud/components/hud.tsx";
const HudWrapper = (props) => {
  const phoneState = useSelector((state) => state.phone);
  const classes = styles$5({
    extraCirc: 0
  });
  const hudWrapperStyles = useSpring({
    right: phoneState.animating || phoneState.hasNotifications ? "32vh" : "2vh"
  });
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.wrapper,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.compassWrapper,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Compass, __spreadValues({}, props.compass), void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 18,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$l,
      lineNumber: 17,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(animated.div, {
      className: classes.hudWrapper,
      style: hudWrapperStyles,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(HudCircles, {
        values: props.values,
        iconIdx: props.iconIdx
      }, void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 21,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$l,
      lineNumber: 20,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$l,
    lineNumber: 16,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$k = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/hud/component.tsx";
const {
  mapStateToProps: mapStateToProps$4,
  mapDispatchToProps: mapDispatchToProps$4
} = compose(store$k, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$4 extends React.Component {
  constructor() {
    super(...arguments);
    this.handleDevShow = (data) => {
      this.props.updateState({
        visible: true,
        values: __spreadValues(__spreadValues({}, this.props.values), data.values),
        compass: __spreadValues(__spreadValues({}, this.props.compass), data.compass),
        voice: __spreadValues(__spreadValues({}, this.props.voice), data.voice)
      });
    };
    this.handleVisibilityChange = (state) => {
      this.props.updateState({
        visible: state
      });
    };
    this.handleEvent = (data) => {
      switch (data.action) {
        case "toggleIcons": {
          const indents = Math.floor((Object.keys(this.getEnabledCircles()).length - 2) / 4);
          this.props.updateState({
            iconIdx: (this.props.iconIdx + 1) % indents
          });
          break;
        }
        case "setHudValues": {
          this.props.updateState({
            values: __spreadValues(__spreadValues({}, this.props.values), data.values),
            voice: __spreadValues(__spreadValues({}, this.props.voice), data.voice)
          });
          break;
        }
      }
    };
    this.getEnabledCircles = () => {
      const enabledCircles = {};
      Object.keys(this.props.values).forEach((key) => {
        if (this.props.values[key].enabled) {
          enabledCircles[key] = this.props.values[key];
        }
      });
      return enabledCircles;
    };
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppWrapper, {
      appName: store$k.key,
      onShow: () => this.handleVisibilityChange(true),
      onHide: () => this.handleVisibilityChange(false),
      onEvent: this.handleEvent,
      full: true,
      unSelectable: true,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(HudWrapper, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$k,
        lineNumber: 87,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$k,
      lineNumber: 79,
      columnNumber: 7
    }, this);
  }
}
var Container$4 = connect(mapStateToProps$4, mapDispatchToProps$4)(Component$4);
var _jsxFileName$j = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/hud/_config.tsx";
const config$4 = {
  name: store$k.key,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$4, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$j,
    lineNumber: 9,
    columnNumber: 16
  }, globalThis),
  type: "interactive"
};
var __glob_1_4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$4
});
var _jsxFileName$i = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/input/component/inputMenu.tsx";
const InputMenu = (props) => {
  const [values2, setValues] = react$1.exports.useState({});
  react$1.exports.useEffect(() => {
    const _values = {};
    props.inputs.forEach((input) => {
      var _a;
      _values[input.name] = (_a = input.value) != null ? _a : "";
    });
    setValues(_values);
  }, [props.inputs]);
  const handleChange = (val, name) => {
    if (values2[name] === void 0) {
      throw new Error(`Input ${name} does not exist`);
    }
    setValues(__spreadProps(__spreadValues({}, values2), {
      [name]: val
    }));
  };
  const handleSubmit = () => {
    nuiAction(props.callbackURL, {
      values: values2
    });
    setValues({});
    closeApplication(store$j.key);
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "inputmenu__wrapper",
    children: [props.header && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "inputmenu__",
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
        children: props.header
      }, void 0, false, {
        fileName: _jsxFileName$i,
        lineNumber: 43,
        columnNumber: 11
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$i,
      lineNumber: 42,
      columnNumber: 9
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "inputmenu__collection",
      children: props.inputs.map((i2) => {
        var _a;
        switch (i2.type) {
          case "number":
            return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Number, __spreadProps(__spreadValues({}, i2), {
              value: values2[i2.name],
              onChange: handleChange
            }), i2.name, false, {
              fileName: _jsxFileName$i,
              lineNumber: 50,
              columnNumber: 22
            }, globalThis);
          case "password":
            return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.Password, __spreadProps(__spreadValues({}, i2), {
              value: values2[i2.name],
              onChange: handleChange
            }), i2.name, false, {
              fileName: _jsxFileName$i,
              lineNumber: 52,
              columnNumber: 22
            }, globalThis);
          case "select":
            return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.AutoComplete, __spreadProps(__spreadValues({}, i2), {
              options: (_a = i2.options) != null ? _a : [],
              value: values2[i2.name],
              onChange: handleChange
            }), i2.name, false, {
              fileName: _jsxFileName$i,
              lineNumber: 55,
              columnNumber: 17
            }, globalThis);
          default:
            return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Input.TextField, __spreadProps(__spreadValues({}, i2), {
              value: values2[i2.name],
              onChange: handleChange
            }), i2.name, false, {
              fileName: _jsxFileName$i,
              lineNumber: 64,
              columnNumber: 22
            }, globalThis);
        }
      })
    }, void 0, false, {
      fileName: _jsxFileName$i,
      lineNumber: 46,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: "inputmenu__btns",
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Secondary, {
        onClick: () => closeApplication(store$j.key),
        children: "Decline"
      }, void 0, false, {
        fileName: _jsxFileName$i,
        lineNumber: 69,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Button$1.Primary, {
        onClick: handleSubmit,
        children: "Accept"
      }, void 0, false, {
        fileName: _jsxFileName$i,
        lineNumber: 70,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$i,
      lineNumber: 68,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$i,
    lineNumber: 40,
    columnNumber: 5
  }, globalThis);
};
var inputs = "";
var _jsxFileName$h = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/input/component.tsx";
const {
  mapStateToProps: mapStateToProps$3,
  mapDispatchToProps: mapDispatchToProps$3
} = compose(store$j, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$3 extends React.Component {
  constructor() {
    super(...arguments);
    this.showInput = (data) => {
      if (!data.inputs) {
        console.error("No inputs found");
        return null;
      }
      if (data.inputs.some((input) => input.type === "select")) {
        data.inputs.filter((input) => input.type === "select").forEach((input) => {
          if (!input.options) {
            console.error("No options given for select input");
            return null;
          }
          input.options.forEach((option) => {
            if (!option.value) {
              console.error("No value given for select option");
              return null;
            }
            if (!option.label) {
              console.error("No label given for select option");
              return null;
            }
          });
        });
      }
      data.inputs = data.inputs.map((input) => {
        if (!input.value) {
          input.value = "";
        }
        return input;
      });
      this.props.updateState(__spreadValues({
        visible: true
      }, data));
    };
    this.hideInput = () => {
      this.props.updateState({
        visible: false,
        inputs: [],
        acceptCb: ""
      });
    };
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppWrapper, {
      appName: store$j.key,
      onShow: this.showInput,
      onHide: this.hideInput,
      full: true,
      center: true,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(InputMenu, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$h,
        lineNumber: 66,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$h,
      lineNumber: 65,
      columnNumber: 7
    }, this);
  }
}
var Container$3 = connect(mapStateToProps$3, mapDispatchToProps$3)(Component$3);
var _jsxFileName$g = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/input/_config.tsx";
const config$3 = {
  name: store$j.key,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$3, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$g,
    lineNumber: 9,
    columnNumber: 16
  }, globalThis),
  type: "interactive"
};
var __glob_1_5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$3
});
var _jsxFileName$f = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/interaction/components/Interaction.tsx";
const Interaction = (props) => {
  const hiddenMargin = useVhToPixel(-20);
  const showMargin = useVhToPixel(1);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "interaction__wrapper",
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Transition, {
      items: props.show,
      reverse: props.show,
      config: {
        duration: 350
      },
      from: {
        marginLeft: hiddenMargin
      },
      enter: {
        marginLeft: showMargin
      },
      leave: {
        marginLeft: hiddenMargin
      },
      children: (styles2, item) => item && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(animated.div, {
        style: styles2,
        className: `interaction ${props.type}`,
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
          variant: "button",
          dangerouslySetInnerHTML: {
            __html: props.text
          }
        }, void 0, false, {
          fileName: _jsxFileName$f,
          lineNumber: 25,
          columnNumber: 15
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$f,
        lineNumber: 24,
        columnNumber: 13
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$f,
      lineNumber: 12,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$f,
    lineNumber: 11,
    columnNumber: 5
  }, globalThis);
};
var interaction = "";
var _jsxFileName$e = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/interaction/component.tsx";
const {
  mapStateToProps: mapStateToProps$2,
  mapDispatchToProps: mapDispatchToProps$2
} = compose(store$i, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$2 extends React.Component {
  constructor() {
    super(...arguments);
    this.showInteraction = (data) => {
      var _a;
      this.props.updateState({
        visible: true,
        show: true,
        text: sanitizeText(((_a = data.text) != null ? _a : "").toUpperCase().replace(/\[.\]/, (match) => `<span class='shadow'>${match}</span>`)),
        type: data.type
      });
    };
    this.hideInteraction = () => {
      this.props.updateState({
        show: false
      });
      setTimeout(() => {
        this.props.updateState({
          visible: false,
          text: "",
          type: "info"
        });
      }, 500);
    };
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppWrapper, {
      appName: store$i.key,
      onShow: this.showInteraction,
      onHide: this.hideInteraction,
      full: true,
      unSelectable: true,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Interaction, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$e,
        lineNumber: 46,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$e,
      lineNumber: 45,
      columnNumber: 7
    }, this);
  }
}
var Container$2 = connect(mapStateToProps$2, mapDispatchToProps$2)(Component$2);
var _jsxFileName$d = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/interaction/_config.tsx";
const config$2 = {
  name: store$i.key,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$2, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$d,
    lineNumber: 9,
    columnNumber: 16
  }, globalThis),
  type: "passive"
};
var __glob_1_6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$2
});
var _jsxFileName$c = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/notifications/components/notification.tsx";
const Notification$1 = (props) => {
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "notification__outer",
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: `notification ${props.type}`,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("p", {
        children: props.message
      }, void 0, false, {
        fileName: _jsxFileName$c,
        lineNumber: 7,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$c,
      lineNumber: 6,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: `notification__filter ${props.type}Bg`
    }, void 0, false, {
      fileName: _jsxFileName$c,
      lineNumber: 9,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$c,
    lineNumber: 5,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$b = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/notifications/components/list.tsx";
const NotificationList = (props) => {
  const hiddenMargin = useVhToPixel(-37);
  const showMargin = useVhToPixel(1);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "notification__list",
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Transition, {
      items: props.notifications,
      config: {
        duration: 500,
        easing: easings.easeInOutQuart
      },
      from: {
        marginRight: hiddenMargin
      },
      enter: {
        marginRight: showMargin
      },
      leave: {
        marginRight: hiddenMargin
      },
      children: (style, item) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(animated.div, {
        style,
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Notification$1, __spreadValues({}, item), void 0, false, {
          fileName: _jsxFileName$b,
          lineNumber: 24,
          columnNumber: 13
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$b,
        lineNumber: 23,
        columnNumber: 11
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$b,
      lineNumber: 12,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$b,
    lineNumber: 11,
    columnNumber: 5
  }, globalThis);
};
var notifications = "";
var _jsxFileName$a = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/notifications/component.tsx";
const {
  mapStateToProps: mapStateToProps$1,
  mapDispatchToProps: mapDispatchToProps$1
} = compose(store$h, {
  mapStateToProps: () => ({}),
  mapDispatchToProps: {}
});
class Component$1 extends React.Component {
  constructor(props) {
    super(props);
    this.types = ["success", "info", "error", "primary"];
    this.handleVisibility = (visible) => {
      this.setState({
        visible
      });
    };
    this.eventHandler = (data) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      switch (data.action) {
        case "add": {
          if (!this.validateType(((_a = data.notification) == null ? void 0 : _a.type) || "info")) {
            console.error("Invalid notification type", data.notification);
            return;
          }
          if (((_b = data.notification) == null ? void 0 : _b.type) === "primary") {
            data.notification.type = "info";
          }
          const id = (_d = (_c = data.notification) == null ? void 0 : _c.id) != null ? _d : this.state.id;
          this.setState({
            id: id + 1
          });
          const notification = {
            id,
            message: sanitizeText(data.notification.message),
            type: (_f = (_e = data.notification) == null ? void 0 : _e.type) != null ? _f : "info",
            timeout: (_h = (_g = data.notification) == null ? void 0 : _g.timeout) != null ? _h : 5e3,
            persistent: (_i = data.notification.persistent) != null ? _i : false
          };
          this.props.updateState({
            notifications: [...this.props.notifications, notification]
          });
          if (notification.persistent)
            return id;
          setTimeout(() => {
            this.props.updateState({
              notifications: this.props.notifications.filter((n2) => n2.id !== id)
            });
          }, notification.timeout);
          break;
        }
        case "remove": {
          this.props.updateState({
            notifications: this.props.notifications.filter((n2) => n2.id !== data.id)
          });
          break;
        }
        default: {
          throw new Error(`Unknown event for notification: ${data.action} | data: ${JSON.stringify(data)}`);
        }
      }
    };
    this.validateType = (notiType) => {
      return this.types.includes(notiType);
    };
    this.state = {
      id: 0
    };
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppWrapper, {
      appName: store$h.key,
      onShow: () => this.handleVisibility(true),
      onHide: () => this.handleVisibility(false),
      onEvent: this.eventHandler,
      center: true,
      unSelectable: true,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NotificationList, __spreadValues({}, this.props), void 0, false, {
        fileName: _jsxFileName$a,
        lineNumber: 90,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$a,
      lineNumber: 82,
      columnNumber: 7
    }, this);
  }
}
var Container$1 = connect(mapStateToProps$1, mapDispatchToProps$1)(Component$1);
var _jsxFileName$9 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/notifications/_config.tsx";
const config$1 = {
  name: store$h.key,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container$1, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$9,
    lineNumber: 9,
    columnNumber: 16
  }, globalThis),
  type: "passive"
};
var __glob_1_7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config$1
});
var shell = "./assets/shell.e3c2f4ca.png";
const styles$4 = makeStyles({
  root: {
    height: "2.5vh",
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-around",
    fontSize: ".8rem",
    userSelect: "none",
    "& > *": {
      cursor: "pointer",
      textAlign: "center",
      width: "2vh"
    }
  }
});
var _jsxFileName$8 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/os/bottombar/bottombar.tsx";
const BottomBar = () => {
  const classes = styles$4();
  const phoneState = useSelector((state) => state.phone);
  const [isHovering, setHovering] = React.useState(false);
  const toggleSilence = () => {
    nuiAction("phone/silence", {
      silenced: !phoneState.isSilent
    });
    genericAction("phone", {
      isSilent: !phoneState.isSilent
    });
    addNotification({
      id: "bottomBar.silence",
      description: phoneState.isSilent ? "Meldingen aangezet" : "Meldingen uitgezet",
      title: "Settings",
      icon: {
        name: "cog",
        color: "#fff",
        background: baseStyle.gray.dark
      }
    });
  };
  const goHome = () => {
    if (phoneState.activeApp == "home-screen")
      return;
    changeApp("home-screen");
  };
  const openCamera = () => {
    genericAction("phone", {
      inCamera: true
    });
    nuiAction("phone/camera/open");
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.root,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
      variant: "body2",
      onClick: toggleSilence,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
        className: `fas fa-${phoneState.isSilent ? "bell-slash" : "bell"}`
      }, void 0, false, {
        fileName: _jsxFileName$8,
        lineNumber: 50,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$8,
      lineNumber: 49,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
        variant: "body2",
        onClick: goHome,
        onMouseEnter: () => setHovering(true),
        onMouseLeave: () => setHovering(false),
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: `${isHovering ? "fas" : "far"} fa-circle`
        }, void 0, false, {
          fileName: _jsxFileName$8,
          lineNumber: 59,
          columnNumber: 11
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$8,
        lineNumber: 53,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$8,
      lineNumber: 52,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
        variant: "body2",
        onClick: openCamera,
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: `fas fa-camera`
        }, void 0, false, {
          fileName: _jsxFileName$8,
          lineNumber: 64,
          columnNumber: 11
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$8,
        lineNumber: 63,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$8,
      lineNumber: 62,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$8,
    lineNumber: 48,
    columnNumber: 5
  }, globalThis);
};
const styles$3 = makeStyles({
  forms: {
    width: "100%",
    height: "calc( 100% - 1.1vh)",
    display: "flex",
    justifyContent: "center",
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    pointerEvents: "none",
    zIndex: 3,
    borderRadius: "1rem",
    "& > div": {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      minWidth: "80%",
      maxWidth: "80%",
      minHeight: "40%",
      padding: ".5vh .5vw",
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      color: baseStyle.gray.lighter,
      backgroundColor: baseStyle.primaryDarker.dark,
      borderBottom: `.5vh solid ${baseStyle.gray.lighter}`,
      boxShadow: "0px 3px 5px 0px black",
      borderRadius: "1vh",
      pointerEvents: "all"
    }
  },
  checkmarkWrapper: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  },
  checkmark: {
    width: "56px",
    height: "56px",
    borderRadius: "50%",
    display: "block",
    strokeWidth: "2",
    strokeMiterlimit: "10",
    margin: "10% auto",
    boxShadow: "inset 0px 0px 0px #7ac142",
    animation: "checkmark-fill 0.4s ease-in-out 0.4s forwards, checkmark-scale 0.3s ease-in-out 0.9s both",
    "& > .checkmark__check": {
      transformOrigin: "50% 50%",
      strokeDasharray: "48",
      strokeDashoffset: "48",
      stroke: "#fff",
      animation: "checkmark-stroke 0.3s cubic-bezier(0.65, 0, 0.45, 1) 0.8s forwards"
    }
  }
});
var _jsxFileName$7 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/os/form/form.tsx";
const Form = () => {
  const classes = styles$3();
  const phoneFormState = useSelector((state) => state["phone.form"]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.forms,
    style: phoneFormState.visible || phoneFormState.checkmark ? {
      backgroundColor: "#00000090",
      pointerEvents: "all"
    } : {
      backgroundColor: "transparent",
      pointerEvents: "none"
    },
    children: [phoneFormState.visible && react$1.exports.isValidElement(phoneFormState.element) && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      children: phoneFormState.element
    }, void 0, false, {
      fileName: _jsxFileName$7,
      lineNumber: 25,
      columnNumber: 76
    }, globalThis), phoneFormState.checkmark && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.checkmarkWrapper,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("svg", {
        className: classes.checkmark,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 52 52",
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("circle", {
          className: "checkmark__circle",
          cx: "26",
          cy: "26",
          r: "25",
          fill: "none"
        }, void 0, false, {
          fileName: _jsxFileName$7,
          lineNumber: 29,
          columnNumber: 13
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("path", {
          className: "checkmark__check",
          fill: "none",
          d: "M14.1 27.2l7.1 7.2 16.7-16.8"
        }, void 0, false, {
          fileName: _jsxFileName$7,
          lineNumber: 30,
          columnNumber: 13
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$7,
        lineNumber: 28,
        columnNumber: 11
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$7,
      lineNumber: 27,
      columnNumber: 9
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$7,
    lineNumber: 11,
    columnNumber: 5
  }, globalThis);
};
const styles$2 = makeStyles({
  list: {
    position: "absolute",
    width: "100%",
    top: 0,
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    zIndex: 3,
    overflow: "hidden",
    pointerEvents: "none"
  },
  innerList: {
    width: "85%"
  },
  box: {
    width: "100%",
    display: "flex",
    flexDirection: "column",
    marginBottom: ".5vh",
    backgroundColor: hexToRGB(baseStyle.primary.darker, 0.7),
    borderRadius: ".5vh",
    transition: "background-color .2s ease-in-out",
    pointerEvents: "all",
    "& > *": {
      pointerEvents: "none"
    },
    "&:hover": {
      backgroundColor: baseStyle.primary.darker
    },
    "& > div": {
      padding: ".5vh .9vh"
    }
  },
  info: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center"
  },
  icon: {
    marginRight: ".5vh",
    fontSize: ".9rem",
    minWidth: "2.5vh",
    minHeight: "2.5vh",
    borderRadius: ".75vh",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  textWrapper: {
    width: "18.5vh"
  },
  text: {
    width: "100%",
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis"
  },
  title: {
    fontSize: ".9rem",
    fontWeight: "bold",
    height: ".9rem",
    lineHeight: "1"
  },
  description: {
    fontSize: ".8rem",
    height: ".8rem",
    lineHeight: "1"
  },
  btns: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-evenly",
    alignItems: "center",
    marginTop: ".3vh",
    userSelect: "none",
    "& button": {
      pointerEvents: "all",
      "& *": {
        pointerEvents: "all"
      }
    }
  }
});
var _jsxFileName$6 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/os/notifications/notifications.tsx";
const NotificationButton = styled(Button$2)({
  borderRadius: "10vh",
  fontSize: ".7em",
  color: "white",
  borderColor: "white",
  padding: ".25vh .75vh"
});
const Notification = ({
  notification
}) => {
  var _a;
  const classes = styles$2();
  const [timer, setTimer] = react$1.exports.useState(notification.timer);
  react$1.exports.useEffect(() => {
    if (notification.timer === void 0)
      return;
    if (notification.timer > 0) {
      let internalTimer = notification.timer;
      const interval = setInterval(() => {
        setTimer(internalTimer--);
      }, 1e3);
      setTimer(notification.timer);
      return () => clearInterval(interval);
    } else {
      let internalTimer = 1;
      const interval = setInterval(() => {
        setTimer(internalTimer++);
      }, 1e3);
      setTimer(notification.timer);
      return () => clearInterval(interval);
    }
  }, [notification.timer]);
  const handleAccept = (evt) => {
    evt.stopPropagation();
    acceptNotification(notification.id);
  };
  const handleDecline = (evt) => {
    evt.stopPropagation();
    declineNotification(notification.id);
  };
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.box,
    onClick: handleDecline,
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.info,
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: classes.icon,
          style: {
            background: notification.icon.background,
            color: notification.icon.color
          },
          children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
            className: `${(_a = notification.icon.lib) != null ? _a : "fas fa-"}${notification.icon.name}`
          }, void 0, false, {
            fileName: _jsxFileName$6,
            lineNumber: 66,
            columnNumber: 13
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$6,
          lineNumber: 59,
          columnNumber: 11
        }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          className: classes.textWrapper,
          children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: [classes.text, classes.title].join(" "),
            children: notification.title.toUpperCase()
          }, void 0, false, {
            fileName: _jsxFileName$6,
            lineNumber: 69,
            columnNumber: 13
          }, globalThis), notification.description && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
            className: [classes.text, classes.description].join(" "),
            children: timer !== void 0 ? `${formatTime(timer)} - ${notification.description}` : notification.description
          }, void 0, false, {
            fileName: _jsxFileName$6,
            lineNumber: 71,
            columnNumber: 15
          }, globalThis)]
        }, void 0, true, {
          fileName: _jsxFileName$6,
          lineNumber: 68,
          columnNumber: 11
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$6,
        lineNumber: 58,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.btns,
        children: [notification.onAccept && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NotificationButton, {
            variant: "outlined",
            onClick: handleAccept,
            children: "Accept"
          }, void 0, false, {
            fileName: _jsxFileName$6,
            lineNumber: 80,
            columnNumber: 15
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$6,
          lineNumber: 79,
          columnNumber: 13
        }, globalThis), notification.onAccept && notification.onDecline && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          children: "|"
        }, void 0, false, {
          fileName: _jsxFileName$6,
          lineNumber: 85,
          columnNumber: 63
        }, globalThis), notification.onDecline && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
          children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NotificationButton, {
            variant: "outlined",
            onClick: handleDecline,
            children: "Decline"
          }, void 0, false, {
            fileName: _jsxFileName$6,
            lineNumber: 88,
            columnNumber: 15
          }, globalThis)
        }, void 0, false, {
          fileName: _jsxFileName$6,
          lineNumber: 87,
          columnNumber: 13
        }, globalThis)]
      }, void 0, true, {
        fileName: _jsxFileName$6,
        lineNumber: 77,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$6,
      lineNumber: 57,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$6,
    lineNumber: 56,
    columnNumber: 5
  }, globalThis);
};
const NotificationWrapper = () => {
  const classes = styles$2();
  const notifications2 = useSelector((state) => state["phone.notifications"]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.list,
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.innerList,
      children: notifications2.list.map((notification) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Notification, {
        notification
      }, notification.id, false, {
        fileName: _jsxFileName$6,
        lineNumber: 107,
        columnNumber: 11
      }, globalThis))
    }, void 0, false, {
      fileName: _jsxFileName$6,
      lineNumber: 105,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$6,
    lineNumber: 104,
    columnNumber: 5
  }, globalThis);
};
const styles$1 = makeStyles({
  root: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    padding: ".2vh 1.5vh",
    fontSize: ".8rem",
    userSelect: "none",
    "& > div": {
      display: "flex",
      flexDirection: "row"
    }
  },
  left: {
    "& > *:not(:first-child)": {
      marginLeft: ".3vh"
    }
  },
  right: {
    "& > *:not(:last-child)": {
      marginRight: ".3vh"
    }
  }
});
var _jsxFileName$5 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/os/top-content/topcontent.tsx";
const TopContent = (props) => {
  const classes = styles$1();
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: classes.root,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.left,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        children: props.game.time
      }, void 0, false, {
        fileName: _jsxFileName$5,
        lineNumber: 16,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        children: ["#", props.character.server_id]
      }, void 0, true, {
        fileName: _jsxFileName$5,
        lineNumber: 17,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$5,
      lineNumber: 15,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.right,
      children: [props.character.hasVPN && /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
        variant: "body2",
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: `fas fa-shield-alt`
        }, void 0, false, {
          fileName: _jsxFileName$5,
          lineNumber: 22,
          columnNumber: 13
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$5,
        lineNumber: 21,
        columnNumber: 11
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Typography, {
        variant: "body2",
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("i", {
          className: `fas fa-${WeatherIcons[props.game.weather]}`
        }, void 0, false, {
          fileName: _jsxFileName$5,
          lineNumber: 26,
          columnNumber: 11
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$5,
        lineNumber: 25,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$5,
      lineNumber: 19,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$5,
    lineNumber: 14,
    columnNumber: 5
  }, globalThis);
};
const styles = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column",
    position: "absolute",
    bottom: "-60vh",
    right: 0
  },
  shell: {
    height: "60vh",
    userSelect: "none",
    pointerEvents: "none",
    "& > img": {
      height: "100%"
    },
    zIndex: 4
  },
  notifications: {
    zIndex: 2
  },
  appWrapper: {
    display: "flex",
    flexDirection: "column",
    position: "absolute",
    top: "1vh",
    left: ".4vh",
    height: "calc(100% - 2.3vh)",
    width: "calc(100% - .8vh)",
    backgroundSize: "cover!important",
    zIndex: 1
  },
  activeApp: {
    height: "100%",
    width: "100%",
    overflow: "auto",
    position: "relative"
  }
});
var _jsxFileName$4 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/os/phone/phone.tsx";
const Phone = (props) => {
  var _a, _b, _c;
  const classes = styles();
  const closedVh = useVhToPixel(60);
  const basedOffset = useVhToPixel(60 - 5.5);
  const notificationState = useSelector((state) => state["phone.notifications"]);
  const [bottomOffset, setBottomOffset] = react$1.exports.useState(basedOffset);
  const rootAnimStyle = useSpring({
    bottom: props.animating ? "0px" : props.hasNotifications ? `-${bottomOffset}px` : `-${closedVh}px`
  });
  react$1.exports.useEffect(() => {
    let offset3 = 0;
    const notiWithActions = notificationState.list.filter((n2) => n2.onAccept || n2.onDecline);
    offset3 += notiWithActions.length * 7.5;
    offset3 += (notificationState.list.length - notiWithActions.length) * 4.3;
    setBottomOffset(basedOffset - offset3);
  }, [notificationState, basedOffset]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(animated.div, {
    className: classes.root,
    style: rootAnimStyle,
    children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.shell,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("img", {
        src: shell,
        alt: "phone shell"
      }, void 0, false, {
        fileName: _jsxFileName$4,
        lineNumber: 40,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName$4,
      lineNumber: 39,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.notifications
    }, void 0, false, {
      fileName: _jsxFileName$4,
      lineNumber: 42,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
      className: classes.appWrapper,
      style: props.background,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(TopContent, {
        character: props.character,
        game: props.game
      }, void 0, false, {
        fileName: _jsxFileName$4,
        lineNumber: 44,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
        className: classes.activeApp,
        children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(NotificationWrapper, {}, void 0, false, {
          fileName: _jsxFileName$4,
          lineNumber: 46,
          columnNumber: 11
        }, globalThis), (_c = (_b = (_a = props.config.find((c2) => c2.name === props.activeApp)) == null ? void 0 : _a.render) == null ? void 0 : _b.call(_a, {})) != null ? _c : `${props.activeApp} is not registered`]
      }, void 0, true, {
        fileName: _jsxFileName$4,
        lineNumber: 45,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(BottomBar, {}, void 0, false, {
        fileName: _jsxFileName$4,
        lineNumber: 49,
        columnNumber: 9
      }, globalThis)]
    }, void 0, true, {
      fileName: _jsxFileName$4,
      lineNumber: 43,
      columnNumber: 7
    }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Form, {}, void 0, false, {
      fileName: _jsxFileName$4,
      lineNumber: 51,
      columnNumber: 7
    }, globalThis)]
  }, void 0, true, {
    fileName: _jsxFileName$4,
    lineNumber: 38,
    columnNumber: 5
  }, globalThis);
};
var _jsxFileName$3 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/component.tsx";
const {
  mapStateToProps,
  mapDispatchToProps
} = compose(store$g, {
  mapStateToProps: (s2) => ({
    character: s2.character,
    game: s2.game
  }),
  mapDispatchToProps: {}
});
class Component extends React.Component {
  constructor(props) {
    super(props);
    this.handleShow = (data) => {
      this.props.updateState(__spreadProps(__spreadValues({}, data), {
        visible: true,
        animating: true
      }));
    };
    this.handleEvent = (pData) => {
      var _a;
      if (pData.action === "init") {
        phoneInit();
        return;
      }
      const {
        appName,
        action: action2,
        data
      } = pData;
      if (!((_a = phoneEvents == null ? void 0 : phoneEvents[appName]) == null ? void 0 : _a[action2])) {
        throw new Error(`Unknown Phone event: ${appName}/${action2}`);
      }
      phoneEvents[appName][action2](data);
    };
    this.config = getPhoneApps();
  }
  componentDidMount() {
    if (phoneApps.length === 0) {
      this.config = getPhoneApps();
    }
    setBackground();
  }
  render() {
    return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(AppWrapper, {
      appName: store$g.key,
      onShow: this.handleShow,
      onEvent: this.handleEvent,
      onHide: hidePhone,
      onEscape: hidePhone,
      full: true,
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Phone, __spreadProps(__spreadValues({}, this.props), {
        config: this.config
      }), void 0, false, {
        fileName: _jsxFileName$3,
        lineNumber: 63,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$3,
      lineNumber: 55,
      columnNumber: 7
    }, this);
  }
}
var Container = connect(mapStateToProps, mapDispatchToProps)(Component);
var _jsxFileName$2 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/main/phone/_config.tsx";
const config = {
  name: store$g.key,
  render: (p2) => /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Container, __spreadValues({}, p2), void 0, false, {
    fileName: _jsxFileName$2,
    lineNumber: 9,
    columnNumber: 16
  }, globalThis),
  type: "interactive"
};
var __glob_1_8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": config
});
const components = [];
const getApp = (appName) => {
  return components.find((cmp2) => cmp2.name == appName);
};
const getAllComponents = () => {
  if (components.length > 0) {
    return components;
  }
  const importAll = (r2) => {
    Object.keys(r2).forEach((key) => {
      const config2 = r2[key].default;
      if (components.find((cmp2) => cmp2.name == config2.name)) {
        console.error(`Double config key detected: ${config2.name}`);
        return;
      }
      components.push(config2);
    });
  };
  importAll({ "./main/cli/_config.tsx": __glob_1_0, "./main/contextmenu/_config.tsx": __glob_1_1, "./main/debuglogs/_config.tsx": __glob_1_2, "./main/financials/_config.tsx": __glob_1_3, "./main/hud/_config.tsx": __glob_1_4, "./main/input/_config.tsx": __glob_1_5, "./main/interaction/_config.tsx": __glob_1_6, "./main/notifications/_config.tsx": __glob_1_7, "./main/phone/_config.tsx": __glob_1_8 });
  return components;
};
var _jsxFileName$1 = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/index.provider.tsx";
const IndexProvider = ({
  children
}) => {
  const isError = useSelector((state) => state.main.error);
  const isMounted = useSelector((state) => state.main.mounted);
  const handleClose = () => {
    nuiAction("reload");
  };
  react$1.exports.useEffect(() => {
    store.dispatch({
      type,
      cb: (state) => __spreadProps(__spreadValues({}, state), {
        main: __spreadProps(__spreadValues({}, state.main), {
          mounted: isError === null || isError.message.trim() === ""
        })
      })
    });
  }, [isError]);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(StyledEngineProvider, {
    injectFirst: true,
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(ThemeProvider$1, {
      theme,
      children: [/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(CssBaseline, {}, void 0, false, {
        fileName: _jsxFileName$1,
        lineNumber: 35,
        columnNumber: 9
      }, globalThis), /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Snackbar, {
        open: isError !== null && (isError == null ? void 0 : isError.message.trim()) !== "",
        autoHideDuration: 5e3,
        onClose: handleClose,
        children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Alert, {
          onClose: handleClose,
          severity: "error",
          sx: {
            width: "100%"
          },
          children: ["An error occurred in $", isError, ". Reloading the UI..."]
        }, void 0, true, {
          fileName: _jsxFileName$1,
          lineNumber: 41,
          columnNumber: 11
        }, globalThis)
      }, void 0, false, {
        fileName: _jsxFileName$1,
        lineNumber: 36,
        columnNumber: 9
      }, globalThis), isMounted && children]
    }, void 0, true, {
      fileName: _jsxFileName$1,
      lineNumber: 34,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName$1,
    lineNumber: 33,
    columnNumber: 5
  }, globalThis);
};
var main = "";
var _jsxFileName = "/home/janle/projects/git/dg/dg_2/resources/[dg]/dg-ui/[src]/src/index.tsx";
{
  init({
    dsn: "https://ecf541af25474c54917d8e2445317213@sentry.nuttyshrimp.me/10",
    integrations: [new BrowserTracing({
      tracingOrigins: [`https://${GetParentResourceName()}`],
      maxTransactionDuration: 3e4
    })],
    release: "1.0.0",
    environment: "development",
    normalizeDepth: 10,
    attachStacktrace: true,
    tracesSampleRate: 1
  });
}
function App() {
  const components2 = getAllComponents();
  react$1.exports.useEffect(() => {
    {
      {
        console.log("[DG-UI] Running in game development mode");
      }
    }
    window.addEventListener("message", handleIncomingEvent);
    return () => {
      window.removeEventListener("message", handleIncomingEvent);
    };
  }, []);
  return /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV("div", {
    className: "ui-wrapper",
    children: components2.map((component, i2) => component.render({
      key: i2
    }))
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 60,
    columnNumber: 10
  }, this);
}
ReactDOM.render(/* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(React.StrictMode, {
  children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(Provider$1, {
    store,
    children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(IndexProvider, {
      children: /* @__PURE__ */ jsxDevRuntime.exports.jsxDEV(App, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 67,
        columnNumber: 9
      }, globalThis)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 66,
      columnNumber: 7
    }, globalThis)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 65,
    columnNumber: 5
  }, globalThis)
}, void 0, false, {
  fileName: _jsxFileName,
  lineNumber: 64,
  columnNumber: 3
}, globalThis), document.getElementById("root"));
//# sourceMappingURL=index.fb905460.js.map
